{"project_id": 3, "chunk_id": 0, "prompt": {"main_file_path": "conversor-de-moedas-main/conversor-de-moedas-main/src/main/java/org/example/action/Main.java", "main_file_content": "package org.example.action; import org.example.helper.ConversionRateHelper; import org.example.helper.InterativeUserMenuHelper; import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int option = 1; double value; double convertValue; while (option != 0) { InterativeUserMenuHelper.principalMenu(); option = sc.nextInt(); if (option != 0) { InterativeUserMenuHelper.secondaryMenu(); value = sc.nextDouble(); try { String[] conversionOption = InterativeUserMenuHelper.getOptions(option); double rateValue = ConversionRateHelper.getRateValue(conversionOption[0], conversionOption[1]); convertValue = ConversionRateHelper.processValueInByUser(value, rateValue); System.out.printf(\"Resultado da Convers\u00e3o: \\n\" + \"* %s %.2f *\\n\\n\", conversionOption[1], convertValue); } catch (Exception e) { e.fillInStackTrace(); soutl(\"\") } } } sc.close(); } }", "dependencies": [{"file_path": "conversor-de-moedas-main/conversor-de-moedas-main/src/main/java/org/example/helper/ConversionRateHelper.java", "file_content": "package org.example.helper; import com.google.gson.Gson; import org.example.http.ApiResponse; import org.example.http.Client; import java.io.IOException; import java.net.http.HttpResponse; import java.util.Map; public class ConversionRateHelper { public static double getRateValue(String coinIn, String coinOut) { double value = 0; Client client = new Client(); Gson gson = new Gson(); try { HttpResponse<String> response = client.response(client.connect(), client.request(coinIn)); ApiResponse apiResponse = gson.fromJson(response.body(), ApiResponse.class); Map<String, Double> conversationRates = apiResponse.getConversionRates(); value = conversationRates.get(coinOut); } catch (IOException | InterruptedException e) { e.fillInStackTrace(); } return value; } public static double processValueInByUser(double valueByUser, double valueByConversionRate) { return valueByUser * valueByConversionRate; } }"}, {"file_path": "conversor-de-moedas-main/conversor-de-moedas-main/src/main/java/org/example/helper/InterativeUserMenuHelper.java", "file_content": "package org.example.helper; public class InterativeUserMenuHelper { public static void principalMenu() { System.out.print(\"\\n\\n\" + \"*Seja bem-vindo/a ao Conversor de Moeda =] \\n\" + \"(1) D\u00f3lar ==> Peso argentino \\n\" + \"(2) Peso argentino ==> D\u00f3lar \\n\" + \"(3) D\u00f3lar ==> Real brasileiro \\n\" + \"(4) Real brasileiro ==> D\u00f3lar \\n\" + \"(5) D\u00f3lar ==> Peso colombiano \\n\" + \"(6) Peso colombiano ==> D\u00f3lar \\n\" + \"(0) Sair \\n\" + \" \\n\" + \"Escolha uma op\u00e7\u00e3o v\u00e1lida: \"); } public static void secondaryMenu() { sout(\"\") } public static String[] getOptions(int option) { String valueIn = \"\"; String valueOut = \"\"; switch (option) { case 1: valueIn = \"USD\"; valueOut = \"ARS\"; break; case 2: valueIn = \"ARS\"; valueOut = \"USD\"; break; case 3: valueIn = \"USD\"; valueOut = \"BRL\"; break; case 4: valueIn = \"BRL\"; valueOut = \"USD\"; break; case 5: valueIn = \"USD\"; valueOut = \"COP\"; break; case 6: valueIn = \"COP\"; valueOut = \"USD\"; break; default: soutl(\"\") } return new String[]{valueIn, valueOut}; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "conversor-de-moedas-main/conversor-de-moedas-main/src/main/java/org/example/helper/ConversionRateHelper.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The class handles both fetching exchange rates from an API and processing conversion calculations, which are two distinct responsibilities."}, {"principle": "Dependency Inversion", "justification": "Directly instantiates the concrete Client class instead of depending on an abstraction for API communication."}]}, {"file_path": "conversor-de-moedas-main/conversor-de-moedas-main/src/main/java/org/example/helper/InterativeUserMenuHelper.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The class manages both menu display logic and option-to-currency mapping, which are separate concerns."}, {"principle": "Open-Closed", "justification": "Adding a new conversion option requires modifying the switch-case in getOptions() instead of extending behavior without changing existing code."}]}]}
{"project_id": 3, "chunk_id": 0, "prompt": {"main_file_path": "conversor-de-moedas-main/conversor-de-moedas-main/src/main/java/org/example/http/Client.java", "main_file_content": "package org.example.http; import java.io.IOException; import java.net.URI; import java.net.http.HttpClient; import java.net.http.HttpRequest; import java.net.http.HttpResponse; import java.net.http.HttpResponse.BodyHandlers; public class Client { private final String AUTHORIZATION; private final String TOKEN; private final String URL; public Client() { AUTHORIZATION = \"Authorization\"; TOKEN = \"Bearer ab14fbdea52e725dc782afab\"; URL = \"https: } public HttpClient connect() { return HttpClient.newHttpClient(); } public HttpRequest request(String coin) { return HttpRequest.newBuilder() .uri(URI.create(URL + coin)) .header(AUTHORIZATION, TOKEN) .build(); } public HttpResponse<String> response(HttpClient connect, HttpRequest request) throws IOException, InterruptedException { return connect.send(request, BodyHandlers.ofString()); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "conversor-de-moedas-main/conversor-de-moedas-main/src/main/java/org/example/http/Client.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Client class manages HTTP connection configuration, constructs requests, and handles responses, indicating multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Modifying request construction or response handling requires direct changes to the Client class, violating extensibility without modification."}]}]}
{"project_id": 3, "chunk_id": 0, "prompt": {"main_file_path": "conversor-de-moedas-main/conversor-de-moedas-main/src/main/java/org/example/http/ApiResponse.java", "main_file_content": "package org.example.http; import java.util.Map; public class ApiResponse { private String result; private String documentation; private String terms_of_use; private String time_last_update_unix; private String time_last_update_utc; private String time_next_update_unix; private String time_next_update_utc; private String base_code; private Map<String, Double> conversion_rates; public String getResult() { return result; } public void setResult(String result) { this.result = result; } public String getDocumentation() { return documentation; } public void setDocumentation(String documentation) { this.documentation = documentation; } public String getTermsOfUse() { return terms_of_use; } public void setTermsOfUse(String terms_of_use) { this.terms_of_use = terms_of_use; } public String getTimeLastUpdateUnix() { return time_last_update_unix; } public void setTimeLastUpdateUnix(String time_last_update_unix) { this.time_last_update_unix = time_last_update_unix; } public String getTimeLastUpdateUtc() { return time_last_update_utc; } public void setTimeLastUpdateUtc(String time_last_update_utc) { this.time_last_update_utc = time_last_update_utc; } public String getTimeNextUpdateUnix() { return time_next_update_unix; } public void setTimeNextUpdateUnix(String time_next_update_unix) { this.time_next_update_unix = time_next_update_unix; } public String getTimeNextUpdateUtc() { return time_next_update_utc; } public void setTimeNextUpdateUtc(String time_next_update_utc) { this.time_next_update_utc = time_next_update_utc; } public String getBaseCode() { return base_code; } public void setBaseCode(String base_code) { this.base_code = base_code; } public Map<String, Double> getConversionRates() { return conversion_rates; } public void setConversionRates(Map<String, Double> conversion_rates) { this.conversion_rates = conversion_rates; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "conversor-de-moedas-main/conversor-de-moedas-main/src/main/java/org/example/http/ApiResponse.java", "violatedPrinciples": []}]}
{"project_id": 3, "chunk_id": 0, "prompt": {"main_file_path": "conversor-de-moedas-main/conversor-de-moedas-main/src/main/java/org/example/helper/ConversionRateHelper.java", "main_file_content": "package org.example.helper; import com.google.gson.Gson; import org.example.http.ApiResponse; import org.example.http.Client; import java.io.IOException; import java.net.http.HttpResponse; import java.util.Map; public class ConversionRateHelper { public static double getRateValue(String coinIn, String coinOut) { double value = 0; Client client = new Client(); Gson gson = new Gson(); try { HttpResponse<String> response = client.response(client.connect(), client.request(coinIn)); ApiResponse apiResponse = gson.fromJson(response.body(), ApiResponse.class); Map<String, Double> conversationRates = apiResponse.getConversionRates(); value = conversationRates.get(coinOut); } catch (IOException | InterruptedException e) { e.fillInStackTrace(); } return value; } public static double processValueInByUser(double valueByUser, double valueByConversionRate) { return valueByUser * valueByConversionRate; } }", "dependencies": [{"file_path": "conversor-de-moedas-main/conversor-de-moedas-main/src/main/java/org/example/http/ApiResponse.java", "file_content": "package org.example.http; import java.util.Map; public class ApiResponse { private String result; private String documentation; private String terms_of_use; private String time_last_update_unix; private String time_last_update_utc; private String time_next_update_unix; private String time_next_update_utc; private String base_code; private Map<String, Double> conversion_rates; public String getResult() { return result; } public void setResult(String result) { this.result = result; } public String getDocumentation() { return documentation; } public void setDocumentation(String documentation) { this.documentation = documentation; } public String getTermsOfUse() { return terms_of_use; } public void setTermsOfUse(String terms_of_use) { this.terms_of_use = terms_of_use; } public String getTimeLastUpdateUnix() { return time_last_update_unix; } public void setTimeLastUpdateUnix(String time_last_update_unix) { this.time_last_update_unix = time_last_update_unix; } public String getTimeLastUpdateUtc() { return time_last_update_utc; } public void setTimeLastUpdateUtc(String time_last_update_utc) { this.time_last_update_utc = time_last_update_utc; } public String getTimeNextUpdateUnix() { return time_next_update_unix; } public void setTimeNextUpdateUnix(String time_next_update_unix) { this.time_next_update_unix = time_next_update_unix; } public String getTimeNextUpdateUtc() { return time_next_update_utc; } public void setTimeNextUpdateUtc(String time_next_update_utc) { this.time_next_update_utc = time_next_update_utc; } public String getBaseCode() { return base_code; } public void setBaseCode(String base_code) { this.base_code = base_code; } public Map<String, Double> getConversionRates() { return conversion_rates; } public void setConversionRates(Map<String, Double> conversion_rates) { this.conversion_rates = conversion_rates; } }"}, {"file_path": "conversor-de-moedas-main/conversor-de-moedas-main/src/main/java/org/example/http/Client.java", "file_content": "package org.example.http; import java.io.IOException; import java.net.URI; import java.net.http.HttpClient; import java.net.http.HttpRequest; import java.net.http.HttpResponse; import java.net.http.HttpResponse.BodyHandlers; public class Client { private final String AUTHORIZATION; private final String TOKEN; private final String URL; public Client() { AUTHORIZATION = \"Authorization\"; TOKEN = \"Bearer ab14fbdea52e725dc782afab\"; URL = \"https: } public HttpClient connect() { return HttpClient.newHttpClient(); } public HttpRequest request(String coin) { return HttpRequest.newBuilder() .uri(URI.create(URL + coin)) .header(AUTHORIZATION, TOKEN) .build(); } public HttpResponse<String> response(HttpClient connect, HttpRequest request) throws IOException, InterruptedException { return connect.send(request, BodyHandlers.ofString()); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "conversor-de-moedas-main/conversor-de-moedas-main/src/main/java/org/example/helper/ConversionRateHelper.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The class handles multiple responsibilities: fetching HTTP data, parsing JSON, and performing currency conversion calculations. This means it has more than one reason to change."}, {"principle": "Open-Closed", "justification": "The class is not designed for extension (e.g., adding new data sources or conversion logic) without modifying existing code, as it directly uses concrete implementations like Client and Gson."}, {"principle": "Dependency Inversion", "justification": "The high-level module ConversionRateHelper directly depends on concrete low-level modules (Client, Gson) instead of abstractions, violating the principle of depending on interfaces."}]}]}
{"project_id": 3, "chunk_id": 0, "prompt": {"main_file_path": "conversor-de-moedas-main/conversor-de-moedas-main/src/main/java/org/example/helper/InterativeUserMenuHelper.java", "main_file_content": "package org.example.helper; public class InterativeUserMenuHelper { public static void principalMenu() { sout(\"\") } public static void secondaryMenu() { sout(\"\") } public static String[] getOptions(int option) { String valueIn = \"\"; String valueOut = \"\"; switch (option) { case 1: valueIn = \"USD\"; valueOut = \"ARS\"; break; case 2: valueIn = \"ARS\"; valueOut = \"USD\"; break; case 3: valueIn = \"USD\"; valueOut = \"BRL\"; break; case 4: valueIn = \"BRL\"; valueOut = \"USD\"; break; case 5: valueIn = \"USD\"; valueOut = \"COP\"; break; case 6: valueIn = \"COP\"; valueOut = \"USD\"; break; default: soutl(\"\") } return new String[]{valueIn, valueOut}; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "conversor-de-moedas-main/conversor-de-moedas-main/src/main/java/org/example/helper/InterativeUserMenuHelper.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The class handles both menu presentation (principalMenu, secondaryMenu) and currency conversion configuration (getOptions), which are multiple responsibilities. Changes in menu UI or conversion logic would both require modifying this class."}, {"principle": "Open-Closed", "justification": "The switch statement in getOptions requires modifying existing code to add new currency conversion types. New conversions cannot be added through extension without altering the method."}]}]}
{"project_id": 5, "chunk_id": 0, "prompt": {"main_file_path": "Grant-master/Grant-master/sample/src/main/java/com/anthonycr/sample/MainActivity.java", "main_file_content": "package com.anthonycr.sample; import android.Manifest; import android.annotation.SuppressLint; import android.content.Context; import android.location.Location; import android.location.LocationManager; import android.os.Bundle; import android.os.Environment; import android.support.annotation.NonNull; import android.support.annotation.Nullable; import android.support.v7.app.AppCompatActivity; import android.util.Log; import android.view.View; import android.widget.Button; import android.widget.TextView; import android.widget.Toast; import com.anthonycr.grant.PermissionsManager; import com.anthonycr.grant.PermissionsResultAction; import java.io.BufferedReader; import java.io.Closeable; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStreamReader; import java.io.OutputStream; import java.util.List; import java.util.Locale; public class MainActivity extends AppCompatActivity implements View.OnClickListener { private static final String TAG = MainActivity.class.getSimpleName(); private static final String PATH = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getPath() + \"/test.txt\"; private TextView textView; @SuppressLint(\"InlinedApi\") @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); PermissionsManager.getInstance().requestAllManifestPermissionsIfNecessary(this, new PermissionsResultAction() { @Override public void onGranted() { Toast.makeText(MainActivity.this, R.string.message_granted, Toast.LENGTH_SHORT).show(); writeToStorage(\"Hello, World!\"); readFromStorage(); } @Override public void onDenied(String permission) { String message = String.format(Locale.getDefault(), getString(R.string.message_denied), permission); Toast.makeText(MainActivity.this, message, Toast.LENGTH_SHORT).show(); } }); boolean hasPermission = PermissionsManager.getInstance().hasPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE); Log.d(TAG, \"Has \" + Manifest.permission.READ_EXTERNAL_STORAGE + \" permission: \" + hasPermission); Button writeStorage = (Button) findViewById(R.id.button_write_storage); Button readStorage = (Button) findViewById(R.id.button_read_storage); Button readContacts = (Button) findViewById(R.id.button_read_contacts); Button getLocation = (Button) findViewById(R.id.button_get_location); this.textView = (TextView) findViewById(R.id.text); writeStorage.setOnClickListener(this); readStorage.setOnClickListener(this); readContacts.setOnClickListener(this); getLocation.setOnClickListener(this); } private void writeToStorage(String text) { File file = new File(PATH); if (!file.exists()) { try { file.createNewFile(); } catch (IOException e) { e.printStackTrace(); } } OutputStream outputStream = null; try { outputStream = new FileOutputStream(file); outputStream.write(text.getBytes()); this.textView.setText(String.format(Locale.getDefault(), getString(R.string.text_write), text)); } catch (IOException e) { Log.e(TAG, \"Unable to write to storage\", e); this.textView.setText(R.string.text_failure_write); } finally { close(outputStream); } } private void readFromStorage() { File file = new File(PATH); BufferedReader inputStream = null; FileInputStream input = null; try { input = new FileInputStream(file); inputStream = new BufferedReader(new InputStreamReader(input)); String test = inputStream.readLine(); this.textView.setText(String.format(Locale.getDefault(), getString(R.string.text_read), test)); } catch (IOException e) { Log.e(TAG, \"Unable to read from storage\", e); this.textView.setText(R.string.text_failure_read); } finally { close(input); close(inputStream); } } @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { Log.i(TAG, \"Activity-onRequestPermissionsResult() PermissionsManager.notifyPermissionsChange()\"); PermissionsManager.getInstance().notifyPermissionsChange(permissions, grantResults); } @SuppressLint(\"InlinedApi\") @Override public void onClick(View v) { switch (v.getId()) { case R.id.button_write_storage: PermissionsManager.getInstance().requestPermissionsIfNecessaryForResult(this, new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE}, new PermissionsResultAction() { @Override public void onGranted() { Log.i(TAG, \"onGranted: Write Storage\"); writeToStorage(\"Hello, World!\"); } @Override public void onDenied(String permission) { Log.i(TAG, \"onDenied: Write Storage: \" + permission); String message = String.format(Locale.getDefault(), getString(R.string.message_denied), permission); Toast.makeText(MainActivity.this, message, Toast.LENGTH_SHORT).show(); } } ); break; case R.id.button_read_storage: PermissionsManager.getInstance().requestPermissionsIfNecessaryForResult(this, new String[]{Manifest.permission.READ_EXTERNAL_STORAGE}, new PermissionsResultAction() { @Override public void onGranted() { Log.i(TAG, \"onGranted: Read Storage\"); readFromStorage(); } @Override public void onDenied(String permission) { Log.i(TAG, \"onDenied: Read Storage: \" + permission); String message = String.format(Locale.getDefault(), getString(R.string.message_denied), permission); Toast.makeText(MainActivity.this, message, Toast.LENGTH_SHORT).show(); } } ); break; case R.id.button_read_contacts: PermissionsManager.getInstance().requestPermissionsIfNecessaryForResult(this, new String[]{Manifest.permission.READ_CONTACTS}, new PermissionsResultAction() { @Override public void onGranted() { Log.i(TAG, \"onGranted: Read Contacts\"); ContactsUtils.readPhoneContacts(MainActivity.this); } @Override public void onDenied(String permission) { Log.i(TAG, \"onDenied: Read Contacts\"); String message = String.format(Locale.getDefault(), getString(R.string.message_denied), permission); Toast.makeText(MainActivity.this, message, Toast.LENGTH_SHORT).show(); } } ); break; case R.id.button_get_location: PermissionsManager.getInstance().requestPermissionsIfNecessaryForResult(this, new String[]{Manifest.permission.ACCESS_COARSE_LOCATION, Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.WRITE_EXTERNAL_STORAGE}, new PermissionsResultAction() { @Override public void onGranted() { double[] location = getCoordinates(); for (double coord : location) { Log.d(TAG, \"Coordinate: \" + coord); writeToStorage(\"Coordinate: \" + coord); } } @Override public void onDenied(String permission) { Log.e(TAG, \"Unable to get location without permission\"); } }); break; } } private static void close(@Nullable Closeable closeable) { if (closeable == null) {return;} try { closeable.close(); } catch (IOException ignored) {} } private double[] getCoordinates() { LocationManager lm = (LocationManager) getSystemService( Context.LOCATION_SERVICE); List<String> providers = lm.getProviders(true); Location l = null; for (int i = providers.size() - 1; i >= 0; i--) { l = lm.getLastKnownLocation(providers.get(i)); if (l != null) break; } double[] gps = new double[2]; if (l != null) { gps[0] = l.getLatitude(); gps[1] = l.getLongitude(); } return gps; } }", "dependencies": [{"file_path": "Grant-master/Grant-master/library/src/main/java/com/anthonycr/grant/PermissionsManager.java", "file_content": "package com.anthonycr.grant; import android.Manifest; import android.app.Activity; import android.content.Context; import android.content.pm.PackageInfo; import android.content.pm.PackageManager; import android.os.Build; import android.support.annotation.NonNull; import android.support.annotation.Nullable; import android.support.v4.app.ActivityCompat; import android.support.v4.app.Fragment; import android.util.Log; import java.lang.ref.WeakReference; import java.lang.reflect.Field; import java.util.ArrayList; import java.util.HashSet; import java.util.Iterator; import java.util.List; import java.util.Set; public class PermissionsManager { private static final String TAG = PermissionsManager.class.getSimpleName(); private final Set<String> mPendingRequests = new HashSet<>(1); private final Set<String> mPermissions = new HashSet<>(1); private final List<WeakReference<PermissionsResultAction>> mPendingActions = new ArrayList<>(1); private static PermissionsManager mInstance = null; public static PermissionsManager getInstance() { if (mInstance == null) { mInstance = new PermissionsManager(); } return mInstance; } private PermissionsManager() { initializePermissionsMap(); } private synchronized void initializePermissionsMap() { Field[] fields = Manifest.permission.class.getFields(); for (Field field : fields) { String name = null; try { name = (String) field.get(\"\"); } catch (IllegalAccessException e) { Log.e(TAG, \"Could not access field\", e); } mPermissions.add(name); } } @NonNull private synchronized String[] getManifestPermissions(@NonNull final Activity activity) { PackageInfo packageInfo = null; List<String> list = new ArrayList<>(1); try { Log.d(TAG, activity.getPackageName()); packageInfo = activity.getPackageManager().getPackageInfo(activity.getPackageName(), PackageManager.GET_PERMISSIONS); } catch (PackageManager.NameNotFoundException e) { Log.e(TAG, \"A problem occurred when retrieving permissions\", e); } if (packageInfo != null) { String[] permissions = packageInfo.requestedPermissions; if (permissions != null) { for (String perm : permissions) { Log.d(TAG, \"Manifest contained permission: \" + perm); list.add(perm); } } } return list.toArray(new String[list.size()]); } private synchronized void addPendingAction(@NonNull String[] permissions, @Nullable PermissionsResultAction action) { if (action == null) { return; } action.registerPermissions(permissions); mPendingActions.add(new WeakReference<>(action)); } private synchronized void removePendingAction(@Nullable PermissionsResultAction action) { for (Iterator<WeakReference<PermissionsResultAction>> iterator = mPendingActions.iterator(); iterator.hasNext(); ) { WeakReference<PermissionsResultAction> weakRef = iterator.next(); if (weakRef.get() == action || weakRef.get() == null) { iterator.remove(); } } } @SuppressWarnings(\"unused\") public synchronized boolean hasPermission(@Nullable Context context, @NonNull String permission) { return context != null && (ActivityCompat.checkSelfPermission(context, permission) == PackageManager.PERMISSION_GRANTED || !mPermissions.contains(permission)); } @SuppressWarnings(\"unused\") public synchronized boolean hasAllPermissions(@Nullable Context context, @NonNull String[] permissions) { if (context == null) { return false; } boolean hasAllPermissions = true; for (String perm : permissions) { hasAllPermissions &= hasPermission(context, perm); } return hasAllPermissions; } @SuppressWarnings(\"unused\") public synchronized void requestAllManifestPermissionsIfNecessary(final @Nullable Activity activity, final @Nullable PermissionsResultAction action) { if (activity == null) { return; } String[] perms = getManifestPermissions(activity); requestPermissionsIfNecessaryForResult(activity, perms, action); } @SuppressWarnings(\"unused\") public synchronized void requestPermissionsIfNecessaryForResult(@Nullable Activity activity, @NonNull String[] permissions, @Nullable PermissionsResultAction action) { if (activity == null) { return; } addPendingAction(permissions, action); if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) { doPermissionWorkBeforeAndroidM(activity, permissions, action); } else { List<String> permList = getPermissionsListToRequest(activity, permissions, action); if (permList.isEmpty()) { removePendingAction(action); } else { String[] permsToRequest = permList.toArray(new String[permList.size()]); mPendingRequests.addAll(permList); ActivityCompat.requestPermissions(activity, permsToRequest, 1); } } } @SuppressWarnings(\"unused\") public synchronized void requestPermissionsIfNecessaryForResult(@NonNull Fragment fragment, @NonNull String[] permissions, @Nullable PermissionsResultAction action) { Activity activity = fragment.getActivity(); if (activity == null) { return; } addPendingAction(permissions, action); if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) { doPermissionWorkBeforeAndroidM(activity, permissions, action); } else { List<String> permList = getPermissionsListToRequest(activity, permissions, action); if (permList.isEmpty()) { removePendingAction(action); } else { String[] permsToRequest = permList.toArray(new String[permList.size()]); mPendingRequests.addAll(permList); fragment.requestPermissions(permsToRequest, 1); } } } @SuppressWarnings(\"unused\") public synchronized void notifyPermissionsChange(@NonNull String[] permissions, @NonNull int[] results) { int size = permissions.length; if (results.length < size) { size = results.length; } Iterator<WeakReference<PermissionsResultAction>> iterator = mPendingActions.iterator(); while (iterator.hasNext()) { PermissionsResultAction action = iterator.next().get(); for (int n = 0; n < size; n++) { if (action == null || action.onResult(permissions[n], results[n])) { iterator.remove(); break; } } } for (int n = 0; n < size; n++) { mPendingRequests.remove(permissions[n]); } } private void doPermissionWorkBeforeAndroidM(@NonNull Activity activity, @NonNull String[] permissions, @Nullable PermissionsResultAction action) { for (String perm : permissions) { if (action != null) { if (!mPermissions.contains(perm)) { action.onResult(perm, Permissions.NOT_FOUND); } else if (ActivityCompat.checkSelfPermission(activity, perm) != PackageManager.PERMISSION_GRANTED) { action.onResult(perm, Permissions.DENIED); } else { action.onResult(perm, Permissions.GRANTED); } } } } @NonNull private List<String> getPermissionsListToRequest(@NonNull Activity activity, @NonNull String[] permissions, @Nullable PermissionsResultAction action) { List<String> permList = new ArrayList<>(permissions.length); for (String perm : permissions) { if (!mPermissions.contains(perm)) { if (action != null) { action.onResult(perm, Permissions.NOT_FOUND); } } else if (ActivityCompat.checkSelfPermission(activity, perm) != PackageManager.PERMISSION_GRANTED) { if (!mPendingRequests.contains(perm)) { permList.add(perm); } } else { if (action != null) { action.onResult(perm, Permissions.GRANTED); } } } return permList; } }"}, {"file_path": "Grant-master/Grant-master/library/src/main/java/com/anthonycr/grant/PermissionsResultAction.java", "file_content": "package com.anthonycr.grant; import android.content.pm.PackageManager; import android.os.Handler; import android.os.Looper; import android.support.annotation.CallSuper; import android.support.annotation.NonNull; import android.util.Log; import java.util.Collections; import java.util.HashSet; import java.util.Set; public abstract class PermissionsResultAction { private static final String TAG = PermissionsResultAction.class.getSimpleName(); private final Set<String> mPermissions = new HashSet<>(1); private Looper mLooper = Looper.getMainLooper(); public PermissionsResultAction() {} @SuppressWarnings(\"unused\") public PermissionsResultAction(@NonNull Looper looper) {mLooper = looper;} public abstract void onGranted(); public abstract void onDenied(String permission); @SuppressWarnings({\"WeakerAccess\", \"SameReturnValue\"}) public synchronized boolean shouldIgnorePermissionNotFound(String permission) { Log.d(TAG, \"Permission not found: \" + permission); return true; } @SuppressWarnings(\"WeakerAccess\") @CallSuper protected synchronized final boolean onResult(final @NonNull String permission, int result) { if (result == PackageManager.PERMISSION_GRANTED) { return onResult(permission, Permissions.GRANTED); } else { return onResult(permission, Permissions.DENIED); } } @SuppressWarnings(\"WeakerAccess\") @CallSuper protected synchronized final boolean onResult(final @NonNull String permission, Permissions result) { mPermissions.remove(permission); if (result == Permissions.GRANTED) { if (mPermissions.isEmpty()) { new Handler(mLooper).post(new Runnable() { @Override public void run() { onGranted(); } }); return true; } } else if (result == Permissions.DENIED) { new Handler(mLooper).post(new Runnable() { @Override public void run() { onDenied(permission); } }); return true; } else if (result == Permissions.NOT_FOUND) { if (shouldIgnorePermissionNotFound(permission)) { if (mPermissions.isEmpty()) { new Handler(mLooper).post(new Runnable() { @Override public void run() { onGranted(); } }); return true; } } else { new Handler(mLooper).post(new Runnable() { @Override public void run() { onDenied(permission); } }); return true; } } return false; } @SuppressWarnings(\"WeakerAccess\") @CallSuper protected synchronized final void registerPermissions(@NonNull String[] perms) { Collections.addAll(mPermissions, perms); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Grant-master/Grant-master/sample/src/main/java/com/anthonycr/sample/MainActivity.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "MainActivity handles UI events, file I/O operations, permission management, and location retrieval, indicating multiple responsibilities."}, {"principle": "Interface Segregation", "justification": "PermissionsResultAction forces clients to implement onGranted() and onDenied() even if they only need one, violating method segregation."}, {"principle": "Dependency Inversion", "justification": "MainActivity directly depends on the concrete PermissionsManager instead of an abstraction for high-level permission handling."}]}]}
{"project_id": 5, "chunk_id": 0, "prompt": {"main_file_path": "Grant-master/Grant-master/sample/src/main/java/com/anthonycr/sample/ContactsUtils.java", "main_file_content": "package com.anthonycr.sample; import android.content.ContentResolver; import android.content.Context; import android.database.Cursor; import android.provider.ContactsContract; import android.util.Log; public class ContactsUtils { private static final String TAG = ContactsUtils.class.getSimpleName(); public static void readPhoneContacts(Context context) { ContentResolver contentResolver = context.getContentResolver(); Cursor cursor = contentResolver.query(ContactsContract.Contacts.CONTENT_URI, null, null, null, null); if (null != cursor && cursor.getCount() > 0) { while (cursor.moveToNext()) { String id = cursor.getString(cursor.getColumnIndex(ContactsContract.Contacts._ID)); String contactName = cursor.getString(cursor.getColumnIndex(ContactsContract.Contacts.DISPLAY_NAME)); Log.d(TAG, \" \" + contactName + \" \"); if (Integer.parseInt(cursor.getString(cursor.getColumnIndex(ContactsContract.Contacts.HAS_PHONE_NUMBER))) > 0) { Cursor pCursor = contentResolver.query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null, ContactsContract.CommonDataKinds.Phone.CONTACT_ID + \" = ?\", new String[]{id}, null); if (null != pCursor) { while (pCursor.moveToNext()) { int phoneType = pCursor.getInt(pCursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.TYPE)); String phoneNo = pCursor.getString(pCursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER)); switch (phoneType) { case ContactsContract.CommonDataKinds.Phone.TYPE_MOBILE: Log.i(contactName + \": TYPE_MOBILE\", ' ' + phoneNo); break; case ContactsContract.CommonDataKinds.Phone.TYPE_HOME: Log.i(contactName + \": TYPE_HOME\", ' ' + phoneNo); break; case ContactsContract.CommonDataKinds.Phone.TYPE_WORK: Log.i(contactName + \": TYPE_WORK\", ' ' + phoneNo); break; case ContactsContract.CommonDataKinds.Phone.TYPE_WORK_MOBILE: Log.i(contactName + \": TYPE_WORK_MOBILE\", ' ' + phoneNo); break; case ContactsContract.CommonDataKinds.Phone.TYPE_OTHER: Log.i(contactName + \": TYPE_OTHER\", ' ' + phoneNo); break; default: break; } } pCursor.close(); } } } cursor.close(); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Grant-master/Grant-master/sample/src/main/java/com/anthonycr/sample/ContactsUtils.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "ContactsUtils handles multiple responsibilities: querying contacts, processing cursor data, and logging. A class should have only one reason to change."}, {"principle": "Open-Closed", "justification": "The switch statement on phone types requires modifying existing code to add new types. The class should allow extension without modification."}]}]}
{"project_id": 5, "chunk_id": 0, "prompt": {"main_file_path": "Grant-master/Grant-master/library/src/main/java/com/anthonycr/grant/PermissionsManager.java", "main_file_content": "package com.anthonycr.grant; import android.Manifest; import android.app.Activity; import android.content.Context; import android.content.pm.PackageInfo; import android.content.pm.PackageManager; import android.os.Build; import android.support.annotation.NonNull; import android.support.annotation.Nullable; import android.support.v4.app.ActivityCompat; import android.support.v4.app.Fragment; import android.util.Log; import java.lang.ref.WeakReference; import java.lang.reflect.Field; import java.util.ArrayList; import java.util.HashSet; import java.util.Iterator; import java.util.List; import java.util.Set; public class PermissionsManager { private static final String TAG = PermissionsManager.class.getSimpleName(); private final Set<String> mPendingRequests = new HashSet<>(1); private final Set<String> mPermissions = new HashSet<>(1); private final List<WeakReference<PermissionsResultAction>> mPendingActions = new ArrayList<>(1); private static PermissionsManager mInstance = null; public static PermissionsManager getInstance() { if (mInstance == null) { mInstance = new PermissionsManager(); } return mInstance; } private PermissionsManager() { initializePermissionsMap(); } private synchronized void initializePermissionsMap() { Field[] fields = Manifest.permission.class.getFields(); for (Field field : fields) { String name = null; try { name = (String) field.get(\"\"); } catch (IllegalAccessException e) { Log.e(TAG, \"Could not access field\", e); } mPermissions.add(name); } } @NonNull private synchronized String[] getManifestPermissions(@NonNull final Activity activity) { PackageInfo packageInfo = null; List<String> list = new ArrayList<>(1); try { Log.d(TAG, activity.getPackageName()); packageInfo = activity.getPackageManager().getPackageInfo(activity.getPackageName(), PackageManager.GET_PERMISSIONS); } catch (PackageManager.NameNotFoundException e) { Log.e(TAG, \"A problem occurred when retrieving permissions\", e); } if (packageInfo != null) { String[] permissions = packageInfo.requestedPermissions; if (permissions != null) { for (String perm : permissions) { Log.d(TAG, \"Manifest contained permission: \" + perm); list.add(perm); } } } return list.toArray(new String[list.size()]); } private synchronized void addPendingAction(@NonNull String[] permissions, @Nullable PermissionsResultAction action) { if (action == null) { return; } action.registerPermissions(permissions); mPendingActions.add(new WeakReference<>(action)); } private synchronized void removePendingAction(@Nullable PermissionsResultAction action) { for (Iterator<WeakReference<PermissionsResultAction>> iterator = mPendingActions.iterator(); iterator.hasNext(); ) { WeakReference<PermissionsResultAction> weakRef = iterator.next(); if (weakRef.get() == action || weakRef.get() == null) { iterator.remove(); } } } @SuppressWarnings(\"unused\") public synchronized boolean hasPermission(@Nullable Context context, @NonNull String permission) { return context != null && (ActivityCompat.checkSelfPermission(context, permission) == PackageManager.PERMISSION_GRANTED || !mPermissions.contains(permission)); } @SuppressWarnings(\"unused\") public synchronized boolean hasAllPermissions(@Nullable Context context, @NonNull String[] permissions) { if (context == null) { return false; } boolean hasAllPermissions = true; for (String perm : permissions) { hasAllPermissions &= hasPermission(context, perm); } return hasAllPermissions; } @SuppressWarnings(\"unused\") public synchronized void requestAllManifestPermissionsIfNecessary(final @Nullable Activity activity, final @Nullable PermissionsResultAction action) { if (activity == null) { return; } String[] perms = getManifestPermissions(activity); requestPermissionsIfNecessaryForResult(activity, perms, action); } @SuppressWarnings(\"unused\") public synchronized void requestPermissionsIfNecessaryForResult(@Nullable Activity activity, @NonNull String[] permissions, @Nullable PermissionsResultAction action) { if (activity == null) { return; } addPendingAction(permissions, action); if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) { doPermissionWorkBeforeAndroidM(activity, permissions, action); } else { List<String> permList = getPermissionsListToRequest(activity, permissions, action); if (permList.isEmpty()) { removePendingAction(action); } else { String[] permsToRequest = permList.toArray(new String[permList.size()]); mPendingRequests.addAll(permList); ActivityCompat.requestPermissions(activity, permsToRequest, 1); } } } @SuppressWarnings(\"unused\") public synchronized void requestPermissionsIfNecessaryForResult(@NonNull Fragment fragment, @NonNull String[] permissions, @Nullable PermissionsResultAction action) { Activity activity = fragment.getActivity(); if (activity == null) { return; } addPendingAction(permissions, action); if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) { doPermissionWorkBeforeAndroidM(activity, permissions, action); } else { List<String> permList = getPermissionsListToRequest(activity, permissions, action); if (permList.isEmpty()) { removePendingAction(action); } else { String[] permsToRequest = permList.toArray(new String[permList.size()]); mPendingRequests.addAll(permList); fragment.requestPermissions(permsToRequest, 1); } } } @SuppressWarnings(\"unused\") public synchronized void notifyPermissionsChange(@NonNull String[] permissions, @NonNull int[] results) { int size = permissions.length; if (results.length < size) { size = results.length; } Iterator<WeakReference<PermissionsResultAction>> iterator = mPendingActions.iterator(); while (iterator.hasNext()) { PermissionsResultAction action = iterator.next().get(); for (int n = 0; n < size; n++) { if (action == null || action.onResult(permissions[n], results[n])) { iterator.remove(); break; } } } for (int n = 0; n < size; n++) { mPendingRequests.remove(permissions[n]); } } private void doPermissionWorkBeforeAndroidM(@NonNull Activity activity, @NonNull String[] permissions, @Nullable PermissionsResultAction action) { for (String perm : permissions) { if (action != null) { if (!mPermissions.contains(perm)) { action.onResult(perm, Permissions.NOT_FOUND); } else if (ActivityCompat.checkSelfPermission(activity, perm) != PackageManager.PERMISSION_GRANTED) { action.onResult(perm, Permissions.DENIED); } else { action.onResult(perm, Permissions.GRANTED); } } } } @NonNull private List<String> getPermissionsListToRequest(@NonNull Activity activity, @NonNull String[] permissions, @Nullable PermissionsResultAction action) { List<String> permList = new ArrayList<>(permissions.length); for (String perm : permissions) { if (!mPermissions.contains(perm)) { if (action != null) { action.onResult(perm, Permissions.NOT_FOUND); } } else if (ActivityCompat.checkSelfPermission(activity, perm) != PackageManager.PERMISSION_GRANTED) { if (!mPendingRequests.contains(perm)) { permList.add(perm); } } else { if (action != null) { action.onResult(perm, Permissions.GRANTED); } } } return permList; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Grant-master/Grant-master/library/src/main/java/com/anthonycr/grant/PermissionsManager.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The class manages permissions, tracks pending requests, initializes permissions from the manifest, and handles both Activity and Fragment interactions, indicating multiple responsibilities."}, {"principle": "Open-Closed", "justification": "The singleton pattern with a private constructor makes it difficult to extend the class without modifying its existing code, violating extensibility."}, {"principle": "Interface Segregation", "justification": "Clients using Activity or Fragment must depend on the entire interface, even if they only use one component, forcing unnecessary method dependencies."}]}]}
{"project_id": 5, "chunk_id": 0, "prompt": {"main_file_path": "Grant-master/Grant-master/library/src/main/java/com/anthonycr/grant/PermissionsResultAction.java", "main_file_content": "package com.anthonycr.grant; import android.content.pm.PackageManager; import android.os.Handler; import android.os.Looper; import android.support.annotation.CallSuper; import android.support.annotation.NonNull; import android.util.Log; import java.util.Collections; import java.util.HashSet; import java.util.Set; public abstract class PermissionsResultAction { private static final String TAG = PermissionsResultAction.class.getSimpleName(); private final Set<String> mPermissions = new HashSet<>(1); private Looper mLooper = Looper.getMainLooper(); public PermissionsResultAction() {} @SuppressWarnings(\"unused\") public PermissionsResultAction(@NonNull Looper looper) {mLooper = looper;} public abstract void onGranted(); public abstract void onDenied(String permission); @SuppressWarnings({\"WeakerAccess\", \"SameReturnValue\"}) public synchronized boolean shouldIgnorePermissionNotFound(String permission) { Log.d(TAG, \"Permission not found: \" + permission); return true; } @SuppressWarnings(\"WeakerAccess\") @CallSuper protected synchronized final boolean onResult(final @NonNull String permission, int result) { if (result == PackageManager.PERMISSION_GRANTED) { return onResult(permission, Permissions.GRANTED); } else { return onResult(permission, Permissions.DENIED); } } @SuppressWarnings(\"WeakerAccess\") @CallSuper protected synchronized final boolean onResult(final @NonNull String permission, Permissions result) { mPermissions.remove(permission); if (result == Permissions.GRANTED) { if (mPermissions.isEmpty()) { new Handler(mLooper).post(new Runnable() { @Override public void run() { onGranted(); } }); return true; } } else if (result == Permissions.DENIED) { new Handler(mLooper).post(new Runnable() { @Override public void run() { onDenied(permission); } }); return true; } else if (result == Permissions.NOT_FOUND) { if (shouldIgnorePermissionNotFound(permission)) { if (mPermissions.isEmpty()) { new Handler(mLooper).post(new Runnable() { @Override public void run() { onGranted(); } }); return true; } } else { new Handler(mLooper).post(new Runnable() { @Override public void run() { onDenied(permission); } }); return true; } } return false; } @SuppressWarnings(\"WeakerAccess\") @CallSuper protected synchronized final void registerPermissions(@NonNull String[] perms) { Collections.addAll(mPermissions, perms); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Grant-master/Grant-master/library/src/main/java/com/anthonycr/grant/PermissionsResultAction.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The class manages permissions tracking, result handling, and thread switching via Handler/Looper, indicating multiple responsibilities. Changes in permission storage, result logic, or threading would require modifications."}, {"principle": "Interface Segregation", "justification": "Subclasses must implement both onGranted() and onDenied() even if they only need one. Forces clients to depend on unused methods, violating ISP."}]}]}
{"project_id": 5, "chunk_id": 0, "prompt": {"main_file_path": "Grant-master/Grant-master/library/src/main/java/com/anthonycr/grant/Permissions.java", "main_file_content": "package com.anthonycr.grant; enum Permissions { GRANTED, DENIED, NOT_FOUND }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Grant-master/Grant-master/library/src/main/java/com/anthonycr/grant/Permissions.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "The Permissions enum cannot be extended to add new permission types without modifying its existing code, violating the Open-Closed Principle."}]}]}
{"project_id": 7, "chunk_id": 0, "prompt": {"main_file_path": "keytype-main/keytype-main/WordManager.java", "main_file_content": "import java.util.ArrayList; class WordManager{ PseudoRandomNumber randomNumberGenerator = new PseudoRandomNumber(System.currentTimeMillis()); void addWord(ArrayList<String> wordList, ArrayList<Word> boardWordList, int ColumnSize, int rowSize, char[][] boardBox){ int randomWordIndex = randomNumberGenerator.generateRandomNumber(0, wordList.size() - 1); String randomWord = wordList.get(randomWordIndex); int randomColumnIndex = randomNumberGenerator.generateRandomNumber(1, ColumnSize - randomWord.length() - 2); int randomRowIndex = randomNumberGenerator.generateRandomNumber(1, 10); boolean canAddWord=true; outerLoop: for(int i=randomColumnIndex-1;i<=randomColumnIndex+randomWord.length();i++){ for(int j=0;j<boardWordList.size();j++){ for(int k=boardWordList.get(j).Y;k<=boardWordList.get(j).word.length()+boardWordList.get(j).Y;k++){ if(i==k && boardWordList.get(j).X==randomRowIndex){ canAddWord=false; break outerLoop; } } } } if(canAddWord){ Word word = new Word(randomWord, randomRowIndex, randomColumnIndex); boardWordList.add(word); } } boolean wordMatching(ArrayList<Word> boardWordList, String userInput, char[][] BoardBox){ for(int i=0;i<boardWordList.size();i++){ if(userInput.equals(boardWordList.get(i).word)){ for(int j=0;j<boardWordList.get(i).word.length();j++){ BoardBox[boardWordList.get(i).X][boardWordList.get(i).Y+j]=' '; } boardWordList.remove(i); return true; } } return false; } void wordDownFall(ArrayList<Word> boardWordList, char[][] BoardBox){ for(int i=0;i<boardWordList.size();i++){ for(int j=0;j<boardWordList.get(i).word.length();j++){ BoardBox[boardWordList.get(i).X][boardWordList.get(i).Y+j]=' '; } } for(int i=0;i<boardWordList.size();i++){ boardWordList.get(i).X=boardWordList.get(i).X+1; } } }", "dependencies": [{"file_path": "keytype-main/keytype-main/PseudoRandomNumber.java", "file_content": "class PseudoRandomNumber { long MULTIPLIER = 1103515245; long INCREMENT = 12345; long MODULUS = (long) Math.pow(2, 31); long seed; PseudoRandomNumber(long seed) { this.seed = seed; } int nextInt() { seed = (MULTIPLIER * seed + INCREMENT) % MODULUS; return (int) seed; } int generateRandomNumber(int min, int max) { int range = max - min + 1; int randomNumber = min + nextInt() % range; if(randomNumber<0)randomNumber=randomNumber*-1; return randomNumber; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "keytype-main/keytype-main/WordManager.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "WordManager handles adding words, checking word matches, and managing word movement. These are multiple distinct responsibilities within a single class."}, {"principle": "Open-Closed", "justification": "Adding new word placement strategies or behaviors would require modifying existing methods in WordManager instead of extending via abstractions."}, {"principle": "Dependency Inversion", "justification": "WordManager directly instantiates PseudoRandomNumber (a concrete class) instead of depending on an abstraction for random number generation."}]}]}
{"project_id": 7, "chunk_id": 0, "prompt": {"main_file_path": "keytype-main/keytype-main/Word.java", "main_file_content": "import java.util.ArrayList; class Word{ String word; int X,Y; Word(String word, int X, int Y) { this.word = word; this.X = X; this.Y = Y; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "keytype-main/keytype-main/Word.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Word class handles both word storage and coordinate management. Changes to word data structure or coordinate logic would require modifying the same class, indicating multiple responsibilities."}]}]}
{"project_id": 7, "chunk_id": 0, "prompt": {"main_file_path": "keytype-main/keytype-main/BoardManager.java", "main_file_content": "import java.util.ArrayList; class BoardManager{ BoardManager(char[][] BoardBox, int RowSize ,int ColumnSize){ for(int i=0;i<RowSize;i++){ for(int j=0;j<ColumnSize;j++){ if(i!=0 && i!=(RowSize-1) && (j==0 || j==(ColumnSize-2)))BoardBox[i][j]='|'; else if(j==ColumnSize-1)BoardBox[i][j]='\\n'; else if(i==0 || i==(RowSize-1))BoardBox[i][j]='='; else BoardBox[i][j]=' '; } } } void gameStart(){ String[] pattern = { \"## ## ########### ## ## ############## ## ## ######### ###########\", \"## ## ########### ## ## ############## ## ## ## ## ###########\", \"## ## ## ## ## ## ## ## ## ## ## \", \"## ## ## ## ## ## ## ## ## ## ## \", \"## ## ## ## ## ## ## ## ## ## ## \", \"### ########### #### ## #### ####### ###########\", \"### ########### ## ## ## ## ###########\", \"## ## ## ## ## ## ## ## \", \"## ## ## ## ## ## ## ## \", \"## ## ## ## ## ## ## ## \", \"## ## ########### ## ## ## ## ###########\", \"## ## ########### ## ## ## ## ###########\"}; for(int i=0;i<pattern.length;i++){ soutl(\"\") } soutl(\"\") soutl(\"\") } void gameOver(){ sout(\"\") System.out.flush(); String[] pattern = { \" ####### #### #### #### ########### ####### ## ## ########### ###### \", \" ######### ## ## ## ## ## ## ########### ######### ## ## ########### ## ##\", \" ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ##\", \" ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ##\", \"## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ##\", \"## ############ ## #### ## ########### ## ## ## ## ########### ####\", \"## ###### ## ## ## ## ########### ## ## ## ## ########### ####\", \"## ###### ## ## ## ## ## ## ## ## ## ## ## ##\", \" ## ## ## ## ## ## ## ## ## ## ## ## ## ##\", \" ## ## ## ## ## ## ## ## ## ## ## ## ## ##\", \" ######### ## ## ## ## ########### ######### ## ## ########### ## ##\", \" ####### ## ## ## ## ########### ####### #### ########### ## ##\"}; for(int i=0;i<pattern.length;i++){ soutl(\"\") } } void displayBoard(char[][] BoardBox, int RowSize ,int ColumnSize){ for(int i=0;i<RowSize;i++){ for(int j=0;j<ColumnSize;j++){ sout(\"\") } } } void setBoardWithBoardWordList(ArrayList<Word> wordList, char[][] BoardBox){ for(int i=0;i<wordList.size();i++){ for(int j=0;j<wordList.get(i).word.length();j++){ BoardBox[wordList.get(i).X][wordList.get(i).Y+j]=wordList.get(i).word.charAt(j); } } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "keytype-main/keytype-main/BoardManager.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "BoardManager handles board initialization, game start/over screens, board display, and word list updates. These are multiple responsibilities requiring separate reasons to change."}, {"principle": "Open-Closed", "justification": "Adding new board rendering logic or game states requires modifying existing methods (e.g., displayBoard, gameStart) rather than extending via inheritance or composition."}, {"principle": "Dependency Inversion", "justification": "setBoardWithBoardWordList directly depends on concrete ArrayList<Word> and Word classes instead of abstractions. High-level board management depends on low-level implementations."}]}]}
{"project_id": 7, "chunk_id": 0, "prompt": {"main_file_path": "keytype-main/keytype-main/KeyType.java", "main_file_content": "import java.util.Scanner; import java.util.ArrayList; class KeyType{ static String wordData = \"wordData.txt\"; static String resumeData = \"resume.txt\"; static String correctWord= \"correctWord.txt\"; static int rowSize = 30; static int columnSize = 100; static char[][] boardBox = new char[rowSize][columnSize]; static int score = 0; static boolean resumeStatus = false; static final int gameTickInterval = 1000; static int wordAddCounter = 0; static final int wordAddInterval = 5; public static void main(String[] args){ Scanner getInput = new Scanner(System.in); FileManager fileManager = new FileManager(); WordManager wordManager= new WordManager(); BoardManager boardManager = new BoardManager(boardBox, rowSize, columnSize); ArrayList<Word> boardWordList = new ArrayList<>(); ArrayList<String> wordList = fileManager.readAllWordFromFile(wordData); boardManager.gameStart(); sout(\"\") int choice = getInput.nextInt(); getInput.nextLine(); switch(choice){ case 1:{ fileManager.writeWordWithIndexForResume(boardWordList, resumeData); break; } case 2:{ fileManager.readWordWithIndexForResume(boardWordList,resumeData); resumeStatus=true; break; } default: { soutl(\"\") } } boolean isGameOver = false; while(!isGameOver){ long startTime = System.currentTimeMillis(); wordManager.addWord(wordList, boardWordList, columnSize, rowSize, boardBox); if(resumeStatus && !fileManager.isFileEmpty(resumeData)){ score=fileManager.correctWordLength(correctWord); boardWordList.remove(boardWordList.size()-1); resumeStatus=false; }else{ wordAddCounter++; if(wordAddCounter>=wordAddInterval) { wordManager.addWord(wordList, boardWordList, columnSize, rowSize, boardBox); wordAddCounter = 0; } } boardManager.setBoardWithBoardWordList(boardWordList,boardBox); fileManager.writeWordWithIndexForResume(boardWordList, resumeData); boardManager.displayBoard(boardBox, rowSize, columnSize); soutl(\"\") sout(\"\") String userInput = getInput.nextLine(); if(userInput.equals(\"exit\")){ System.exit(0); } boolean wordMatchingStatus = wordManager.wordMatching(boardWordList, userInput, boardBox); if(wordMatchingStatus){ score++; fileManager.writeCorrectWord(correctWord,userInput); } wordManager.wordDownFall(boardWordList, boardBox); for(int i=0;i<boardWordList.size();i++){ if(boardWordList.get(i).X==(rowSize-1)){ isGameOver=true; boardWordList.clear(); fileManager.writeWordWithIndexForResume(boardWordList, resumeData); } } long endTime = System.currentTimeMillis(); long elapsedTime = endTime - startTime; if(elapsedTime<gameTickInterval){ try{ Thread.sleep(gameTickInterval-elapsedTime); }catch(InterruptedException e){ e.printStackTrace(); } } } if(isGameOver){ boardManager.gameOver(); soutl(\"\") fileManager.displayCorrectWord(correctWord); fileManager.clearCorrectWordFile(correctWord); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "keytype-main/keytype-main/KeyType.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The KeyType class handles multiple responsibilities: game loop management, user input handling, file I/O operations, and coordinating dependencies like FileManager and WordManager. This violates SRP as it has multiple reasons to change."}, {"principle": "Open-Closed", "justification": "The main method uses a switch-case structure for specific choices (1 and 2). Adding new functionality (e.g., a new game mode) would require modifying existing code instead of extending via abstractions, violating OCP."}, {"principle": "Dependency Inversion", "justification": "KeyType directly instantiates concrete implementations (FileManager, WordManager, BoardManager) instead of depending on abstractions. High-level modules should depend on interfaces, not low-level concretions."}]}]}
{"project_id": 7, "chunk_id": 0, "prompt": {"main_file_path": "keytype-main/keytype-main/PseudoRandomNumber.java", "main_file_content": "class PseudoRandomNumber { long MULTIPLIER = 1103515245; long INCREMENT = 12345; long MODULUS = (long) Math.pow(2, 31); long seed; PseudoRandomNumber(long seed) { this.seed = seed; } int nextInt() { seed = (MULTIPLIER * seed + INCREMENT) % MODULUS; return (int) seed; } int generateRandomNumber(int min, int max) { int range = max - min + 1; int randomNumber = min + nextInt() % range; if(randomNumber<0)randomNumber=randomNumber*-1; return randomNumber; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "keytype-main/keytype-main/PseudoRandomNumber.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The PseudoRandomNumber class handles both generating pseudo-random numbers and adjusting them to a specific range. These are two distinct responsibilities, so the class has more than one reason to change."}, {"principle": "Open-Closed", "justification": "The class cannot be extended to introduce new random number generation algorithms without modifying its existing code. It lacks abstractions (e.g., interfaces) to allow behavioral extensions."}]}]}
{"project_id": 7, "chunk_id": 0, "prompt": {"main_file_path": "keytype-main/keytype-main/FileManager.java", "main_file_content": "import java.io.IOException; import java.util.ArrayList; import java.io.BufferedReader; import java.io.FileReader; import java.io.BufferedWriter; import java.io.FileWriter; import java.nio.file.Files; import java.nio.file.Path; class FileManager { ArrayList<String> readAllWordFromFile(String fileName){ ArrayList<String> data = new ArrayList<String>(); String line; try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) { while ((line = reader.readLine()) != null) { data.add(line); } } catch (IOException e) { e.printStackTrace(); } return data; } void writeCorrectWord(String fileName, String userInput){ try (BufferedWriter writter = new BufferedWriter(new FileWriter(fileName, true))) { writter.write(userInput+\"\\n\"); } catch (IOException e) { e.printStackTrace(); } } void writeWordWithIndexForResume(ArrayList<Word> boardWordList, String fileName){ try (BufferedWriter writter = new BufferedWriter(new FileWriter(fileName))) { for(int i=0;i<boardWordList.size();i++){ writter.write(boardWordList.get(i).word+\"|\"+boardWordList.get(i).X+\"|\"+boardWordList.get(i).Y+\"\\n\"); } } catch (IOException e) { e.printStackTrace(); } } void displayCorrectWord(String fileName){ try (BufferedReader br = new BufferedReader(new FileReader(fileName))) { int count=1; String line; while ((line = br.readLine()) != null) { soutl(\"\") count++; } } catch (IOException e) { e.printStackTrace(); } } void clearCorrectWordFile(String fileName){ try (BufferedWriter writter = new BufferedWriter(new FileWriter(fileName))) { writter.write(\"\"); } catch (IOException e) { e.printStackTrace(); } } void readWordWithIndexForResume(ArrayList<Word> boardWordList, String fileName){ try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) { String line; while ((line = reader.readLine()) != null) { String[] components = line.split(\"\\\\|\"); Word word = new Word(components[0], Integer.parseInt(components[1]), Integer.parseInt(components[2])); boardWordList.add(word); } } catch (IOException e) { e.printStackTrace(); } } int correctWordLength(String fileName){ int lineCount = 0; try (BufferedReader br = new BufferedReader(new FileReader(fileName))) { String line; while ((line = br.readLine()) != null) { lineCount++; } } catch (IOException e) { e.printStackTrace(); } return lineCount; } boolean isFileEmpty(String fileName){ try{ Path path = Path.of(fileName); return (Files.size(path)==0)?true:false; } catch (IOException e) { e.printStackTrace(); } return false; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "keytype-main/keytype-main/FileManager.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "FileManager handles multiple responsibilities: reading, writing, clearing files, checking emptiness, and parsing Word objects. Each responsibility is a separate reason to change."}, {"principle": "Open-Closed", "justification": "FileManager is not extensible without modifying existing code (e.g., adding new file operations requires altering the class directly)."}]}]}
{"project_id": 8, "chunk_id": 0, "prompt": {"main_file_path": "mybatis-generator-lombok-plugin-master/src/main/java/com/softwareloop/mybatis/generator/plugins/LombokPlugin.java", "main_file_content": "package com.softwareloop.mybatis.generator.plugins; import org.mybatis.generator.api.IntrospectedColumn; import org.mybatis.generator.api.IntrospectedTable; import org.mybatis.generator.api.PluginAdapter; import org.mybatis.generator.api.dom.java.FullyQualifiedJavaType; import org.mybatis.generator.api.dom.java.Interface; import org.mybatis.generator.api.dom.java.Method; import org.mybatis.generator.api.dom.java.TopLevelClass; import java.util.*; public class LombokPlugin extends PluginAdapter { private final Collection<Annotations> annotations; public LombokPlugin() { annotations = new LinkedHashSet<Annotations>(Annotations.values().length); } public boolean validate(List<String> warnings) { return true; } @Override public boolean modelBaseRecordClassGenerated( TopLevelClass topLevelClass, IntrospectedTable introspectedTable ) { addAnnotations(topLevelClass); return true; } @Override public boolean modelPrimaryKeyClassGenerated( TopLevelClass topLevelClass, IntrospectedTable introspectedTable ) { addAnnotations(topLevelClass); return true; } @Override public boolean modelRecordWithBLOBsClassGenerated( TopLevelClass topLevelClass, IntrospectedTable introspectedTable ) { addAnnotations(topLevelClass); return true; } @Override public boolean modelGetterMethodGenerated( Method method, TopLevelClass topLevelClass, IntrospectedColumn introspectedColumn, IntrospectedTable introspectedTable, ModelClassType modelClassType ) { return false; } @Override public boolean modelSetterMethodGenerated( Method method, TopLevelClass topLevelClass, IntrospectedColumn introspectedColumn, IntrospectedTable introspectedTable, ModelClassType modelClassType ) { return false; } private void addAnnotations(TopLevelClass topLevelClass) { for (Annotations annotation : annotations) { topLevelClass.addImportedType(annotation.javaType); topLevelClass.addAnnotation(annotation.asAnnotation()); } } @Override public void setProperties(Properties properties) { super.setProperties(properties); annotations.add(Annotations.DATA); for (String annotationName : properties.stringPropertyNames()) { if (annotationName.contains(\".\")) { continue; } String value = properties.getProperty(annotationName); if (!Boolean.parseBoolean(value)) { continue; } Annotations annotation = Annotations.getValueOf(annotationName); if (annotation == null) { continue; } String optionsPrefix = annotationName + \".\"; for (String propertyName : properties.stringPropertyNames()) { if (!propertyName.startsWith(optionsPrefix)) { continue; } String propertyValue = properties.getProperty(propertyName); annotation.appendOptions(propertyName, propertyValue); annotations.add(annotation); annotations.addAll(Annotations.getDependencies(annotation)); } } } @Override public boolean clientGenerated( Interface interfaze, TopLevelClass topLevelClass, IntrospectedTable introspectedTable ) { interfaze.addImportedType(new FullyQualifiedJavaType( \"org.apache.ibatis.annotations.Mapper\")); interfaze.addAnnotation(\"@Mapper\"); return true; } private enum Annotations { DATA(\"data\", \"@Data\", \"lombok.Data\"), BUILDER(\"builder\", \"@Builder\", \"lombok.Builder\"), ALL_ARGS_CONSTRUCTOR(\"allArgsConstructor\", \"@AllArgsConstructor\", \"lombok.AllArgsConstructor\"), NO_ARGS_CONSTRUCTOR(\"noArgsConstructor\", \"@NoArgsConstructor\", \"lombok.NoArgsConstructor\"), ACCESSORS(\"accessors\", \"@Accessors\", \"lombok.experimental.Accessors\"), TO_STRING(\"toString\", \"@ToString\", \"lombok.ToString\"); private final String paramName; private final String name; private final FullyQualifiedJavaType javaType; private final List<String> options; Annotations(String paramName, String name, String className) { this.paramName = paramName; this.name = name; this.javaType = new FullyQualifiedJavaType(className); this.options = new ArrayList<String>(); } private static Annotations getValueOf(String paramName) { for (Annotations annotation : Annotations.values()) if (String.CASE_INSENSITIVE_ORDER.compare(paramName, annotation.paramName) == 0) return annotation; return null; } private static Collection<Annotations> getDependencies(Annotations annotation) { if (annotation == ALL_ARGS_CONSTRUCTOR) return Collections.singleton(NO_ARGS_CONSTRUCTOR); else return Collections.emptyList(); } private static String quote(String value) { if (Boolean.TRUE.toString().equals(value) || Boolean.FALSE.toString().equals(value)) return value; return value.replaceAll(\"[\\\\w]+\", \"\\\"$0\\\"\"); } private void appendOptions(String key, String value) { String keyPart = key.substring(key.indexOf(\".\") + 1); String valuePart = value.contains(\",\") ? String.format(\"{%s}\", value) : value; this.options.add(String.format(\"%s=%s\", keyPart, quote(valuePart))); } private String asAnnotation() { if (options.isEmpty()) { return name; } StringBuilder sb = new StringBuilder(); sb.append(name); sb.append(\"(\"); boolean first = true; for (String option : options) { if (first) { first = false; } else { sb.append(\", \"); } sb.append(option); } sb.append(\")\"); return sb.toString(); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "mybatis-generator-lombok-plugin-master/src/main/java/com/softwareloop/mybatis/generator/plugins/LombokPlugin.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "The LombokPlugin's Annotations enum is not extensible without modifying its code. Adding new Lombok annotations requires changing the enum, violating OCP."}, {"principle": "Single Responsibility", "justification": "The LombokPlugin handles property parsing, annotation configuration, and client interface modification, indicating multiple responsibilities."}]}]}
{"project_id": 8, "chunk_id": 0, "prompt": {"main_file_path": "mybatis-generator-lombok-plugin-master/mybatis-generator-lombok-plugin-master/src/main/java/com/softwareloop/mybatis/generator/plugins/LombokPlugin.java", "main_file_content": "package com.softwareloop.mybatis.generator.plugins; import org.mybatis.generator.api.IntrospectedColumn; import org.mybatis.generator.api.IntrospectedTable; import org.mybatis.generator.api.PluginAdapter; import org.mybatis.generator.api.dom.java.FullyQualifiedJavaType; import org.mybatis.generator.api.dom.java.Interface; import org.mybatis.generator.api.dom.java.Method; import org.mybatis.generator.api.dom.java.TopLevelClass; import java.util.*; public class LombokPlugin extends PluginAdapter { private final Collection<Annotations> annotations; public LombokPlugin() { annotations = new LinkedHashSet<Annotations>(Annotations.values().length); } public boolean validate(List<String> warnings) { return true; } @Override public boolean modelBaseRecordClassGenerated( TopLevelClass topLevelClass, IntrospectedTable introspectedTable ) { addAnnotations(topLevelClass); return true; } @Override public boolean modelPrimaryKeyClassGenerated( TopLevelClass topLevelClass, IntrospectedTable introspectedTable ) { addAnnotations(topLevelClass); return true; } @Override public boolean modelRecordWithBLOBsClassGenerated( TopLevelClass topLevelClass, IntrospectedTable introspectedTable ) { addAnnotations(topLevelClass); return true; } @Override public boolean modelGetterMethodGenerated( Method method, TopLevelClass topLevelClass, IntrospectedColumn introspectedColumn, IntrospectedTable introspectedTable, ModelClassType modelClassType ) { return false; } @Override public boolean modelSetterMethodGenerated( Method method, TopLevelClass topLevelClass, IntrospectedColumn introspectedColumn, IntrospectedTable introspectedTable, ModelClassType modelClassType ) { return false; } private void addAnnotations(TopLevelClass topLevelClass) { for (Annotations annotation : annotations) { topLevelClass.addImportedType(annotation.javaType); topLevelClass.addAnnotation(annotation.asAnnotation()); } } @Override public void setProperties(Properties properties) { super.setProperties(properties); annotations.add(Annotations.DATA); for (String annotationName : properties.stringPropertyNames()) { if (annotationName.contains(\".\")) { continue; } String value = properties.getProperty(annotationName); if (!Boolean.parseBoolean(value)) { continue; } Annotations annotation = Annotations.getValueOf(annotationName); if (annotation == null) { continue; } String optionsPrefix = annotationName + \".\"; for (String propertyName : properties.stringPropertyNames()) { if (!propertyName.startsWith(optionsPrefix)) { continue; } String propertyValue = properties.getProperty(propertyName); annotation.appendOptions(propertyName, propertyValue); annotations.add(annotation); annotations.addAll(Annotations.getDependencies(annotation)); } } } @Override public boolean clientGenerated( Interface interfaze, TopLevelClass topLevelClass, IntrospectedTable introspectedTable ) { interfaze.addImportedType(new FullyQualifiedJavaType( \"org.apache.ibatis.annotations.Mapper\")); interfaze.addAnnotation(\"@Mapper\"); return true; } private enum Annotations { DATA(\"data\", \"@Data\", \"lombok.Data\"), BUILDER(\"builder\", \"@Builder\", \"lombok.Builder\"), ALL_ARGS_CONSTRUCTOR(\"allArgsConstructor\", \"@AllArgsConstructor\", \"lombok.AllArgsConstructor\"), NO_ARGS_CONSTRUCTOR(\"noArgsConstructor\", \"@NoArgsConstructor\", \"lombok.NoArgsConstructor\"), ACCESSORS(\"accessors\", \"@Accessors\", \"lombok.experimental.Accessors\"), TO_STRING(\"toString\", \"@ToString\", \"lombok.ToString\"); private final String paramName; private final String name; private final FullyQualifiedJavaType javaType; private final List<String> options; Annotations(String paramName, String name, String className) { this.paramName = paramName; this.name = name; this.javaType = new FullyQualifiedJavaType(className); this.options = new ArrayList<String>(); } private static Annotations getValueOf(String paramName) { for (Annotations annotation : Annotations.values()) if (String.CASE_INSENSITIVE_ORDER.compare(paramName, annotation.paramName) == 0) return annotation; return null; } private static Collection<Annotations> getDependencies(Annotations annotation) { if (annotation == ALL_ARGS_CONSTRUCTOR) return Collections.singleton(NO_ARGS_CONSTRUCTOR); else return Collections.emptyList(); } private static String quote(String value) { if (Boolean.TRUE.toString().equals(value) || Boolean.FALSE.toString().equals(value)) return value; return value.replaceAll(\"[\\\\w]+\", \"\\\"$0\\\"\"); } private void appendOptions(String key, String value) { String keyPart = key.substring(key.indexOf(\".\") + 1); String valuePart = value.contains(\",\") ? String.format(\"{%s}\", value) : value; this.options.add(String.format(\"%s=%s\", keyPart, quote(valuePart))); } private String asAnnotation() { if (options.isEmpty()) { return name; } StringBuilder sb = new StringBuilder(); sb.append(name); sb.append(\"(\"); boolean first = true; for (String option : options) { if (first) { first = false; } else { sb.append(\", \"); } sb.append(option); } sb.append(\")\"); return sb.toString(); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "mybatis-generator-lombok-plugin-master/mybatis-generator-lombok-plugin-master/src/main/java/com/softwareloop/mybatis/generator/plugins/LombokPlugin.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "LombokPlugin handles multiple responsibilities: configuring Lombok annotations for model classes and adding @Mapper to client interfaces. These two distinct tasks should be separated into different classes."}, {"principle": "Open-Closed", "justification": "Adding support for new Lombok annotations requires modifying the Annotations enum and LombokPlugin logic instead of extending via abstractions. The class is not closed for modification."}]}]}
{"project_id": 9, "chunk_id": 0, "prompt": {"main_file_path": "password-generator-terminal-main/MainMenu.java", "main_file_content": "import java.util.Scanner; public class MainMenu { public static void main(String[] args) { Scanner input = new Scanner(System.in); GeneratorSettings genOBJ = new GeneratorSettings(); int selection; String modify; while (true) { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") sout(\"\") selection = input.nextInt(); switch (selection) { case 1: genOBJ.generator(); break; case 2: genOBJ.displaySettings(); while (true) { soutl(\"\") sout(\"\") modify = input.next(); if (modify.equals(\"Y\") || modify.equals(\"y\")) { genOBJ.modifySettings(); break; } else if (modify.equals(\"N\") || modify.equals(\"n\")) { break; } else { soutl(\"\") } } break; case 3: genOBJ.history(); break; case 4: soutl(\"\") System.exit(0); break; default: soutl(\"\") break; } } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "password-generator-terminal-main/MainMenu.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "MainMenu handles user input processing, menu display logic, and application flow control. These multiple responsibilities violate SRP as they represent more than one reason for the class to change."}, {"principle": "Open-Closed", "justification": "MainMenu's switch-case structure for menu options requires direct modification to add new functionality. This violates OCP since extending behavior necessitates changing existing code rather than extending through abstractions."}, {"principle": "Dependency Inversion", "justification": "MainMenu directly instantiates and depends on the concrete GeneratorSettings class instead of an abstraction. High-level modules should depend on interfaces/abstract classes rather than concrete implementations."}]}]}
{"project_id": 9, "chunk_id": 0, "prompt": {"main_file_path": "password-generator-terminal-main/GeneratorSettings.java", "main_file_content": "import java.util.Scanner; public class GeneratorSettings extends Generator { Scanner input = new Scanner(System.in); void displaySettings() { soutl(\"\") soutl(\"\") soutl(\"\") if (passwordLength < 8) { soutl(\"\") soutl(\"\") } if (passwordLength == 1) { soutl(\"\") } else { soutl(\"\") } sout(\"\") if (firstCharIsNumber) { soutl(\"\") } else { soutl(\"\") } sout(\"\") if (firstCharIsSymbol) { soutl(\"\") } else { soutl(\"\") } sout(\"\") if (generateWithSymbols) { soutl(\"\") } else { soutl(\"\") } sout(\"\") if (useSimilarChars) { soutl(\"\") } else { soutl(\"\") } } void modifySettings() { int selection; boolean returnToMainMenu = false; do { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") sout(\"\") selection = input.nextInt(); switch (selection) { case 1: { displaySettings(); break; } case 2: soutl(\"\") while (true) { sout(\"\") passwordLength = input.nextInt(); if (passwordLength < 1 || passwordLength > 100) { soutl(\"\") } else { soutl(\"\") break; } } break; case 3: while (true) { soutl(\"\") sout(\"\") modify = input.next(); if (modify.equals(\"Y\") || modify.equals(\"y\")) { firstCharIsNumber = true; firstCharIsSymbol = false; soutl(\"\") break; } else if (modify.equals(\"N\") || modify.equals(\"n\")) { firstCharIsNumber = false; firstCharIsSymbol = false; soutl(\"\") break; } else { soutl(\"\") } } break; case 4: while (true) { soutl(\"\") sout(\"\") modify = input.next(); if (modify.equals(\"Y\") || modify.equals(\"y\")) { firstCharIsSymbol = true; firstCharIsNumber = false; soutl(\"\") break; } else if (modify.equals(\"N\") || modify.equals(\"n\")) { firstCharIsSymbol = false; firstCharIsNumber = false; soutl(\"\") break; } else { soutl(\"\") } } break; case 5: while (true) { soutl(\"\") sout(\"\") modify = input.next(); if (modify.equals(\"Y\") || modify.equals(\"y\")) { generateWithSymbols = true; soutl(\"\") break; } else if (modify.equals(\"N\") || modify.equals(\"n\")) { generateWithSymbols = false; firstCharIsSymbol = false; soutl(\"\") break; } else { soutl(\"\") } } break; case 6: while (true) { soutl(\"\") soutl(\"\") sout(\"\") modify = input.next(); if (modify.equals(\"Y\") || modify.equals(\"y\")) { useSimilarChars = true; soutl(\"\") break; } else if (modify.equals(\"N\") || modify.equals(\"n\")) { useSimilarChars = false; soutl(\"\") break; } else { soutl(\"\") } } break; case 7: soutl(\"\") returnToMainMenu = true; break; default: soutl(\"\") } } while (!returnToMainMenu); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "password-generator-terminal-main/GeneratorSettings.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "GeneratorSettings handles both user input/output (via Scanner) and password generation settings management. These are two distinct responsibilities, requiring changes for UI adjustments or business logic modifications."}, {"principle": "Open-Closed", "justification": "Adding new password generation settings requires modifying existing code in modifySettings() switch-case logic instead of extending through new abstractions. This violates closed-for-modification requirements."}]}]}
{"project_id": 9, "chunk_id": 0, "prompt": {"main_file_path": "password-generator-terminal-main/Generator.java", "main_file_content": "import java.lang.Math; import java.util.ArrayList; public class Generator { public ArrayList<String> generatedPasswords = new ArrayList<>(); StringBuilder str = new StringBuilder(); String modify; char [] similarChars = {'i', 'I', 'l', 'L', '1', '0', 'o', 'O'}; boolean firstCharIsNumber = false, firstCharIsSymbol = false; boolean generateWithSymbols = true, useSimilarChars = false; int passwordLength = 16; void generator() { int randomValue; char character; if (firstCharIsNumber) { if (!useSimilarChars) { randomValue = (int) (Math.random() * (57 + 1 - 50) + 50); } else { randomValue = (int) (Math.random() * (57 + 1 - 48) + 48); } character = (char) randomValue; str.append(character); } else if (firstCharIsSymbol) { while (true) { randomValue = (int) (Math.random() * (126 + 1 - 48) + 48); character = (char) randomValue; if (!(Character.isDigit(character) || Character.isLetter(character))) { str.append(character); break; } } } if (generateWithSymbols) { while (str.length() < passwordLength) { randomValue = (int) (Math.random() * (126 + 1 - 48) + 48); character = (char) randomValue; str.append(character); if (!useSimilarChars) { removeSimilarCharacters(character); } } } else { while (str.length() < passwordLength) { randomValue = (int) (Math.random() * (126 + 1 - 48) + 48); character = (char) randomValue; if (Character.isDigit(character)) { str.append(character); } else if (Character.isLetter(character)) { str.append(character); } if (!useSimilarChars) { removeSimilarCharacters(character); } } } soutl(\"\") generatedPasswords.add(str.toString()); str.delete(0,passwordLength); } void history() { soutl(\"\") soutl(\"\") soutl(\"\") if (generatedPasswords.isEmpty()) { soutl(\"\") } int i = 1; for (String str : generatedPasswords) { soutl(\"\") i++; } } void removeSimilarCharacters(char character) { for (int i = 0; i < similarChars.length; i++) { if (similarChars[i] == character) { str.delete(str.length() - 1, character); break; } } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "password-generator-terminal-main/Generator.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Generator class manages password generation, history storage, and character filtering, violating SRP by handling multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Adding new password generation strategies requires modifying the generator() method directly, violating OCP as the class is not open for extension."}, {"principle": "Dependency Inversion", "justification": "High-level password generation logic is tightly coupled with low-level character randomization and filtering details without abstractions, violating DIP."}]}]}
{"project_id": 9, "chunk_id": 0, "prompt": {"main_file_path": "password-generator-terminal-main/password-generator-terminal-main/MainMenu.java", "main_file_content": "import java.util.Scanner; public class MainMenu { public static void main(String[] args) { Scanner input = new Scanner(System.in); GeneratorSettings genOBJ = new GeneratorSettings(); int selection; String modify; while (true) { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") sout(\"\") selection = input.nextInt(); switch (selection) { case 1: genOBJ.generator(); break; case 2: genOBJ.displaySettings(); while (true) { soutl(\"\") sout(\"\") modify = input.next(); if (modify.equals(\"Y\") || modify.equals(\"y\")) { genOBJ.modifySettings(); break; } else if (modify.equals(\"N\") || modify.equals(\"n\")) { break; } else { soutl(\"\") } } break; case 3: genOBJ.history(); break; case 4: soutl(\"\") System.exit(0); break; default: soutl(\"\") break; } } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "password-generator-terminal-main/password-generator-terminal-main/MainMenu.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "MainMenu handles user input, menu display, and application flow control, which are multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Adding new menu options requires modifying the switch statement in MainMenu, violating the open for extension but closed for modification principle."}, {"principle": "Dependency Inversion", "justification": "MainMenu directly depends on the concrete GeneratorSettings class instead of an abstraction, creating a tight coupling."}]}]}
{"project_id": 9, "chunk_id": 0, "prompt": {"main_file_path": "password-generator-terminal-main/password-generator-terminal-main/GeneratorSettings.java", "main_file_content": "import java.util.Scanner; public class GeneratorSettings extends Generator { Scanner input = new Scanner(System.in); void displaySettings() { soutl(\"\") soutl(\"\") soutl(\"\") if (passwordLength < 8) { soutl(\"\") soutl(\"\") } if (passwordLength == 1) { soutl(\"\") } else { soutl(\"\") } sout(\"\") if (firstCharIsNumber) { soutl(\"\") } else { soutl(\"\") } sout(\"\") if (firstCharIsSymbol) { soutl(\"\") } else { soutl(\"\") } sout(\"\") if (generateWithSymbols) { soutl(\"\") } else { soutl(\"\") } sout(\"\") if (useSimilarChars) { soutl(\"\") } else { soutl(\"\") } } void modifySettings() { int selection; boolean returnToMainMenu = false; do { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") sout(\"\") selection = input.nextInt(); switch (selection) { case 1: { displaySettings(); break; } case 2: soutl(\"\") while (true) { sout(\"\") passwordLength = input.nextInt(); if (passwordLength < 1 || passwordLength > 100) { soutl(\"\") } else { soutl(\"\") break; } } break; case 3: while (true) { soutl(\"\") sout(\"\") modify = input.next(); if (modify.equals(\"Y\") || modify.equals(\"y\")) { firstCharIsNumber = true; firstCharIsSymbol = false; soutl(\"\") break; } else if (modify.equals(\"N\") || modify.equals(\"n\")) { firstCharIsNumber = false; firstCharIsSymbol = false; soutl(\"\") break; } else { soutl(\"\") } } break; case 4: while (true) { soutl(\"\") sout(\"\") modify = input.next(); if (modify.equals(\"Y\") || modify.equals(\"y\")) { firstCharIsSymbol = true; firstCharIsNumber = false; soutl(\"\") break; } else if (modify.equals(\"N\") || modify.equals(\"n\")) { firstCharIsSymbol = false; firstCharIsNumber = false; soutl(\"\") break; } else { soutl(\"\") } } break; case 5: while (true) { soutl(\"\") sout(\"\") modify = input.next(); if (modify.equals(\"Y\") || modify.equals(\"y\")) { generateWithSymbols = true; soutl(\"\") break; } else if (modify.equals(\"N\") || modify.equals(\"n\")) { generateWithSymbols = false; firstCharIsSymbol = false; soutl(\"\") break; } else { soutl(\"\") } } break; case 6: while (true) { soutl(\"\") soutl(\"\") sout(\"\") modify = input.next(); if (modify.equals(\"Y\") || modify.equals(\"y\")) { useSimilarChars = true; soutl(\"\") break; } else if (modify.equals(\"N\") || modify.equals(\"n\")) { useSimilarChars = false; soutl(\"\") break; } else { soutl(\"\") } } break; case 7: soutl(\"\") returnToMainMenu = true; break; default: soutl(\"\") } } while (!returnToMainMenu); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "password-generator-terminal-main/password-generator-terminal-main/GeneratorSettings.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "GeneratorSettings handles both UI interactions (user input/output via Scanner) and settings management logic. These are two distinct responsibilities requiring separate classes."}, {"principle": "Open-Closed", "justification": "Adding new settings requires modifying the modifySettings() method's switch-case logic directly. The class isn't extensible without altering existing code."}]}]}
{"project_id": 9, "chunk_id": 0, "prompt": {"main_file_path": "password-generator-terminal-main/password-generator-terminal-main/Generator.java", "main_file_content": "import java.lang.Math; import java.util.ArrayList; public class Generator { public ArrayList<String> generatedPasswords = new ArrayList<>(); StringBuilder str = new StringBuilder(); String modify; char [] similarChars = {'i', 'I', 'l', 'L', '1', '0', 'o', 'O'}; boolean firstCharIsNumber = false, firstCharIsSymbol = false; boolean generateWithSymbols = true, useSimilarChars = false; int passwordLength = 16; void generator() { int randomValue; char character; if (firstCharIsNumber) { if (!useSimilarChars) { randomValue = (int) (Math.random() * (57 + 1 - 50) + 50); } else { randomValue = (int) (Math.random() * (57 + 1 - 48) + 48); } character = (char) randomValue; str.append(character); } else if (firstCharIsSymbol) { while (true) { randomValue = (int) (Math.random() * (126 + 1 - 48) + 48); character = (char) randomValue; if (!(Character.isDigit(character) || Character.isLetter(character))) { str.append(character); break; } } } if (generateWithSymbols) { while (str.length() < passwordLength) { randomValue = (int) (Math.random() * (126 + 1 - 48) + 48); character = (char) randomValue; str.append(character); if (!useSimilarChars) { removeSimilarCharacters(character); } } } else { while (str.length() < passwordLength) { randomValue = (int) (Math.random() * (126 + 1 - 48) + 48); character = (char) randomValue; if (Character.isDigit(character)) { str.append(character); } else if (Character.isLetter(character)) { str.append(character); } if (!useSimilarChars) { removeSimilarCharacters(character); } } } soutl(\"\") generatedPasswords.add(str.toString()); str.delete(0,passwordLength); } void history() { soutl(\"\") soutl(\"\") soutl(\"\") if (generatedPasswords.isEmpty()) { soutl(\"\") } int i = 1; for (String str : generatedPasswords) { soutl(\"\") i++; } } void removeSimilarCharacters(char character) { for (int i = 0; i < similarChars.length; i++) { if (similarChars[i] == character) { str.delete(str.length() - 1, character); break; } } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "password-generator-terminal-main/password-generator-terminal-main/Generator.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Generator class handles password generation, history management, and character filtering, indicating multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Adding new password generation strategies or modifying existing ones would require direct changes to the generator() method instead of extension."}]}]}
{"project_id": 11, "chunk_id": 0, "prompt": {"main_file_path": "Cab-Booking-master/src/Bookcab.java", "main_file_content": "import java.util.*; public class Bookcab { static Scanner sc = new Scanner(System.in); static void bookCab(String src, String dest, Customer currCust){ boolean avail=false; for(Cab i:Main.drivers){ if(i.location!=null){ avail=true; break; } } if(!avail){ soutl(\"\") return; } int dist= Main.iniloc.get(src), minDist=Integer.MAX_VALUE; Cab availCab = null; for(Cab i: Main.drivers){ int val=Math.abs(dist- Main.iniloc.get(i.location)); if(val<minDist){ minDist=val; availCab=i; } } if(availCab==null){ soutl(\"\") return; } soutl(\"\") soutl(\"\") soutl(\"\") int bookOpt=sc.nextInt(); if(bookOpt<0 || bookOpt>2){ soutl(\"\") } else if(bookOpt==1){ soutl(\"\") availCab.location=dest; int fare=Math.abs(Main.iniloc.get(src)-Main.iniloc.get(dest))*10; Cab.Trip bookedCab = new Cab.Trip(src, dest, currCust, fare); availCab.trip.add(bookedCab); Customer.Trip bookedCust = new Customer.Trip(src, dest, availCab, fare); currCust.trip.add(bookedCust); } else{ soutl(\"\") } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Cab-Booking-master/src/Bookcab.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Bookcab class handles cab availability checks, cab selection, fare calculation, booking input processing, and trip creation. This combines multiple responsibilities (coordination, calculation, I/O) into one class."}, {"principle": "Open-Closed", "justification": "The fare calculation logic (fare = distance * 10) and cab selection algorithm are hardcoded. To modify these behaviors, the Bookcab class must be directly edited rather than extended."}, {"principle": "Dependency Inversion", "justification": "Bookcab directly depends on concrete Main.drivers and Main.iniloc implementations instead of abstractions. High-level booking logic is tightly coupled to low-level data storage details."}]}]}
{"project_id": 11, "chunk_id": 0, "prompt": {"main_file_path": "Cab-Booking-master/src/Customer.java", "main_file_content": "import java.util.*; public class Customer { static Scanner sc = new Scanner(System.in); int id; String name, password; List<Trip> trip; Customer(int id, String name, String password){ this.id=id; this.name=name; this.password=password; trip = new ArrayList<>(); } static class Trip{ String src, dest; int fare; Cab cab; Trip(String src, String dest, Cab cab, int fare){ this.src=src; this.dest=dest; this.cab=cab; this.fare=fare; } } static public Customer getCustomer(){ int id; String name, password; soutl(\"\") id=sc.nextInt(); soutl(\"\") name=sc.next(); soutl(\"\") password=sc.next(); return new Customer(id, name, password); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Cab-Booking-master/src/Customer.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Customer class handles multiple responsibilities: managing customer data, trip information via a nested Trip class, and input collection via the static getCustomer method, which violates having only one reason to change."}, {"principle": "Dependency Inversion", "justification": "The Trip class directly depends on the concrete Cab implementation instead of an abstraction. High-level modules (Customer/Trip) should depend on abstractions, not low-level concrete classes."}]}]}
{"project_id": 11, "chunk_id": 0, "prompt": {"main_file_path": "Cab-Booking-master/src/Cab.java", "main_file_content": "import java.util.*; public class Cab { static Scanner sc = new Scanner(System.in); int id; String name, password, location; List<Trip> trip; Cab(int id, String name, String password, String location){ this.id=id; this.name=name; this.password=password; this.location=location; trip=new ArrayList<>(); } static class Trip{ String src, dest; int fare; Customer cust; Trip(String src, String dest, Customer cust, int fare){ this.src=src; this.dest=dest; this.cust=cust; this.fare=fare; } } static public Cab getCab(){ int id; String name, password; soutl(\"\") id=sc.nextInt(); soutl(\"\") name=sc.next(); soutl(\"\") password=sc.next(); return new Cab(id, name, password, null); } static void showCabLocations(){ soutl(\"\") for(Cab i: Main.drivers){ soutl(\"\") } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Cab-Booking-master/src/Cab.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Cab class manages cab details, trip data, and UI interactions (Scanner usage, display logic), handling multiple responsibilities."}, {"principle": "Dependency Inversion", "justification": "Cab directly depends on concrete Main.drivers list instead of an abstraction for accessing driver data."}]}]}
{"project_id": 11, "chunk_id": 0, "prompt": {"main_file_path": "Cab-Booking-master/src/Main.java", "main_file_content": "import java.util.*; public class Main { static Scanner sc = new Scanner(System.in); static List<Customer> users; static List<Cab> drivers; static Map<String, Integer> iniloc; static Customer currCust; static Cab currCab; public static void main(String[] args) { users = new ArrayList<>(); drivers = new ArrayList<>(); iniloc = new HashMap<>(); soutl(\"\") while(true){ soutl(\"\") soutl(\"\") int opt=sc.nextInt(); if(opt>=4 || opt<0) break; if(opt==1){ if (!drivers.isEmpty() && validUser(\"Driver\")) { soutl(\"\") for (Cab.Trip i : currCab.trip) { soutl(\"\") } } else { soutl(\"\") } } else if(opt==2){ soutl(\"\") int cusOpt=sc.nextInt(); if(cusOpt<0 || cusOpt>3){ soutl(\"\") } else if(cusOpt==1){ users.add(Customer.getCustomer()); } else if(cusOpt==2){ if(!users.isEmpty() && validUser(\"Customer\")){ if(!drivers.isEmpty()) { Cab.showCabLocations(); String src, dest; soutl(\"\") src = sc.next(); soutl(\"\") dest = sc.next(); Bookcab.bookCab(src, dest, currCust); } else{ soutl(\"\") } } else{ soutl(\"\") } } else{ if(!users.isEmpty() && validUser(\"Customer\")){ soutl(\"\") for(Customer.Trip i:currCust.trip){ soutl(\"\") } } } } else{ soutl(\"\") int admOpt=sc.nextInt(); if(admOpt<0 || admOpt>3){ soutl(\"\") } else if(admOpt==1){ soutl(\"\") soutl(\"\") } else if(admOpt==2){ drivers.add(Cab.getCab()); } else { soutl(\"\") int locOpt = sc.nextInt(); if (locOpt < 0 || locOpt > 2) { soutl(\"\") } else if (locOpt == 1) { soutl(\"\") int locCnt = sc.nextInt(); for (int i = 0; i < locCnt; i++) { soutl(\"\") String locname = sc.next(); soutl(\"\") int dist = sc.nextInt(); iniloc.put(locname, dist); } } else if (locOpt == 2) { soutl(\"\") int cabCnt = sc.nextInt(); if(drivers.size()<cabCnt){ soutl(\"\") } else { for (int i = 0; i < cabCnt; i++) { soutl(\"\") int id = sc.nextInt(); soutl(\"\") String locname = sc.next(); for(Cab j : drivers){ if(j.id==id){ j.location=locname; break; } } } } } } } } } static boolean validUser(String currUser){ String name, password; soutl(\"\") name=sc.next(); soutl(\"\") password=sc.next(); if(currUser.equals(\"Customer\")){ for(Customer i:users){ if(i.name.equals(name) && i.password.equals(password)){ currCust=i; return true; } } } else{ for(Cab i:drivers){ if(i.name.equals(name) && i.password.equals(password)){ currCab=i; return true; } } } return false; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Cab-Booking-master/src/Main.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Main class handles user input validation, UI flow, business logic coordination, and direct data storage. This constitutes multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Main's main loop uses rigid if/else chains to handle options. Adding new functionality requires modifying existing conditionals rather than extending through abstractions."}, {"principle": "Dependency Inversion", "justification": "High-level Main directly depends on concrete Customer/Cab classes and static Bookcab methods. No abstractions decouple high-level policies from low-level implementations."}]}]}
{"project_id": 13, "chunk_id": 0, "prompt": {"main_file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/MainActivity.java", "main_file_content": "package com.example.myrecyclviewdemo; import android.content.Context; import android.os.Bundle; import android.support.v7.app.AppCompatActivity; import android.support.v7.widget.RecyclerView; import android.support.v7.widget.StaggeredGridLayoutManager; import android.util.Log; import android.widget.LinearLayout; import com.cjj.MaterialRefreshLayout; import com.example.myrecyclviewdemo.Constants.Contants; import com.example.myrecyclviewdemo.adapter.HomepagerRecycleAdapter; import com.example.myrecyclviewdemo.bean.Headerbean; import com.example.myrecyclviewdemo.bean.HomeCategory; import com.example.myrecyclviewdemo.bean.RefreshBean; import com.example.myrecyclviewdemo.utils.RefreshUtils; import com.example.myrecyclviewdemo.weidget.MyStaggerGrildLayoutManger; import com.google.gson.Gson; import com.lzy.okgo.OkGo; import com.lzy.okgo.callback.StringCallback; import java.util.ArrayList; import butterknife.Bind; import butterknife.ButterKnife; import okhttp3.Call; import okhttp3.Response; public class MainActivity extends AppCompatActivity implements RefreshUtils.RefreshListenser { @Bind(R.id.rv_mainactivity) RecyclerView rvMainactivity; @Bind(R.id.mrl_mainactivity) MaterialRefreshLayout mrfMainactivity; @Bind(R.id.activity_main) LinearLayout activityMain; private RefreshUtils refreshUtils; private Context mContext; private HomepagerRecycleAdapter homepagerRecycleAdapter; private boolean flagFirst = true; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); mContext = this; initrefresh(); initdata(); } private void initdata() { homepagerRecycleAdapter = new HomepagerRecycleAdapter(mContext); rvMainactivity.setAdapter(homepagerRecycleAdapter); rvMainactivity.setLayoutManager(new MyStaggerGrildLayoutManger(mContext, 2, StaggeredGridLayoutManager.VERTICAL)); getHeaderData(); getcategoryData(); getCenterBean(); getRefreshData(); } private void getHeaderData() { OkGo.get(Contants.API.HOST_SLIDLAYOUT) .execute(new StringCallback() { @Override public void onSuccess(String s, Call call, Response response) { s = \"{\" + \"\\\"data\\\":\" + s + \"}\"; Headerbean headerbean = new Gson().fromJson(s, Headerbean.class); if (headerbean != null) { if (headerbean.getData().size() != 0) { homepagerRecycleAdapter.setheaderbean(headerbean); } } } @Override public void onError(Call call, Response response, Exception e) { super.onError(call, response, e); Log.e(\"ssss\", \"onError: \" + e.toString()); } }); } private void getcategoryData() { ArrayList<HomeCategory> homeCategories = new ArrayList<>(); HomeCategory c1 = new HomeCategory(R.mipmap.icon_cart, \"\u8d2d\u7269\u8f66\"); HomeCategory c2 = new HomeCategory(R.mipmap.icon_discover, \"\u53d1\u73b0\"); HomeCategory c3 = new HomeCategory(R.mipmap.icon_hot, \"\u70ed\u95e8\"); HomeCategory c4 = new HomeCategory(R.mipmap.icon_user, \"\u5bfb\u627e\"); homeCategories.add(c1); homeCategories.add(c2); homeCategories.add(c3); homeCategories.add(c4); homepagerRecycleAdapter.setCategoryBean(homeCategories); } private void getCenterBean() { OkGo.get(Contants.API.CAMPAIGN_HOME) .execute(new StringCallback() { @Override public void onSuccess(String s, Call call, Response response) { s = \"{\" + \"\\\"data\\\":\" + s + \"}\"; RefreshBean refreshBean = new Gson().fromJson(s, RefreshBean.class); if (refreshBean != null) { if (refreshBean.getData().size() != 0) { homepagerRecycleAdapter.setCenterBean(refreshBean); refreshUtils.finishrefreshSleep(); } } } @Override public void onError(Call call, Response response, Exception e) { super.onError(call, response, e); Log.e(\"ssss\", \"onError: \" + e.toString()); refreshUtils.finishrefresh(); } }); } private void getRefreshData() { OkGo.get(Contants.API.CAMPAIGN_HOME) .execute(new StringCallback() { @Override public void onSuccess(String s, Call call, Response response) { s = \"{\" + \"\\\"data\\\":\" + s + \"}\"; RefreshBean refreshBean = new Gson().fromJson(s, RefreshBean.class); if (refreshBean != null) { if (refreshBean.getData().size() != 0) { homepagerRecycleAdapter.setRefreshBean(refreshBean, flagFirst); if (flagFirst) { refreshUtils.finishrefreshSleep(); flagFirst = false; } else refreshUtils.finishrefresh(); } } } @Override public void onError(Call call, Response response, Exception e) { super.onError(call, response, e); Log.e(\"ssss\", \"onError: \" + e.toString()); refreshUtils.finishrefresh(); } }); } private void initrefresh() { refreshUtils = new RefreshUtils(); refreshUtils.newBuilder(mContext).setRefreshLayout(mrfMainactivity) .setLoadMore(true).build(this); } @Override public void refreshdata() { flagFirst = true; initdata(); } @Override public void loadrefreshdata() { new Thread(new Runnable() { @Override public void run() { try { Thread.sleep(500); getRefreshData(); } catch (InterruptedException e) { e.printStackTrace(); } } }).start(); } }", "dependencies": [{"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/Constants/Contants.java", "file_content": "package com.example.myrecyclviewdemo.Constants; public class Contants { public static class API { public static final String HOST_SLIDLAYOUT = \"http: \"081/course_api/banner/query?type=1\"; public static final String BASE_URL = \"http: public static final String CAMPAIGN_HOME = BASE_URL + \"campaign/recommend\"; } }"}, {"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/adapter/HomepagerRecycleAdapter.java", "file_content": "package com.example.myrecyclviewdemo.adapter; import android.content.Context; import android.support.v7.widget.GridLayoutManager; import android.support.v7.widget.RecyclerView; import android.support.v7.widget.StaggeredGridLayoutManager; import android.util.Log; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.ImageView; import android.widget.LinearLayout; import com.bumptech.glide.Glide; import com.example.myrecyclviewdemo.R; import com.example.myrecyclviewdemo.bean.Headerbean; import com.example.myrecyclviewdemo.bean.HomeCategory; import com.example.myrecyclviewdemo.bean.RefreshBean; import com.example.myrecyclviewdemo.weidget.AsHomepageHeaderView; import com.example.myrecyclviewdemo.weidget.ImageUtils; import com.example.myrecyclviewdemo.weidget.MyStaggerGrildLayoutManger; import java.util.ArrayList; import java.util.List; import butterknife.Bind; import butterknife.ButterKnife; public class HomepagerRecycleAdapter extends RecyclerView.Adapter { private final Context mContext; private List<Headerbean.DataBean> headerData; private int count = 3; private List<RefreshBean.DataBean> refreshbean; private List<RefreshBean.DataBean> centerBean; private ArrayList<HomeCategory> mHomeCategories; private int TYPE_TOP = 1; private List<Integer> mHeights = new ArrayList<>(); private int TYPE_CENTER = 2; private int TYPE_CATEGORY = 3; private int TYPE_HEADER = 4; private int REFRESHPOSITION = 5; private int CENTERPOSITION; private int TYPE_REFRESH = 6; private LayoutInflater inflater; private RecyclerView recyclerView; private MyStaggerGrildLayoutManger mystager; public HomepagerRecycleAdapter(Context context) { mContext = context; inflater = LayoutInflater.from(mContext); headerData = new ArrayList<>(); refreshbean = new ArrayList<>(); centerBean = new ArrayList<>(); } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { if (viewType == TYPE_TOP) { View viewtop = inflater.inflate(R.layout.adapter_slider, parent, false); StaggeredGridLayoutManager.LayoutParams params = (StaggeredGridLayoutManager.LayoutParams) viewtop.getLayoutParams(); params.setFullSpan(true); viewtop.setLayoutParams(params); return new TypeTopsliderHolder(viewtop); } else if (viewType == TYPE_HEADER) { View view2 = inflater.inflate(R.layout.item_homepagertypeheader_type, parent, false); StaggeredGridLayoutManager.LayoutParams params = (StaggeredGridLayoutManager.LayoutParams) view2.getLayoutParams(); params.setFullSpan(true); view2.setLayoutParams(params); return new TypeheadHolder(view2); } else if (viewType == TYPE_CENTER) { View view = inflater.inflate(R.layout.itam_homepageradapter_rv2, parent, false); StaggeredGridLayoutManager.LayoutParams params2 = (StaggeredGridLayoutManager.LayoutParams) view.getLayoutParams(); params2.setFullSpan(true); view.setLayoutParams(params2); return new TypetypeHolder2(view); } else if (viewType == TYPE_CATEGORY) { View view = inflater.inflate(R.layout.itam_homepageradapter_rv2, parent, false); StaggeredGridLayoutManager.LayoutParams params2 = (StaggeredGridLayoutManager.LayoutParams) view.getLayoutParams(); params2.setFullSpan(true); view.setLayoutParams(params2); return new TypetypeHolder(view); } else if (viewType == TYPE_REFRESH) { return new TypeRefresh(inflater.inflate(R.layout.item_raiders2, parent, false)); } else { View viewtop = inflater.inflate(R.layout.adapter_slider, parent, false); StaggeredGridLayoutManager.LayoutParams params = (StaggeredGridLayoutManager.LayoutParams) viewtop.getLayoutParams(); params.setFullSpan(true); viewtop.setLayoutParams(params); return new TypeTopsliderHolder(viewtop); } } @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { if (holder instanceof TypeTopsliderHolder && headerData.size() != 0 && ((TypeTopsliderHolder) holder).linearLayout.getChildCount() == 0) { initslider(((TypeTopsliderHolder) holder), headerData); } else if (holder instanceof TypetypeHolder && centerBean.size() != 0) { initcategory(((TypetypeHolder) holder)); } else if (holder instanceof TypeheadHolder) { initTop(((TypeheadHolder) holder), position); } else if (holder instanceof TypetypeHolder2 && centerBean.size() != 0) { initCenterBean(((TypetypeHolder2) holder)); } else if (holder instanceof TypeRefresh && refreshbean.size() != 0) { initrefreshdata(((TypeRefresh) holder), position - REFRESHPOSITION - 1); } } private void initrefreshdata(TypeRefresh holder, int position) { Log.e(\"position\", \"initrefreshdata: \" + position); if (mHeights.size() <= getItemCount() + 2) { mHeights.add((int) (500 + Math.random() * 400)); } ViewGroup.LayoutParams layoutParams = holder.homeReadPivIv.getLayoutParams(); if (mHeights.size() > position) layoutParams.height = mHeights.get(position); else layoutParams.height = 589; holder.homeReadPivIv.setLayoutParams(layoutParams); holder.homeReadPivIv.setScaleType(ImageView.ScaleType.FIT_XY); if (refreshbean.size() > position) { ImageUtils.load(mContext, refreshbean.get(position).getCpOne().getImgUrl(), holder.homeReadPivIv); } else { ImageUtils.load(mContext, refreshbean.get(0).getCpTwo().getImgUrl(), holder.homeReadPivIv); } } private void initCenterBean(TypetypeHolder2 holder) { holder.rvtype.setLayoutManager(new GridLayoutManager(mContext, 2)); TypeHistoryAdapter centerAdapter = new TypeHistoryAdapter(mContext, centerBean); holder.rvtype.setAdapter(centerAdapter); } private void initcategory(TypetypeHolder holder) { holder.rvtype.setLayoutManager(new GridLayoutManager(mContext, mHomeCategories.size())); TypeCategoryAdapter categoryAdapter = new TypeCategoryAdapter(mContext, mHomeCategories); holder.rvtype.setAdapter(categoryAdapter); } private void initTop(TypeheadHolder holder, int position) { if (position == CENTERPOSITION) { holder.hview.setTypeName(\"\u4e2d\u95f4head\"); } else if (position == REFRESHPOSITION) { holder.hview.setTypeName(\"\u4e0b\u90e8head\"); } } @Override public int getItemViewType(int position) { CENTERPOSITION = mHomeCategories.size() == 0 ? 1 : 2; REFRESHPOSITION = centerBean.size() == 0 ? 3 : 4; Log.e(\"getItemViewType\", \"getItemViewType: \" + CENTERPOSITION + \",:\" + REFRESHPOSITION); if (position == 0) return TYPE_TOP; else if (position == CENTERPOSITION || position == REFRESHPOSITION) return TYPE_HEADER; else if (position == 1) return TYPE_CATEGORY; else if (position == CENTERPOSITION + 1) return TYPE_CENTER; else return TYPE_REFRESH; } private void initslider(TypeTopsliderHolder holder, List<Headerbean.DataBean> data) { LinearLayout linearLayout = holder.linearLayout; for (int i = 0; i < data.size(); i++) { ImageView imageView = new ImageView(mContext); LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.MATCH_PARENT); layoutParams.rightMargin = 40; imageView.setLayoutParams(layoutParams); ImageUtils.load(mContext, data.get(i).getImgUrl(), imageView); imageView.setScaleType(ImageView.ScaleType.FIT_XY); linearLayout.addView(imageView); } } @Override public int getItemCount() { return count; } @Override public void onAttachedToRecyclerView(RecyclerView recyclerView) { super.onAttachedToRecyclerView(recyclerView); this.recyclerView = recyclerView; RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager(); if (layoutManager instanceof MyStaggerGrildLayoutManger) { mystager = ((MyStaggerGrildLayoutManger) layoutManager); } recyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() { @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) { if (newState == 2) { Glide.with(mContext).pauseRequests(); } else { Glide.with(mContext).resumeRequests(); } } @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { } }); } public void setheaderbean(Headerbean headerbean) { headerData = headerbean.getData(); notifyDataSetChanged(); } public void setRefreshBean(RefreshBean refreshBean, boolean flagFirst) { refreshbean.addAll(refreshBean.getData()); int count1 = this.count; this.count += refreshBean.getData().size(); notifyDataSetChanged(); if (!flagFirst) { recyclerView.smoothScrollToPosition(count1 + 2); } } public void setCenterBean(RefreshBean refreshBean) { centerBean = refreshBean.getData(); count++; notifyDataSetChanged(); } public void setCategoryBean(ArrayList<HomeCategory> homeCategories) { mHomeCategories = homeCategories; count++; notifyDataSetChanged(); } public class TypeTopsliderHolder extends RecyclerView.ViewHolder { @Bind(R.id.ll_slider) LinearLayout linearLayout; public TypeTopsliderHolder(View view) { super(view); ButterKnife.bind(this, view); } } public class TypeheadHolder extends RecyclerView.ViewHolder { @Bind(R.id.ashv_homepager) AsHomepageHeaderView hview; public TypeheadHolder(View view) { super(view); ButterKnife.bind(this, view); hview.setMoreclicklistenser(new AsHomepageHeaderView.MoreclickListenser() { @Override public void setmoreclicklistenser() { } }); } } public class TypetypeHolder extends RecyclerView.ViewHolder { @Bind(R.id.rv_homepageradapter_artist) RecyclerView rvtype; public TypetypeHolder(View view) { super(view); ButterKnife.bind(this, view); } } public class TypetypeHolder2 extends RecyclerView.ViewHolder { @Bind(R.id.rv_homepageradapter_artist) RecyclerView rvtype; public TypetypeHolder2(View view) { super(view); ButterKnife.bind(this, view); } } static class TypeRefresh extends RecyclerView.ViewHolder { @Bind(R.id.home_read_piv_iv) ImageView homeReadPivIv; TypeRefresh(View view) { super(view); ButterKnife.bind(this, view); } } }"}, {"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/bean/Headerbean.java", "file_content": "package com.example.myrecyclviewdemo.bean; import java.util.List; public class Headerbean { @Override public String toString() { return \"Headerbean{\" + \"data=\" + data + '}'; } private List<DataBean> data; public List<DataBean> getData() { return data; } public void setData(List<DataBean> data) { this.data = data; } public static class DataBean { @Override public String toString() { return \"DataBean{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", imgUrl='\" + imgUrl + '\\'' + \", type=\" + type + '}'; } private int id; private String name; private String imgUrl; private int type; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getImgUrl() { return imgUrl; } public void setImgUrl(String imgUrl) { this.imgUrl = imgUrl; } public int getType() { return type; } public void setType(int type) { this.type = type; } } }"}, {"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/bean/HomeCategory.java", "file_content": "package com.example.myrecyclviewdemo.bean; import android.app.Application; import com.example.myrecyclviewdemo.app.Myappplication; public class HomeCategory { private int imageid; private String typename; public HomeCategory(int imageid, String typename) { this.imageid = imageid; this.typename = typename; } public HomeCategory(int imageid, int stringID) { this.imageid = imageid; typename = Myappplication.mContext.getResources().getString(stringID); } public int getImageid() { return imageid; } public void setImageid(int imageid) { this.imageid = imageid; } public String getTypename() { return typename; } public void setTypename(String typename) { this.typename = typename; } }"}, {"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/bean/RefreshBean.java", "file_content": "package com.example.myrecyclviewdemo.bean; import java.util.List; public class RefreshBean { private List<DataBean> data; public List<DataBean> getData() { return data; } public void setData(List<DataBean> data) { this.data = data; } public static class DataBean { private CpOneBean cpOne; private CpTwoBean cpTwo; private CpThreeBean cpThree; private int id; private String title; private int campaignOne; private int campaignTwo; private int campaignThree; public CpOneBean getCpOne() { return cpOne; } public void setCpOne(CpOneBean cpOne) { this.cpOne = cpOne; } public CpTwoBean getCpTwo() { return cpTwo; } public void setCpTwo(CpTwoBean cpTwo) { this.cpTwo = cpTwo; } public CpThreeBean getCpThree() { return cpThree; } public void setCpThree(CpThreeBean cpThree) { this.cpThree = cpThree; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public int getCampaignOne() { return campaignOne; } public void setCampaignOne(int campaignOne) { this.campaignOne = campaignOne; } public int getCampaignTwo() { return campaignTwo; } public void setCampaignTwo(int campaignTwo) { this.campaignTwo = campaignTwo; } public int getCampaignThree() { return campaignThree; } public void setCampaignThree(int campaignThree) { this.campaignThree = campaignThree; } public static class CpOneBean { private int id; private String title; private String imgUrl; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getImgUrl() { return imgUrl; } public void setImgUrl(String imgUrl) { this.imgUrl = imgUrl; } } public static class CpTwoBean { private int id; private String title; private String imgUrl; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getImgUrl() { return imgUrl; } public void setImgUrl(String imgUrl) { this.imgUrl = imgUrl; } } public static class CpThreeBean { private int id; private String title; private String imgUrl; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getImgUrl() { return imgUrl; } public void setImgUrl(String imgUrl) { this.imgUrl = imgUrl; } } } }"}, {"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/utils/RefreshUtils.java", "file_content": "package com.example.myrecyclviewdemo.utils; import android.content.Context; import com.cjj.MaterialRefreshLayout; import com.cjj.MaterialRefreshListener; public class RefreshUtils { private Builder builder; private RefreshListenser mRefreshListenser; public RefreshUtils() { } public Builder newBuilder(Context context) { builder = new Builder(context); return builder; } private void initRefreshLayout() { builder.mRefreshLayout.setLoadMore(builder.canLoadMore); builder.mRefreshLayout.setIsOverLay(builder.isOverLay); builder.mRefreshLayout.setWaveShow(builder.isWaveShow); builder.mRefreshLayout.setMaterialRefreshListener(new MaterialRefreshListener() { @Override public void onRefresh(MaterialRefreshLayout materialRefreshLayout) { if (mRefreshListenser != null) { mRefreshListenser.refreshdata(); } } @Override public void onRefreshLoadMore(MaterialRefreshLayout materialRefreshLayout) { if (mRefreshListenser != null) { mRefreshListenser.loadrefreshdata(); } } }); } public void finishrefresh() { builder.mRefreshLayout.finishRefresh(); builder.mRefreshLayout.finishRefreshLoadMore(); } public void finishrefreshSleep() { new Thread(new Runnable() { @Override public void run() { try { Thread.sleep(2000); builder.mRefreshLayout.post(new Runnable() { @Override public void run() { finishrefresh(); } }); } catch (InterruptedException e) { e.printStackTrace(); builder.mRefreshLayout.post(new Runnable() { @Override public void run() { finishrefresh(); } }); } } }).start(); } public class Builder { private Context mContext; private MaterialRefreshLayout mRefreshLayout; private boolean canLoadMore; public boolean isOverLay = true; public boolean isWaveShow = false; public Builder(Context context) { mContext = context; } public Builder setOverLay(boolean overLay) { isOverLay = overLay; return builder; } public Builder setWaveShow(boolean isWaveShow) { this.isWaveShow = isWaveShow; return builder; } public Builder setLoadMore(boolean loadMore) { this.canLoadMore = loadMore; return builder; } public Builder setRefreshLayout(MaterialRefreshLayout refreshLayout) { this.mRefreshLayout = refreshLayout; return builder; } public void build(RefreshListenser listener) { mRefreshListenser = listener; valid(); initRefreshLayout(); } private void valid() { if (this.mContext == null) throw new RuntimeException(\"content can't be null\"); if (this.mRefreshLayout == null) throw new RuntimeException(\"MaterialRefreshLayout can't be null\"); } } public interface RefreshListenser { void refreshdata(); void loadrefreshdata(); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/MainActivity.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "MainActivity handles UI setup, network requests, data parsing, adapter configuration, and refresh logic, indicating multiple responsibilities."}, {"principle": "Dependency Inversion", "justification": "Directly depends on concrete classes like OkGo, Gson, and HomepagerRecycleAdapter without abstractions, violating high-level module dependency rules."}]}, {"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/adapter/HomepagerRecycleAdapter.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Manages multiple view types, data binding, layout logic, and Glide image loading, exceeding a single responsibility."}, {"principle": "Open-Closed", "justification": "Requires modification to support new view types or data sources instead of being extendable via abstraction."}, {"principle": "Dependency Inversion", "justification": "Directly depends on concrete MyStaggerGrildLayoutManger and GridLayoutManager instead of abstractions."}]}, {"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/bean/HomeCategory.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "Directly references Myappplication.mContext, a concrete implementation, instead of receiving context via abstraction."}]}]}
{"project_id": 13, "chunk_id": 1, "prompt": {"main_file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/MainActivity.java", "main_file_content": "package com.example.myrecyclviewdemo; import android.content.Context; import android.os.Bundle; import android.support.v7.app.AppCompatActivity; import android.support.v7.widget.RecyclerView; import android.support.v7.widget.StaggeredGridLayoutManager; import android.util.Log; import android.widget.LinearLayout; import com.cjj.MaterialRefreshLayout; import com.example.myrecyclviewdemo.Constants.Contants; import com.example.myrecyclviewdemo.adapter.HomepagerRecycleAdapter; import com.example.myrecyclviewdemo.bean.Headerbean; import com.example.myrecyclviewdemo.bean.HomeCategory; import com.example.myrecyclviewdemo.bean.RefreshBean; import com.example.myrecyclviewdemo.utils.RefreshUtils; import com.example.myrecyclviewdemo.weidget.MyStaggerGrildLayoutManger; import com.google.gson.Gson; import com.lzy.okgo.OkGo; import com.lzy.okgo.callback.StringCallback; import java.util.ArrayList; import butterknife.Bind; import butterknife.ButterKnife; import okhttp3.Call; import okhttp3.Response; public class MainActivity extends AppCompatActivity implements RefreshUtils.RefreshListenser { @Bind(R.id.rv_mainactivity) RecyclerView rvMainactivity; @Bind(R.id.mrl_mainactivity) MaterialRefreshLayout mrfMainactivity; @Bind(R.id.activity_main) LinearLayout activityMain; private RefreshUtils refreshUtils; private Context mContext; private HomepagerRecycleAdapter homepagerRecycleAdapter; private boolean flagFirst = true; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); mContext = this; initrefresh(); initdata(); } private void initdata() { homepagerRecycleAdapter = new HomepagerRecycleAdapter(mContext); rvMainactivity.setAdapter(homepagerRecycleAdapter); rvMainactivity.setLayoutManager(new MyStaggerGrildLayoutManger(mContext, 2, StaggeredGridLayoutManager.VERTICAL)); getHeaderData(); getcategoryData(); getCenterBean(); getRefreshData(); } private void getHeaderData() { OkGo.get(Contants.API.HOST_SLIDLAYOUT) .execute(new StringCallback() { @Override public void onSuccess(String s, Call call, Response response) { s = \"{\" + \"\\\"data\\\":\" + s + \"}\"; Headerbean headerbean = new Gson().fromJson(s, Headerbean.class); if (headerbean != null) { if (headerbean.getData().size() != 0) { homepagerRecycleAdapter.setheaderbean(headerbean); } } } @Override public void onError(Call call, Response response, Exception e) { super.onError(call, response, e); Log.e(\"ssss\", \"onError: \" + e.toString()); } }); } private void getcategoryData() { ArrayList<HomeCategory> homeCategories = new ArrayList<>(); HomeCategory c1 = new HomeCategory(R.mipmap.icon_cart, \"\u8d2d\u7269\u8f66\"); HomeCategory c2 = new HomeCategory(R.mipmap.icon_discover, \"\u53d1\u73b0\"); HomeCategory c3 = new HomeCategory(R.mipmap.icon_hot, \"\u70ed\u95e8\"); HomeCategory c4 = new HomeCategory(R.mipmap.icon_user, \"\u5bfb\u627e\"); homeCategories.add(c1); homeCategories.add(c2); homeCategories.add(c3); homeCategories.add(c4); homepagerRecycleAdapter.setCategoryBean(homeCategories); } private void getCenterBean() { OkGo.get(Contants.API.CAMPAIGN_HOME) .execute(new StringCallback() { @Override public void onSuccess(String s, Call call, Response response) { s = \"{\" + \"\\\"data\\\":\" + s + \"}\"; RefreshBean refreshBean = new Gson().fromJson(s, RefreshBean.class); if (refreshBean != null) { if (refreshBean.getData().size() != 0) { homepagerRecycleAdapter.setCenterBean(refreshBean); refreshUtils.finishrefreshSleep(); } } } @Override public void onError(Call call, Response response, Exception e) { super.onError(call, response, e); Log.e(\"ssss\", \"onError: \" + e.toString()); refreshUtils.finishrefresh(); } }); } private void getRefreshData() { OkGo.get(Contants.API.CAMPAIGN_HOME) .execute(new StringCallback() { @Override public void onSuccess(String s, Call call, Response response) { s = \"{\" + \"\\\"data\\\":\" + s + \"}\"; RefreshBean refreshBean = new Gson().fromJson(s, RefreshBean.class); if (refreshBean != null) { if (refreshBean.getData().size() != 0) { homepagerRecycleAdapter.setRefreshBean(refreshBean, flagFirst); if (flagFirst) { refreshUtils.finishrefreshSleep(); flagFirst = false; } else refreshUtils.finishrefresh(); } } } @Override public void onError(Call call, Response response, Exception e) { super.onError(call, response, e); Log.e(\"ssss\", \"onError: \" + e.toString()); refreshUtils.finishrefresh(); } }); } private void initrefresh() { refreshUtils = new RefreshUtils(); refreshUtils.newBuilder(mContext).setRefreshLayout(mrfMainactivity) .setLoadMore(true).build(this); } @Override public void refreshdata() { flagFirst = true; initdata(); } @Override public void loadrefreshdata() { new Thread(new Runnable() { @Override public void run() { try { Thread.sleep(500); getRefreshData(); } catch (InterruptedException e) { e.printStackTrace(); } } }).start(); } }", "dependencies": [{"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/weidget/MyStaggerGrildLayoutManger.java", "file_content": "package com.example.myrecyclviewdemo.weidget; import android.content.Context; import android.graphics.PointF; import android.support.v7.widget.LinearSmoothScroller; import android.support.v7.widget.RecyclerView; import android.support.v7.widget.StaggeredGridLayoutManager; import android.util.DisplayMetrics; public class MyStaggerGrildLayoutManger extends StaggeredGridLayoutManager { private float MILLISECONDS_PER_INCH = 1f; private Context contxt; public MyStaggerGrildLayoutManger(Context context, int spanCount, int orientation) { super(spanCount, orientation); } @Override public void smoothScrollToPosition(RecyclerView recyclerView, RecyclerView.State state, int position) { LinearSmoothScroller linearSmoothScroller = new LinearSmoothScroller(recyclerView.getContext()) { @Override public PointF computeScrollVectorForPosition(int targetPosition) { return null; } @Override protected float calculateSpeedPerPixel (DisplayMetrics displayMetrics) { return MILLISECONDS_PER_INCH / displayMetrics.density; } }; linearSmoothScroller.setTargetPosition(position); startSmoothScroll(linearSmoothScroller); } public void setSpeedSlow() { MILLISECONDS_PER_INCH = contxt.getResources().getDisplayMetrics().density * 0.3f; } public void setSpeedFast() { MILLISECONDS_PER_INCH = contxt.getResources().getDisplayMetrics().density * 0.03f; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/MainActivity.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "MainActivity handles UI setup, network requests, data parsing, and refresh logic, indicating multiple responsibilities."}, {"principle": "Dependency Inversion", "justification": "High-level module MainActivity directly depends on concrete classes like OkGo, Gson, HomepagerRecycleAdapter, and RefreshUtils instead of abstractions."}]}]}
{"project_id": 13, "chunk_id": 0, "prompt": {"main_file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/app/Myappplication.java", "main_file_content": "package com.example.myrecyclviewdemo.app; import android.app.Application; import com.lzy.okgo.OkGo; import com.lzy.okgo.cache.CacheEntity; import com.lzy.okgo.cache.CacheMode; import com.lzy.okgo.cookie.store.PersistentCookieStore; import com.lzy.okgo.model.HttpHeaders; import java.util.logging.Level; public class Myappplication extends Application { public static Myappplication mContext; @Override public void onCreate() { super.onCreate(); mContext=this; initOkGo(); } private void initOkGo() { HttpHeaders headers = new HttpHeaders(); OkGo.init(this); try { OkGo.getInstance() .debug(\"OkGo\", Level.INFO, true) .setConnectTimeout(OkGo.DEFAULT_MILLISECONDS) .setReadTimeOut(OkGo.DEFAULT_MILLISECONDS) .setWriteTimeOut(OkGo.DEFAULT_MILLISECONDS) .setCacheMode(CacheMode.REQUEST_FAILED_READ_CACHE) .setCacheTime(CacheEntity.CACHE_NEVER_EXPIRE) .setRetryCount(3) .setCookieStore(new PersistentCookieStore()) .setCertificates() .addCommonHeaders(headers); } catch (Exception e) { e.printStackTrace(); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/app/Myappplication.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Myappplication class handles both application lifecycle management (context initialization) and network client configuration (OkGo setup), introducing multiple reasons to change."}, {"principle": "Open-Closed", "justification": "Modifying OkGo configuration (e.g., headers, cache rules) requires direct changes to Myappplication's code instead of being extendable via new classes or overrides."}, {"principle": "Dependency Inversion", "justification": "Myappplication (high-level module) directly initializes and configures OkGo (low-level module) without depending on abstractions, creating a concrete dependency chain."}]}]}
{"project_id": 13, "chunk_id": 0, "prompt": {"main_file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/bean/Headerbean.java", "main_file_content": "package com.example.myrecyclviewdemo.bean; import java.util.List; public class Headerbean { @Override public String toString() { return \"Headerbean{\" + \"data=\" + data + '}'; } private List<DataBean> data; public List<DataBean> getData() { return data; } public void setData(List<DataBean> data) { this.data = data; } public static class DataBean { @Override public String toString() { return \"DataBean{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", imgUrl='\" + imgUrl + '\\'' + \", type=\" + type + '}'; } private int id; private String name; private String imgUrl; private int type; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getImgUrl() { return imgUrl; } public void setImgUrl(String imgUrl) { this.imgUrl = imgUrl; } public int getType() { return type; } public void setType(int type) { this.type = type; } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/bean/Headerbean.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Headerbean manages both its own data and the nested DataBean class, handling serialization/deserialization and data storage responsibilities. This creates multiple potential reasons for change related to data structure modifications or output format changes."}]}]}
{"project_id": 13, "chunk_id": 0, "prompt": {"main_file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/bean/RefreshBean.java", "main_file_content": "package com.example.myrecyclviewdemo.bean; import java.util.List; public class RefreshBean { private List<DataBean> data; public List<DataBean> getData() { return data; } public void setData(List<DataBean> data) { this.data = data; } public static class DataBean { private CpOneBean cpOne; private CpTwoBean cpTwo; private CpThreeBean cpThree; private int id; private String title; private int campaignOne; private int campaignTwo; private int campaignThree; public CpOneBean getCpOne() { return cpOne; } public void setCpOne(CpOneBean cpOne) { this.cpOne = cpOne; } public CpTwoBean getCpTwo() { return cpTwo; } public void setCpTwo(CpTwoBean cpTwo) { this.cpTwo = cpTwo; } public CpThreeBean getCpThree() { return cpThree; } public void setCpThree(CpThreeBean cpThree) { this.cpThree = cpThree; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public int getCampaignOne() { return campaignOne; } public void setCampaignOne(int campaignOne) { this.campaignOne = campaignOne; } public int getCampaignTwo() { return campaignTwo; } public void setCampaignTwo(int campaignTwo) { this.campaignTwo = campaignTwo; } public int getCampaignThree() { return campaignThree; } public void setCampaignThree(int campaignThree) { this.campaignThree = campaignThree; } public static class CpOneBean { private int id; private String title; private String imgUrl; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getImgUrl() { return imgUrl; } public void setImgUrl(String imgUrl) { this.imgUrl = imgUrl; } } public static class CpTwoBean { private int id; private String title; private String imgUrl; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getImgUrl() { return imgUrl; } public void setImgUrl(String imgUrl) { this.imgUrl = imgUrl; } } public static class CpThreeBean { private int id; private String title; private String imgUrl; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getImgUrl() { return imgUrl; } public void setImgUrl(String imgUrl) { this.imgUrl = imgUrl; } } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/bean/RefreshBean.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The DataBean class manages multiple responsibilities by directly handling three distinct campaign bean types (CpOneBean, CpTwoBean, CpThreeBean), leading to multiple reasons to change if any campaign structure evolves."}, {"principle": "Open-Closed", "justification": "Adding a new campaign type (e.g., CpFourBean) requires modifying DataBean's structure, violating OCP as the class is not open for extension without altering existing code."}]}]}
{"project_id": 13, "chunk_id": 0, "prompt": {"main_file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/bean/HomeCategory.java", "main_file_content": "package com.example.myrecyclviewdemo.bean; import android.app.Application; import com.example.myrecyclviewdemo.app.Myappplication; public class HomeCategory { private int imageid; private String typename; public HomeCategory(int imageid, String typename) { this.imageid = imageid; this.typename = typename; } public HomeCategory(int imageid, int stringID) { this.imageid = imageid; typename = Myappplication.mContext.getResources().getString(stringID); } public int getImageid() { return imageid; } public void setImageid(int imageid) { this.imageid = imageid; } public String getTypename() { return typename; } public void setTypename(String typename) { this.typename = typename; } }", "dependencies": [{"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/app/Myappplication.java", "file_content": "package com.example.myrecyclviewdemo.app; import android.app.Application; import com.lzy.okgo.OkGo; import com.lzy.okgo.cache.CacheEntity; import com.lzy.okgo.cache.CacheMode; import com.lzy.okgo.cookie.store.PersistentCookieStore; import com.lzy.okgo.model.HttpHeaders; import java.util.logging.Level; public class Myappplication extends Application { public static Myappplication mContext; @Override public void onCreate() { super.onCreate(); mContext=this; initOkGo(); } private void initOkGo() { HttpHeaders headers = new HttpHeaders(); OkGo.init(this); try { OkGo.getInstance() .debug(\"OkGo\", Level.INFO, true) .setConnectTimeout(OkGo.DEFAULT_MILLISECONDS) .setReadTimeOut(OkGo.DEFAULT_MILLISECONDS) .setWriteTimeOut(OkGo.DEFAULT_MILLISECONDS) .setCacheMode(CacheMode.REQUEST_FAILED_READ_CACHE) .setCacheTime(CacheEntity.CACHE_NEVER_EXPIRE) .setRetryCount(3) .setCookieStore(new PersistentCookieStore()) .setCertificates() .addCommonHeaders(headers); } catch (Exception e) { e.printStackTrace(); } } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/bean/HomeCategory.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "HomeCategory handles both data storage and string resource resolution via Myappplication.mContext, introducing multiple reasons to change."}, {"principle": "Dependency Inversion", "justification": "HomeCategory directly depends on the concrete Myappplication class instead of an abstraction for resource retrieval, creating tight coupling."}]}]}
{"project_id": 13, "chunk_id": 0, "prompt": {"main_file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/Constants/Contants.java", "main_file_content": "package com.example.myrecyclviewdemo.Constants; public class Contants { public static class API { public static final String HOST_SLIDLAYOUT = \"http: \"081/course_api/banner/query?type=1\"; public static final String BASE_URL = \"http: public static final String CAMPAIGN_HOME = BASE_URL + \"campaign/recommend\"; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/Constants/Contants.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Contants class groups multiple unrelated constants (e.g., API endpoints) under one class, indicating it handles more than one responsibility. This creates multiple potential reasons for change, such as modifying API URLs or adding new constant categories."}]}]}
{"project_id": 13, "chunk_id": 0, "prompt": {"main_file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/weidget/AsImageTextView.java", "main_file_content": "package com.example.myrecyclviewdemo.weidget; import android.content.Context; import android.graphics.drawable.Drawable; import android.util.AttributeSet; import android.view.View; import android.widget.ImageView; import android.widget.RelativeLayout; import android.widget.TextView; import com.example.myrecyclviewdemo.R; public class AsImageTextView extends RelativeLayout implements View.OnClickListener { private ImageView ivImagetext; private TextView tvImagetext; public ImageView getIvImagetext() { return ivImagetext; } public void setIvImagetext(ImageView ivImagetext) { this.ivImagetext = ivImagetext; } public TextView getTvImagetext() { return tvImagetext; } public void setTvImagetext(TextView tvImagetext) { this.tvImagetext = tvImagetext; } public AsImageTextView(Context context) { this(context, null); } public AsImageTextView(Context context, AttributeSet attrs) { this(context, attrs, 0); } public AsImageTextView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); View.inflate(context, R.layout.asimagetextview, this); ivImagetext = ((ImageView) findViewById(R.id.iv_imagetext)); tvImagetext = ((TextView) findViewById(R.id.tv_imagetext)); initattrs(); } private void initattrs() { } public void setIvImagetext(int imageid) { Drawable drawable = getResources().getDrawable(imageid); if (drawable != null) { ivImagetext.setImageDrawable(drawable); } } public void setTvImagetext(String typename) { if (typename != null) { tvImagetext.setText(typename + \"\"); } } @Override public void onClick(View view) { if (imagetextclick != null) { imagetextclick.setImagetextclick(); } } public interface Imagetextclick { public void setImagetextclick(); } public Imagetextclick imagetextclick; public Imagetextclick getImagetextclic() { return imagetextclick; } public void setImagetextclick(Imagetextclick imagetextclick) { this.imagetextclick = imagetextclick; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/weidget/AsImageTextView.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "The class initializes a fixed layout and view hierarchy in its constructor. Modifying its behavior (e.g., layout structure) requires direct code changes instead of extension."}, {"principle": "Single Responsibility", "justification": "The class handles layout inflation, view binding, image/text updates, and click event management, indicating multiple responsibilities."}]}]}
{"project_id": 13, "chunk_id": 0, "prompt": {"main_file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/weidget/ImageUtils.java", "main_file_content": "package com.example.myrecyclviewdemo.weidget; import android.app.Activity; import android.content.Context; import android.os.Build; import android.widget.ImageView; import com.bumptech.glide.Glide; import com.bumptech.glide.load.engine.DiskCacheStrategy; import com.example.myrecyclviewdemo.R; import com.example.myrecyclviewdemo.app.Myappplication; public class ImageUtils { public static void load(Activity activity, String url, ImageView iv) { if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) { if (!activity.isDestroyed()) { Glide.with(Myappplication.mContext).load(url).error(R.mipmap.ic_launcher).crossFade().diskCacheStrategy(DiskCacheStrategy.SOURCE).into(iv); } } } public static void load(Context context, String url, ImageView iv) { if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) { Glide.with(context).load(url).crossFade().diskCacheStrategy(DiskCacheStrategy.SOURCE) .error(R.mipmap.ic_launcher) .into(iv); } } public static void loadAll(Context context, String url, ImageView iv) { Glide.with(context).load(url).crossFade().skipMemoryCache(true).diskCacheStrategy(DiskCacheStrategy.NONE) .error(R.mipmap.ic_launcher) .into(iv); } public static void loadAll(Activity activity, String url, ImageView iv) { if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) { if (!activity.isDestroyed()) { Glide.with(activity).load(url).error(R.mipmap.ic_launcher).crossFade().skipMemoryCache(true).diskCacheStrategy(DiskCacheStrategy.NONE).into(iv); } } } }", "dependencies": [{"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/app/Myappplication.java", "file_content": "package com.example.myrecyclviewdemo.app; import android.app.Application; import com.lzy.okgo.OkGo; import com.lzy.okgo.cache.CacheEntity; import com.lzy.okgo.cache.CacheMode; import com.lzy.okgo.cookie.store.PersistentCookieStore; import com.lzy.okgo.model.HttpHeaders; import java.util.logging.Level; public class Myappplication extends Application { public static Myappplication mContext; @Override public void onCreate() { super.onCreate(); mContext=this; initOkGo(); } private void initOkGo() { HttpHeaders headers = new HttpHeaders(); OkGo.init(this); try { OkGo.getInstance() .debug(\"OkGo\", Level.INFO, true) .setConnectTimeout(OkGo.DEFAULT_MILLISECONDS) .setReadTimeOut(OkGo.DEFAULT_MILLISECONDS) .setWriteTimeOut(OkGo.DEFAULT_MILLISECONDS) .setCacheMode(CacheMode.REQUEST_FAILED_READ_CACHE) .setCacheTime(CacheEntity.CACHE_NEVER_EXPIRE) .setRetryCount(3) .setCookieStore(new PersistentCookieStore()) .setCertificates() .addCommonHeaders(headers); } catch (Exception e) { e.printStackTrace(); } } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/weidget/ImageUtils.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "ImageUtils handles both image loading configuration and activity lifecycle checks, which are two distinct responsibilities. Changes in Glide configuration or lifecycle management logic would require modifying the same class."}, {"principle": "Open-Closed", "justification": "The class uses static methods and cannot be extended to introduce new image-loading behaviors (e.g., new caching strategies) without modifying its existing code."}, {"principle": "Dependency Inversion", "justification": "ImageUtils directly depends on concrete implementations (Glide, Myappplication.mContext) instead of abstractions. High-level image-loading logic should depend on interfaces, not low-level libraries or application contexts."}]}]}
{"project_id": 13, "chunk_id": 0, "prompt": {"main_file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/weidget/AsHomepageHeaderView.java", "main_file_content": "package com.example.myrecyclviewdemo.weidget; import android.content.Context; import android.graphics.drawable.Drawable; import android.support.v7.widget.TintTypedArray; import android.util.AttributeSet; import android.view.View; import android.widget.ImageView; import android.widget.RelativeLayout; import android.widget.TextView; import com.example.myrecyclviewdemo.R; public class AsHomepageHeaderView extends RelativeLayout implements View.OnClickListener { private ImageView iv_more; private TextView tv_more; private TextView tv_type; private String typeName; private TextView iv_left; private Drawable leftDrawable; private Context mContext; private boolean isrightivtvvisible; public AsHomepageHeaderView(Context context) { this(context, null); } public AsHomepageHeaderView(Context context, AttributeSet attrs) { this(context, attrs, 0); } public AsHomepageHeaderView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); initviews(context); initAttrs(attrs); } private void initviews(Context context) { View.inflate(context, R.layout.ashomepagerheaderview, this); iv_left = ((TextView) findViewById(R.id.iv_ashomeitem_left)); iv_more = ((ImageView) findViewById(R.id.iv_ashomepagerheader_more)); tv_more = ((TextView) findViewById(R.id.tv_ashomepagerheader_more)); tv_type = ((TextView) findViewById(R.id.tv_ashomepagerheader_type)); } private void initAttrs(AttributeSet attrs) { TintTypedArray tta = TintTypedArray.obtainStyledAttributes(getContext(), attrs, R.styleable.HomepageHeaderView); typeName = tta.getString(R.styleable.HomepageHeaderView_typename); leftDrawable = tta.getDrawable(R.styleable.HomepageHeaderView_lefthimage); isrightivtvvisible = tta.getBoolean(R.styleable.HomepageHeaderView_isrightivtvvisible, false); if (isrightivtvvisible) { tv_more.setVisibility(GONE); iv_more.setVisibility(GONE); } if (typeName != null) { tv_type.setText(typeName + \"\"); } tv_more.setOnClickListener(this); iv_more.setOnClickListener(this); } public void setTypeName(String typename) { tv_type.setText(typename + \"\"); } @Override public void onClick(View view) { if (moreclicklistenser != null) { moreclicklistenser.setmoreclicklistenser(); } } public void setRightIvtVGone(boolean visibleless) { if (visibleless) { tv_more.setVisibility(GONE); iv_more.setVisibility(GONE); } else { tv_more.setVisibility(VISIBLE); iv_more.setVisibility(VISIBLE); } } public interface MoreclickListenser { public void setmoreclicklistenser(); } public MoreclickListenser moreclicklistenser; public void setMoreclicklistenser(MoreclickListenser moreclicklistenser) { this.moreclicklistenser = moreclicklistenser; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/weidget/AsHomepageHeaderView.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The class handles view inflation, attribute initialization, click listeners, and UI state management. These multiple responsibilities create multiple reasons for the class to change."}, {"principle": "Open-Closed", "justification": "The class cannot be extended to modify attribute initialization or click handling behavior without modifying its existing code (e.g., private initAttrs method and hardcoded click logic in onClick)."}]}]}
{"project_id": 13, "chunk_id": 0, "prompt": {"main_file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/weidget/MyStaggerGrildLayoutManger.java", "main_file_content": "package com.example.myrecyclviewdemo.weidget; import android.content.Context; import android.graphics.PointF; import android.support.v7.widget.LinearSmoothScroller; import android.support.v7.widget.RecyclerView; import android.support.v7.widget.StaggeredGridLayoutManager; import android.util.DisplayMetrics; public class MyStaggerGrildLayoutManger extends StaggeredGridLayoutManager { private float MILLISECONDS_PER_INCH = 1f; private Context contxt; public MyStaggerGrildLayoutManger(Context context, int spanCount, int orientation) { super(spanCount, orientation); } @Override public void smoothScrollToPosition(RecyclerView recyclerView, RecyclerView.State state, int position) { LinearSmoothScroller linearSmoothScroller = new LinearSmoothScroller(recyclerView.getContext()) { @Override public PointF computeScrollVectorForPosition(int targetPosition) { return null; } @Override protected float calculateSpeedPerPixel (DisplayMetrics displayMetrics) { return MILLISECONDS_PER_INCH / displayMetrics.density; } }; linearSmoothScroller.setTargetPosition(position); startSmoothScroll(linearSmoothScroller); } public void setSpeedSlow() { MILLISECONDS_PER_INCH = contxt.getResources().getDisplayMetrics().density * 0.3f; } public void setSpeedFast() { MILLISECONDS_PER_INCH = contxt.getResources().getDisplayMetrics().density * 0.03f; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/weidget/MyStaggerGrildLayoutManger.java", "violatedPrinciples": [{"principle": "Liskov", "justification": "The computeScrollVectorForPosition() method returns null, which may break the expected scroll behavior defined by the base class. This violates LSP as subtypes must maintain functional interchangeability with their base types."}]}]}
{"project_id": 13, "chunk_id": 0, "prompt": {"main_file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/utils/RefreshUtils.java", "main_file_content": "package com.example.myrecyclviewdemo.utils; import android.content.Context; import com.cjj.MaterialRefreshLayout; import com.cjj.MaterialRefreshListener; public class RefreshUtils { private Builder builder; private RefreshListenser mRefreshListenser; public RefreshUtils() { } public Builder newBuilder(Context context) { builder = new Builder(context); return builder; } private void initRefreshLayout() { builder.mRefreshLayout.setLoadMore(builder.canLoadMore); builder.mRefreshLayout.setIsOverLay(builder.isOverLay); builder.mRefreshLayout.setWaveShow(builder.isWaveShow); builder.mRefreshLayout.setMaterialRefreshListener(new MaterialRefreshListener() { @Override public void onRefresh(MaterialRefreshLayout materialRefreshLayout) { if (mRefreshListenser != null) { mRefreshListenser.refreshdata(); } } @Override public void onRefreshLoadMore(MaterialRefreshLayout materialRefreshLayout) { if (mRefreshListenser != null) { mRefreshListenser.loadrefreshdata(); } } }); } public void finishrefresh() { builder.mRefreshLayout.finishRefresh(); builder.mRefreshLayout.finishRefreshLoadMore(); } public void finishrefreshSleep() { new Thread(new Runnable() { @Override public void run() { try { Thread.sleep(2000); builder.mRefreshLayout.post(new Runnable() { @Override public void run() { finishrefresh(); } }); } catch (InterruptedException e) { e.printStackTrace(); builder.mRefreshLayout.post(new Runnable() { @Override public void run() { finishrefresh(); } }); } } }).start(); } public class Builder { private Context mContext; private MaterialRefreshLayout mRefreshLayout; private boolean canLoadMore; public boolean isOverLay = true; public boolean isWaveShow = false; public Builder(Context context) { mContext = context; } public Builder setOverLay(boolean overLay) { isOverLay = overLay; return builder; } public Builder setWaveShow(boolean isWaveShow) { this.isWaveShow = isWaveShow; return builder; } public Builder setLoadMore(boolean loadMore) { this.canLoadMore = loadMore; return builder; } public Builder setRefreshLayout(MaterialRefreshLayout refreshLayout) { this.mRefreshLayout = refreshLayout; return builder; } public void build(RefreshListenser listener) { mRefreshListenser = listener; valid(); initRefreshLayout(); } private void valid() { if (this.mContext == null) throw new RuntimeException(\"content can't be null\"); if (this.mRefreshLayout == null) throw new RuntimeException(\"MaterialRefreshLayout can't be null\"); } } public interface RefreshListenser { void refreshdata(); void loadrefreshdata(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/utils/RefreshUtils.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "RefreshUtils handles both refresh configuration (via Builder) and refresh execution logic (finishrefresh), while Builder manages construction, validation, and dependency injection. This combines multiple responsibilities in one class."}, {"principle": "Open-Closed", "justification": "Adding new refresh behaviors (e.g., different finish mechanisms) requires modifying RefreshUtils/Builder code instead of extending through abstractions. No extension points are provided for closed modification."}, {"principle": "Interface Segregation", "justification": "RefreshListenser forces clients to implement both refreshdata() and loadrefreshdata() even if they only need one. Clients cannot depend on a minimal, focused interface."}, {"principle": "Dependency Inversion", "justification": "High-level RefreshUtils directly depends on concrete MaterialRefreshLayout (low-level). No abstraction is introduced for the refresh mechanism, violating policy/implementation separation."}]}]}
{"project_id": 13, "chunk_id": 0, "prompt": {"main_file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/adapter/TypeHistoryAdapter.java", "main_file_content": "package com.example.myrecyclviewdemo.adapter; import android.content.Context; import android.content.Intent; import android.net.Uri; import android.support.v7.widget.RecyclerView; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.ImageView; import android.widget.TextView; import com.example.myrecyclviewdemo.R; import com.example.myrecyclviewdemo.bean.RefreshBean; import com.example.myrecyclviewdemo.weidget.ImageUtils; import java.util.List; import butterknife.Bind; import butterknife.ButterKnife; public class TypeHistoryAdapter extends RecyclerView.Adapter<TypeHistoryAdapter.TypeHistoryHolder> { private Context mContext; private List<RefreshBean.DataBean> mHomehopspot; private LayoutInflater inflater; public TypeHistoryAdapter(Context mContext, List<RefreshBean.DataBean> mHomeCategory) { this.mContext = mContext; this.mHomehopspot = mHomeCategory; inflater = LayoutInflater.from(mContext); } @Override public TypeHistoryHolder onCreateViewHolder(ViewGroup parent, int viewType) { return new TypeHistoryHolder(inflater.inflate(R.layout.item_raiders, parent, false)); } @Override public void onBindViewHolder(TypeHistoryHolder holder, int position) { RefreshBean.DataBean contentBean = mHomehopspot.get(position); ImageUtils.load(mContext, contentBean.getCpThree().getImgUrl(), holder.homeReadPivIv); holder.homeReadTitle.setText(\"#\" + contentBean.getTitle()); } @Override public int getItemCount() { return mHomehopspot == null ? 0 : mHomehopspot.size(); } public class TypeHistoryHolder extends RecyclerView.ViewHolder { @Bind(R.id.home_read_piv_iv) ImageView homeReadPivIv; @Bind(R.id.home_read_title) TextView homeReadTitle; public TypeHistoryHolder(View view) { super(view); ButterKnife.bind(this, view); } } }", "dependencies": [{"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/bean/RefreshBean.java", "file_content": "package com.example.myrecyclviewdemo.bean; import java.util.List; public class RefreshBean { private List<DataBean> data; public List<DataBean> getData() { return data; } public void setData(List<DataBean> data) { this.data = data; } public static class DataBean { private CpOneBean cpOne; private CpTwoBean cpTwo; private CpThreeBean cpThree; private int id; private String title; private int campaignOne; private int campaignTwo; private int campaignThree; public CpOneBean getCpOne() { return cpOne; } public void setCpOne(CpOneBean cpOne) { this.cpOne = cpOne; } public CpTwoBean getCpTwo() { return cpTwo; } public void setCpTwo(CpTwoBean cpTwo) { this.cpTwo = cpTwo; } public CpThreeBean getCpThree() { return cpThree; } public void setCpThree(CpThreeBean cpThree) { this.cpThree = cpThree; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public int getCampaignOne() { return campaignOne; } public void setCampaignOne(int campaignOne) { this.campaignOne = campaignOne; } public int getCampaignTwo() { return campaignTwo; } public void setCampaignTwo(int campaignTwo) { this.campaignTwo = campaignTwo; } public int getCampaignThree() { return campaignThree; } public void setCampaignThree(int campaignThree) { this.campaignThree = campaignThree; } public static class CpOneBean { private int id; private String title; private String imgUrl; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getImgUrl() { return imgUrl; } public void setImgUrl(String imgUrl) { this.imgUrl = imgUrl; } } public static class CpTwoBean { private int id; private String title; private String imgUrl; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getImgUrl() { return imgUrl; } public void setImgUrl(String imgUrl) { this.imgUrl = imgUrl; } } public static class CpThreeBean { private int id; private String title; private String imgUrl; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getImgUrl() { return imgUrl; } public void setImgUrl(String imgUrl) { this.imgUrl = imgUrl; } } } }"}, {"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/weidget/ImageUtils.java", "file_content": "package com.example.myrecyclviewdemo.weidget; import android.app.Activity; import android.content.Context; import android.os.Build; import android.widget.ImageView; import com.bumptech.glide.Glide; import com.bumptech.glide.load.engine.DiskCacheStrategy; import com.example.myrecyclviewdemo.R; import com.example.myrecyclviewdemo.app.Myappplication; public class ImageUtils { public static void load(Activity activity, String url, ImageView iv) { if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) { if (!activity.isDestroyed()) { Glide.with(Myappplication.mContext).load(url).error(R.mipmap.ic_launcher).crossFade().diskCacheStrategy(DiskCacheStrategy.SOURCE).into(iv); } } } public static void load(Context context, String url, ImageView iv) { if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) { Glide.with(context).load(url).crossFade().diskCacheStrategy(DiskCacheStrategy.SOURCE) .error(R.mipmap.ic_launcher) .into(iv); } } public static void loadAll(Context context, String url, ImageView iv) { Glide.with(context).load(url).crossFade().skipMemoryCache(true).diskCacheStrategy(DiskCacheStrategy.NONE) .error(R.mipmap.ic_launcher) .into(iv); } public static void loadAll(Activity activity, String url, ImageView iv) { if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) { if (!activity.isDestroyed()) { Glide.with(activity).load(url).error(R.mipmap.ic_launcher).crossFade().skipMemoryCache(true).diskCacheStrategy(DiskCacheStrategy.NONE).into(iv); } } } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/adapter/TypeHistoryAdapter.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "TypeHistoryAdapter directly depends on concrete ImageUtils class for image loading. High-level adapter should depend on abstractions (e.g., ImageLoader interface) rather than low-level implementation details."}, {"principle": "Single Responsibility", "justification": "TypeHistoryAdapter handles both data binding and view management, while also formatting titles (# concatenation). Formatting logic should be extracted to a separate component."}]}]}
{"project_id": 13, "chunk_id": 0, "prompt": {"main_file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/adapter/TypeCategoryAdapter.java", "main_file_content": "package com.example.myrecyclviewdemo.adapter; import android.content.Context; import android.content.Intent; import android.net.Uri; import android.support.v7.widget.RecyclerView; import android.util.Log; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import com.example.myrecyclviewdemo.R; import com.example.myrecyclviewdemo.bean.HomeCategory; import com.example.myrecyclviewdemo.weidget.AsImageTextView; import java.util.List; import butterknife.Bind; import butterknife.ButterKnife; public class TypeCategoryAdapter extends RecyclerView.Adapter<TypeCategoryAdapter.TypetypeHolder> { private Context mContext; private List<HomeCategory> mHomeCategory; private LayoutInflater inflater; public TypeCategoryAdapter(Context mContext, List<HomeCategory> mHomeCategory) { this.mContext = mContext; this.mHomeCategory = mHomeCategory; inflater = LayoutInflater.from(mContext); } @Override public TypetypeHolder onCreateViewHolder(ViewGroup parent, int viewType) { return new TypetypeHolder(inflater.inflate(R.layout.item_homepageradapter_ivtv, null)); } @Override public void onBindViewHolder(TypetypeHolder holder, int position) { HomeCategory homeCategory = mHomeCategory.get(position); holder.asivtvHomepageradapter.setTvImagetext(homeCategory.getTypename()); holder.asivtvHomepageradapter.setIvImagetext(homeCategory.getImageid()); } @Override public int getItemCount() { return mHomeCategory == null ? 0 : mHomeCategory.size(); } public class TypetypeHolder extends RecyclerView.ViewHolder { @Bind(R.id.asivtv_homepageradapter) AsImageTextView asivtvHomepageradapter; public TypetypeHolder(View view) { super(view); ButterKnife.bind(this, view); } } }", "dependencies": [{"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/bean/HomeCategory.java", "file_content": "package com.example.myrecyclviewdemo.bean; import android.app.Application; import com.example.myrecyclviewdemo.app.Myappplication; public class HomeCategory { private int imageid; private String typename; public HomeCategory(int imageid, String typename) { this.imageid = imageid; this.typename = typename; } public HomeCategory(int imageid, int stringID) { this.imageid = imageid; typename = Myappplication.mContext.getResources().getString(stringID); } public int getImageid() { return imageid; } public void setImageid(int imageid) { this.imageid = imageid; } public String getTypename() { return typename; } public void setTypename(String typename) { this.typename = typename; } }"}, {"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/weidget/AsImageTextView.java", "file_content": "package com.example.myrecyclviewdemo.weidget; import android.content.Context; import android.graphics.drawable.Drawable; import android.util.AttributeSet; import android.view.View; import android.widget.ImageView; import android.widget.RelativeLayout; import android.widget.TextView; import com.example.myrecyclviewdemo.R; public class AsImageTextView extends RelativeLayout implements View.OnClickListener { private ImageView ivImagetext; private TextView tvImagetext; public ImageView getIvImagetext() { return ivImagetext; } public void setIvImagetext(ImageView ivImagetext) { this.ivImagetext = ivImagetext; } public TextView getTvImagetext() { return tvImagetext; } public void setTvImagetext(TextView tvImagetext) { this.tvImagetext = tvImagetext; } public AsImageTextView(Context context) { this(context, null); } public AsImageTextView(Context context, AttributeSet attrs) { this(context, attrs, 0); } public AsImageTextView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); View.inflate(context, R.layout.asimagetextview, this); ivImagetext = ((ImageView) findViewById(R.id.iv_imagetext)); tvImagetext = ((TextView) findViewById(R.id.tv_imagetext)); initattrs(); } private void initattrs() { } public void setIvImagetext(int imageid) { Drawable drawable = getResources().getDrawable(imageid); if (drawable != null) { ivImagetext.setImageDrawable(drawable); } } public void setTvImagetext(String typename) { if (typename != null) { tvImagetext.setText(typename + \"\"); } } @Override public void onClick(View view) { if (imagetextclick != null) { imagetextclick.setImagetextclick(); } } public interface Imagetextclick { public void setImagetextclick(); } public Imagetextclick imagetextclick; public Imagetextclick getImagetextclic() { return imagetextclick; } public void setImagetextclick(Imagetextclick imagetextclick) { this.imagetextclick = imagetextclick; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/bean/HomeCategory.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "HomeCategory handles both data storage and resource string resolution via Myappplication.mContext, introducing multiple reasons to change."}, {"principle": "Dependency Inversion", "justification": "HomeCategory directly references Myappplication.mContext, a concrete implementation, instead of depending on an abstraction for context."}]}]}
{"project_id": 13, "chunk_id": 0, "prompt": {"main_file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/adapter/HomepagerRecycleAdapter.java", "main_file_content": "package com.example.myrecyclviewdemo.adapter; import android.content.Context; import android.support.v7.widget.GridLayoutManager; import android.support.v7.widget.RecyclerView; import android.support.v7.widget.StaggeredGridLayoutManager; import android.util.Log; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.ImageView; import android.widget.LinearLayout; import com.bumptech.glide.Glide; import com.example.myrecyclviewdemo.R; import com.example.myrecyclviewdemo.bean.Headerbean; import com.example.myrecyclviewdemo.bean.HomeCategory; import com.example.myrecyclviewdemo.bean.RefreshBean; import com.example.myrecyclviewdemo.weidget.AsHomepageHeaderView; import com.example.myrecyclviewdemo.weidget.ImageUtils; import com.example.myrecyclviewdemo.weidget.MyStaggerGrildLayoutManger; import java.util.ArrayList; import java.util.List; import butterknife.Bind; import butterknife.ButterKnife; public class HomepagerRecycleAdapter extends RecyclerView.Adapter { private final Context mContext; private List<Headerbean.DataBean> headerData; private int count = 3; private List<RefreshBean.DataBean> refreshbean; private List<RefreshBean.DataBean> centerBean; private ArrayList<HomeCategory> mHomeCategories; private int TYPE_TOP = 1; private List<Integer> mHeights = new ArrayList<>(); private int TYPE_CENTER = 2; private int TYPE_CATEGORY = 3; private int TYPE_HEADER = 4; private int REFRESHPOSITION = 5; private int CENTERPOSITION; private int TYPE_REFRESH = 6; private LayoutInflater inflater; private RecyclerView recyclerView; private MyStaggerGrildLayoutManger mystager; public HomepagerRecycleAdapter(Context context) { mContext = context; inflater = LayoutInflater.from(mContext); headerData = new ArrayList<>(); refreshbean = new ArrayList<>(); centerBean = new ArrayList<>(); } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { if (viewType == TYPE_TOP) { View viewtop = inflater.inflate(R.layout.adapter_slider, parent, false); StaggeredGridLayoutManager.LayoutParams params = (StaggeredGridLayoutManager.LayoutParams) viewtop.getLayoutParams(); params.setFullSpan(true); viewtop.setLayoutParams(params); return new TypeTopsliderHolder(viewtop); } else if (viewType == TYPE_HEADER) { View view2 = inflater.inflate(R.layout.item_homepagertypeheader_type, parent, false); StaggeredGridLayoutManager.LayoutParams params = (StaggeredGridLayoutManager.LayoutParams) view2.getLayoutParams(); params.setFullSpan(true); view2.setLayoutParams(params); return new TypeheadHolder(view2); } else if (viewType == TYPE_CENTER) { View view = inflater.inflate(R.layout.itam_homepageradapter_rv2, parent, false); StaggeredGridLayoutManager.LayoutParams params2 = (StaggeredGridLayoutManager.LayoutParams) view.getLayoutParams(); params2.setFullSpan(true); view.setLayoutParams(params2); return new TypetypeHolder2(view); } else if (viewType == TYPE_CATEGORY) { View view = inflater.inflate(R.layout.itam_homepageradapter_rv2, parent, false); StaggeredGridLayoutManager.LayoutParams params2 = (StaggeredGridLayoutManager.LayoutParams) view.getLayoutParams(); params2.setFullSpan(true); view.setLayoutParams(params2); return new TypetypeHolder(view); } else if (viewType == TYPE_REFRESH) { return new TypeRefresh(inflater.inflate(R.layout.item_raiders2, parent, false)); } else { View viewtop = inflater.inflate(R.layout.adapter_slider, parent, false); StaggeredGridLayoutManager.LayoutParams params = (StaggeredGridLayoutManager.LayoutParams) viewtop.getLayoutParams(); params.setFullSpan(true); viewtop.setLayoutParams(params); return new TypeTopsliderHolder(viewtop); } } @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { if (holder instanceof TypeTopsliderHolder && headerData.size() != 0 && ((TypeTopsliderHolder) holder).linearLayout.getChildCount() == 0) { initslider(((TypeTopsliderHolder) holder), headerData); } else if (holder instanceof TypetypeHolder && centerBean.size() != 0) { initcategory(((TypetypeHolder) holder)); } else if (holder instanceof TypeheadHolder) { initTop(((TypeheadHolder) holder), position); } else if (holder instanceof TypetypeHolder2 && centerBean.size() != 0) { initCenterBean(((TypetypeHolder2) holder)); } else if (holder instanceof TypeRefresh && refreshbean.size() != 0) { initrefreshdata(((TypeRefresh) holder), position - REFRESHPOSITION - 1); } } private void initrefreshdata(TypeRefresh holder, int position) { Log.e(\"position\", \"initrefreshdata: \" + position); if (mHeights.size() <= getItemCount() + 2) { mHeights.add((int) (500 + Math.random() * 400)); } ViewGroup.LayoutParams layoutParams = holder.homeReadPivIv.getLayoutParams(); if (mHeights.size() > position) layoutParams.height = mHeights.get(position); else layoutParams.height = 589; holder.homeReadPivIv.setLayoutParams(layoutParams); holder.homeReadPivIv.setScaleType(ImageView.ScaleType.FIT_XY); if (refreshbean.size() > position) { ImageUtils.load(mContext, refreshbean.get(position).getCpOne().getImgUrl(), holder.homeReadPivIv); } else { ImageUtils.load(mContext, refreshbean.get(0).getCpTwo().getImgUrl(), holder.homeReadPivIv); } } private void initCenterBean(TypetypeHolder2 holder) { holder.rvtype.setLayoutManager(new GridLayoutManager(mContext, 2)); TypeHistoryAdapter centerAdapter = new TypeHistoryAdapter(mContext, centerBean); holder.rvtype.setAdapter(centerAdapter); } private void initcategory(TypetypeHolder holder) { holder.rvtype.setLayoutManager(new GridLayoutManager(mContext, mHomeCategories.size())); TypeCategoryAdapter categoryAdapter = new TypeCategoryAdapter(mContext, mHomeCategories); holder.rvtype.setAdapter(categoryAdapter); } private void initTop(TypeheadHolder holder, int position) { if (position == CENTERPOSITION) { holder.hview.setTypeName(\"\u4e2d\u95f4head\"); } else if (position == REFRESHPOSITION) { holder.hview.setTypeName(\"\u4e0b\u90e8head\"); } } @Override public int getItemViewType(int position) { CENTERPOSITION = mHomeCategories.size() == 0 ? 1 : 2; REFRESHPOSITION = centerBean.size() == 0 ? 3 : 4; Log.e(\"getItemViewType\", \"getItemViewType: \" + CENTERPOSITION + \",:\" + REFRESHPOSITION); if (position == 0) return TYPE_TOP; else if (position == CENTERPOSITION || position == REFRESHPOSITION) return TYPE_HEADER; else if (position == 1) return TYPE_CATEGORY; else if (position == CENTERPOSITION + 1) return TYPE_CENTER; else return TYPE_REFRESH; } private void initslider(TypeTopsliderHolder holder, List<Headerbean.DataBean> data) { LinearLayout linearLayout = holder.linearLayout; for (int i = 0; i < data.size(); i++) { ImageView imageView = new ImageView(mContext); LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.MATCH_PARENT); layoutParams.rightMargin = 40; imageView.setLayoutParams(layoutParams); ImageUtils.load(mContext, data.get(i).getImgUrl(), imageView); imageView.setScaleType(ImageView.ScaleType.FIT_XY); linearLayout.addView(imageView); } } @Override public int getItemCount() { return count; } @Override public void onAttachedToRecyclerView(RecyclerView recyclerView) { super.onAttachedToRecyclerView(recyclerView); this.recyclerView = recyclerView; RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager(); if (layoutManager instanceof MyStaggerGrildLayoutManger) { mystager = ((MyStaggerGrildLayoutManger) layoutManager); } recyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() { @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) { if (newState == 2) { Glide.with(mContext).pauseRequests(); } else { Glide.with(mContext).resumeRequests(); } } @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { } }); } public void setheaderbean(Headerbean headerbean) { headerData = headerbean.getData(); notifyDataSetChanged(); } public void setRefreshBean(RefreshBean refreshBean, boolean flagFirst) { refreshbean.addAll(refreshBean.getData()); int count1 = this.count; this.count += refreshBean.getData().size(); notifyDataSetChanged(); if (!flagFirst) { recyclerView.smoothScrollToPosition(count1 + 2); } } public void setCenterBean(RefreshBean refreshBean) { centerBean = refreshBean.getData(); count++; notifyDataSetChanged(); } public void setCategoryBean(ArrayList<HomeCategory> homeCategories) { mHomeCategories = homeCategories; count++; notifyDataSetChanged(); } public class TypeTopsliderHolder extends RecyclerView.ViewHolder { @Bind(R.id.ll_slider) LinearLayout linearLayout; public TypeTopsliderHolder(View view) { super(view); ButterKnife.bind(this, view); } } public class TypeheadHolder extends RecyclerView.ViewHolder { @Bind(R.id.ashv_homepager) AsHomepageHeaderView hview; public TypeheadHolder(View view) { super(view); ButterKnife.bind(this, view); hview.setMoreclicklistenser(new AsHomepageHeaderView.MoreclickListenser() { @Override public void setmoreclicklistenser() { } }); } } public class TypetypeHolder extends RecyclerView.ViewHolder { @Bind(R.id.rv_homepageradapter_artist) RecyclerView rvtype; public TypetypeHolder(View view) { super(view); ButterKnife.bind(this, view); } } public class TypetypeHolder2 extends RecyclerView.ViewHolder { @Bind(R.id.rv_homepageradapter_artist) RecyclerView rvtype; public TypetypeHolder2(View view) { super(view); ButterKnife.bind(this, view); } } static class TypeRefresh extends RecyclerView.ViewHolder { @Bind(R.id.home_read_piv_iv) ImageView homeReadPivIv; TypeRefresh(View view) { super(view); ButterKnife.bind(this, view); } } }", "dependencies": [{"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/bean/Headerbean.java", "file_content": "package com.example.myrecyclviewdemo.bean; import java.util.List; public class Headerbean { @Override public String toString() { return \"Headerbean{\" + \"data=\" + data + '}'; } private List<DataBean> data; public List<DataBean> getData() { return data; } public void setData(List<DataBean> data) { this.data = data; } public static class DataBean { @Override public String toString() { return \"DataBean{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", imgUrl='\" + imgUrl + '\\'' + \", type=\" + type + '}'; } private int id; private String name; private String imgUrl; private int type; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getImgUrl() { return imgUrl; } public void setImgUrl(String imgUrl) { this.imgUrl = imgUrl; } public int getType() { return type; } public void setType(int type) { this.type = type; } } }"}, {"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/bean/HomeCategory.java", "file_content": "package com.example.myrecyclviewdemo.bean; import android.app.Application; import com.example.myrecyclviewdemo.app.Myappplication; public class HomeCategory { private int imageid; private String typename; public HomeCategory(int imageid, String typename) { this.imageid = imageid; this.typename = typename; } public HomeCategory(int imageid, int stringID) { this.imageid = imageid; typename = Myappplication.mContext.getResources().getString(stringID); } public int getImageid() { return imageid; } public void setImageid(int imageid) { this.imageid = imageid; } public String getTypename() { return typename; } public void setTypename(String typename) { this.typename = typename; } }"}, {"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/bean/RefreshBean.java", "file_content": "package com.example.myrecyclviewdemo.bean; import java.util.List; public class RefreshBean { private List<DataBean> data; public List<DataBean> getData() { return data; } public void setData(List<DataBean> data) { this.data = data; } public static class DataBean { private CpOneBean cpOne; private CpTwoBean cpTwo; private CpThreeBean cpThree; private int id; private String title; private int campaignOne; private int campaignTwo; private int campaignThree; public CpOneBean getCpOne() { return cpOne; } public void setCpOne(CpOneBean cpOne) { this.cpOne = cpOne; } public CpTwoBean getCpTwo() { return cpTwo; } public void setCpTwo(CpTwoBean cpTwo) { this.cpTwo = cpTwo; } public CpThreeBean getCpThree() { return cpThree; } public void setCpThree(CpThreeBean cpThree) { this.cpThree = cpThree; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public int getCampaignOne() { return campaignOne; } public void setCampaignOne(int campaignOne) { this.campaignOne = campaignOne; } public int getCampaignTwo() { return campaignTwo; } public void setCampaignTwo(int campaignTwo) { this.campaignTwo = campaignTwo; } public int getCampaignThree() { return campaignThree; } public void setCampaignThree(int campaignThree) { this.campaignThree = campaignThree; } public static class CpOneBean { private int id; private String title; private String imgUrl; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getImgUrl() { return imgUrl; } public void setImgUrl(String imgUrl) { this.imgUrl = imgUrl; } } public static class CpTwoBean { private int id; private String title; private String imgUrl; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getImgUrl() { return imgUrl; } public void setImgUrl(String imgUrl) { this.imgUrl = imgUrl; } } public static class CpThreeBean { private int id; private String title; private String imgUrl; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getImgUrl() { return imgUrl; } public void setImgUrl(String imgUrl) { this.imgUrl = imgUrl; } } } }"}, {"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/weidget/AsHomepageHeaderView.java", "file_content": "package com.example.myrecyclviewdemo.weidget; import android.content.Context; import android.graphics.drawable.Drawable; import android.support.v7.widget.TintTypedArray; import android.util.AttributeSet; import android.view.View; import android.widget.ImageView; import android.widget.RelativeLayout; import android.widget.TextView; import com.example.myrecyclviewdemo.R; public class AsHomepageHeaderView extends RelativeLayout implements View.OnClickListener { private ImageView iv_more; private TextView tv_more; private TextView tv_type; private String typeName; private TextView iv_left; private Drawable leftDrawable; private Context mContext; private boolean isrightivtvvisible; public AsHomepageHeaderView(Context context) { this(context, null); } public AsHomepageHeaderView(Context context, AttributeSet attrs) { this(context, attrs, 0); } public AsHomepageHeaderView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); initviews(context); initAttrs(attrs); } private void initviews(Context context) { View.inflate(context, R.layout.ashomepagerheaderview, this); iv_left = ((TextView) findViewById(R.id.iv_ashomeitem_left)); iv_more = ((ImageView) findViewById(R.id.iv_ashomepagerheader_more)); tv_more = ((TextView) findViewById(R.id.tv_ashomepagerheader_more)); tv_type = ((TextView) findViewById(R.id.tv_ashomepagerheader_type)); } private void initAttrs(AttributeSet attrs) { TintTypedArray tta = TintTypedArray.obtainStyledAttributes(getContext(), attrs, R.styleable.HomepageHeaderView); typeName = tta.getString(R.styleable.HomepageHeaderView_typename); leftDrawable = tta.getDrawable(R.styleable.HomepageHeaderView_lefthimage); isrightivtvvisible = tta.getBoolean(R.styleable.HomepageHeaderView_isrightivtvvisible, false); if (isrightivtvvisible) { tv_more.setVisibility(GONE); iv_more.setVisibility(GONE); } if (typeName != null) { tv_type.setText(typeName + \"\"); } tv_more.setOnClickListener(this); iv_more.setOnClickListener(this); } public void setTypeName(String typename) { tv_type.setText(typename + \"\"); } @Override public void onClick(View view) { if (moreclicklistenser != null) { moreclicklistenser.setmoreclicklistenser(); } } public void setRightIvtVGone(boolean visibleless) { if (visibleless) { tv_more.setVisibility(GONE); iv_more.setVisibility(GONE); } else { tv_more.setVisibility(VISIBLE); iv_more.setVisibility(VISIBLE); } } public interface MoreclickListenser { public void setmoreclicklistenser(); } public MoreclickListenser moreclicklistenser; public void setMoreclicklistenser(MoreclickListenser moreclicklistenser) { this.moreclicklistenser = moreclicklistenser; } }"}, {"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/weidget/ImageUtils.java", "file_content": "package com.example.myrecyclviewdemo.weidget; import android.app.Activity; import android.content.Context; import android.os.Build; import android.widget.ImageView; import com.bumptech.glide.Glide; import com.bumptech.glide.load.engine.DiskCacheStrategy; import com.example.myrecyclviewdemo.R; import com.example.myrecyclviewdemo.app.Myappplication; public class ImageUtils { public static void load(Activity activity, String url, ImageView iv) { if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) { if (!activity.isDestroyed()) { Glide.with(Myappplication.mContext).load(url).error(R.mipmap.ic_launcher).crossFade().diskCacheStrategy(DiskCacheStrategy.SOURCE).into(iv); } } } public static void load(Context context, String url, ImageView iv) { if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) { Glide.with(context).load(url).crossFade().diskCacheStrategy(DiskCacheStrategy.SOURCE) .error(R.mipmap.ic_launcher) .into(iv); } } public static void loadAll(Context context, String url, ImageView iv) { Glide.with(context).load(url).crossFade().skipMemoryCache(true).diskCacheStrategy(DiskCacheStrategy.NONE) .error(R.mipmap.ic_launcher) .into(iv); } public static void loadAll(Activity activity, String url, ImageView iv) { if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) { if (!activity.isDestroyed()) { Glide.with(activity).load(url).error(R.mipmap.ic_launcher).crossFade().skipMemoryCache(true).diskCacheStrategy(DiskCacheStrategy.NONE).into(iv); } } } }"}, {"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/weidget/MyStaggerGrildLayoutManger.java", "file_content": "package com.example.myrecyclviewdemo.weidget; import android.content.Context; import android.graphics.PointF; import android.support.v7.widget.LinearSmoothScroller; import android.support.v7.widget.RecyclerView; import android.support.v7.widget.StaggeredGridLayoutManager; import android.util.DisplayMetrics; public class MyStaggerGrildLayoutManger extends StaggeredGridLayoutManager { private float MILLISECONDS_PER_INCH = 1f; private Context contxt; public MyStaggerGrildLayoutManger(Context context, int spanCount, int orientation) { super(spanCount, orientation); } @Override public void smoothScrollToPosition(RecyclerView recyclerView, RecyclerView.State state, int position) { LinearSmoothScroller linearSmoothScroller = new LinearSmoothScroller(recyclerView.getContext()) { @Override public PointF computeScrollVectorForPosition(int targetPosition) { return null; } @Override protected float calculateSpeedPerPixel (DisplayMetrics displayMetrics) { return MILLISECONDS_PER_INCH / displayMetrics.density; } }; linearSmoothScroller.setTargetPosition(position); startSmoothScroll(linearSmoothScroller); } public void setSpeedSlow() { MILLISECONDS_PER_INCH = contxt.getResources().getDisplayMetrics().density * 0.3f; } public void setSpeedFast() { MILLISECONDS_PER_INCH = contxt.getResources().getDisplayMetrics().density * 0.03f; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/main/java/com/example/myrecyclviewdemo/adapter/HomepagerRecycleAdapter.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "HomepagerRecycleAdapter manages multiple responsibilities: view type handling, layout inflation, Glide request control via scroll listener, and direct data manipulation. This exceeds a single reason to change."}, {"principle": "Open-Closed", "justification": "Adding new view types requires modifying existing onCreateViewHolder/onBindViewHolder logic with new conditionals instead of extending via abstraction."}, {"principle": "Dependency Inversion", "justification": "High-level adapter directly instantiates TypeHistoryAdapter/TypeCategoryAdapter and depends on MyStaggerGrildLayoutManger implementation rather than abstractions."}]}]}
{"project_id": 13, "chunk_id": 0, "prompt": {"main_file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/test/java/com/example/myrecyclviewdemo/ExampleUnitTest.java", "main_file_content": "package com.example.myrecyclviewdemo; import org.junit.Test; import static org.junit.Assert.*; public class ExampleUnitTest { @Test public void addition_isCorrect() throws Exception { assertEquals(4, 2 + 2); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/test/java/com/example/myrecyclviewdemo/ExampleUnitTest.java", "violatedPrinciples": []}]}
{"project_id": 13, "chunk_id": 0, "prompt": {"main_file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/androidTest/java/com/example/myrecyclviewdemo/ExampleInstrumentedTest.java", "main_file_content": "package com.example.myrecyclviewdemo; import android.content.Context; import android.support.test.InstrumentationRegistry; import android.support.test.runner.AndroidJUnit4; import org.junit.Test; import org.junit.runner.RunWith; import static org.junit.Assert.*; @RunWith(AndroidJUnit4.class) public class ExampleInstrumentedTest { @Test public void useAppContext() throws Exception { Context appContext = InstrumentationRegistry.getTargetContext(); assertEquals(\"com.example.myrecyclviewdemo\", appContext.getPackageName()); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "RecycleviewStaggered-master/RecycleviewStaggered-master/app/src/androidTest/java/com/example/myrecyclviewdemo/ExampleInstrumentedTest.java", "violatedPrinciples": []}]}
{"project_id": 15, "chunk_id": 0, "prompt": {"main_file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/Main.java", "main_file_content": "package com.netflix.prana; import com.google.inject.Injector; import com.netflix.config.ConfigurationManager; import com.netflix.config.DeploymentContext; import com.netflix.governator.guice.LifecycleInjector; import com.netflix.governator.lifecycle.LifecycleManager; import com.netflix.karyon.KaryonServer; import com.netflix.prana.config.PranaConfig; import com.netflix.prana.http.api.HandlersModule; import com.netflix.prana.service.ServiceModule; import org.kohsuke.args4j.CmdLineException; import org.kohsuke.args4j.CmdLineParser; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.util.Properties; public class Main { private static Logger logger = LoggerFactory.getLogger(Main.class); public static void main(String[] args) { PranaConfig pranaConfig = new PranaConfig(); CmdLineParser cmdLineParser = new CmdLineParser(pranaConfig); try { cmdLineParser.parseArgument(args); } catch (CmdLineException e) { System.err.println(e.getMessage()); cmdLineParser.printUsage(System.err); System.exit(1); } try { MainModule sm = new MainModule(pranaConfig); try { FileInputStream fileInputStream = new FileInputStream(pranaConfig.getConfigFile()); Properties properties = new Properties(); properties.load(fileInputStream); ConfigurationManager.loadProperties(properties); } catch (FileNotFoundException fox) { logger.error(String.format(\"Config file %s is not present, loading default properties present in classpath\", pranaConfig.getConfigFile())); } DeploymentContext deploymentContext = ConfigurationManager.getDeploymentContext(); deploymentContext.setApplicationId(pranaConfig.getAppName()); Injector injector = LifecycleInjector.builder().withModules(sm, new ServiceModule(), new HandlersModule()).build().createInjector(); LifecycleManager manager = injector.getInstance(LifecycleManager.class); manager.start(); KaryonServer karyonServer = injector.getInstance(KaryonServer.class); karyonServer.startAndWaitTillShutdown(); } catch (Exception e) { logger.error(e.getMessage()); System.exit(1); } } }", "dependencies": [{"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/config/PranaConfig.java", "file_content": "package com.netflix.prana.config; import org.kohsuke.args4j.Option; public class PranaConfig { @Option(name = \"-p\", aliases = \"--http-port-api\", usage = \"Http Port of Prana Server\") private int httpPort = 8078; @Option(name = \"-a\", aliases = \"--app-name\", usage = \"Parent host application name\") private String appName = \"prana\"; @Option(name = \"-c\", aliases = \"--config\", usage = \"Prana configuration file\") private String configFile = \"prana.properties\"; public int getHttpPort() { return httpPort; } public String getAppName() { return appName; } public String getConfigFile() { return configFile; } }"}, {"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/api/HandlersModule.java", "file_content": "package com.netflix.prana.http.api; import com.google.inject.AbstractModule; import com.google.inject.Scopes; public class HandlersModule extends AbstractModule { @Override protected void configure() { bind(StatusHandler.class).in(Scopes.SINGLETON); bind(SimpleRouter.class).in(Scopes.SINGLETON); bind(ProxyHandler.class).in(Scopes.SINGLETON); bind(HealthCheckHandler.class).in(Scopes.SINGLETON); } }"}, {"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/service/ServiceModule.java", "file_content": "package com.netflix.prana.service; import com.google.inject.AbstractModule; import com.google.inject.Scopes; public class ServiceModule extends AbstractModule { @Override protected void configure() { bind(HostService.class).to(EurekaHostService.class).in(Scopes.SINGLETON); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/Main.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Main class handles command-line parsing, configuration loading, dependency injection setup, lifecycle management, and server startup, indicating multiple responsibilities."}, {"principle": "Dependency Inversion", "justification": "Main directly depends on concrete classes like LifecycleInjector, ConfigurationManager, and KaryonServer instead of abstractions for high-level policy control."}]}]}
{"project_id": 15, "chunk_id": 0, "prompt": {"main_file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/MainModule.java", "main_file_content": "package com.netflix.prana; import com.google.inject.AbstractModule; import com.google.inject.Inject; import com.google.inject.Provides; import com.google.inject.Singleton; import com.netflix.adminresources.resources.KaryonWebAdminModule; import com.netflix.karyon.Karyon; import com.netflix.karyon.KaryonBootstrapSuite; import com.netflix.karyon.KaryonServer; import com.netflix.karyon.archaius.ArchaiusSuite; import com.netflix.karyon.eureka.KaryonEurekaModule; import com.netflix.prana.config.PranaConfig; import com.netflix.prana.http.api.SimpleRouter; public class MainModule extends AbstractModule { private PranaConfig config; public MainModule(PranaConfig config) { this.config = config; } @Override protected void configure() { } @Provides @Singleton @Inject public KaryonServer providesKaryonSever(SimpleRouter simpleRouter) { return Karyon.forRequestHandler(config.getHttpPort(), simpleRouter, new KaryonBootstrapSuite(), KaryonEurekaModule.asSuite(), KaryonWebAdminModule.asSuite(), new ArchaiusSuite(config.getAppName()) ); } }", "dependencies": [{"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/config/PranaConfig.java", "file_content": "package com.netflix.prana.config; import org.kohsuke.args4j.Option; public class PranaConfig { @Option(name = \"-p\", aliases = \"--http-port-api\", usage = \"Http Port of Prana Server\") private int httpPort = 8078; @Option(name = \"-a\", aliases = \"--app-name\", usage = \"Parent host application name\") private String appName = \"prana\"; @Option(name = \"-c\", aliases = \"--config\", usage = \"Prana configuration file\") private String configFile = \"prana.properties\"; public int getHttpPort() { return httpPort; } public String getAppName() { return appName; } public String getConfigFile() { return configFile; } }"}, {"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/api/SimpleRouter.java", "file_content": "package com.netflix.prana.http.api; import com.google.inject.Inject; import com.netflix.karyon.transport.http.SimpleUriRouter; import io.netty.buffer.ByteBuf; import io.reactivex.netty.protocol.http.server.HttpServerRequest; import io.reactivex.netty.protocol.http.server.HttpServerResponse; import io.reactivex.netty.protocol.http.server.RequestHandler; import rx.Observable; public class SimpleRouter implements RequestHandler<ByteBuf, ByteBuf> { private final SimpleUriRouter<ByteBuf, ByteBuf> delegate; @Inject public SimpleRouter(ProxyHandler proxyHandler, HealthCheckHandler healthCheckHandler, HostsHandler hostsHandler, PingHandler pingHandler, DynamicPropertiesHandler dynamicPropertiesHandler, StatusHandler statusHandler) { delegate = new SimpleUriRouter<>(); delegate.addUri(\"/healthcheck\", healthCheckHandler) .addUri(\"/dynamicproperties\", dynamicPropertiesHandler) .addUri(\"/proxy\", proxyHandler) .addUri(\"/eureka/hosts\", hostsHandler) .addUri(\"/ping\", pingHandler) .addUri(\"/status\", statusHandler); } @Override public Observable<Void> handle(HttpServerRequest<ByteBuf> request, HttpServerResponse<ByteBuf> response) { return delegate.handle(request, response); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/MainModule.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "MainModule configures bindings and constructs KaryonServer, handling multiple responsibilities. Changes to server setup or bindings would require modifying the same class."}, {"principle": "Open-Closed", "justification": "Extending KaryonServer configuration requires modifying providesKaryonSever method directly instead of via extension, violating OCP."}, {"principle": "Dependency Inversion", "justification": "MainModule directly depends on concrete Karyon*Suite and ArchaiusSuite implementations instead of abstractions, tying high-level setup to low-level details."}]}]}
{"project_id": 15, "chunk_id": 0, "prompt": {"main_file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/config/PranaConfig.java", "main_file_content": "package com.netflix.prana.config; import org.kohsuke.args4j.Option; public class PranaConfig { @Option(name = \"-p\", aliases = \"--http-port-api\", usage = \"Http Port of Prana Server\") private int httpPort = 8078; @Option(name = \"-a\", aliases = \"--app-name\", usage = \"Parent host application name\") private String appName = \"prana\"; @Option(name = \"-c\", aliases = \"--config\", usage = \"Prana configuration file\") private String configFile = \"prana.properties\"; public int getHttpPort() { return httpPort; } public String getAppName() { return appName; } public String getConfigFile() { return configFile; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/config/PranaConfig.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "Adding a new configuration parameter requires modifying the PranaConfig class by adding a new field, annotation, and getter, violating the requirement to be closed for modification."}, {"principle": "Dependency Inversion", "justification": "PranaConfig directly depends on the concrete org.kohsuke.args4j.Option class from a third-party library, violating the requirement for high-level modules to depend on abstractions."}]}]}
{"project_id": 15, "chunk_id": 0, "prompt": {"main_file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/internal/DefaultContext.java", "main_file_content": "package com.netflix.prana.internal; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.ObjectMapper; import com.netflix.prana.http.Context; import io.netty.buffer.ByteBuf; import io.netty.handler.codec.http.HttpResponseStatus; import io.reactivex.netty.protocol.http.server.HttpRequestHeaders; import io.reactivex.netty.protocol.http.server.HttpServerRequest; import io.reactivex.netty.protocol.http.server.HttpServerResponse; import rx.Observable; import javax.ws.rs.core.MediaType; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; public class DefaultContext implements Context { private static final String ULTIMATE_FAILURE_STRING = \"no content\"; private final HttpServerResponse<ByteBuf> response; private final HttpRequestHeaders requestHeaders; private final Map<String, List<String>> queryParameters; private final ObjectMapper objectMapper; public DefaultContext(HttpServerRequest<ByteBuf> request, HttpServerResponse<ByteBuf> response, ObjectMapper objectMapper) { this.response = response; this.requestHeaders = request.getHeaders(); this.queryParameters = request.getQueryParameters(); this.objectMapper = objectMapper; } @Override public String getHeader(String name) { return requestHeaders.getHeader(name); } @Override public void setHeader(String name, String value) { response.getHeaders().setHeader(name, value); } @Override public String getQueryParam(String key) { List<String> param = queryParameters.get(key); return (param != null && param.size() > 0) ? param.get(0) : null; } @Override public List<String> getQueryParams(String key) { List<String> param = queryParameters.get(key); return (param != null && param.size() > 0) ? param : new ArrayList<String>(); } @Override public Observable<Void> send(Object object) { return sendJson(object); } @Override public Observable<Void> sendSimple(String message) { setOk(); response.writeString(message); return response.close(); } @Override public Observable<Void> sendError(final HttpResponseStatus status, final String message) { Map<String, String> messageObject = new HashMap<String, String>() {{ put(\"reason\", status.reasonPhrase()); put(\"message\", message); }}; return sendJson(messageObject); } private void setOk() { response.setStatus(HttpResponseStatus.OK); } private Observable<Void> sendJson(Object object) { byte[] bytes = new byte[0]; try { setOk(); bytes = objectMapper.writeValueAsBytes(object); response.getHeaders().setHeader(\"Content-type\", MediaType.APPLICATION_JSON); } catch (JsonProcessingException e) { response.setStatus(HttpResponseStatus.INTERNAL_SERVER_ERROR); try { bytes = objectMapper.writeValueAsBytes(e); } catch (JsonProcessingException e1) { } } if (bytes.length > 0) { response.writeBytes(bytes); } else { response.writeString(ULTIMATE_FAILURE_STRING); } return response.close(); } }", "dependencies": [{"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/Context.java", "file_content": "package com.netflix.prana.http; import io.netty.handler.codec.http.HttpResponseStatus; import rx.Observable; import java.util.List; public interface Context { Observable<Void> send(Object object); Observable<Void> sendSimple(String message); Observable<Void> sendError(HttpResponseStatus status, String message); String getHeader(String name); void setHeader(String name, String value); String getQueryParam(String key); List<String> getQueryParams(String key); }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/internal/DefaultContext.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "DefaultContext handles multiple responsibilities: HTTP response management, JSON serialization, and error handling. Changes in serialization logic or HTTP handling would require modifying the same class."}, {"principle": "Open-Closed", "justification": "Adding new response types (e.g., XML) requires modifying sendJson or send methods. Private sendJson restricts extension without altering existing code."}, {"principle": "Dependency Inversion", "justification": "Depends directly on concrete Netty classes (HttpServerRequest/Response) and ObjectMapper. High-level context logic should depend on abstractions, not low-level implementations."}]}]}
{"project_id": 15, "chunk_id": 0, "prompt": {"main_file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/Context.java", "main_file_content": "package com.netflix.prana.http; import io.netty.handler.codec.http.HttpResponseStatus; import rx.Observable; import java.util.List; public interface Context { Observable<Void> send(Object object); Observable<Void> sendSimple(String message); Observable<Void> sendError(HttpResponseStatus status, String message); String getHeader(String name); void setHeader(String name, String value); String getQueryParam(String key); List<String> getQueryParams(String key); }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/Context.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Context interface handles multiple responsibilities: sending HTTP responses, managing headers, and retrieving query parameters. These should be separated into distinct interfaces to adhere to SRP."}, {"principle": "Interface Segregation", "justification": "Clients implementing Context must depend on all methods, even if they only need a subset (e.g., send methods without header/query param handling). This forces unnecessary method implementations, violating ISP."}]}]}
{"project_id": 15, "chunk_id": 0, "prompt": {"main_file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/service/EurekaHostService.java", "main_file_content": "package com.netflix.prana.service; import com.google.inject.Inject; import com.netflix.appinfo.InstanceInfo; import com.netflix.discovery.DiscoveryClient; import java.util.List; public class EurekaHostService implements HostService { private DiscoveryClient discoveryClient; @Inject public EurekaHostService(DiscoveryClient discoveryClient) { this.discoveryClient = discoveryClient; } @Override public List<InstanceInfo> getHosts(String appName) { return discoveryClient.getApplication(appName).getInstances(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/service/EurekaHostService.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "EurekaHostService directly depends on the concrete DiscoveryClient class. High-level modules should depend on abstractions, not concrete implementations."}]}]}
{"project_id": 15, "chunk_id": 0, "prompt": {"main_file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/service/HostService.java", "main_file_content": "package com.netflix.prana.service; import com.netflix.appinfo.InstanceInfo; import java.util.List; public interface HostService { List<InstanceInfo> getHosts(String appName); }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/service/HostService.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "HostService interface depends on concrete class InstanceInfo. High-level modules should depend on abstractions (e.g., an interface for InstanceInfo) rather than concrete implementations."}]}]}
{"project_id": 15, "chunk_id": 0, "prompt": {"main_file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/service/ServiceModule.java", "main_file_content": "package com.netflix.prana.service; import com.google.inject.AbstractModule; import com.google.inject.Scopes; public class ServiceModule extends AbstractModule { @Override protected void configure() { bind(HostService.class).to(EurekaHostService.class).in(Scopes.SINGLETON); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/service/ServiceModule.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "ServiceModule directly binds HostService to concrete EurekaHostService. High-level modules should depend on abstractions, not concrete implementations. If HostService is not an abstraction, this violates DIP."}]}]}
{"project_id": 15, "chunk_id": 0, "prompt": {"main_file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/api/HealthCheckHandler.java", "main_file_content": "package com.netflix.prana.http.api; import com.fasterxml.jackson.databind.ObjectMapper; import com.google.common.base.Strings; import com.netflix.config.DynamicProperty; import com.netflix.prana.http.Context; import io.netty.buffer.ByteBuf; import io.netty.channel.ChannelOption; import io.netty.handler.codec.http.HttpResponseStatus; import io.reactivex.netty.RxNetty; import io.reactivex.netty.pipeline.PipelineConfigurators; import io.reactivex.netty.protocol.http.client.HttpClient; import io.reactivex.netty.protocol.http.client.HttpClientRequest; import io.reactivex.netty.protocol.http.client.HttpClientResponse; import rx.Observable; import rx.exceptions.OnErrorThrowable; import rx.functions.Func1; import javax.inject.Inject; import java.net.MalformedURLException; import java.net.URL; public class HealthCheckHandler extends AbstractRequestHandler { private static final String DEFAULT_CONTENT_TYPE = \"application/xml\"; private static final Observable<Void> DEFAULT_NOOP_RESPONSE = Observable.just(null); public static final int DEFAULT_APPLICATION_PORT = 7101; public static final int DEFAULT_CONNECTION_TIMEOUT = 2000; public static final String DEFAULT_HEALTHCHECK_ENDPOINT = \"http: public static final String DEFAULT_OK_HEALTH = \"<health>ok</health>\"; public static final String DEFAULT_FAIL_HEALTH = \"<health>fail</health>\"; @Inject public HealthCheckHandler(ObjectMapper objectMapper) { super(objectMapper); } @Override Observable<Void> handle(final Context context) { String externalHealthCheckURL = DynamicProperty.getInstance(\"prana.host.healthcheck.url\") .getString(DEFAULT_HEALTHCHECK_ENDPOINT); context.setHeader(\"Content-type\", DEFAULT_CONTENT_TYPE); if (Strings.isNullOrEmpty(externalHealthCheckURL)) { return context.sendSimple(DEFAULT_OK_HEALTH); } else { return getResponse(externalHealthCheckURL).flatMap(new Func1<HttpClientResponse<ByteBuf>, Observable<Void>>() { @Override public Observable<Void> call(HttpClientResponse<ByteBuf> response) { if (response.getStatus().code() == HttpResponseStatus.OK.code()) { context.sendSimple(DEFAULT_OK_HEALTH); } else { context.sendError(HttpResponseStatus.SERVICE_UNAVAILABLE, DEFAULT_FAIL_HEALTH); } return DEFAULT_NOOP_RESPONSE; } }).onErrorFlatMap(new Func1<OnErrorThrowable, Observable<Void>>() { @Override public Observable<Void> call(OnErrorThrowable onErrorThrowable) { context.sendError(HttpResponseStatus.SERVICE_UNAVAILABLE, DEFAULT_FAIL_HEALTH); return DEFAULT_NOOP_RESPONSE; } }); } } private Observable<HttpClientResponse<ByteBuf>> getResponse(String externalHealthCheckURL) { String host = \"localhost\"; int port = DEFAULT_APPLICATION_PORT; String path = \"/healthcheck\"; try { URL url = new URL(externalHealthCheckURL); host = url.getHost(); port = url.getPort(); path = url.getPath(); } catch (MalformedURLException e) { } Integer timeout = DynamicProperty.getInstance(\"prana.host.healthcheck.timeout\").getInteger(DEFAULT_CONNECTION_TIMEOUT); HttpClient<ByteBuf, ByteBuf> httpClient = RxNetty.<ByteBuf, ByteBuf>newHttpClientBuilder(host, port) .pipelineConfigurator(PipelineConfigurators.<ByteBuf, ByteBuf>httpClientConfigurator()) .channelOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, timeout) .build(); return httpClient.submit(HttpClientRequest.createGet(path)); } }", "dependencies": [{"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/Context.java", "file_content": "package com.netflix.prana.http; import io.netty.handler.codec.http.HttpResponseStatus; import rx.Observable; import java.util.List; public interface Context { Observable<Void> send(Object object); Observable<Void> sendSimple(String message); Observable<Void> sendError(HttpResponseStatus status, String message); String getHeader(String name); void setHeader(String name, String value); String getQueryParam(String key); List<String> getQueryParams(String key); }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/api/HealthCheckHandler.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "HealthCheckHandler manages health check responses, configures HTTP clients, parses URLs, and handles dynamic properties. These multiple responsibilities indicate a Single Responsibility Principle violation."}, {"principle": "Open-Closed", "justification": "Adding new health check behaviors or response handling would require modifying existing methods (e.g., handle, getResponse), violating the Open/Closed Principle."}, {"principle": "Dependency Inversion", "justification": "HealthCheckHandler directly instantiates low-level HttpClient and depends on concrete DynamicProperty, instead of depending on abstractions, violating Dependency Inversion Principle."}]}]}
{"project_id": 15, "chunk_id": 0, "prompt": {"main_file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/api/HostsHandler.java", "main_file_content": "package com.netflix.prana.http.api; import com.fasterxml.jackson.databind.ObjectMapper; import com.google.common.base.Strings; import com.google.inject.Inject; import com.netflix.appinfo.InstanceInfo; import com.netflix.prana.http.Context; import com.netflix.prana.service.HostService; import io.netty.handler.codec.http.HttpResponseStatus; import rx.Observable; import java.util.ArrayList; import java.util.List; import static com.netflix.appinfo.InstanceInfo.InstanceStatus; public class HostsHandler extends AbstractRequestHandler { private final HostService hostService; @Inject public HostsHandler(HostService hostService, ObjectMapper objectMapper) { super(objectMapper); this.hostService = hostService; } @Override Observable<Void> handle(Context context) { String appName = context.getQueryParam(\"appName\"); String vip = context.getQueryParam(\"vip\"); if (Strings.isNullOrEmpty(appName)) { return context.sendError(HttpResponseStatus.BAD_REQUEST, \"appName has to be specified\"); } else { List<InstanceInfo> instances = hostService.getHosts(appName); List<String> hosts = new ArrayList<>(); for (InstanceInfo instanceInfo : instances) { if (vip != null && !instanceInfo.getVIPAddress().contains(vip) && instanceInfo.getStatus().equals(InstanceStatus.UP)) { continue; } hosts.add(instanceInfo.getHostName()); } return context.send(hosts); } } }", "dependencies": [{"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/Context.java", "file_content": "package com.netflix.prana.http; import io.netty.handler.codec.http.HttpResponseStatus; import rx.Observable; import java.util.List; public interface Context { Observable<Void> send(Object object); Observable<Void> sendSimple(String message); Observable<Void> sendError(HttpResponseStatus status, String message); String getHeader(String name); void setHeader(String name, String value); String getQueryParam(String key); List<String> getQueryParams(String key); }"}, {"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/service/HostService.java", "file_content": "package com.netflix.prana.service; import com.netflix.appinfo.InstanceInfo; import java.util.List; public interface HostService { List<InstanceInfo> getHosts(String appName); }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/api/HostsHandler.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "HostsHandler handles multiple responsibilities: processing HTTP requests, filtering instances based on VIP, and response construction. Changes to any of these aspects would require modifying the class."}, {"principle": "Open-Closed", "justification": "The filtering logic in handle() is hardcoded. Adding new filtering criteria requires modifying existing code instead of extending through new classes or strategies."}, {"principle": "Interface Segregation", "justification": "HostsHandler depends on the Context interface but only uses send(), sendError(), and getQueryParam(). Unused methods like sendSimple() and setHeader() force unnecessary dependencies."}]}]}
{"project_id": 15, "chunk_id": 0, "prompt": {"main_file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/api/StatusHandler.java", "main_file_content": "package com.netflix.prana.http.api; import com.fasterxml.jackson.databind.ObjectMapper; import com.netflix.appinfo.ApplicationInfoManager; import com.netflix.prana.http.Context; import rx.Observable; import javax.inject.Inject; import java.util.HashMap; import java.util.Map; public class StatusHandler extends AbstractRequestHandler { private final ApplicationInfoManager applicationInfoManager; @Inject public StatusHandler(ObjectMapper objectMapper, ApplicationInfoManager applicationInfoManager) { super(objectMapper); this.applicationInfoManager = applicationInfoManager; } @Override Observable<Void> handle(Context context) { Map<String, String> status = new HashMap<String, String>() {{ put(\"status\", applicationInfoManager.getInfo().getStatus().name()); }}; return context.send(status); } }", "dependencies": [{"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/Context.java", "file_content": "package com.netflix.prana.http; import io.netty.handler.codec.http.HttpResponseStatus; import rx.Observable; import java.util.List; public interface Context { Observable<Void> send(Object object); Observable<Void> sendSimple(String message); Observable<Void> sendError(HttpResponseStatus status, String message); String getHeader(String name); void setHeader(String name, String value); String getQueryParam(String key); List<String> getQueryParams(String key); }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/api/StatusHandler.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "High-level module StatusHandler directly depends on concrete classes ApplicationInfoManager and ObjectMapper instead of abstractions, violating DIP."}, {"principle": "Interface Segregation", "justification": "StatusHandler depends on the full Context interface but only uses the send method, forcing unnecessary dependency on unused methods."}]}]}
{"project_id": 15, "chunk_id": 0, "prompt": {"main_file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/api/ProxyHandler.java", "main_file_content": "package com.netflix.prana.http.api; import com.google.common.base.Strings; import com.netflix.client.config.IClientConfig; import com.netflix.client.config.IClientConfigKey; import com.netflix.config.DynamicProperty; import com.netflix.niws.loadbalancer.DiscoveryEnabledNIWSServerList; import com.netflix.ribbon.transport.netty.RibbonTransport; import com.netflix.ribbon.transport.netty.http.LoadBalancingHttpClient; import io.netty.buffer.ByteBuf; import io.reactivex.netty.protocol.http.client.HttpClientPipelineConfigurator; import io.reactivex.netty.protocol.http.client.HttpClientRequest; import io.reactivex.netty.protocol.http.client.HttpClientResponse; import io.reactivex.netty.protocol.http.server.HttpServerRequest; import io.reactivex.netty.protocol.http.server.HttpServerResponse; import io.reactivex.netty.protocol.http.server.RequestHandler; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import rx.Observable; import rx.functions.Action0; import rx.functions.Action1; import rx.functions.Func1; import java.util.List; import java.util.Map; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; public class ProxyHandler implements RequestHandler<ByteBuf, ByteBuf> { private static final ConcurrentHashMap<String, LoadBalancingHttpClient<ByteBuf, ByteBuf>> httpClients = new ConcurrentHashMap<>(); private final String PROXY_REQ_ACCEPT_ENCODING = DynamicProperty.getInstance(\"prana.proxy.req.acceptencoding\").getString(\"deflate, gzip\"); private Logger logger = LoggerFactory.getLogger(getClass().getName()); private final String ERROR_RESPONSE = \"<status><status_code>500</status_code><message>Error forwarding request to origin</message></status>\"; @Override public Observable<Void> handle(final HttpServerRequest<ByteBuf> serverRequest, final HttpServerResponse<ByteBuf> serverResponse) { String vip = Utils.forQueryParam(serverRequest.getQueryParameters(), \"vip\"); String path = Utils.forQueryParam(serverRequest.getQueryParameters(), \"path\"); if (Strings.isNullOrEmpty(vip)) { serverResponse.getHeaders().set(\"Content-Type\", \"application/xml\"); serverResponse.writeString(ERROR_RESPONSE); logger.error(\"VIP is empty\"); return serverResponse.close(); } if (path == null) { path = \"\"; } final LoadBalancingHttpClient<ByteBuf, ByteBuf> client = getClient(vip); final HttpClientRequest<ByteBuf> req = HttpClientRequest.create(serverRequest.getHttpMethod(), path); populateRequestHeaders(serverRequest, req); final UnicastDisposableCachingSubject<ByteBuf> cachedContent = UnicastDisposableCachingSubject.create(); serverRequest.getContent().map(new Func1<ByteBuf, ByteBuf>() { @Override public ByteBuf call(ByteBuf byteBuf) { return byteBuf.retain(); } }).subscribe(cachedContent); req.withContentSource(cachedContent); return client.submit(req).flatMap(new Func1<HttpClientResponse<ByteBuf>, Observable<Void>>() { @Override public Observable<Void> call(final HttpClientResponse<ByteBuf> response) { serverResponse.setStatus(response.getStatus()); List<Map.Entry<String, String>> headers = response.getHeaders().entries(); for (Map.Entry<String, String> header : headers) { serverResponse.getHeaders().add(header.getKey(), header.getValue()); } return response.getContent().map(new Func1<ByteBuf, ByteBuf>() { @Override public ByteBuf call(ByteBuf byteBuf) { return byteBuf.retain(); } }).map(new Func1<ByteBuf, Void>() { @Override public Void call(ByteBuf byteBuf) { serverResponse.write(byteBuf); return null; } }); } }).onErrorResumeNext(new Func1<Throwable, Observable<Void>>() { @Override public Observable<Void> call(Throwable throwable) { serverResponse.getHeaders().set(\"Content-Type\", \"application/xml\"); serverResponse.writeString(ERROR_RESPONSE); return Observable.just(null); } }).doOnCompleted(new Action0() { @Override public void call() { serverResponse.close(); cachedContent.dispose(new Action1<ByteBuf>() { @Override public void call(ByteBuf byteBuf) { if (byteBuf.refCnt() > 1) { byteBuf.release(); } } }); } }); } private void populateRequestHeaders(HttpServerRequest<ByteBuf> serverRequest, HttpClientRequest<ByteBuf> request) { Set<String> headerNames = serverRequest.getHeaders().names(); for (String name : headerNames) { if (name.contains(\"content-length\")) { continue; } request.getHeaders().add(name, serverRequest.getHeaders().getHeader(name)); } if (PROXY_REQ_ACCEPT_ENCODING != null && PROXY_REQ_ACCEPT_ENCODING.length() > 0) { request.getHeaders().addHeader(\"accept-encoding\", PROXY_REQ_ACCEPT_ENCODING); } } private LoadBalancingHttpClient<ByteBuf, ByteBuf> getClient(String vip) { LoadBalancingHttpClient<ByteBuf, ByteBuf> client = httpClients.get(vip); if (client == null) { IClientConfig config = IClientConfig.Builder.newBuilder(\"prana_backend\"). withDefaultValues(). withDeploymentContextBasedVipAddresses(vip). build(). set(IClientConfigKey.Keys.MaxTotalConnections, 2000). set(IClientConfigKey.Keys.MaxConnectionsPerHost, 2000). set(IClientConfigKey.Keys.OkToRetryOnAllOperations, false). set(IClientConfigKey.Keys.NIWSServerListClassName, DiscoveryEnabledNIWSServerList.class.getName()); client = RibbonTransport.newHttpClient(new HttpClientPipelineConfigurator<ByteBuf, ByteBuf>(), config); httpClients.putIfAbsent(vip, client); } return client; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/api/ProxyHandler.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "ProxyHandler manages HTTP client creation, request handling, header population, error responses, and response forwarding, indicating multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Adding new client creation logic or request processing steps requires modifying ProxyHandler directly, as there are no extension points via abstractions."}, {"principle": "Dependency Inversion", "justification": "ProxyHandler directly instantiates RibbonTransport and LoadBalancingHttpClient, depending on concrete implementations instead of abstractions for high-level HTTP client management."}]}]}
{"project_id": 15, "chunk_id": 0, "prompt": {"main_file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/api/HandlersModule.java", "main_file_content": "package com.netflix.prana.http.api; import com.google.inject.AbstractModule; import com.google.inject.Scopes; public class HandlersModule extends AbstractModule { @Override protected void configure() { bind(StatusHandler.class).in(Scopes.SINGLETON); bind(SimpleRouter.class).in(Scopes.SINGLETON); bind(ProxyHandler.class).in(Scopes.SINGLETON); bind(HealthCheckHandler.class).in(Scopes.SINGLETON); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/api/HandlersModule.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "The HandlersModule's configure method directly binds concrete classes. Adding new handlers requires modifying existing code instead of extending through new modules, violating the Open/Closed Principle."}]}]}
{"project_id": 15, "chunk_id": 0, "prompt": {"main_file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/api/NIWSCommand.java", "main_file_content": "package com.netflix.prana.http.api; import com.netflix.hystrix.HystrixCommandProperties; import com.netflix.ribbon.transport.netty.http.LoadBalancingHttpClient; import com.netflix.hystrix.HystrixCommandGroupKey; import com.netflix.hystrix.HystrixCommandKey; import com.netflix.hystrix.HystrixObservableCommand; import io.netty.buffer.ByteBuf; import io.reactivex.netty.protocol.http.client.HttpClientRequest; import io.reactivex.netty.protocol.http.client.HttpClientResponse; import rx.Observable; public class NIWSCommand extends HystrixObservableCommand<HttpClientResponse<ByteBuf>> { private final LoadBalancingHttpClient<ByteBuf, ByteBuf> httpClient; private final HttpClientRequest<ByteBuf> req; protected NIWSCommand(LoadBalancingHttpClient<ByteBuf, ByteBuf> httpClient, HttpClientRequest<ByteBuf> req, HystrixCommandKey key) { super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(\"prana\")).andCommandKey(key). andCommandPropertiesDefaults(HystrixCommandProperties.Setter(). withExecutionIsolationThreadTimeoutInMilliseconds(10000). withRequestCacheEnabled(false). withExecutionIsolationSemaphoreMaxConcurrentRequests(1000). withCircuitBreakerEnabled(false))); this.httpClient = httpClient; this.req = req; } @Override protected Observable<HttpClientResponse<ByteBuf>> run() { return httpClient.submit(req); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/api/NIWSCommand.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "NIWSCommand directly depends on concrete implementation LoadBalancingHttpClient. High-level modules should depend on abstractions rather than low-level concrete classes."}]}]}
{"project_id": 15, "chunk_id": 0, "prompt": {"main_file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/api/Utils.java", "main_file_content": "package com.netflix.prana.http.api; import java.util.List; import java.util.Map; public class Utils { public static String forQueryParam(Map<String, List<String>> queryParams, String paramName) { List<String> values = queryParams.get(paramName); if (values != null) { return values.get(0); } return null; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 15, "chunk_id": 0, "prompt": {"main_file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/api/PingHandler.java", "main_file_content": "package com.netflix.prana.http.api; import com.fasterxml.jackson.databind.ObjectMapper; import com.netflix.prana.http.Context; import rx.Observable; import javax.inject.Inject; public class PingHandler extends AbstractRequestHandler { private static final String CACHE_CONTROL_HEADER = \"Cache-Control\"; private static final String CACHE_CONTROL_HEADER_VAL = \"must-revalidate,no-cache,no-store\"; private static final String DEFAULT_PONG_RESPONSE = \"pong\"; @Inject public PingHandler(ObjectMapper objectMapper) { super(objectMapper); } @Override Observable<Void> handle(Context context) { context.setHeader(CACHE_CONTROL_HEADER, CACHE_CONTROL_HEADER_VAL); return context.sendSimple(DEFAULT_PONG_RESPONSE); } }", "dependencies": [{"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/Context.java", "file_content": "package com.netflix.prana.http; import io.netty.handler.codec.http.HttpResponseStatus; import rx.Observable; import java.util.List; public interface Context { Observable<Void> send(Object object); Observable<Void> sendSimple(String message); Observable<Void> sendError(HttpResponseStatus status, String message); String getHeader(String name); void setHeader(String name, String value); String getQueryParam(String key); List<String> getQueryParams(String key); }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/api/PingHandler.java", "violatedPrinciples": [{"principle": "Interface Segregation", "justification": "PingHandler depends on the Context interface but only uses setHeader and sendSimple, while Context defines additional unused methods (send, sendError, getHeader, getQueryParam, getQueryParams). Clients should not depend on interfaces with methods they don't use."}, {"principle": "Dependency Inversion", "justification": "PingHandler directly depends on the concrete ObjectMapper class instead of an abstraction. High-level modules should depend on abstractions, not concrete implementations (excluding built-in classes)."}]}]}
{"project_id": 15, "chunk_id": 0, "prompt": {"main_file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/api/AbstractRequestHandler.java", "main_file_content": "package com.netflix.prana.http.api; import com.fasterxml.jackson.databind.ObjectMapper; import com.netflix.prana.http.Context; import com.netflix.prana.internal.DefaultContext; import io.netty.buffer.ByteBuf; import io.reactivex.netty.protocol.http.server.HttpServerRequest; import io.reactivex.netty.protocol.http.server.HttpServerResponse; import io.reactivex.netty.protocol.http.server.RequestHandler; import rx.Observable; public abstract class AbstractRequestHandler implements RequestHandler<ByteBuf, ByteBuf> { private final ObjectMapper objectMapper; protected AbstractRequestHandler(ObjectMapper objectMapper) { this.objectMapper = objectMapper; } abstract Observable<Void> handle(Context context); @Override public Observable<Void> handle(HttpServerRequest<ByteBuf> request, final HttpServerResponse<ByteBuf> response) { DefaultContext context = new DefaultContext(request, response, objectMapper); return handle(context); } }", "dependencies": [{"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/Context.java", "file_content": "package com.netflix.prana.http; import io.netty.handler.codec.http.HttpResponseStatus; import rx.Observable; import java.util.List; public interface Context { Observable<Void> send(Object object); Observable<Void> sendSimple(String message); Observable<Void> sendError(HttpResponseStatus status, String message); String getHeader(String name); void setHeader(String name, String value); String getQueryParam(String key); List<String> getQueryParams(String key); }"}, {"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/internal/DefaultContext.java", "file_content": "package com.netflix.prana.internal; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.ObjectMapper; import com.netflix.prana.http.Context; import io.netty.buffer.ByteBuf; import io.netty.handler.codec.http.HttpResponseStatus; import io.reactivex.netty.protocol.http.server.HttpRequestHeaders; import io.reactivex.netty.protocol.http.server.HttpServerRequest; import io.reactivex.netty.protocol.http.server.HttpServerResponse; import rx.Observable; import javax.ws.rs.core.MediaType; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; public class DefaultContext implements Context { private static final String ULTIMATE_FAILURE_STRING = \"no content\"; private final HttpServerResponse<ByteBuf> response; private final HttpRequestHeaders requestHeaders; private final Map<String, List<String>> queryParameters; private final ObjectMapper objectMapper; public DefaultContext(HttpServerRequest<ByteBuf> request, HttpServerResponse<ByteBuf> response, ObjectMapper objectMapper) { this.response = response; this.requestHeaders = request.getHeaders(); this.queryParameters = request.getQueryParameters(); this.objectMapper = objectMapper; } @Override public String getHeader(String name) { return requestHeaders.getHeader(name); } @Override public void setHeader(String name, String value) { response.getHeaders().setHeader(name, value); } @Override public String getQueryParam(String key) { List<String> param = queryParameters.get(key); return (param != null && param.size() > 0) ? param.get(0) : null; } @Override public List<String> getQueryParams(String key) { List<String> param = queryParameters.get(key); return (param != null && param.size() > 0) ? param : new ArrayList<String>(); } @Override public Observable<Void> send(Object object) { return sendJson(object); } @Override public Observable<Void> sendSimple(String message) { setOk(); response.writeString(message); return response.close(); } @Override public Observable<Void> sendError(final HttpResponseStatus status, final String message) { Map<String, String> messageObject = new HashMap<String, String>() {{ put(\"reason\", status.reasonPhrase()); put(\"message\", message); }}; return sendJson(messageObject); } private void setOk() { response.setStatus(HttpResponseStatus.OK); } private Observable<Void> sendJson(Object object) { byte[] bytes = new byte[0]; try { setOk(); bytes = objectMapper.writeValueAsBytes(object); response.getHeaders().setHeader(\"Content-type\", MediaType.APPLICATION_JSON); } catch (JsonProcessingException e) { response.setStatus(HttpResponseStatus.INTERNAL_SERVER_ERROR); try { bytes = objectMapper.writeValueAsBytes(e); } catch (JsonProcessingException e1) { } } if (bytes.length > 0) { response.writeBytes(bytes); } else { response.writeString(ULTIMATE_FAILURE_STRING); } return response.close(); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/api/AbstractRequestHandler.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "AbstractRequestHandler directly instantiates DefaultContext (concrete class) and depends on ObjectMapper (concrete) in constructor, violating dependence on abstractions."}]}, {"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/Context.java", "violatedPrinciples": [{"principle": "Interface Segregation", "justification": "Context interface has multiple methods (e.g., send, sendError, header methods), forcing clients to implement unused functionality."}]}]}
{"project_id": 15, "chunk_id": 0, "prompt": {"main_file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/api/UnicastDisposableCachingSubject.java", "main_file_content": "package com.netflix.prana.http.api; import io.netty.util.ReferenceCountUtil; import io.netty.util.ReferenceCounted; import rx.Observer; import rx.Subscriber; import rx.functions.Action0; import rx.functions.Action1; import rx.internal.operators.NotificationLite; import rx.observers.Subscribers; import rx.subjects.Subject; import rx.subscriptions.Subscriptions; import java.util.concurrent.ConcurrentLinkedQueue; import java.util.concurrent.atomic.AtomicIntegerFieldUpdater; import java.util.concurrent.atomic.AtomicReferenceFieldUpdater; final class UnicastDisposableCachingSubject<T extends ReferenceCounted> extends Subject<T, T> { private final State<T> state; private UnicastDisposableCachingSubject(State<T> state) { super(new OnSubscribeAction<>(state)); this.state = state; } public static <T extends ReferenceCounted> UnicastDisposableCachingSubject<T> create() { State<T> state = new State<>(); return new UnicastDisposableCachingSubject<>(state); } public void dispose(Action1<T> disposedElementsProcessor) { if (state.casState(State.STATES.UNSUBSCRIBED, State.STATES.DISPOSED)) { _dispose(disposedElementsProcessor); } else if (state.casState(State.STATES.SUBSCRIBED, State.STATES.DISPOSED)) { state.observerRef.onCompleted(); _dispose(disposedElementsProcessor); } } private void _dispose(Action1<T> disposedElementsProcessor) { Subscriber<T> noOpSub = new PassThruObserver<>(Subscribers.create(disposedElementsProcessor, new Action1<Throwable>() { @Override public void call(Throwable throwable) { } }), state); state.buffer.sendAllNotifications(noOpSub); state.setObserverRef(noOpSub); } private static final class State<T> { private enum STATES { UNSUBSCRIBED , SUBSCRIBED , DISPOSED } private volatile int state = STATES.UNSUBSCRIBED.ordinal(); private volatile Observer<? super T> observerRef = new BufferedObserver(); private final ByteBufAwareBuffer<T> buffer = new ByteBufAwareBuffer<>(); @SuppressWarnings(\"rawtypes\") private static final AtomicReferenceFieldUpdater<State, Observer> OBSERVER_UPDATER = AtomicReferenceFieldUpdater.newUpdater(State.class, Observer.class, \"observerRef\"); @SuppressWarnings(\"rawtypes\") private static final AtomicIntegerFieldUpdater<State> STATE_UPDATER = AtomicIntegerFieldUpdater.newUpdater(State.class, \"state\"); public boolean casState(STATES expected, STATES next) { return STATE_UPDATER.compareAndSet(this, expected.ordinal(), next.ordinal()); } public void setObserverRef(Observer<? super T> o) { observerRef = o; } public boolean casObserverRef(Observer<? super T> expected, Observer<? super T> next) { return OBSERVER_UPDATER.compareAndSet(this, expected, next); } private final class BufferedObserver extends Subscriber<T> { private final NotificationLite<Object> nl = NotificationLite.instance(); @Override public void onCompleted() { buffer.add(nl.completed()); } @Override public void onError(Throwable e) { buffer.add(nl.error(e)); } @Override public void onNext(T t) { buffer.add(nl.next(t)); } } } private static final class OnSubscribeAction<T> implements OnSubscribe<T> { private final State<T> state; public OnSubscribeAction(State<T> state) { this.state = state; } @Override public void call(final Subscriber<? super T> subscriber) { if (state.casState(State.STATES.UNSUBSCRIBED, State.STATES.SUBSCRIBED)) { state.buffer.sendAllNotifications(subscriber); state.setObserverRef(new PassThruObserver<>(subscriber, state)); subscriber.add(Subscriptions.create(new Action0() { @Override public void call() { state.setObserverRef(Subscribers.empty()); } })); } else if (State.STATES.SUBSCRIBED.ordinal() == state.state) { subscriber.onError(new IllegalStateException(\"Content can only have one subscription. Use Observable.publish() if you want to multicast.\")); } else if (State.STATES.DISPOSED.ordinal() == state.state) { subscriber.onError(new IllegalStateException(\"Content stream is already disposed.\")); } } } @Override public void onCompleted() { state.observerRef.onCompleted(); } @Override public void onError(Throwable e) { state.observerRef.onError(e); } @Override public void onNext(T t) { state.observerRef.onNext(t); } private static final class PassThruObserver<T> extends Subscriber<T> { private final Observer<? super T> actual; private final ByteBufAwareBuffer<T> buffer; private final State<T> state; PassThruObserver(Observer<? super T> actual, State<T> state) { this.actual = actual; buffer = state.buffer; this.state = state; } @Override public void onCompleted() { drainIfNeededAndSwitchToActual(); actual.onCompleted(); } @Override public void onError(Throwable e) { drainIfNeededAndSwitchToActual(); actual.onError(e); } @Override public void onNext(T t) { drainIfNeededAndSwitchToActual(); actual.onNext(t); } private void drainIfNeededAndSwitchToActual() { buffer.sendAllNotifications(this); state.casObserverRef(this, actual); } } private static final class ByteBufAwareBuffer<T> { private final ConcurrentLinkedQueue<Object> actual = new ConcurrentLinkedQueue<>(); private final NotificationLite<T> nl = NotificationLite.instance(); private void add(Object toAdd) { ReferenceCountUtil.retain(toAdd); actual.add(toAdd); } public void sendAllNotifications(Subscriber<? super T> subscriber) { Object notification; while ((notification = actual.poll()) != null) { try { nl.accept(subscriber, notification); } finally { ReferenceCountUtil.release(notification); } } } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/api/UnicastDisposableCachingSubject.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "UnicastDisposableCachingSubject manages state transitions, caching, disposal logic, and Subject behavior, indicating multiple responsibilities. The State inner class also handles buffering, observer management, and state transitions."}, {"principle": "Open-Closed", "justification": "The class is declared final, preventing extension without modifying its code. This directly violates OCP, as new behavior cannot be added via inheritance."}, {"principle": "Dependency Inversion", "justification": "High-level modules like UnicastDisposableCachingSubject directly depend on concrete low-level classes such as State and ByteBufAwareBuffer instead of abstractions, creating tight coupling."}]}]}
{"project_id": 15, "chunk_id": 0, "prompt": {"main_file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/api/DynamicPropertiesHandler.java", "main_file_content": "package com.netflix.prana.http.api; import com.fasterxml.jackson.databind.ObjectMapper; import com.netflix.config.DynamicProperty; import com.netflix.prana.http.Context; import rx.Observable; import javax.inject.Inject; import java.util.HashMap; import java.util.List; import java.util.Map; public class DynamicPropertiesHandler extends AbstractRequestHandler { private static final String ID_QUERY_PARAMETER = \"id\"; @Inject public DynamicPropertiesHandler(ObjectMapper objectMapper) { super(objectMapper); } @Override Observable<Void> handle(Context context) { Map<String, String> properties = new HashMap<>(); List<String> ids = context.getQueryParams(ID_QUERY_PARAMETER); for (String id : ids) { String property = DynamicProperty.getInstance(id).getString(null); properties.put(id, property); } return context.send(properties); } }", "dependencies": [{"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/Context.java", "file_content": "package com.netflix.prana.http; import io.netty.handler.codec.http.HttpResponseStatus; import rx.Observable; import java.util.List; public interface Context { Observable<Void> send(Object object); Observable<Void> sendSimple(String message); Observable<Void> sendError(HttpResponseStatus status, String message); String getHeader(String name); void setHeader(String name, String value); String getQueryParam(String key); List<String> getQueryParams(String key); }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/api/DynamicPropertiesHandler.java", "violatedPrinciples": [{"principle": "Interface Segregation", "justification": "DynamicPropertiesHandler depends on the full Context interface but only uses send() and getQueryParams(). Clients should not depend on unused methods like sendError() or getHeader()."}, {"principle": "Dependency Inversion", "justification": "High-level module DynamicPropertiesHandler directly depends on concrete classes ObjectMapper (constructor-injected) and DynamicProperty (via getInstance()), instead of abstractions."}]}]}
{"project_id": 15, "chunk_id": 0, "prompt": {"main_file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/api/SimpleRouter.java", "main_file_content": "package com.netflix.prana.http.api; import com.google.inject.Inject; import com.netflix.karyon.transport.http.SimpleUriRouter; import io.netty.buffer.ByteBuf; import io.reactivex.netty.protocol.http.server.HttpServerRequest; import io.reactivex.netty.protocol.http.server.HttpServerResponse; import io.reactivex.netty.protocol.http.server.RequestHandler; import rx.Observable; public class SimpleRouter implements RequestHandler<ByteBuf, ByteBuf> { private final SimpleUriRouter<ByteBuf, ByteBuf> delegate; @Inject public SimpleRouter(ProxyHandler proxyHandler, HealthCheckHandler healthCheckHandler, HostsHandler hostsHandler, PingHandler pingHandler, DynamicPropertiesHandler dynamicPropertiesHandler, StatusHandler statusHandler) { delegate = new SimpleUriRouter<>(); delegate.addUri(\"/healthcheck\", healthCheckHandler) .addUri(\"/dynamicproperties\", dynamicPropertiesHandler) .addUri(\"/proxy\", proxyHandler) .addUri(\"/eureka/hosts\", hostsHandler) .addUri(\"/ping\", pingHandler) .addUri(\"/status\", statusHandler); } @Override public Observable<Void> handle(HttpServerRequest<ByteBuf> request, HttpServerResponse<ByteBuf> response) { return delegate.handle(request, response); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/http/api/SimpleRouter.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "Adding new routes requires modifying the SimpleRouter constructor, violating OCP as the class is not closed for modification."}, {"principle": "Dependency Inversion", "justification": "High-level SimpleRouter directly depends on concrete handler implementations instead of abstractions, violating DIP."}]}]}
{"project_id": 15, "chunk_id": 0, "prompt": {"main_file_path": "Prana-master/Prana-master/src/test/java/com/netflix/prana/http/api/TestUtils.java", "main_file_content": "package com.netflix.prana.http.api; import io.netty.buffer.ByteBuf; import io.reactivex.netty.protocol.http.client.HttpClient; import io.reactivex.netty.protocol.http.client.HttpClientRequest; import io.reactivex.netty.protocol.http.client.HttpClientResponse; import rx.Observable; import rx.exceptions.OnErrorThrowable; import rx.functions.Func1; import java.nio.charset.Charset; public class TestUtils { public static String getResponse(HttpClientRequest<ByteBuf> request, HttpClient<ByteBuf, ByteBuf> client) { return client.submit(request).flatMap(new Func1<HttpClientResponse<ByteBuf>, Observable<String>>() { @Override public Observable<String> call(HttpClientResponse<ByteBuf> response) { return response.getContent().map(new Func1<ByteBuf, String>() { @Override public String call(ByteBuf byteBuf) { return byteBuf.toString(Charset.defaultCharset()); } }); } }).onErrorFlatMap(new Func1<OnErrorThrowable, Observable<String>>() { @Override public Observable<String> call(OnErrorThrowable onErrorThrowable) { throw onErrorThrowable; } }).toBlocking().first(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Prana-master/Prana-master/src/test/java/com/netflix/prana/http/api/TestUtils.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "TestUtils directly depends on concrete HttpClientRequest and HttpClient classes instead of abstractions. High-level modules should depend on abstractions, not low-level implementations."}]}]}
{"project_id": 15, "chunk_id": 0, "prompt": {"main_file_path": "Prana-master/Prana-master/src/test/java/com/netflix/prana/http/api/AbstractIntegrationTest.java", "main_file_content": "package com.netflix.prana.http.api; import com.fasterxml.jackson.databind.ObjectMapper; import io.netty.buffer.ByteBuf; import io.netty.channel.ChannelOption; import io.reactivex.netty.RxNetty; import io.reactivex.netty.pipeline.PipelineConfigurators; import io.reactivex.netty.protocol.http.client.HttpClient; import io.reactivex.netty.protocol.http.server.HttpServer; import io.reactivex.netty.protocol.http.server.RequestHandler; import org.junit.After; import org.junit.Before; public abstract class AbstractIntegrationTest { protected ObjectMapper objectMapper = new ObjectMapper(); protected HttpServer<ByteBuf, ByteBuf> server; protected HttpClient<ByteBuf, ByteBuf> client; protected abstract RequestHandler<ByteBuf, ByteBuf> getHandler(); @Before public void setUp() { server = RxNetty.newHttpServerBuilder(0, getHandler()) .pipelineConfigurator(PipelineConfigurators.<ByteBuf, ByteBuf>httpServerConfigurator()).build(); server.start(); client = RxNetty.<ByteBuf, ByteBuf>newHttpClientBuilder(\"localhost\", server.getServerPort()) .pipelineConfigurator(PipelineConfigurators.<ByteBuf, ByteBuf>httpClientConfigurator()) .channelOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 2000) .build(); } @After public void tearDown() throws InterruptedException { server.shutdown(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Prana-master/Prana-master/src/test/java/com/netflix/prana/http/api/AbstractIntegrationTest.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "AbstractIntegrationTest directly depends on concrete RxNetty HttpServer and HttpClient implementations instead of abstractions. High-level test classes should depend on interfaces, not low-level modules."}]}]}
{"project_id": 15, "chunk_id": 0, "prompt": {"main_file_path": "Prana-master/Prana-master/src/test/java/com/netflix/prana/http/api/HostsHandlerTest.java", "main_file_content": "package com.netflix.prana.http.api; import com.fasterxml.jackson.databind.ObjectMapper; import com.netflix.appinfo.InstanceInfo; import com.netflix.prana.service.HostService; import io.netty.buffer.ByteBuf; import io.reactivex.netty.protocol.http.client.HttpClientRequest; import io.reactivex.netty.protocol.http.server.RequestHandler; import org.junit.Assert; import org.junit.Test; import java.util.ArrayList; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.when; public class HostsHandlerTest extends AbstractIntegrationTest { private HostService hostService = mock(HostService.class); @Override protected RequestHandler<ByteBuf, ByteBuf> getHandler() { ArrayList<InstanceInfo> instanceInfos = new ArrayList<>(); instanceInfos.add(InstanceInfo.Builder.newBuilder().setAppName(\"foo\").setVIPAddress(\"bar\").setHostName(\"host1\").build()); instanceInfos.add(InstanceInfo.Builder.newBuilder().setAppName(\"foo\").setVIPAddress(\"bar\").setHostName(\"host2\").build()); when(hostService.getHosts(\"foo\")).thenReturn(instanceInfos); return new HostsHandler(hostService, new ObjectMapper()); } @Test public void shouldReturnAListOfHostsWhenBothVipAndAppIsSpecified() { HttpClientRequest<ByteBuf> request = HttpClientRequest.<ByteBuf>createGet(\"/hosts?appName=foo&vip=bar\"); String response = TestUtils.getResponse(request, client); Assert.assertEquals(\"[\\\"host1\\\",\\\"host2\\\"]\", response); } }", "dependencies": [{"file_path": "Prana-master/Prana-master/src/main/java/com/netflix/prana/service/HostService.java", "file_content": "package com.netflix.prana.service; import com.netflix.appinfo.InstanceInfo; import java.util.List; public interface HostService { List<InstanceInfo> getHosts(String appName); }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 15, "chunk_id": 0, "prompt": {"main_file_path": "Prana-master/Prana-master/src/test/java/com/netflix/prana/http/api/PingHandlerTest.java", "main_file_content": "package com.netflix.prana.http.api; import io.netty.buffer.ByteBuf; import io.reactivex.netty.protocol.http.client.HttpClientRequest; import io.reactivex.netty.protocol.http.server.RequestHandler; import org.junit.Test; import static org.junit.Assert.assertEquals; public class PingHandlerTest extends AbstractIntegrationTest { @Test public void shouldRespondWithPong() { HttpClientRequest<ByteBuf> request = HttpClientRequest.<ByteBuf>createGet(\"/ping\"); assertEquals(\"pong\", TestUtils.getResponse(request, client)); } @Override protected RequestHandler<ByteBuf, ByteBuf> getHandler() { return new PingHandler(objectMapper); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 15, "chunk_id": 0, "prompt": {"main_file_path": "Prana-master/Prana-master/src/test/java/com/netflix/prana/http/api/DynamicPropertiesHandlerTest.java", "main_file_content": "package com.netflix.prana.http.api; import com.netflix.config.ConfigurationManager; import io.netty.buffer.ByteBuf; import io.reactivex.netty.protocol.http.client.HttpClientRequest; import io.reactivex.netty.protocol.http.server.RequestHandler; import org.junit.Test; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertTrue; public class DynamicPropertiesHandlerTest extends AbstractIntegrationTest { @Test public void shouldReturnListOfProperties() { ConfigurationManager.getConfigInstance().setProperty(\"foo\", \"bar\"); ConfigurationManager.getConfigInstance().setProperty(\"lol\", 10); HttpClientRequest<ByteBuf> request = HttpClientRequest.<ByteBuf>createGet(\"/dynamicproperties?id=foo&id=lol\"); String response = TestUtils.getResponse(request, client); assertTrue(response.contains(\"\\\"lol\\\":\\\"10\\\"\")); assertTrue(response.contains(\"\\\"foo\\\":\\\"bar\\\"\")); } @Test public void shouldReturnNullForUnknownProperties() { HttpClientRequest<ByteBuf> request = HttpClientRequest.<ByteBuf>createGet(\"/dynamicproperties?id=bar\"); assertEquals(\"{\\\"bar\\\":null}\", TestUtils.getResponse(request, client)); } @Override protected RequestHandler<ByteBuf, ByteBuf> getHandler() { return new DynamicPropertiesHandler(objectMapper); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Prana-master/Prana-master/src/test/java/com/netflix/prana/http/api/DynamicPropertiesHandlerTest.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "DynamicPropertiesHandler is directly instantiated with a concrete objectMapper dependency instead of depending on an abstraction. High-level test class depends on concrete implementation details rather than abstractions."}]}]}
{"project_id": 15, "chunk_id": 0, "prompt": {"main_file_path": "Prana-master/Prana-master/src/test/java/com/netflix/prana/http/api/StatusHandlerTest.java", "main_file_content": "package com.netflix.prana.http.api; import com.netflix.appinfo.ApplicationInfoManager; import com.netflix.appinfo.InstanceInfo; import io.netty.buffer.ByteBuf; import io.reactivex.netty.protocol.http.client.HttpClientRequest; import io.reactivex.netty.protocol.http.server.RequestHandler; import org.junit.Test; import static org.junit.Assert.assertTrue; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.when; public class StatusHandlerTest extends AbstractIntegrationTest { private ApplicationInfoManager applicationInfoManager = mock(ApplicationInfoManager.class); @Override protected RequestHandler<ByteBuf, ByteBuf> getHandler() { return new StatusHandler(objectMapper, applicationInfoManager); } @Test public void shouldReturnDiscoveryStatus() { InstanceInfo outOfService = InstanceInfo.Builder.newBuilder() .setAppName(\"foo\") .setStatus(InstanceInfo.InstanceStatus.OUT_OF_SERVICE).build(); when(applicationInfoManager.getInfo()).thenReturn(outOfService); HttpClientRequest<ByteBuf> request = HttpClientRequest.<ByteBuf>createGet(\"/status\"); String response = TestUtils.getResponse(request, client); assertTrue(response.contains(\"\\\"status\\\":\\\"OUT_OF_SERVICE\\\"\")); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Prana-master/Prana-master/src/test/java/com/netflix/prana/http/api/StatusHandlerTest.java", "violatedPrinciples": []}]}
{"project_id": 15, "chunk_id": 0, "prompt": {"main_file_path": "Prana-master/Prana-master/src/test/java/com/netflix/prana/http/api/HealthCheckHandlerTest.java", "main_file_content": "package com.netflix.prana.http.api; import com.netflix.config.ConfigurationManager; import io.netty.buffer.ByteBuf; import io.netty.handler.codec.http.HttpResponseStatus; import io.reactivex.netty.RxNetty; import io.reactivex.netty.pipeline.PipelineConfigurators; import io.reactivex.netty.protocol.http.client.HttpClientRequest; import io.reactivex.netty.protocol.http.server.HttpServer; import io.reactivex.netty.protocol.http.server.HttpServerRequest; import io.reactivex.netty.protocol.http.server.HttpServerResponse; import io.reactivex.netty.protocol.http.server.RequestHandler; import org.junit.After; import org.junit.Assert; import org.junit.Before; import org.junit.Test; import rx.Observable; public class HealthCheckHandlerTest extends AbstractIntegrationTest { private HttpServer<ByteBuf, ByteBuf> externalServer; private int externalServerPort; @Override protected RequestHandler<ByteBuf, ByteBuf> getHandler() { return new HealthCheckHandler(objectMapper); } @Before public void setUp() { super.setUp(); externalServer = RxNetty.newHttpServerBuilder(0, new ExternalServerHandler()) .pipelineConfigurator(PipelineConfigurators.<ByteBuf, ByteBuf>httpServerConfigurator()).build(); externalServer.start(); this.externalServerPort = externalServer.getServerPort(); } @After public void tearDown() throws InterruptedException{ super.tearDown(); externalServer.shutdown(); } @Test public void shouldPingExternalHostsForHealthCheck() { ConfigurationManager.getConfigInstance().setProperty(\"prana.host.healthcheck.url\", \"http: HttpClientRequest<ByteBuf> request = HttpClientRequest.<ByteBuf>createGet(\"/healthcheck\"); Assert.assertEquals(\"<health>ok</health>\", TestUtils.getResponse(request, client)); } @Test public void shouldReturnOkIfHealthCheckURLIsSetToNull() { System.setProperty(\"prana.host.healthcheck.url\", \"\"); ConfigurationManager.getConfigInstance().setProperty(\"prana.host.healthcheck.url\", \"\"); HttpClientRequest<ByteBuf> request = HttpClientRequest.<ByteBuf>createGet(\"/healthcheck\"); Assert.assertEquals(\"<health>ok</health>\", TestUtils.getResponse(request, client)); } private class ExternalServerHandler implements RequestHandler<ByteBuf, ByteBuf> { @Override public Observable<Void> handle(HttpServerRequest<ByteBuf> request, HttpServerResponse<ByteBuf> response) { response.setStatus(HttpResponseStatus.OK); return response.close(); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Prana-master/Prana-master/src/test/java/com/netflix/prana/http/api/HealthCheckHandlerTest.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "High-level test module directly instantiates RxNetty's HttpServer (concrete class) instead of depending on an abstraction. Low-level server implementation is directly referenced without interface inversion."}]}]}
{"project_id": 16, "chunk_id": 0, "prompt": {"main_file_path": "Bank-Application-main/Bank-Application-main/LaxmiChitFund.java", "main_file_content": "import java.util.*; class LaxmiChitFund { static String username; static long mobile; static String pan; static long adhar; static String address; static int pin; static double bal; final static long accountNumber = 123412341234l; final static String ifscCode = \"LCF1234\"; static ArrayList<String> statement = new ArrayList<>(); public static void main(String [] args) { welcome(); } public static void welcome() { for(;;) { Scanner sc = new Scanner(System.in); soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") sout(\"\") int opt = sc.nextInt(); switch(opt) { case 1: login(sc); break; case 2: createAccount(sc); break; default: soutl(\"\") } } } public static void login(Scanner sc) { if(username!=null) { for(int i =1; i<=3; i++) { soutl(\"\") soutl(\"\") soutl(\"\") sout(\"\") long mobile1 = sc.nextLong(); sout(\"\") int pin1 = sc.nextInt(); if((mobile==mobile1)&&(pin==pin1)) { homePage(sc); } else { soutl(\"\") soutl(\"\") soutl(\"\") } } System.exit(0); } else { soutl(\"\") soutl(\"\") soutl(\"\") } } public static void createAccount(Scanner sc) { soutl(\"\") soutl(\"\") soutl(\"\") sout(\"\") sc.nextLine(); username = sc.nextLine(); sout(\"\") mobile = sc.nextLong(); sout(\"\") adhar = sc.nextLong(); sout(\"\") pan = sc.next(); sout(\"\") sc.nextLine(); address = sc.nextLine(); sout(\"\") pin = sc.nextInt(); sout(\"\") bal = sc.nextDouble(); statement.add(\"Deposit : \"+bal); soutl(\"\") soutl(\"\") soutl(\"\") } public static void homePage(Scanner sc) { for(;;) { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") sout(\"\") int option = sc.nextInt(); soutl(\"\") switch(option) { case 1: deposit(sc); break; case 2: withdraw(sc); break; case 3: checkBalance(sc); break; case 4: statement(sc); break; case 5: editProfile(sc); break; case 6: System.exit(0); default: soutl(\"\") } } } public static void deposit(Scanner sc) { soutl(\"\") soutl(\"\") soutl(\"\") double depositAmount = sc.nextDouble(); bal += depositAmount; statement.add(\"Deposit: \"+ depositAmount); soutl(\"\") soutl(\"\") } public static void withdraw(Scanner sc) { for(int i= 1; i<=3; i++) { soutl(\"\") soutl(\"\") soutl(\"\") double withdrawAmount = sc.nextDouble(); soutl(\"\") int pin1 = sc.nextInt(); if(pin1==pin) { if(withdrawAmount<=bal) { bal-=withdrawAmount; statement.add(\"Withdraw: \"+withdrawAmount); soutl(\"\") } else { soutl(\"\") } return; } else { soutl(\"\") soutl(\"\") } } soutl(\"\") soutl(\"\") System.exit(0); } public static void checkBalance(Scanner sc) { for(int i= 1; i<=3; i++) { soutl(\"\") soutl(\"\") int pin1 = sc.nextInt(); if(pin1==pin) { soutl(\"\") soutl(\"\") return; } else { soutl(\"\") soutl(\"\") } } soutl(\"\") soutl(\"\") System.exit(0); } public static void statement(Scanner sc) { soutl(\"\") soutl(\"\") for(String tran : statement) { soutl(\"\") } } public static void editProfile(Scanner sc) { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") sout(\"\") int opt1 = sc.nextInt(); switch(opt1) { case 1: updateUsername(sc); break; case 2: updateMobile(sc); break; case 3: updateAddress(sc); break; case 4: updatePin(sc); break; default: soutl(\"\") } } public static void updateUsername(Scanner sc) { soutl(\"\") soutl(\"\") sc.nextLine(); String username1 = sc.nextLine(); for(int i= 1; i<=3; i++) { soutl(\"\") int pin1 = sc.nextInt(); if(pin==pin1) { soutl(\"\") username = username1; soutl(\"\") return; } else { soutl(\"\") soutl(\"\") } } soutl(\"\") soutl(\"\") System.exit(0); } public static void updateMobile(Scanner sc) { soutl(\"\") soutl(\"\") long mobile1= sc.nextLong(); for(int i= 1; i<=3; i++) { soutl(\"\") int pin1 = sc.nextInt(); if(pin==pin1) { soutl(\"\") mobile = mobile1; soutl(\"\") return; } else { soutl(\"\") soutl(\"\") } } soutl(\"\") soutl(\"\") System.exit(0); } public static void updateAddress(Scanner sc) { soutl(\"\") soutl(\"\") sc.nextLine(); String address1 = sc.nextLine(); for(int i= 1; i<=3; i++) { soutl(\"\") int pin1 = sc.nextInt(); if(pin==pin1) { soutl(\"\") address = address1; soutl(\"\") return; } else { soutl(\"\") soutl(\"\") } } soutl(\"\") soutl(\"\") System.exit(0); } public static void updatePin(Scanner sc) { soutl(\"\") soutl(\"\") int pin1 = sc.nextInt(); for(int i= 1; i<=3; i++) { soutl(\"\") long mobile1 = sc.nextLong(); if(mobile==mobile1) { soutl(\"\") pin = pin1; soutl(\"\") return; } else { soutl(\"\") soutl(\"\") } } soutl(\"\") soutl(\"\") System.exit(0); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Bank-Application-main/Bank-Application-main/LaxmiChitFund.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The LaxmiChitFund class handles multiple responsibilities: user authentication, account management, transactions, profile editing, and UI interactions. This requires the class to change for unrelated reasons, violating SRP."}, {"principle": "Open-Closed", "justification": "The class cannot be extended without modifying its code (e.g., adding new transaction types or UI components). All logic is implemented in static methods with no abstractions, violating OCP."}, {"principle": "Dependency Inversion", "justification": "High-level banking logic (e.g., deposit/withdraw) is tightly coupled with low-level implementation details (static variables, Scanner). No abstractions separate policy from implementation, violating DIP."}]}]}
{"project_id": 17, "chunk_id": 0, "prompt": {"main_file_path": "Chatting-Service-master/Basic_Chatting_Application/src/Client.java", "main_file_content": "import java.awt.BorderLayout; import java.awt.Color; import java.awt.Font; import java.awt.Image; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.KeyAdapter; import java.awt.event.KeyEvent; import java.awt.event.MouseAdapter; import java.awt.event.MouseEvent; import java.io.DataInputStream; import java.io.DataOutputStream; import java.io.IOException; import java.net.Socket; import java.text.SimpleDateFormat; import java.util.Calendar; import javax.swing.Box; import javax.swing.BoxLayout; import javax.swing.ImageIcon; import javax.swing.JButton; import javax.swing.JFrame; import javax.swing.JLabel; import javax.swing.JPanel; import javax.swing.JScrollPane; import javax.swing.JTextField; import javax.swing.Timer; import javax.swing.border.EmptyBorder; public class Client extends JFrame implements ActionListener{ private static final long serialVersionUID = 1L; JPanel p1; JTextField text; JButton button; static JPanel area; static JFrame f1 = new JFrame(); static Box vertical = Box.createVerticalBox(); static Socket s; static DataInputStream din; static DataOutputStream dout; Boolean typing; public Client(){ f1.setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE); p1 = new JPanel(); p1.setLayout(null); p1.setBackground(Color.blue); p1.setBounds(0, 0, 450, 70); f1.add(p1); Image img = new ImageIcon(this.getClass().getResource(\"/3.png\")).getImage().getScaledInstance(30, 30, Image.SCALE_DEFAULT); ImageIcon img1 = new ImageIcon(img); JLabel label = new JLabel(img1); label.setBounds(5, 17, 30, 30); p1.add(label); label.addMouseListener(new MouseAdapter() { public void mouseClicked(MouseEvent ae) { System.exit(0); } }); Image img2 = new ImageIcon(this.getClass().getResource(\"/male-modified.png\")).getImage().getScaledInstance(60, 60, Image.SCALE_DEFAULT); ImageIcon img3 = new ImageIcon(img2); JLabel label2 = new JLabel(img3); label2.setBounds(40, 5, 60, 60); p1.add(label2); Image img4 = new ImageIcon(this.getClass().getResource(\"/video.png\")).getImage().getScaledInstance(30, 30, Image.SCALE_DEFAULT); ImageIcon img5 = new ImageIcon(img4); JLabel label5 = new JLabel(img5); label5.setBounds(290, 23,30, 30); p1.add(label5); Image img6 = new ImageIcon(this.getClass().getResource(\"/phone.png\")).getImage().getScaledInstance(35, 30, Image.SCALE_DEFAULT); ImageIcon img7 = new ImageIcon(img6); JLabel label6 = new JLabel(img7); label6.setBounds(350, 23, 35, 30); p1.add(label6); Image img8 = new ImageIcon(this.getClass().getResource(\"/3icon.png\")).getImage().getScaledInstance(13, 25, Image.SCALE_DEFAULT); ImageIcon img9 = new ImageIcon(img8); JLabel label7 = new JLabel(img9); label7.setBounds(410, 23, 13, 25); p1.add(label7); JLabel label3 = new JLabel(\"Name 2\"); label3.setFont(new Font(\"SAN_SERIF\", Font.BOLD, 18)); label3.setForeground(Color.white); label3.setBounds(110, 17, 100, 20); p1.add(label3); JLabel label4 = new JLabel(\"Active Now\"); label4.setFont(new Font(\"SAN_SERIF\", Font.PLAIN, 14)); label4.setForeground(Color.white); label4.setBounds(110, 36, 100, 20); p1.add(label4); Timer t = new Timer(1, new ActionListener(){ public void actionPerformed(ActionEvent ae){ if(!typing){ label4.setText(\"Active Now\"); } } }); t.setInitialDelay(2000); area = new JPanel(); area.setBounds(5, 75, 440, 570); area.setFont(new Font(\"SAN_SERIF\", Font.PLAIN, 16)); JScrollPane pane = new JScrollPane(area); pane.setBounds(5, 75, 440, 570); pane.setFont(new Font(\"SAN_SERIF\", Font.PLAIN, 16)); pane.getVerticalScrollBar().setUnitIncrement(14); f1.add(pane); text = new JTextField(); text.setBounds(5, 655, 320, 40); text.setFont(new Font(\"SAN_SERIF\", Font.PLAIN, 16)); f1.add(text); text.addKeyListener(new KeyAdapter(){ public void keyPressed(KeyEvent ke){ label4.setText(\"typing...\"); t.stop(); typing = true; } public void keyReleased(KeyEvent ke){ typing = false; if(!t.isRunning()){ t.start(); } } }); button = new JButton(\"Send\"); button.setBounds(335, 655, 110, 40); button.setBackground(Color.green.darker()); button.setForeground(Color.white); button.setFont(new Font(\"SAN_SERIF\", Font.PLAIN, 16)); button.addActionListener(this); f1.add(button); f1.getContentPane().setBackground(Color.black); f1.setLayout(null); f1.setSize(450, 700); f1.setLocation(1000, 200); f1.setUndecorated(true); f1.setVisible(true); } @Override public void actionPerformed(ActionEvent ae){ try { String out = text.getText(); if(!out.isEmpty()) { JPanel p2 = formatLabel(out); text.setText(\"\"); area.setLayout(new BorderLayout()); JPanel right = new JPanel(new BorderLayout()); right.add(p2, BorderLayout.LINE_END); vertical.add(right); vertical.add(Box.createVerticalStrut(15)); area.add(vertical, BorderLayout.PAGE_START); f1.revalidate(); dout.writeUTF(out); } } catch (IOException e) { e.printStackTrace(); } } public static JPanel formatLabel(String out){ JPanel p3 = new JPanel(); p3.setLayout(new BoxLayout(p3, BoxLayout.Y_AXIS)); JLabel l1 = new JLabel(\"<html><p style = \\\"width : 150px\\\">\"+out+\"</p></html>\"); l1.setFont(new Font(\"Tahoma\", Font.PLAIN, 16)); l1.setBackground(new Color(37, 211, 102)); l1.setOpaque(true); l1.setBorder(new EmptyBorder(15,15,15,50)); Calendar cal = Calendar.getInstance(); SimpleDateFormat sdf = new SimpleDateFormat(\"HH:mm\"); JLabel l2 = new JLabel(); l2.setText(sdf.format(cal.getTime())); p3.add(l1); p3.add(l2); return p3; } public static void main(String[] args) { new Client(); try { s = new Socket(\"127.0.0.1\", 1000); din = new DataInputStream(s.getInputStream()); dout = new DataOutputStream(s.getOutputStream()); String msgin = \"\"; while(true){ area.setLayout(new BorderLayout()); msgin = din.readUTF(); JPanel p2 = formatLabel(msgin); JPanel left = new JPanel(new BorderLayout()); left.add(p2, BorderLayout.LINE_START); vertical.add(left); vertical.add(Box.createVerticalStrut(15)); area.add(vertical, BorderLayout.PAGE_START); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } f1.validate(); } }catch(Exception e) { soutl(\"\") soutl(\"\") e.printStackTrace(); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Chatting-Service-master/Basic_Chatting_Application/src/Client.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Client class handles GUI construction, network communication, message formatting, and user input processing. This aggregation of unrelated responsibilities violates SRP as changes in any one area would require modifying the class."}, {"principle": "Open-Closed", "justification": "The formatLabel method and network handling logic are implemented directly in the class without abstraction. Extending message formatting or communication behavior would require modifying existing code rather than extending through inheritance/composition."}, {"principle": "Dependency Inversion", "justification": "High-level Client directly instantiates low-level Socket, DataInputStream, and DataOutputStream without depending on abstractions. Network implementation details are tightly coupled to the business logic of the chat client."}]}]}
{"project_id": 17, "chunk_id": 0, "prompt": {"main_file_path": "Chatting-Service-master/Basic_Chatting_Application/src/Server.java", "main_file_content": "import java.awt.BorderLayout; import java.awt.Color; import java.awt.Font; import java.awt.Image; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.KeyAdapter; import java.awt.event.KeyEvent; import java.awt.event.MouseAdapter; import java.awt.event.MouseEvent; import java.io.DataInputStream; import java.io.DataOutputStream; import java.io.IOException; import java.net.ServerSocket; import java.net.Socket; import java.text.SimpleDateFormat; import java.util.Calendar; import javax.swing.Box; import javax.swing.BoxLayout; import javax.swing.ImageIcon; import javax.swing.JButton; import javax.swing.JFrame; import javax.swing.JLabel; import javax.swing.JPanel; import javax.swing.JScrollPane; import javax.swing.JTextField; import javax.swing.Timer; import javax.swing.border.EmptyBorder; public class Server extends JFrame implements ActionListener{ private static final long serialVersionUID = 1L; JPanel p1; JTextField text; JButton button; static JPanel area; static JFrame f1 = new JFrame(); static Box vertical = Box.createVerticalBox(); static ServerSocket skt; static Socket s; static DataInputStream din; static DataOutputStream dout; Boolean typing; public Server(){ f1.setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE); p1 = new JPanel(); p1.setLayout(null); p1.setBackground(new Color(255,140,0)); p1.setBounds(0, 0, 450, 70); f1.add(p1); Image img = new ImageIcon(this.getClass().getResource(\"/3.png\")).getImage().getScaledInstance(30, 30, Image.SCALE_DEFAULT); ImageIcon img1 = new ImageIcon(img); JLabel label = new JLabel(img1); label.setBounds(5, 17, 30, 30); p1.add(label); label.addMouseListener(new MouseAdapter() { public void mouseClicked(MouseEvent ae) { System.exit(0); } }); Image img2 = new ImageIcon(this.getClass().getResource(\"/female-modified.png\")).getImage().getScaledInstance(60, 60, Image.SCALE_DEFAULT); ImageIcon img3 = new ImageIcon(img2); JLabel label2 = new JLabel(img3); label2.setBounds(40, 5, 60, 60); p1.add(label2); Image img4 = new ImageIcon(this.getClass().getResource(\"/video.png\")).getImage().getScaledInstance(30, 30, Image.SCALE_DEFAULT); ImageIcon img5 = new ImageIcon(img4); JLabel label5 = new JLabel(img5); label5.setBounds(290, 23,30, 30); p1.add(label5); Image img6 = new ImageIcon(this.getClass().getResource(\"/phone.png\")).getImage().getScaledInstance(35, 30, Image.SCALE_DEFAULT); ImageIcon img7 = new ImageIcon(img6); JLabel label6 = new JLabel(img7); label6.setBounds(350, 23, 35, 30); p1.add(label6); Image img8 = new ImageIcon(this.getClass().getResource(\"/3icon.png\")).getImage().getScaledInstance(13, 25, Image.SCALE_DEFAULT); ImageIcon img9 = new ImageIcon(img8); JLabel label7 = new JLabel(img9); label7.setBounds(410, 23, 13, 25); p1.add(label7); JLabel label3 = new JLabel(\"Name 1\"); label3.setFont(new Font(\"SAN_SERIF\", Font.BOLD, 18)); label3.setForeground(Color.white); label3.setBounds(110, 17, 100, 20); p1.add(label3); JLabel label4 = new JLabel(\"Active Now\"); label4.setFont(new Font(\"SAN_SERIF\", Font.PLAIN, 14)); label4.setForeground(Color.white); label4.setBounds(110, 36, 100, 20); p1.add(label4); JLabel serverlabel = new JLabel(\"'Server'\"); serverlabel.setFont(new Font(\"SAN_SERIF\", Font.PLAIN, 15)); serverlabel.setForeground(Color.white); serverlabel.setBounds(205, 25, 100, 20); p1.add(serverlabel); Timer t = new Timer(1, new ActionListener(){ public void actionPerformed(ActionEvent ae){ if(!typing){ label4.setText(\"Active Now\"); } } }); t.setInitialDelay(2000); area = new JPanel(); area.setBounds(5, 75, 440, 570); area.setFont(new Font(\"SAN_SERIF\", Font.PLAIN, 16)); JScrollPane pane = new JScrollPane(area); pane.setBounds(5, 75, 440, 570); pane.setFont(new Font(\"SAN_SERIF\", Font.PLAIN, 16)); pane.getVerticalScrollBar().setUnitIncrement(14); f1.add(pane); text = new JTextField(); text.setBounds(5, 655, 320, 40); text.setFont(new Font(\"SAN_SERIF\", Font.PLAIN, 16)); f1.add(text); text.addKeyListener(new KeyAdapter(){ public void keyPressed(KeyEvent ke){ label4.setText(\"typing...\"); t.stop(); typing = true; } public void keyReleased(KeyEvent ke){ typing = false; if(!t.isRunning()){ t.start(); } } }); button = new JButton(\"Send\"); button.setBounds(335, 655, 110, 40); button.setBackground(Color.green.darker()); button.setForeground(Color.white); button.setFont(new Font(\"SAN_SERIF\", Font.PLAIN, 16)); button.addActionListener(this); f1.add(button); f1.getContentPane().setBackground(Color.black); f1.setLayout(null); f1.setSize(450, 700); f1.setLocation(20, 200); f1.setUndecorated(true); f1.setVisible(true); } @Override public void actionPerformed(ActionEvent ae){ try { String out = text.getText(); if(!out.isEmpty()) { JPanel p2 = formatLabel(out); text.setText(\"\"); area.setLayout(new BorderLayout()); JPanel right = new JPanel(new BorderLayout()); right.add(p2, BorderLayout.LINE_END); vertical.add(right); vertical.add(Box.createVerticalStrut(15)); area.add(vertical, BorderLayout.PAGE_START); f1.revalidate(); dout.writeUTF(out); } } catch (IOException e) { e.printStackTrace(); } } public static JPanel formatLabel(String out){ JPanel p3 = new JPanel(); p3.setLayout(new BoxLayout(p3, BoxLayout.Y_AXIS)); JLabel l1 = new JLabel(\"<html><p style = \\\"width : 150px\\\">\"+out+\"</p></html>\"); l1.setFont(new Font(\"Tahoma\", Font.PLAIN, 16)); l1.setBackground(new Color(37, 211, 102)); l1.setOpaque(true); l1.setBorder(new EmptyBorder(15,15,15,10)); Calendar cal = Calendar.getInstance(); SimpleDateFormat sdf = new SimpleDateFormat(\"HH:mm\"); JLabel l2 = new JLabel(); l2.setText(sdf.format(cal.getTime())); p3.add(l1); p3.add(l2); return p3; } public static void main(String[] args) { new Server(); String msgin = \"\"; try { skt = new ServerSocket(1000); while(true){ s = skt.accept(); din = new DataInputStream(s.getInputStream()); dout = new DataOutputStream(s.getOutputStream()); while(true){ area.setLayout(new BorderLayout()); msgin = din.readUTF(); JPanel p2 = formatLabel(msgin); JPanel left = new JPanel(new BorderLayout()); left.add(p2, BorderLayout.LINE_START); vertical.add(left); vertical.add(Box.createVerticalStrut(15)); area.add(vertical, BorderLayout.PAGE_START); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } f1.validate(); } } }catch(Exception e) { e.printStackTrace(); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Chatting-Service-master/Basic_Chatting_Application/src/Server.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Server class handles GUI construction, network communication, message formatting, and event handling, indicating multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Adding new message types or communication protocols would require modifying the Server class directly instead of extending it."}]}]}
{"project_id": 18, "chunk_id": 0, "prompt": {"main_file_path": "ValayCalculator/MyCalculator/src/jCalculator/JavaCalculator.java", "main_file_content": "package jCalculator; import javax.swing.JOptionPane; public class JavaCalculator extends javax.swing.JFrame { private double total1 = 0.0; private double total2 = 0.0; private char math_operator; private double sin = 0.0; private double cos = 0.0; private double tan = 0.0; private void getOperator(String btnText) { math_operator = btnText.charAt(0); total1 = total1 + Double.parseDouble(txtDisplay.getText()); txtDisplay.setText(\"\"); } public JavaCalculator() { initComponents(); } @SuppressWarnings(\"unchecked\") private void initComponents() { txtDisplay = new javax.swing.JTextField(); jPanel1 = new javax.swing.JPanel(); btnOne = new javax.swing.JButton(); btnTwo = new javax.swing.JButton(); btnThree = new javax.swing.JButton(); btnFour = new javax.swing.JButton(); btnFive = new javax.swing.JButton(); btnSix = new javax.swing.JButton(); btnSeven = new javax.swing.JButton(); btnEight = new javax.swing.JButton(); btnNine = new javax.swing.JButton(); btnZero = new javax.swing.JButton(); btnPoint = new javax.swing.JButton(); btnEquals = new javax.swing.JButton(); jPanel2 = new javax.swing.JPanel(); btnPlus = new javax.swing.JButton(); btnClear = new javax.swing.JButton(); btnSubtract = new javax.swing.JButton(); btnMultiply = new javax.swing.JButton(); btnDivide = new javax.swing.JButton(); btnSin = new javax.swing.JButton(); btnCos = new javax.swing.JButton(); btnTan = new javax.swing.JButton(); btnRemainder = new javax.swing.JButton(); HelpComboBox = new javax.swing.JComboBox(); btnHelp = new javax.swing.JButton(); setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE); setTitle(\"Caclulator\"); txtDisplay.setFont(new java.awt.Font(\"Perpetua Titling MT\", 1, 14)); txtDisplay.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(java.awt.event.ActionEvent evt) { txtDisplayActionPerformed(evt); } }); btnOne.setFont(new java.awt.Font(\"Comic Sans MS\", 1, 14)); btnOne.setText(\"1\"); btnOne.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(java.awt.event.ActionEvent evt) { btnOneActionPerformed(evt); } }); btnTwo.setFont(new java.awt.Font(\"Comic Sans MS\", 1, 14)); btnTwo.setText(\"2\"); btnTwo.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(java.awt.event.ActionEvent evt) { btnTwoActionPerformed(evt); } }); btnThree.setFont(new java.awt.Font(\"Comic Sans MS\", 1, 14)); btnThree.setText(\"3\"); btnThree.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(java.awt.event.ActionEvent evt) { btnThreeActionPerformed(evt); } }); btnFour.setFont(new java.awt.Font(\"Comic Sans MS\", 1, 14)); btnFour.setText(\"4\"); btnFour.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(java.awt.event.ActionEvent evt) { btnFourActionPerformed(evt); } }); btnFive.setFont(new java.awt.Font(\"Comic Sans MS\", 1, 14)); btnFive.setText(\"5\"); btnFive.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(java.awt.event.ActionEvent evt) { btnFiveActionPerformed(evt); } }); btnSix.setFont(new java.awt.Font(\"Comic Sans MS\", 1, 14)); btnSix.setText(\"6\"); btnSix.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(java.awt.event.ActionEvent evt) { btnSixActionPerformed(evt); } }); btnSeven.setFont(new java.awt.Font(\"Comic Sans MS\", 1, 14)); btnSeven.setText(\"7\"); btnSeven.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(java.awt.event.ActionEvent evt) { btnSevenActionPerformed(evt); } }); btnEight.setFont(new java.awt.Font(\"Comic Sans MS\", 1, 14)); btnEight.setText(\"8\"); btnEight.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(java.awt.event.ActionEvent evt) { btnEightActionPerformed(evt); } }); btnNine.setFont(new java.awt.Font(\"Comic Sans MS\", 1, 14)); btnNine.setText(\"9\"); btnNine.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(java.awt.event.ActionEvent evt) { btnNineActionPerformed(evt); } }); btnZero.setFont(new java.awt.Font(\"Comic Sans MS\", 1, 14)); btnZero.setText(\"0\"); btnZero.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(java.awt.event.ActionEvent evt) { btnZeroActionPerformed(evt); } }); btnPoint.setFont(new java.awt.Font(\"Comic Sans MS\", 1, 14)); btnPoint.setText(\".\"); btnPoint.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(java.awt.event.ActionEvent evt) { btnPointActionPerformed(evt); } }); btnEquals.setFont(new java.awt.Font(\"Comic Sans MS\", 1, 14)); btnEquals.setText(\"=\"); btnEquals.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(java.awt.event.ActionEvent evt) { btnEqualsActionPerformed(evt); } }); javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1); jPanel1.setLayout(jPanel1Layout); jPanel1Layout.setHorizontalGroup( jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING) .addGroup(jPanel1Layout.createSequentialGroup() .addGap(33, 33, 33) .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING) .addComponent(btnOne, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE) .addComponent(btnFour, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE) .addComponent(btnPoint, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE) .addComponent(btnSeven, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)) .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING) .addGroup(jPanel1Layout.createSequentialGroup() .addGap(37, 37, 37) .addComponent(btnZero, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE) .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE) .addComponent(btnEquals, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)) .addGroup(jPanel1Layout.createSequentialGroup() .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false) .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup() .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE) .addComponent(btnTwo, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)) .addGroup(jPanel1Layout.createSequentialGroup() .addGap(37, 37, 37) .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING) .addComponent(btnEight, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE) .addComponent(btnFive, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)))) .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING) .addGroup(jPanel1Layout.createSequentialGroup() .addGap(34, 34, 34) .addComponent(btnSix, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)) .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup() .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED) .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING) .addComponent(btnNine, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE) .addComponent(btnThree, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)))))) .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)) ); jPanel1Layout.setVerticalGroup( jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING) .addGroup(jPanel1Layout.createSequentialGroup() .addContainerGap() .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE) .addComponent(btnNine, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE) .addComponent(btnEight, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE) .addComponent(btnSeven, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)) .addGap(46, 46, 46) .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE) .addComponent(btnFive, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE) .addComponent(btnFour, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE) .addComponent(btnSix, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)) .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE) .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE) .addComponent(btnThree, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE) .addComponent(btnTwo, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE) .addComponent(btnOne, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)) .addGap(30, 30, 30) .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE) .addComponent(btnZero, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE) .addComponent(btnPoint, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE) .addComponent(btnEquals, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)) .addContainerGap()) ); btnPlus.setFont(new java.awt.Font(\"Comic Sans MS\", 1, 14)); btnPlus.setText(\"+\"); btnPlus.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(java.awt.event.ActionEvent evt) { btnPlusActionPerformed(evt); } }); btnClear.setFont(new java.awt.Font(\"Comic Sans MS\", 1, 14)); btnClear.setText(\"Clear\"); btnClear.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(java.awt.event.ActionEvent evt) { btnClearActionPerformed(evt); } }); btnSubtract.setFont(new java.awt.Font(\"Comic Sans MS\", 1, 14)); btnSubtract.setText(\"-\"); btnSubtract.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(java.awt.event.ActionEvent evt) { btnSubtractActionPerformed(evt); } }); btnMultiply.setFont(new java.awt.Font(\"Comic Sans MS\", 1, 14)); btnMultiply.setText(\"*\"); btnMultiply.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(java.awt.event.ActionEvent evt) { btnMultiplyActionPerformed(evt); } }); btnDivide.setFont(new java.awt.Font(\"Comic Sans MS\", 1, 14)); btnDivide.setText(\"/\"); btnDivide.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(java.awt.event.ActionEvent evt) { btnDivideActionPerformed(evt); } }); btnSin.setFont(new java.awt.Font(\"Comic Sans MS\", 1, 14)); btnSin.setText(\"sin\"); btnSin.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(java.awt.event.ActionEvent evt) { btnSinActionPerformed(evt); } }); btnCos.setFont(new java.awt.Font(\"Comic Sans MS\", 1, 14)); btnCos.setText(\"cos\"); btnCos.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(java.awt.event.ActionEvent evt) { btnCosActionPerformed(evt); } }); btnTan.setFont(new java.awt.Font(\"Comic Sans MS\", 1, 14)); btnTan.setText(\"tan\"); btnTan.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(java.awt.event.ActionEvent evt) { btnTanActionPerformed(evt); } }); btnRemainder.setFont(new java.awt.Font(\"Comic Sans MS\", 1, 14)); btnRemainder.setText(\"%\"); btnRemainder.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(java.awt.event.ActionEvent evt) { btnRemainderActionPerformed(evt); } }); javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2); jPanel2.setLayout(jPanel2Layout); jPanel2Layout.setHorizontalGroup( jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING) .addGroup(jPanel2Layout.createSequentialGroup() .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING) .addGroup(jPanel2Layout.createSequentialGroup() .addContainerGap() .addComponent(btnMultiply, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE) .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE) .addComponent(btnDivide, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)) .addGroup(jPanel2Layout.createSequentialGroup() .addContainerGap() .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING) .addComponent(btnSin, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE) .addComponent(btnTan)) .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE) .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING) .addComponent(btnCos, javax.swing.GroupLayout.Alignment.TRAILING) .addComponent(btnRemainder, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE))) .addGroup(jPanel2Layout.createSequentialGroup() .addContainerGap() .addComponent(btnPlus, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE) .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE) .addComponent(btnSubtract, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE))) .addContainerGap()) .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup() .addGap(0, 0, Short.MAX_VALUE) .addComponent(btnClear, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE) .addGap(43, 43, 43)) ); jPanel2Layout.setVerticalGroup( jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING) .addGroup(jPanel2Layout.createSequentialGroup() .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE) .addComponent(btnPlus, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE) .addComponent(btnSubtract, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)) .addGap(29, 29, 29) .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE) .addComponent(btnMultiply, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE) .addComponent(btnDivide, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)) .addGap(33, 33, 33) .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE) .addComponent(btnSin, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE) .addComponent(btnCos)) .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 24, Short.MAX_VALUE) .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE) .addComponent(btnTan, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE) .addComponent(btnRemainder, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)) .addGap(18, 18, 18) .addComponent(btnClear, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE) .addContainerGap()) ); HelpComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { \"Sine Info\", \"Cosine Info\", \"Tangent Info\", \"Remainder Info\" })); HelpComboBox.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(java.awt.event.ActionEvent evt) { HelpComboBoxActionPerformed(evt); } }); btnHelp.setFont(new java.awt.Font(\"Comic Sans MS\", 1, 14)); btnHelp.setText(\"Help\"); btnHelp.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(java.awt.event.ActionEvent evt) { btnHelpActionPerformed(evt); } }); javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane()); getContentPane().setLayout(layout); layout.setHorizontalGroup( layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING) .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup() .addContainerGap(12, Short.MAX_VALUE) .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING) .addComponent(HelpComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE) .addGroup(layout.createSequentialGroup() .addGap(10, 10, 10) .addComponent(btnHelp, javax.swing.GroupLayout.PREFERRED_SIZE, 65, javax.swing.GroupLayout.PREFERRED_SIZE))) .addGap(18, 18, 18) .addComponent(txtDisplay, javax.swing.GroupLayout.PREFERRED_SIZE, 268, javax.swing.GroupLayout.PREFERRED_SIZE) .addGap(60, 60, 60)) .addGroup(layout.createSequentialGroup() .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE) .addGap(18, 18, 18) .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)) ); layout.setVerticalGroup( layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING) .addGroup(layout.createSequentialGroup() .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING) .addComponent(txtDisplay, javax.swing.GroupLayout.PREFERRED_SIZE, 48, javax.swing.GroupLayout.PREFERRED_SIZE) .addGroup(layout.createSequentialGroup() .addComponent(HelpComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE) .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED) .addComponent(btnHelp, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE))) .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED) .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING) .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE) .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))) ); pack(); } private void txtDisplayActionPerformed(java.awt.event.ActionEvent evt) { } private void btnOneActionPerformed(java.awt.event.ActionEvent evt) { String btnOneText = txtDisplay.getText() + btnOne.getText(); txtDisplay.setText( btnOneText ); } private void btnTwoActionPerformed(java.awt.event.ActionEvent evt) { String btnTwoText = txtDisplay.getText() + btnTwo.getText(); txtDisplay.setText( btnTwoText ); } private void btnThreeActionPerformed(java.awt.event.ActionEvent evt) { String btnThreeText = txtDisplay.getText() + btnThree.getText(); txtDisplay.setText( btnThreeText ); } private void btnFourActionPerformed(java.awt.event.ActionEvent evt) { String btnFourText = txtDisplay.getText() + btnFour.getText(); txtDisplay.setText( btnFourText ); } private void btnFiveActionPerformed(java.awt.event.ActionEvent evt) { String btnFiveText = txtDisplay.getText() + btnFive.getText(); txtDisplay.setText( btnFiveText ); } private void btnSixActionPerformed(java.awt.event.ActionEvent evt) { String btnSixText = txtDisplay.getText() + btnSix.getText(); txtDisplay.setText( btnSixText ); } private void btnSevenActionPerformed(java.awt.event.ActionEvent evt) { String btnSevenText = txtDisplay.getText() + btnSeven.getText(); txtDisplay.setText( btnSevenText ); } private void btnEightActionPerformed(java.awt.event.ActionEvent evt) { String btnEightText = txtDisplay.getText() + btnEight.getText(); txtDisplay.setText( btnEightText ); } private void btnNineActionPerformed(java.awt.event.ActionEvent evt) { String btnNineText = txtDisplay.getText() + btnNine.getText(); txtDisplay.setText( btnNineText ); } private void btnZeroActionPerformed(java.awt.event.ActionEvent evt) { String btnZeroText = txtDisplay.getText() + btnZero.getText(); txtDisplay.setText( btnZeroText ); } private void btnPlusActionPerformed(java.awt.event.ActionEvent evt) { String button_text = btnPlus.getText(); getOperator(button_text); } private void btnEqualsActionPerformed(java.awt.event.ActionEvent evt) { switch ( math_operator ) { case '+': total2 = total1 + Double.parseDouble( txtDisplay.getText( ) ) ;break; case '-': total2 = total1 - Double.parseDouble(txtDisplay.getText( ) ); break; case '/': total2 = total1 / Double.parseDouble(txtDisplay.getText( ) ); break; case '*': total2 = total1 * Double.parseDouble(txtDisplay.getText( ) ); break; case '%': total2 = total1 % Double.parseDouble(txtDisplay.getText( ) ); break; } txtDisplay.setText( Double.toString( total2) ); total1 = 0; } private void btnClearActionPerformed(java.awt.event.ActionEvent evt) { total2 = 0; txtDisplay.setText(\"\"); } private void btnPointActionPerformed(java.awt.event.ActionEvent evt) { String btnPointText = txtDisplay.getText() + btnPoint.getText(); txtDisplay.setText( btnPointText ); } private void btnSubtractActionPerformed(java.awt.event.ActionEvent evt) { String button_text = btnSubtract.getText(); getOperator(button_text); } private void btnDivideActionPerformed(java.awt.event.ActionEvent evt) { String button_text = btnDivide.getText(); getOperator(button_text); } private void btnMultiplyActionPerformed(java.awt.event.ActionEvent evt) { String button_text = btnMultiply.getText(); getOperator(button_text); } private void btnSinActionPerformed(java.awt.event.ActionEvent evt) { sin = Math.sin(Double.parseDouble(txtDisplay.getText( ) )); txtDisplay.setText( Double.toString(sin) ); } private void btnCosActionPerformed(java.awt.event.ActionEvent evt) { cos = Math.cos(Double.parseDouble(txtDisplay.getText( ) )); txtDisplay.setText( Double.toString(cos) ); } private void btnTanActionPerformed(java.awt.event.ActionEvent evt) { tan = Math.tan(Double.parseDouble(txtDisplay.getText( ) )); txtDisplay.setText( Double.toString(tan) ); } private void btnRemainderActionPerformed(java.awt.event.ActionEvent evt) { String button_text = btnRemainder.getText(); getOperator(button_text); } private void HelpComboBoxActionPerformed(java.awt.event.ActionEvent evt) { int i=HelpComboBox.getSelectedIndex(); if (i==0){ String downloadURL=\"https: java.awt.Desktop myNewBrowserDesktop = java.awt.Desktop.getDesktop(); try{ java.net.URI myNewLocation = new java.net.URI(downloadURL); myNewBrowserDesktop.browse(myNewLocation); } catch(Exception e){ } } if (i==1){ String downloadURL=\"http: java.awt.Desktop myNewBrowserDesktop = java.awt.Desktop.getDesktop(); try{ java.net.URI myNewLocation = new java.net.URI(downloadURL); myNewBrowserDesktop.browse(myNewLocation); } catch(Exception e){ } } if (i==2){ String downloadURL=\"http: java.awt.Desktop myNewBrowserDesktop = java.awt.Desktop.getDesktop(); try{ java.net.URI myNewLocation = new java.net.URI(downloadURL); myNewBrowserDesktop.browse(myNewLocation); } catch(Exception e){ } } if (i==3){ String downloadURL=\"http: java.awt.Desktop myNewBrowserDesktop = java.awt.Desktop.getDesktop(); try{ java.net.URI myNewLocation = new java.net.URI(downloadURL); myNewBrowserDesktop.browse(myNewLocation); } catch(Exception e){ } } } private void btnHelpActionPerformed(java.awt.event.ActionEvent evt) { JOptionPane.showMessageDialog(null, \"Click on the numbers or type numbers into box by clicking on the blank strip and typing in numbers. \\n The '+' add two numbers together. Enter number then hit '+' and enter another number and click '='.\\n The '-' subtracts two numbers. Enter number then hit '-' and enter another number and click '='.\\n The '*' multiplies two numbers together. Enter number then hit '*' and enter another number and click '='.\\n The '/' divides two numbers together. Enter number then hit '/' and enter another number and click '='.\\n The 'sin' uses the sine function. Enter number then hit 'sin'. For more information, check the bar on top.\\n The 'cos' uses the cosines function. Enter number then hit 'cos'. For more information, check the bar on top.\\n The 'tan' uses the tangent function. Enter number then hit 'tan'. For more information, check the bar on top. \\n The '%' uses the remainder function. Enter number then hit '%'. For more information, check the bar on top. \\n The 'Clear' button clears all values in the white box.\"); } public static void main(String args[]) { try { for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) { if (\"Nimbus\".equals(info.getName())) { javax.swing.UIManager.setLookAndFeel(info.getClassName()); break; } } } catch (ClassNotFoundException ex) { java.util.logging.Logger.getLogger(JavaCalculator.class.getName()).log(java.util.logging.Level.SEVERE, null, ex); } catch (InstantiationException ex) { java.util.logging.Logger.getLogger(JavaCalculator.class.getName()).log(java.util.logging.Level.SEVERE, null, ex); } catch (IllegalAccessException ex) { java.util.logging.Logger.getLogger(JavaCalculator.class.getName()).log(java.util.logging.Level.SEVERE, null, ex); } catch (javax.swing.UnsupportedLookAndFeelException ex) { java.util.logging.Logger.getLogger(JavaCalculator.class.getName()).log(java.util.logging.Level.SEVERE, null, ex); } java.awt.EventQueue.invokeLater(new Runnable() { public void run() { new JavaCalculator().setVisible(true); } }); } private javax.swing.JComboBox HelpComboBox; private javax.swing.JButton btnClear; private javax.swing.JButton btnCos; private javax.swing.JButton btnDivide; private javax.swing.JButton btnEight; private javax.swing.JButton btnEquals; private javax.swing.JButton btnFive; private javax.swing.JButton btnFour; private javax.swing.JButton btnHelp; private javax.swing.JButton btnMultiply; private javax.swing.JButton btnNine; private javax.swing.JButton btnOne; private javax.swing.JButton btnPlus; private javax.swing.JButton btnPoint; private javax.swing.JButton btnRemainder; private javax.swing.JButton btnSeven; private javax.swing.JButton btnSin; private javax.swing.JButton btnSix; private javax.swing.JButton btnSubtract; private javax.swing.JButton btnTan; private javax.swing.JButton btnThree; private javax.swing.JButton btnTwo; private javax.swing.JButton btnZero; private javax.swing.JPanel jPanel1; private javax.swing.JPanel jPanel2; private javax.swing.JTextField txtDisplay; }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "ValayCalculator/MyCalculator/src/jCalculator/JavaCalculator.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The JavaCalculator class handles UI layout, input processing, mathematical operations, and help functionality, indicating multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Adding new operations (e.g., logarithmic functions) requires modifying the existing btnEqualsActionPerformed method instead of extending through abstractions."}]}]}
{"project_id": 20, "chunk_id": 0, "prompt": {"main_file_path": "java-totp-master/java-totp-master/totp-spring-boot-starter/src/main/java/dev/samstevens/totp/spring/autoconfigure/TotpAutoConfiguration.java", "main_file_content": "package dev.samstevens.totp.spring.autoconfigure; import dev.samstevens.totp.TotpInfo; import dev.samstevens.totp.code.*; import dev.samstevens.totp.qr.QrDataFactory; import dev.samstevens.totp.qr.QrGenerator; import dev.samstevens.totp.qr.ZxingPngQrGenerator; import dev.samstevens.totp.recovery.RecoveryCodeGenerator; import dev.samstevens.totp.secret.DefaultSecretGenerator; import dev.samstevens.totp.secret.SecretGenerator; import dev.samstevens.totp.time.SystemTimeProvider; import dev.samstevens.totp.time.TimeProvider; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.autoconfigure.condition.ConditionalOnClass; import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean; import org.springframework.boot.context.properties.EnableConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration @ConditionalOnClass(TotpInfo.class) @EnableConfigurationProperties(TotpProperties.class) public class TotpAutoConfiguration { private TotpProperties props; @Autowired public TotpAutoConfiguration(TotpProperties props) { this.props = props; } @Bean @ConditionalOnMissingBean public SecretGenerator secretGenerator() { int length = props.getSecret().getLength(); return new DefaultSecretGenerator(length); } @Bean @ConditionalOnMissingBean public TimeProvider timeProvider() { return new SystemTimeProvider(); } @Bean @ConditionalOnMissingBean public HashingAlgorithm hashingAlgorithm() { return HashingAlgorithm.SHA1; } @Bean @ConditionalOnMissingBean public QrDataFactory qrDataFactory(HashingAlgorithm hashingAlgorithm) { return new QrDataFactory(hashingAlgorithm, getCodeLength(), getTimePeriod()); } @Bean @ConditionalOnMissingBean public QrGenerator qrGenerator() { return new ZxingPngQrGenerator(); } @Bean @ConditionalOnMissingBean public CodeGenerator codeGenerator(HashingAlgorithm algorithm) { return new DefaultCodeGenerator(algorithm, getCodeLength()); } @Bean @ConditionalOnMissingBean public CodeVerifier codeVerifier(CodeGenerator codeGenerator, TimeProvider timeProvider) { DefaultCodeVerifier verifier = new DefaultCodeVerifier(codeGenerator, timeProvider); verifier.setTimePeriod(getTimePeriod()); verifier.setAllowedTimePeriodDiscrepancy(props.getTime().getDiscrepancy()); return verifier; } @Bean @ConditionalOnMissingBean public RecoveryCodeGenerator recoveryCodeGenerator() { return new RecoveryCodeGenerator(); } private int getCodeLength() { return props.getCode().getLength(); } private int getTimePeriod() { return props.getTime().getPeriod(); } }", "dependencies": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/TotpInfo.java", "file_content": "package dev.samstevens.totp; public class TotpInfo { public static String VERSION = \"1.7.1\"; }"}, {"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/qr/QrDataFactory.java", "file_content": "package dev.samstevens.totp.qr; import dev.samstevens.totp.code.HashingAlgorithm; public class QrDataFactory { private HashingAlgorithm defaultAlgorithm; private int defaultDigits; private int defaultTimePeriod; public QrDataFactory(HashingAlgorithm defaultAlgorithm, int defaultDigits, int defaultTimePeriod) { this.defaultAlgorithm = defaultAlgorithm; this.defaultDigits = defaultDigits; this.defaultTimePeriod = defaultTimePeriod; } public QrData.Builder newBuilder() { return new QrData.Builder() .algorithm(defaultAlgorithm) .digits(defaultDigits) .period(defaultTimePeriod); } }"}, {"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/qr/QrGenerator.java", "file_content": "package dev.samstevens.totp.qr; import dev.samstevens.totp.exceptions.QrGenerationException; public interface QrGenerator { String getImageMimeType(); byte[] generate(QrData data) throws QrGenerationException; }"}, {"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/qr/ZxingPngQrGenerator.java", "file_content": "package dev.samstevens.totp.qr; import com.google.zxing.BarcodeFormat; import com.google.zxing.Writer; import com.google.zxing.client.j2se.MatrixToImageWriter; import com.google.zxing.common.BitMatrix; import com.google.zxing.qrcode.QRCodeWriter; import dev.samstevens.totp.exceptions.QrGenerationException; import java.io.ByteArrayOutputStream; public class ZxingPngQrGenerator implements QrGenerator { private final Writer writer; private int imageSize = 350; public ZxingPngQrGenerator() { this(new QRCodeWriter()); } public ZxingPngQrGenerator(Writer writer) { this.writer = writer; } public void setImageSize(int imageSize) { this.imageSize = imageSize; } public int getImageSize() { return imageSize; } public String getImageMimeType() { return \"image/png\"; } @Override public byte[] generate(QrData data) throws QrGenerationException { try { BitMatrix bitMatrix = writer.encode(data.getUri(), BarcodeFormat.QR_CODE, imageSize, imageSize); ByteArrayOutputStream pngOutputStream = new ByteArrayOutputStream(); MatrixToImageWriter.writeToStream(bitMatrix, \"PNG\", pngOutputStream); return pngOutputStream.toByteArray(); } catch (Exception e) { throw new QrGenerationException(\"Failed to generate QR code. See nested exception.\", e); } } }"}, {"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/recovery/RecoveryCodeGenerator.java", "file_content": "package dev.samstevens.totp.recovery; import java.security.InvalidParameterException; import java.security.SecureRandom; import java.util.Arrays; import java.util.Random; public class RecoveryCodeGenerator { private static final char[] CHARACTERS = \"abcdefghijklmnopqrstuvwxyz0123456789\".toCharArray(); private static final int CODE_LENGTH = 16; private static final int GROUPS_NBR = 4; private Random random = new SecureRandom(); public String[] generateCodes(int amount) { if (amount < 1) { throw new InvalidParameterException(\"Amount must be at least 1.\"); } String[] codes = new String[amount]; Arrays.setAll(codes, i -> generateCode()); return codes; } private String generateCode() { final StringBuilder code = new StringBuilder(CODE_LENGTH + (CODE_LENGTH/GROUPS_NBR) - 1); for (int i = 0; i < CODE_LENGTH; i++) { code.append(CHARACTERS[random.nextInt(CHARACTERS.length)]); if ((i+1) % GROUPS_NBR == 0 && (i+1) != CODE_LENGTH) { code.append(\"-\"); } } return code.toString(); } }"}, {"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/secret/DefaultSecretGenerator.java", "file_content": "package dev.samstevens.totp.secret; import org.apache.commons.codec.binary.Base32; import java.security.SecureRandom; @SuppressWarnings(\"WeakerAccess\") public class DefaultSecretGenerator implements SecretGenerator { private final SecureRandom randomBytes = new SecureRandom(); private final static Base32 encoder = new Base32(); private final int numCharacters; public DefaultSecretGenerator() { this.numCharacters = 32; } public DefaultSecretGenerator(int numCharacters) { this.numCharacters = numCharacters; } @Override public String generate() { return new String(encoder.encode(getRandomBytes())); } private byte[] getRandomBytes() { byte[] bytes = new byte[(numCharacters * 5) / 8]; randomBytes.nextBytes(bytes); return bytes; } }"}, {"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/secret/SecretGenerator.java", "file_content": "package dev.samstevens.totp.secret; public interface SecretGenerator { String generate(); }"}, {"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/time/SystemTimeProvider.java", "file_content": "package dev.samstevens.totp.time; import dev.samstevens.totp.exceptions.TimeProviderException; import java.time.Instant; public class SystemTimeProvider implements TimeProvider { @Override public long getTime() throws TimeProviderException { return Instant.now().getEpochSecond(); } }"}, {"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/time/TimeProvider.java", "file_content": "package dev.samstevens.totp.time; import dev.samstevens.totp.exceptions.TimeProviderException; public interface TimeProvider { long getTime() throws TimeProviderException; }"}, {"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/code/DefaultCodeVerifier.java", "file_content": "package dev.samstevens.totp.code; import dev.samstevens.totp.exceptions.CodeGenerationException; import dev.samstevens.totp.time.TimeProvider; public class DefaultCodeVerifier implements CodeVerifier { private final CodeGenerator codeGenerator; private final TimeProvider timeProvider; private int timePeriod = 30; private int allowedTimePeriodDiscrepancy = 1; public DefaultCodeVerifier(CodeGenerator codeGenerator, TimeProvider timeProvider) { this.codeGenerator = codeGenerator; this.timeProvider = timeProvider; } public void setTimePeriod(int timePeriod) { this.timePeriod = timePeriod; } public void setAllowedTimePeriodDiscrepancy(int allowedTimePeriodDiscrepancy) { this.allowedTimePeriodDiscrepancy = allowedTimePeriodDiscrepancy; } @Override public boolean isValidCode(String secret, String code) { long currentBucket = Math.floorDiv(timeProvider.getTime(), timePeriod); boolean success = false; for (int i = -allowedTimePeriodDiscrepancy; i <= allowedTimePeriodDiscrepancy; i++) { success = checkCode(secret, currentBucket + i, code) || success; } return success; } private boolean checkCode(String secret, long counter, String code) { try { String actualCode = codeGenerator.generate(secret, counter); return timeSafeStringComparison(actualCode, code); } catch (CodeGenerationException e) { return false; } } private boolean timeSafeStringComparison(String a, String b) { byte[] aBytes = a.getBytes(); byte[] bBytes = b.getBytes(); if (aBytes.length != bBytes.length) { return false; } int result = 0; for (int i = 0; i < aBytes.length; i++) { result |= aBytes[i] ^ bBytes[i]; } return result == 0; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/recovery/RecoveryCodeGenerator.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "RecoveryCodeGenerator is a concrete class without an interface. High-level modules depending on it directly violates DIP, as they should depend on abstractions instead."}]}, {"file_path": "java-totp-master/java-totp-master/totp-spring-boot-starter/src/main/java/dev/samstevens/totp/spring/autoconfigure/TotpAutoConfiguration.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "Directly instantiating RecoveryCodeGenerator (a concrete class) without an abstraction forces high-level modules to depend on implementation details, violating DIP."}]}]}
{"project_id": 20, "chunk_id": 0, "prompt": {"main_file_path": "java-totp-master/java-totp-master/totp-spring-boot-starter/src/main/java/dev/samstevens/totp/spring/autoconfigure/TotpProperties.java", "main_file_content": "package dev.samstevens.totp.spring.autoconfigure; import org.springframework.boot.context.properties.ConfigurationProperties; @ConfigurationProperties(prefix = \"totp\") public class TotpProperties { private static final int DEFAULT_SECRET_LENGTH = 32; private static final int DEFAULT_CODE_LENGTH = 6; private static final int DEFAULT_TIME_PERIOD = 30; private static final int DEFAULT_TIME_DISCREPANCY = 1; private final Secret secret = new Secret(); private final Code code = new Code(); private final Time time = new Time(); public Secret getSecret() { return secret; } public Code getCode() { return code; } public Time getTime() { return time; } public static class Secret { private int length = DEFAULT_SECRET_LENGTH; public int getLength() { return length; } public void setLength(int length) { this.length = length; } } public static class Code { private int length = DEFAULT_CODE_LENGTH; public int getLength() { return length; } public void setLength(int length) { this.length = length; } } public static class Time { private int period = DEFAULT_TIME_PERIOD; private int discrepancy = DEFAULT_TIME_DISCREPANCY; public int getPeriod() { return period; } public void setPeriod(int period) { this.period = period; } public int getDiscrepancy() { return discrepancy; } public void setDiscrepancy(int discrepancy) { this.discrepancy = discrepancy; } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "java-totp-master/java-totp-master/totp-spring-boot-starter/src/main/java/dev/samstevens/totp/spring/autoconfigure/TotpProperties.java", "violatedPrinciples": []}]}
{"project_id": 20, "chunk_id": 0, "prompt": {"main_file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/TotpInfo.java", "main_file_content": "package dev.samstevens.totp; public class TotpInfo { public static String VERSION = \"1.7.1\"; }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/TotpInfo.java", "violatedPrinciples": []}]}
{"project_id": 20, "chunk_id": 0, "prompt": {"main_file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/util/Utils.java", "main_file_content": "package dev.samstevens.totp.util; import org.apache.commons.codec.binary.Base64; public class Utils { private static Base64 base64Codec = new Base64(); private Utils() { } public static String getDataUriForImage(byte[] data, String mimeType) { String encodedData = new String(base64Codec.encode(data)); return String.format(\"data:%s;base64,%s\", mimeType, encodedData); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/util/Utils.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "Utils directly instantiates and depends on the concrete Base64 class from Apache Commons Codec. High-level modules should depend on abstractions rather than concrete implementations."}]}]}
{"project_id": 20, "chunk_id": 0, "prompt": {"main_file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/recovery/RecoveryCodeGenerator.java", "main_file_content": "package dev.samstevens.totp.recovery; import java.security.InvalidParameterException; import java.security.SecureRandom; import java.util.Arrays; import java.util.Random; public class RecoveryCodeGenerator { private static final char[] CHARACTERS = \"abcdefghijklmnopqrstuvwxyz0123456789\".toCharArray(); private static final int CODE_LENGTH = 16; private static final int GROUPS_NBR = 4; private Random random = new SecureRandom(); public String[] generateCodes(int amount) { if (amount < 1) { throw new InvalidParameterException(\"Amount must be at least 1.\"); } String[] codes = new String[amount]; Arrays.setAll(codes, i -> generateCode()); return codes; } private String generateCode() { final StringBuilder code = new StringBuilder(CODE_LENGTH + (CODE_LENGTH/GROUPS_NBR) - 1); for (int i = 0; i < CODE_LENGTH; i++) { code.append(CHARACTERS[random.nextInt(CHARACTERS.length)]); if ((i+1) % GROUPS_NBR == 0 && (i+1) != CODE_LENGTH) { code.append(\"-\"); } } return code.toString(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/recovery/RecoveryCodeGenerator.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "The RecoveryCodeGenerator class cannot be extended to modify code generation (e.g., character set, group size) without modifying its existing code. It lacks abstraction points like interfaces or protected configuration fields to enable customization through inheritance or composition."}]}]}
{"project_id": 20, "chunk_id": 0, "prompt": {"main_file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/code/DefaultCodeGenerator.java", "main_file_content": "package dev.samstevens.totp.code; import dev.samstevens.totp.exceptions.CodeGenerationException; import org.apache.commons.codec.binary.Base32; import javax.crypto.Mac; import javax.crypto.spec.SecretKeySpec; import java.security.InvalidKeyException; import java.security.InvalidParameterException; import java.security.NoSuchAlgorithmException; public class DefaultCodeGenerator implements CodeGenerator { private final HashingAlgorithm algorithm; private final int digits; public DefaultCodeGenerator() { this(HashingAlgorithm.SHA1, 6); } public DefaultCodeGenerator(HashingAlgorithm algorithm) { this(algorithm, 6); } public DefaultCodeGenerator(HashingAlgorithm algorithm, int digits) { if (algorithm == null) { throw new InvalidParameterException(\"HashingAlgorithm must not be null.\"); } if (digits < 1) { throw new InvalidParameterException(\"Number of digits must be higher than 0.\"); } this.algorithm = algorithm; this.digits = digits; } @Override public String generate(String key, long counter) throws CodeGenerationException { try { byte[] hash = generateHash(key, counter); return getDigitsFromHash(hash); } catch (Exception e) { throw new CodeGenerationException(\"Failed to generate code. See nested exception.\", e); } } private byte[] generateHash(String key, long counter) throws InvalidKeyException, NoSuchAlgorithmException { byte[] data = new byte[8]; long value = counter; for (int i = 8; i-- > 0; value >>>= 8) { data[i] = (byte) value; } Base32 codec = new Base32(); byte[] decodedKey = codec.decode(key); SecretKeySpec signKey = new SecretKeySpec(decodedKey, algorithm.getHmacAlgorithm()); Mac mac = Mac.getInstance(algorithm.getHmacAlgorithm()); mac.init(signKey); return mac.doFinal(data); } private String getDigitsFromHash(byte[] hash) { int offset = hash[hash.length - 1] & 0xF; long truncatedHash = 0; for (int i = 0; i < 4; ++i) { truncatedHash <<= 8; truncatedHash |= (hash[offset + i] & 0xFF); } truncatedHash &= 0x7FFFFFFF; truncatedHash %= Math.pow(10, digits); return String.format(\"%0\" + digits + \"d\", truncatedHash); } }", "dependencies": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/exceptions/CodeGenerationException.java", "file_content": "package dev.samstevens.totp.exceptions; public class CodeGenerationException extends Exception { public CodeGenerationException(String message, Throwable cause) { super(message, cause); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/code/DefaultCodeGenerator.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "DefaultCodeGenerator directly instantiates Apache Commons' Base32, a concrete low-level module, instead of depending on an abstraction. High-level code generators should depend on abstractions for encoding/decoding operations."}]}]}
{"project_id": 20, "chunk_id": 0, "prompt": {"main_file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/code/CodeVerifier.java", "main_file_content": "package dev.samstevens.totp.code; public interface CodeVerifier { boolean isValidCode(String secret, String code); }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 20, "chunk_id": 0, "prompt": {"main_file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/code/HashingAlgorithm.java", "main_file_content": "package dev.samstevens.totp.code; public enum HashingAlgorithm { SHA1(\"HmacSHA1\", \"SHA1\"), SHA256(\"HmacSHA256\", \"SHA256\"), SHA512(\"HmacSHA512\", \"SHA512\"); private final String hmacAlgorithm; private final String friendlyName; HashingAlgorithm(String hmacAlgorithm, String friendlyName) { this.hmacAlgorithm = hmacAlgorithm; this.friendlyName = friendlyName; } public String getHmacAlgorithm() { return hmacAlgorithm; } public String getFriendlyName() { return friendlyName; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/code/HashingAlgorithm.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "HashingAlgorithm is an enum that cannot be extended without modifying its source code to add new algorithms, violating the Open/Closed Principle."}]}]}
{"project_id": 20, "chunk_id": 0, "prompt": {"main_file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/code/CodeGenerator.java", "main_file_content": "package dev.samstevens.totp.code; import dev.samstevens.totp.exceptions.CodeGenerationException; public interface CodeGenerator { String generate(String secret, long counter) throws CodeGenerationException; }", "dependencies": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/exceptions/CodeGenerationException.java", "file_content": "package dev.samstevens.totp.exceptions; public class CodeGenerationException extends Exception { public CodeGenerationException(String message, Throwable cause) { super(message, cause); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 20, "chunk_id": 0, "prompt": {"main_file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/code/DefaultCodeVerifier.java", "main_file_content": "package dev.samstevens.totp.code; import dev.samstevens.totp.exceptions.CodeGenerationException; import dev.samstevens.totp.time.TimeProvider; public class DefaultCodeVerifier implements CodeVerifier { private final CodeGenerator codeGenerator; private final TimeProvider timeProvider; private int timePeriod = 30; private int allowedTimePeriodDiscrepancy = 1; public DefaultCodeVerifier(CodeGenerator codeGenerator, TimeProvider timeProvider) { this.codeGenerator = codeGenerator; this.timeProvider = timeProvider; } public void setTimePeriod(int timePeriod) { this.timePeriod = timePeriod; } public void setAllowedTimePeriodDiscrepancy(int allowedTimePeriodDiscrepancy) { this.allowedTimePeriodDiscrepancy = allowedTimePeriodDiscrepancy; } @Override public boolean isValidCode(String secret, String code) { long currentBucket = Math.floorDiv(timeProvider.getTime(), timePeriod); boolean success = false; for (int i = -allowedTimePeriodDiscrepancy; i <= allowedTimePeriodDiscrepancy; i++) { success = checkCode(secret, currentBucket + i, code) || success; } return success; } private boolean checkCode(String secret, long counter, String code) { try { String actualCode = codeGenerator.generate(secret, counter); return timeSafeStringComparison(actualCode, code); } catch (CodeGenerationException e) { return false; } } private boolean timeSafeStringComparison(String a, String b) { byte[] aBytes = a.getBytes(); byte[] bBytes = b.getBytes(); if (aBytes.length != bBytes.length) { return false; } int result = 0; for (int i = 0; i < aBytes.length; i++) { result |= aBytes[i] ^ bBytes[i]; } return result == 0; } }", "dependencies": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/exceptions/CodeGenerationException.java", "file_content": "package dev.samstevens.totp.exceptions; public class CodeGenerationException extends Exception { public CodeGenerationException(String message, Throwable cause) { super(message, cause); } }"}, {"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/time/TimeProvider.java", "file_content": "package dev.samstevens.totp.time; import dev.samstevens.totp.exceptions.TimeProviderException; public interface TimeProvider { long getTime() throws TimeProviderException; }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 20, "chunk_id": 0, "prompt": {"main_file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/qr/QrDataFactory.java", "main_file_content": "package dev.samstevens.totp.qr; import dev.samstevens.totp.code.HashingAlgorithm; public class QrDataFactory { private HashingAlgorithm defaultAlgorithm; private int defaultDigits; private int defaultTimePeriod; public QrDataFactory(HashingAlgorithm defaultAlgorithm, int defaultDigits, int defaultTimePeriod) { this.defaultAlgorithm = defaultAlgorithm; this.defaultDigits = defaultDigits; this.defaultTimePeriod = defaultTimePeriod; } public QrData.Builder newBuilder() { return new QrData.Builder() .algorithm(defaultAlgorithm) .digits(defaultDigits) .period(defaultTimePeriod); } }", "dependencies": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/code/HashingAlgorithm.java", "file_content": "package dev.samstevens.totp.code; public enum HashingAlgorithm { SHA1(\"HmacSHA1\", \"SHA1\"), SHA256(\"HmacSHA256\", \"SHA256\"), SHA512(\"HmacSHA512\", \"SHA512\"); private final String hmacAlgorithm; private final String friendlyName; HashingAlgorithm(String hmacAlgorithm, String friendlyName) { this.hmacAlgorithm = hmacAlgorithm; this.friendlyName = friendlyName; } public String getHmacAlgorithm() { return hmacAlgorithm; } public String getFriendlyName() { return friendlyName; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/qr/QrDataFactory.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "QrDataFactory directly depends on the concrete HashingAlgorithm enum. High-level modules should depend on abstractions (interfaces) rather than concrete implementations."}]}]}
{"project_id": 20, "chunk_id": 0, "prompt": {"main_file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/qr/QrGenerator.java", "main_file_content": "package dev.samstevens.totp.qr; import dev.samstevens.totp.exceptions.QrGenerationException; public interface QrGenerator { String getImageMimeType(); byte[] generate(QrData data) throws QrGenerationException; }", "dependencies": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/exceptions/QrGenerationException.java", "file_content": "package dev.samstevens.totp.exceptions; public class QrGenerationException extends Exception { public QrGenerationException(String message, Throwable cause) { super(message, cause); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 20, "chunk_id": 0, "prompt": {"main_file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/qr/QrData.java", "main_file_content": "package dev.samstevens.totp.qr; import dev.samstevens.totp.code.HashingAlgorithm; import java.io.UnsupportedEncodingException; import java.net.URLEncoder; import java.nio.charset.StandardCharsets; @SuppressWarnings(\"WeakerAccess\") public class QrData { private final String type; private final String label; private final String secret; private final String issuer; private final String algorithm; private final int digits; private final int period; private QrData(String type, String label, String secret, String issuer, String algorithm, int digits, int period) { this.type = type; this.label = label; this.secret = secret; this.issuer = issuer; this.algorithm = algorithm; this.digits = digits; this.period = period; } public String getType() { return type; } public String getLabel() { return label; } public String getSecret() { return secret; } public String getIssuer() { return issuer; } public String getAlgorithm() { return algorithm; } public int getDigits() { return digits; } public int getPeriod() { return period; } public String getUri() { return \"otpauth: uriEncode(type) + \"/\" + uriEncode(label) + \"?\" + \"secret=\" + uriEncode(secret) + \"&issuer=\" + uriEncode(issuer) + \"&algorithm=\" + uriEncode(algorithm) + \"&digits=\" + digits + \"&period=\" + period; } private String uriEncode(String text) { if (text == null) { return \"\"; } try { return URLEncoder.encode(text, StandardCharsets.UTF_8.toString()).replaceAll(\"\\\\+\", \"%20\"); } catch (UnsupportedEncodingException e) { throw new RuntimeException(\"Could not URI encode QrData.\"); } } public static class Builder { private String label; private String secret; private String issuer; private HashingAlgorithm algorithm = HashingAlgorithm.SHA1; private int digits = 6; private int period = 30; public Builder label(String label) { this.label = label; return this; } public Builder secret(String secret) { this.secret = secret; return this; } public Builder issuer(String issuer) { this.issuer = issuer; return this; } public Builder algorithm(HashingAlgorithm algorithm) { this.algorithm = algorithm; return this; } public Builder digits(int digits) { this.digits = digits; return this; } public Builder period(int period) { this.period = period; return this; } public QrData build() { return new QrData(\"totp\", label, secret, issuer, algorithm.getFriendlyName(), digits, period); } } }", "dependencies": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/code/HashingAlgorithm.java", "file_content": "package dev.samstevens.totp.code; public enum HashingAlgorithm { SHA1(\"HmacSHA1\", \"SHA1\"), SHA256(\"HmacSHA256\", \"SHA256\"), SHA512(\"HmacSHA512\", \"SHA512\"); private final String hmacAlgorithm; private final String friendlyName; HashingAlgorithm(String hmacAlgorithm, String friendlyName) { this.hmacAlgorithm = hmacAlgorithm; this.friendlyName = friendlyName; } public String getHmacAlgorithm() { return hmacAlgorithm; } public String getFriendlyName() { return friendlyName; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/qr/QrData.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "QrData manages QR data properties and constructs a URI string, handling both data representation and URI generation logic, which are two distinct responsibilities."}, {"principle": "Open-Closed", "justification": "QrData cannot be extended to modify URI construction or encoding behavior without altering its existing code, violating the open for extension principle."}, {"principle": "Dependency Inversion", "justification": "QrData.Builder directly depends on the concrete HashingAlgorithm enum instead of an abstraction, coupling high-level modules to low-level implementations."}]}]}
{"project_id": 20, "chunk_id": 0, "prompt": {"main_file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/qr/ZxingPngQrGenerator.java", "main_file_content": "package dev.samstevens.totp.qr; import com.google.zxing.BarcodeFormat; import com.google.zxing.Writer; import com.google.zxing.client.j2se.MatrixToImageWriter; import com.google.zxing.common.BitMatrix; import com.google.zxing.qrcode.QRCodeWriter; import dev.samstevens.totp.exceptions.QrGenerationException; import java.io.ByteArrayOutputStream; public class ZxingPngQrGenerator implements QrGenerator { private final Writer writer; private int imageSize = 350; public ZxingPngQrGenerator() { this(new QRCodeWriter()); } public ZxingPngQrGenerator(Writer writer) { this.writer = writer; } public void setImageSize(int imageSize) { this.imageSize = imageSize; } public int getImageSize() { return imageSize; } public String getImageMimeType() { return \"image/png\"; } @Override public byte[] generate(QrData data) throws QrGenerationException { try { BitMatrix bitMatrix = writer.encode(data.getUri(), BarcodeFormat.QR_CODE, imageSize, imageSize); ByteArrayOutputStream pngOutputStream = new ByteArrayOutputStream(); MatrixToImageWriter.writeToStream(bitMatrix, \"PNG\", pngOutputStream); return pngOutputStream.toByteArray(); } catch (Exception e) { throw new QrGenerationException(\"Failed to generate QR code. See nested exception.\", e); } } }", "dependencies": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/exceptions/QrGenerationException.java", "file_content": "package dev.samstevens.totp.exceptions; public class QrGenerationException extends Exception { public QrGenerationException(String message, Throwable cause) { super(message, cause); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/qr/ZxingPngQrGenerator.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "ZxingPngQrGenerator directly depends on the concrete MatrixToImageWriter class for PNG conversion. High-level modules should depend on abstractions, not low-level implementations."}]}]}
{"project_id": 20, "chunk_id": 0, "prompt": {"main_file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/exceptions/TimeProviderException.java", "main_file_content": "package dev.samstevens.totp.exceptions; public class TimeProviderException extends RuntimeException { public TimeProviderException(String message) { super(message); } public TimeProviderException(String message, Throwable cause) { super(message, cause); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/exceptions/TimeProviderException.java", "violatedPrinciples": []}]}
{"project_id": 20, "chunk_id": 0, "prompt": {"main_file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/exceptions/QrGenerationException.java", "main_file_content": "package dev.samstevens.totp.exceptions; public class QrGenerationException extends Exception { public QrGenerationException(String message, Throwable cause) { super(message, cause); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/exceptions/QrGenerationException.java", "violatedPrinciples": []}]}
{"project_id": 20, "chunk_id": 0, "prompt": {"main_file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/exceptions/CodeGenerationException.java", "main_file_content": "package dev.samstevens.totp.exceptions; public class CodeGenerationException extends Exception { public CodeGenerationException(String message, Throwable cause) { super(message, cause); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/exceptions/CodeGenerationException.java", "violatedPrinciples": []}]}
{"project_id": 20, "chunk_id": 0, "prompt": {"main_file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/time/NtpTimeProvider.java", "main_file_content": "package dev.samstevens.totp.time; import dev.samstevens.totp.exceptions.TimeProviderException; import org.apache.commons.net.ntp.NTPUDPClient; import org.apache.commons.net.ntp.TimeInfo; import java.net.InetAddress; import java.net.UnknownHostException; public class NtpTimeProvider implements TimeProvider { private final NTPUDPClient client; private final InetAddress ntpHost; public NtpTimeProvider(String ntpHostname) throws UnknownHostException { this(ntpHostname, 3000); } public NtpTimeProvider(String ntpHostname, int timeout) throws UnknownHostException { this(ntpHostname, timeout, \"org.apache.commons.net.ntp.NTPUDPClient\"); } NtpTimeProvider(String ntpHostname, String dependentClass) throws UnknownHostException { this(ntpHostname, 3000, dependentClass); } private NtpTimeProvider(String ntpHostname, int timeout, String dependentClass) throws UnknownHostException { checkHasDependency(dependentClass); client = new NTPUDPClient(); client.setDefaultTimeout(timeout); ntpHost = InetAddress.getByName(ntpHostname); } @Override public long getTime() throws TimeProviderException { TimeInfo timeInfo; try { timeInfo = client.getTime(ntpHost); timeInfo.computeDetails(); } catch (Exception e) { throw new TimeProviderException(\"Failed to provide time from NTP server. See nested exception.\", e); } if (timeInfo.getOffset() == null) { throw new TimeProviderException(\"Failed to calculate NTP offset\"); } return (System.currentTimeMillis() + timeInfo.getOffset()) / 1000; } private void checkHasDependency(String dependentClass) { try { Class<?> ntpClientClass = Class.forName(dependentClass); } catch (ClassNotFoundException e) { throw new RuntimeException(\"The Apache Commons Net library must be on the classpath to use the NtpTimeProvider.\"); } } }", "dependencies": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/exceptions/TimeProviderException.java", "file_content": "package dev.samstevens.totp.exceptions; public class TimeProviderException extends RuntimeException { public TimeProviderException(String message) { super(message); } public TimeProviderException(String message, Throwable cause) { super(message, cause); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/time/NtpTimeProvider.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "NtpTimeProvider handles both time retrieval and dependency checks (via checkHasDependency), introducing multiple responsibilities."}, {"principle": "Dependency Inversion", "justification": "NtpTimeProvider directly instantiates NTPUDPClient (low-level module) instead of depending on an abstraction, violating abstraction dependency rules."}]}]}
{"project_id": 20, "chunk_id": 0, "prompt": {"main_file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/time/TimeProvider.java", "main_file_content": "package dev.samstevens.totp.time; import dev.samstevens.totp.exceptions.TimeProviderException; public interface TimeProvider { long getTime() throws TimeProviderException; }", "dependencies": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/exceptions/TimeProviderException.java", "file_content": "package dev.samstevens.totp.exceptions; public class TimeProviderException extends RuntimeException { public TimeProviderException(String message) { super(message); } public TimeProviderException(String message, Throwable cause) { super(message, cause); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 20, "chunk_id": 0, "prompt": {"main_file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/time/SystemTimeProvider.java", "main_file_content": "package dev.samstevens.totp.time; import dev.samstevens.totp.exceptions.TimeProviderException; import java.time.Instant; public class SystemTimeProvider implements TimeProvider { @Override public long getTime() throws TimeProviderException { return Instant.now().getEpochSecond(); } }", "dependencies": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/exceptions/TimeProviderException.java", "file_content": "package dev.samstevens.totp.exceptions; public class TimeProviderException extends RuntimeException { public TimeProviderException(String message) { super(message); } public TimeProviderException(String message, Throwable cause) { super(message, cause); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 20, "chunk_id": 0, "prompt": {"main_file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/secret/SecretGenerator.java", "main_file_content": "package dev.samstevens.totp.secret; public interface SecretGenerator { String generate(); }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/secret/SecretGenerator.java", "violatedPrinciples": []}]}
{"project_id": 20, "chunk_id": 0, "prompt": {"main_file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/secret/DefaultSecretGenerator.java", "main_file_content": "package dev.samstevens.totp.secret; import org.apache.commons.codec.binary.Base32; import java.security.SecureRandom; @SuppressWarnings(\"WeakerAccess\") public class DefaultSecretGenerator implements SecretGenerator { private final SecureRandom randomBytes = new SecureRandom(); private final static Base32 encoder = new Base32(); private final int numCharacters; public DefaultSecretGenerator() { this.numCharacters = 32; } public DefaultSecretGenerator(int numCharacters) { this.numCharacters = numCharacters; } @Override public String generate() { return new String(encoder.encode(getRandomBytes())); } private byte[] getRandomBytes() { byte[] bytes = new byte[(numCharacters * 5) / 8]; randomBytes.nextBytes(bytes); return bytes; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/secret/DefaultSecretGenerator.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "The class directly instantiates Base32, making it impossible to change the encoding algorithm without modifying the class. Extending functionality (e.g., switching encoders) requires altering existing code."}, {"principle": "Dependency Inversion", "justification": "High-level secret generation depends on concrete Base32 (third-party) instead of an abstraction. Low-level encoding details are tightly coupled to the business logic."}]}]}
{"project_id": 20, "chunk_id": 0, "prompt": {"main_file_path": "java-totp-master/java-totp-master/totp/src/test/java/dev/samstevens/totp/IOUtils.java", "main_file_content": "package dev.samstevens.totp; import java.io.FileOutputStream; import java.io.IOException; public class IOUtils { public static void writeFile(byte[] contents, String filePath) throws IOException { try (FileOutputStream stream = new FileOutputStream(filePath)) { stream.write(contents); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "java-totp-master/java-totp-master/totp/src/test/java/dev/samstevens/totp/IOUtils.java", "violatedPrinciples": []}]}
{"project_id": 20, "chunk_id": 0, "prompt": {"main_file_path": "java-totp-master/java-totp-master/totp/src/test/java/dev/samstevens/totp/util/DataUriEncodingTest.java", "main_file_content": "package dev.samstevens.totp.util; import static dev.samstevens.totp.util.Utils.getDataUriForImage; import static org.junit.jupiter.api.Assertions.assertEquals; import java.util.Base64; import org.junit.jupiter.api.Test; public class DataUriEncodingTest { @Test public void testDataUriEncode() { final String pngImage = \"iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=\"; final byte[] imageData = Base64.getDecoder().decode(pngImage); assertEquals(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=\", getDataUriForImage(imageData, \"image/png\")); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "java-totp-master/java-totp-master/totp/src/test/java/dev/samstevens/totp/util/DataUriEncodingTest.java", "violatedPrinciples": []}]}
{"project_id": 20, "chunk_id": 0, "prompt": {"main_file_path": "java-totp-master/java-totp-master/totp/src/test/java/dev/samstevens/totp/recovery/RecoveryCodeGeneratorTest.java", "main_file_content": "package dev.samstevens.totp.recovery; import org.junit.jupiter.api.Test; import java.security.InvalidParameterException; import java.util.Arrays; import java.util.HashSet; import java.util.Set; import static org.junit.jupiter.api.Assertions.*; public class RecoveryCodeGeneratorTest { @Test public void testCorrectAmountGenerated() { RecoveryCodeGenerator generator = new RecoveryCodeGenerator(); String[] codes = generator.generateCodes(16); assertEquals(16, codes.length); for (String code : codes) { assertNotNull(code); } } @Test public void testCodesMatchFormat() { RecoveryCodeGenerator generator = new RecoveryCodeGenerator(); String[] codes = generator.generateCodes(16); for (String code : codes) { assertTrue(code.matches(\"[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}\"), code); } } @Test public void testCodesAreUnique() { RecoveryCodeGenerator generator = new RecoveryCodeGenerator(); String[] codes = generator.generateCodes(25); Set<String> uniqueCodes = new HashSet<>(Arrays.asList(codes)); assertEquals(25, uniqueCodes.size()); } @Test public void testInvalidNumberThrowsException() { RecoveryCodeGenerator generator = new RecoveryCodeGenerator(); assertThrows(InvalidParameterException.class, () -> { generator.generateCodes(-1); }); } }", "dependencies": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/recovery/RecoveryCodeGenerator.java", "file_content": "package dev.samstevens.totp.recovery; import java.security.InvalidParameterException; import java.security.SecureRandom; import java.util.Arrays; import java.util.Random; public class RecoveryCodeGenerator { private static final char[] CHARACTERS = \"abcdefghijklmnopqrstuvwxyz0123456789\".toCharArray(); private static final int CODE_LENGTH = 16; private static final int GROUPS_NBR = 4; private Random random = new SecureRandom(); public String[] generateCodes(int amount) { if (amount < 1) { throw new InvalidParameterException(\"Amount must be at least 1.\"); } String[] codes = new String[amount]; Arrays.setAll(codes, i -> generateCode()); return codes; } private String generateCode() { final StringBuilder code = new StringBuilder(CODE_LENGTH + (CODE_LENGTH/GROUPS_NBR) - 1); for (int i = 0; i < CODE_LENGTH; i++) { code.append(CHARACTERS[random.nextInt(CHARACTERS.length)]); if ((i+1) % GROUPS_NBR == 0 && (i+1) != CODE_LENGTH) { code.append(\"-\"); } } return code.toString(); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/recovery/RecoveryCodeGenerator.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "RecoveryCodeGenerator directly instantiates SecureRandom, a concrete implementation. High-level modules should depend on abstractions (e.g., injecting Random via constructor)."}]}]}
{"project_id": 20, "chunk_id": 0, "prompt": {"main_file_path": "java-totp-master/java-totp-master/totp/src/test/java/dev/samstevens/totp/code/DefaultCodeVerifierTest.java", "main_file_content": "package dev.samstevens.totp.code; import dev.samstevens.totp.exceptions.CodeGenerationException; import dev.samstevens.totp.time.TimeProvider; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.*; import static org.mockito.Mockito.*; public class DefaultCodeVerifierTest { @Test public void testCodeIsValid() { String secret = \"EX47GINFPBK5GNLYLILGD2H6ZLGJNNWB\"; long timeToRunAt = 1567975936; String correctCode = \"862707\"; int timePeriod = 30; assertTrue(isValidCode(secret, correctCode, timeToRunAt - timePeriod, timePeriod)); assertTrue(isValidCode(secret, correctCode, timeToRunAt, timePeriod)); assertTrue(isValidCode(secret, correctCode, timeToRunAt + timePeriod, timePeriod)); assertFalse(isValidCode(secret, correctCode, timeToRunAt + timePeriod + 15, timePeriod)); assertFalse(isValidCode(secret, \"123\", timeToRunAt, timePeriod)); } @Test public void testCodeGenerationFailureReturnsFalse() throws CodeGenerationException { String secret = \"EX47GINFPBK5GNLYLILGD2H6ZLGJNNWB\"; TimeProvider timeProvider = mock(TimeProvider.class); when(timeProvider.getTime()).thenReturn(1567975936L); CodeGenerator codeGenerator = mock(CodeGenerator.class); when(codeGenerator.generate(anyString(), anyLong())).thenThrow(new CodeGenerationException(\"Test\", new RuntimeException())); DefaultCodeVerifier verifier = new DefaultCodeVerifier(codeGenerator, timeProvider); verifier.setAllowedTimePeriodDiscrepancy(1); assertEquals(false, verifier.isValidCode(secret, \"1234\")); } private boolean isValidCode(String secret, String code, long time, int timePeriod) { TimeProvider timeProvider = mock(TimeProvider.class); when(timeProvider.getTime()).thenReturn(time); DefaultCodeVerifier verifier = new DefaultCodeVerifier(new DefaultCodeGenerator(), timeProvider); verifier.setTimePeriod(timePeriod); return verifier.isValidCode(secret, code); } }", "dependencies": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/exceptions/CodeGenerationException.java", "file_content": "package dev.samstevens.totp.exceptions; public class CodeGenerationException extends Exception { public CodeGenerationException(String message, Throwable cause) { super(message, cause); } }"}, {"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/time/TimeProvider.java", "file_content": "package dev.samstevens.totp.time; import dev.samstevens.totp.exceptions.TimeProviderException; public interface TimeProvider { long getTime() throws TimeProviderException; }"}, {"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/code/DefaultCodeVerifier.java", "file_content": "package dev.samstevens.totp.code; import dev.samstevens.totp.exceptions.CodeGenerationException; import dev.samstevens.totp.time.TimeProvider; public class DefaultCodeVerifier implements CodeVerifier { private final CodeGenerator codeGenerator; private final TimeProvider timeProvider; private int timePeriod = 30; private int allowedTimePeriodDiscrepancy = 1; public DefaultCodeVerifier(CodeGenerator codeGenerator, TimeProvider timeProvider) { this.codeGenerator = codeGenerator; this.timeProvider = timeProvider; } public void setTimePeriod(int timePeriod) { this.timePeriod = timePeriod; } public void setAllowedTimePeriodDiscrepancy(int allowedTimePeriodDiscrepancy) { this.allowedTimePeriodDiscrepancy = allowedTimePeriodDiscrepancy; } @Override public boolean isValidCode(String secret, String code) { long currentBucket = Math.floorDiv(timeProvider.getTime(), timePeriod); boolean success = false; for (int i = -allowedTimePeriodDiscrepancy; i <= allowedTimePeriodDiscrepancy; i++) { success = checkCode(secret, currentBucket + i, code) || success; } return success; } private boolean checkCode(String secret, long counter, String code) { try { String actualCode = codeGenerator.generate(secret, counter); return timeSafeStringComparison(actualCode, code); } catch (CodeGenerationException e) { return false; } } private boolean timeSafeStringComparison(String a, String b) { byte[] aBytes = a.getBytes(); byte[] bBytes = b.getBytes(); if (aBytes.length != bBytes.length) { return false; } int result = 0; for (int i = 0; i < aBytes.length; i++) { result |= aBytes[i] ^ bBytes[i]; } return result == 0; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 20, "chunk_id": 0, "prompt": {"main_file_path": "java-totp-master/java-totp-master/totp/src/test/java/dev/samstevens/totp/code/DefaultCodeGeneratorTest.java", "main_file_content": "package dev.samstevens.totp.code; import dev.samstevens.totp.exceptions.CodeGenerationException; import org.junit.jupiter.api.Test; import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.Arguments; import org.junit.jupiter.params.provider.MethodSource; import java.security.InvalidParameterException; import java.util.stream.Stream; import static org.junit.jupiter.api.Assertions.*; import static org.junit.jupiter.params.provider.Arguments.arguments; public class DefaultCodeGeneratorTest { @ParameterizedTest @MethodSource(\"expectedCodesProvider\") public void testCodeIsGenerated(String secret, int time, HashingAlgorithm algorithm, String expectedCode) throws CodeGenerationException { String code = generateCode(algorithm, secret, time); assertEquals(expectedCode, code); } static Stream<Arguments> expectedCodesProvider() { return Stream.of( arguments(\"W3C5B3WKR4AUKFVWYU2WNMYB756OAKWY\", 1567631536, HashingAlgorithm.SHA1, \"082371\"), arguments(\"W3C5B3WKR4AUKFVWYU2WNMYB756OAKWY\", 1567631536, HashingAlgorithm.SHA256, \"272978\"), arguments(\"W3C5B3WKR4AUKFVWYU2WNMYB756OAKWY\", 1567631536, HashingAlgorithm.SHA512, \"325200\"), arguments(\"makrzl2hict4ojeji2iah4kndmq6sgka\", 1582750403, HashingAlgorithm.SHA1, \"848586\"), arguments(\"makrzl2hict4ojeji2iah4kndmq6sgka\", 1582750403, HashingAlgorithm.SHA256, \"965726\"), arguments(\"makrzl2hict4ojeji2iah4kndmq6sgka\", 1582750403, HashingAlgorithm.SHA512, \"741306\") ); } @Test public void testDigitLength() throws CodeGenerationException { DefaultCodeGenerator g = new DefaultCodeGenerator(HashingAlgorithm.SHA1); String code = g.generate(\"W3C5B3WKR4AUKFVWYU2WNMYB756OAKWY\", 1567631536); assertEquals(6, code.length()); g = new DefaultCodeGenerator(HashingAlgorithm.SHA1, 8); code = g.generate(\"W3C5B3WKR4AUKFVWYU2WNMYB756OAKWY\", 1567631536); assertEquals(8, code.length()); g = new DefaultCodeGenerator(HashingAlgorithm.SHA1, 4); code = g.generate(\"W3C5B3WKR4AUKFVWYU2WNMYB756OAKWY\", 1567631536); assertEquals(4, code.length()); } @Test public void testInvalidHashingAlgorithmThrowsException() { assertThrows(InvalidParameterException.class, () -> { new DefaultCodeGenerator(null, 6); }); } @Test public void testInvalidDigitLengthThrowsException() { assertThrows(InvalidParameterException.class, () -> { new DefaultCodeGenerator(HashingAlgorithm.SHA1, 0); }); } @Test public void testInvalidKeyThrowsCodeGenerationException() throws CodeGenerationException { CodeGenerationException e = assertThrows(CodeGenerationException.class, () -> { DefaultCodeGenerator g = new DefaultCodeGenerator(HashingAlgorithm.SHA1, 4); g.generate(\"1234\", 1567631536); }); assertNotNull(e.getCause()); } private String generateCode(HashingAlgorithm algorithm, String secret, int time) throws CodeGenerationException { long currentBucket = Math.floorDiv(time, 30); DefaultCodeGenerator g = new DefaultCodeGenerator(algorithm); return g.generate(secret, currentBucket); } }", "dependencies": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/exceptions/CodeGenerationException.java", "file_content": "package dev.samstevens.totp.exceptions; public class CodeGenerationException extends Exception { public CodeGenerationException(String message, Throwable cause) { super(message, cause); } }"}, {"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/code/DefaultCodeGenerator.java", "file_content": "package dev.samstevens.totp.code; import dev.samstevens.totp.exceptions.CodeGenerationException; import org.apache.commons.codec.binary.Base32; import javax.crypto.Mac; import javax.crypto.spec.SecretKeySpec; import java.security.InvalidKeyException; import java.security.InvalidParameterException; import java.security.NoSuchAlgorithmException; public class DefaultCodeGenerator implements CodeGenerator { private final HashingAlgorithm algorithm; private final int digits; public DefaultCodeGenerator() { this(HashingAlgorithm.SHA1, 6); } public DefaultCodeGenerator(HashingAlgorithm algorithm) { this(algorithm, 6); } public DefaultCodeGenerator(HashingAlgorithm algorithm, int digits) { if (algorithm == null) { throw new InvalidParameterException(\"HashingAlgorithm must not be null.\"); } if (digits < 1) { throw new InvalidParameterException(\"Number of digits must be higher than 0.\"); } this.algorithm = algorithm; this.digits = digits; } @Override public String generate(String key, long counter) throws CodeGenerationException { try { byte[] hash = generateHash(key, counter); return getDigitsFromHash(hash); } catch (Exception e) { throw new CodeGenerationException(\"Failed to generate code. See nested exception.\", e); } } private byte[] generateHash(String key, long counter) throws InvalidKeyException, NoSuchAlgorithmException { byte[] data = new byte[8]; long value = counter; for (int i = 8; i-- > 0; value >>>= 8) { data[i] = (byte) value; } Base32 codec = new Base32(); byte[] decodedKey = codec.decode(key); SecretKeySpec signKey = new SecretKeySpec(decodedKey, algorithm.getHmacAlgorithm()); Mac mac = Mac.getInstance(algorithm.getHmacAlgorithm()); mac.init(signKey); return mac.doFinal(data); } private String getDigitsFromHash(byte[] hash) { int offset = hash[hash.length - 1] & 0xF; long truncatedHash = 0; for (int i = 0; i < 4; ++i) { truncatedHash <<= 8; truncatedHash |= (hash[offset + i] & 0xFF); } truncatedHash &= 0x7FFFFFFF; truncatedHash %= Math.pow(10, digits); return String.format(\"%0\" + digits + \"d\", truncatedHash); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/code/DefaultCodeGenerator.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "Adding a new hashing algorithm requires modifying the HashingAlgorithm enum, forcing DefaultCodeGenerator to depend on concrete implementations instead of being extensible without changing existing code."}, {"principle": "Dependency Inversion", "justification": "DefaultCodeGenerator directly depends on the concrete HashingAlgorithm enum instead of an abstraction, violating the principle that high-level modules should depend on abstractions."}]}]}
{"project_id": 20, "chunk_id": 0, "prompt": {"main_file_path": "java-totp-master/java-totp-master/totp/src/test/java/dev/samstevens/totp/qr/QrDataFactoryTest.java", "main_file_content": "package dev.samstevens.totp.qr; import dev.samstevens.totp.code.HashingAlgorithm; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.*; public class QrDataFactoryTest { @Test public void testFactorySetsDefaultsOnBuilder() { QrDataFactory qrDataFactory = new QrDataFactory(HashingAlgorithm.SHA256, 6, 30); QrData data = qrDataFactory.newBuilder().build(); assertEquals(HashingAlgorithm.SHA256.getFriendlyName(), data.getAlgorithm()); assertEquals(6, data.getDigits()); assertEquals(30, data.getPeriod()); } }", "dependencies": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/code/HashingAlgorithm.java", "file_content": "package dev.samstevens.totp.code; public enum HashingAlgorithm { SHA1(\"HmacSHA1\", \"SHA1\"), SHA256(\"HmacSHA256\", \"SHA256\"), SHA512(\"HmacSHA512\", \"SHA512\"); private final String hmacAlgorithm; private final String friendlyName; HashingAlgorithm(String hmacAlgorithm, String friendlyName) { this.hmacAlgorithm = hmacAlgorithm; this.friendlyName = friendlyName; } public String getHmacAlgorithm() { return hmacAlgorithm; } public String getFriendlyName() { return friendlyName; } }"}, {"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/qr/QrDataFactory.java", "file_content": "package dev.samstevens.totp.qr; import dev.samstevens.totp.code.HashingAlgorithm; public class QrDataFactory { private HashingAlgorithm defaultAlgorithm; private int defaultDigits; private int defaultTimePeriod; public QrDataFactory(HashingAlgorithm defaultAlgorithm, int defaultDigits, int defaultTimePeriod) { this.defaultAlgorithm = defaultAlgorithm; this.defaultDigits = defaultDigits; this.defaultTimePeriod = defaultTimePeriod; } public QrData.Builder newBuilder() { return new QrData.Builder() .algorithm(defaultAlgorithm) .digits(defaultDigits) .period(defaultTimePeriod); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/qr/QrDataFactory.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "QrDataFactory directly depends on the concrete HashingAlgorithm enum in its constructor. High-level modules should depend on abstractions, not concrete implementations."}]}]}
{"project_id": 20, "chunk_id": 0, "prompt": {"main_file_path": "java-totp-master/java-totp-master/totp/src/test/java/dev/samstevens/totp/qr/QrDataTest.java", "main_file_content": "package dev.samstevens.totp.qr; import dev.samstevens.totp.code.HashingAlgorithm; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.*; public class QrDataTest { @Test public void testUriGeneration() { QrData data = new QrData.Builder() .label(\"example@example.com\") .secret(\"the-secret-here\") .issuer(\"AppName AppCorp\") .algorithm(HashingAlgorithm.SHA256) .digits(6) .period(30) .build(); assertEquals( \"otpauth: data.getUri() ); } @Test public void testNullFieldUriGeneration() { QrData data = new QrData.Builder() .label(null) .secret(null) .issuer(\"AppName AppCorp\") .algorithm(HashingAlgorithm.SHA256) .digits(6) .period(30) .build(); assertEquals( \"otpauth: data.getUri() ); } }", "dependencies": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/code/HashingAlgorithm.java", "file_content": "package dev.samstevens.totp.code; public enum HashingAlgorithm { SHA1(\"HmacSHA1\", \"SHA1\"), SHA256(\"HmacSHA256\", \"SHA256\"), SHA512(\"HmacSHA512\", \"SHA512\"); private final String hmacAlgorithm; private final String friendlyName; HashingAlgorithm(String hmacAlgorithm, String friendlyName) { this.hmacAlgorithm = hmacAlgorithm; this.friendlyName = friendlyName; } public String getHmacAlgorithm() { return hmacAlgorithm; } public String getFriendlyName() { return friendlyName; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/code/HashingAlgorithm.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "HashingAlgorithm is an enum that cannot be extended without modifying its source code to add new algorithms, violating the Open/Closed Principle."}]}]}
{"project_id": 20, "chunk_id": 0, "prompt": {"main_file_path": "java-totp-master/java-totp-master/totp/src/test/java/dev/samstevens/totp/qr/ZxingPngQrGeneratorTest.java", "main_file_content": "package dev.samstevens.totp.qr; import com.google.zxing.Writer; import com.google.zxing.WriterException; import dev.samstevens.totp.exceptions.QrGenerationException; import org.junit.jupiter.api.Test; import javax.imageio.ImageIO; import java.awt.image.BufferedImage; import java.io.File; import java.io.IOException; import static dev.samstevens.totp.IOUtils.*; import static org.junit.jupiter.api.Assertions.*; import static org.mockito.ArgumentMatchers.*; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.when; public class ZxingPngQrGeneratorTest { @Test public void testSomething() throws QrGenerationException, IOException { ZxingPngQrGenerator generator = new ZxingPngQrGenerator(); QrData data = new QrData.Builder() .label(\"example@example.com\") .secret(\"EX47GINFPBK5GNLYLILGD2H6ZLGJNNWB\") .issuer(\"AppName\") .digits(6) .period(30) .build(); writeFile(generator.generate(data), \"./test_qr.png\"); } @Test public void testMimeType() { assertEquals(\"image/png\", new ZxingPngQrGenerator().getImageMimeType()); } @Test public void testImageSize() throws QrGenerationException, IOException { ZxingPngQrGenerator generator = new ZxingPngQrGenerator(); generator.setImageSize(500); byte[] data = generator.generate(getData()); String filename = \"/tmp/test_qr.png\"; writeFile(data, filename); File file = new File(filename); BufferedImage image = ImageIO.read(file); assertEquals(500, generator.getImageSize()); assertEquals(500, image.getWidth()); assertEquals(500, image.getHeight()); file.delete(); } @Test public void testExceptionIsWrapped() throws WriterException { Throwable exception = new RuntimeException(); Writer writer = mock(Writer.class); when(writer.encode(anyString(), any(), anyInt(), anyInt())).thenThrow(exception); ZxingPngQrGenerator generator = new ZxingPngQrGenerator(writer); QrGenerationException e = assertThrows(QrGenerationException.class, () -> { generator.generate(getData()); }); assertEquals(\"Failed to generate QR code. See nested exception.\", e.getMessage()); assertEquals(exception, e.getCause()); } private QrData getData() { return new QrData.Builder() .label(\"example@example.com\") .secret(\"EX47GINFPBK5GNLYLILGD2H6ZLGJNNWB\") .issuer(\"AppName\") .digits(6) .period(30) .build(); } }", "dependencies": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/exceptions/QrGenerationException.java", "file_content": "package dev.samstevens.totp.exceptions; public class QrGenerationException extends Exception { public QrGenerationException(String message, Throwable cause) { super(message, cause); } }"}, {"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/qr/ZxingPngQrGenerator.java", "file_content": "package dev.samstevens.totp.qr; import com.google.zxing.BarcodeFormat; import com.google.zxing.Writer; import com.google.zxing.client.j2se.MatrixToImageWriter; import com.google.zxing.common.BitMatrix; import com.google.zxing.qrcode.QRCodeWriter; import dev.samstevens.totp.exceptions.QrGenerationException; import java.io.ByteArrayOutputStream; public class ZxingPngQrGenerator implements QrGenerator { private final Writer writer; private int imageSize = 350; public ZxingPngQrGenerator() { this(new QRCodeWriter()); } public ZxingPngQrGenerator(Writer writer) { this.writer = writer; } public void setImageSize(int imageSize) { this.imageSize = imageSize; } public int getImageSize() { return imageSize; } public String getImageMimeType() { return \"image/png\"; } @Override public byte[] generate(QrData data) throws QrGenerationException { try { BitMatrix bitMatrix = writer.encode(data.getUri(), BarcodeFormat.QR_CODE, imageSize, imageSize); ByteArrayOutputStream pngOutputStream = new ByteArrayOutputStream(); MatrixToImageWriter.writeToStream(bitMatrix, \"PNG\", pngOutputStream); return pngOutputStream.toByteArray(); } catch (Exception e) { throw new QrGenerationException(\"Failed to generate QR code. See nested exception.\", e); } } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/qr/ZxingPngQrGenerator.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "ZxingPngQrGenerator directly depends on the concrete MatrixToImageWriter class (low-level module) instead of an abstraction for image writing, violating DIP."}]}]}
{"project_id": 20, "chunk_id": 0, "prompt": {"main_file_path": "java-totp-master/java-totp-master/totp/src/test/java/dev/samstevens/totp/time/NtpTimeProviderTest.java", "main_file_content": "package dev.samstevens.totp.time; import dev.samstevens.totp.exceptions.TimeProviderException; import org.junit.jupiter.api.Test; import java.net.UnknownHostException; import static org.junit.jupiter.api.Assertions.*; public class NtpTimeProviderTest { @Test public void testProvidesTime() throws UnknownHostException { TimeProvider time = new NtpTimeProvider(\"pool.ntp.org\"); long currentTime = time.getTime(); assertEquals(10, String.valueOf(currentTime).length()); } @Test public void testUnknownHostThrowsException() { assertThrows(UnknownHostException.class, () -> { new NtpTimeProvider(\"sdfsf/safsf\"); }); } @Test public void testNonNtpHostThrowsException() throws UnknownHostException { TimeProvider time = new NtpTimeProvider(\"www.example.com\"); TimeProviderException e = assertThrows(TimeProviderException.class, time::getTime); assertNotNull(e.getCause()); } @Test public void testRequiresDependency() { RuntimeException e = assertThrows(RuntimeException.class, () -> { new NtpTimeProvider(\"www.example.com\", \"fake.class.Here\"); }); assertEquals(\"The Apache Commons Net library must be on the classpath to use the NtpTimeProvider.\", e.getMessage()); } }", "dependencies": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/exceptions/TimeProviderException.java", "file_content": "package dev.samstevens.totp.exceptions; public class TimeProviderException extends RuntimeException { public TimeProviderException(String message) { super(message); } public TimeProviderException(String message, Throwable cause) { super(message, cause); } }"}, {"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/time/NtpTimeProvider.java", "file_content": "package dev.samstevens.totp.time; import dev.samstevens.totp.exceptions.TimeProviderException; import org.apache.commons.net.ntp.NTPUDPClient; import org.apache.commons.net.ntp.TimeInfo; import java.net.InetAddress; import java.net.UnknownHostException; public class NtpTimeProvider implements TimeProvider { private final NTPUDPClient client; private final InetAddress ntpHost; public NtpTimeProvider(String ntpHostname) throws UnknownHostException { this(ntpHostname, 3000); } public NtpTimeProvider(String ntpHostname, int timeout) throws UnknownHostException { this(ntpHostname, timeout, \"org.apache.commons.net.ntp.NTPUDPClient\"); } NtpTimeProvider(String ntpHostname, String dependentClass) throws UnknownHostException { this(ntpHostname, 3000, dependentClass); } private NtpTimeProvider(String ntpHostname, int timeout, String dependentClass) throws UnknownHostException { checkHasDependency(dependentClass); client = new NTPUDPClient(); client.setDefaultTimeout(timeout); ntpHost = InetAddress.getByName(ntpHostname); } @Override public long getTime() throws TimeProviderException { TimeInfo timeInfo; try { timeInfo = client.getTime(ntpHost); timeInfo.computeDetails(); } catch (Exception e) { throw new TimeProviderException(\"Failed to provide time from NTP server. See nested exception.\", e); } if (timeInfo.getOffset() == null) { throw new TimeProviderException(\"Failed to calculate NTP offset\"); } return (System.currentTimeMillis() + timeInfo.getOffset()) / 1000; } private void checkHasDependency(String dependentClass) { try { Class<?> ntpClientClass = Class.forName(dependentClass); } catch (ClassNotFoundException e) { throw new RuntimeException(\"The Apache Commons Net library must be on the classpath to use the NtpTimeProvider.\"); } } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/time/NtpTimeProvider.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "NtpTimeProvider handles both time retrieval and dependency checks, introducing multiple reasons to change if either responsibility evolves."}, {"principle": "Dependency Inversion", "justification": "NtpTimeProvider directly depends on the concrete NTPUDPClient from Apache Commons Net instead of an abstraction, violating the principle that high-level modules should depend on abstractions."}]}]}
{"project_id": 20, "chunk_id": 0, "prompt": {"main_file_path": "java-totp-master/java-totp-master/totp/src/test/java/dev/samstevens/totp/time/SystemTimeProviderTest.java", "main_file_content": "package dev.samstevens.totp.time; import org.junit.jupiter.api.Test; import java.time.Instant; import static org.junit.jupiter.api.Assertions.*; public class SystemTimeProviderTest { @Test public void testProvidesTime() { long currentTime = Instant.now().getEpochSecond(); TimeProvider time = new SystemTimeProvider(); long providedTime = time.getTime(); assertTrue(currentTime - 5 <= providedTime); assertTrue(providedTime <= currentTime + 5); assertEquals(10, String.valueOf(currentTime).length()); } }", "dependencies": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/time/SystemTimeProvider.java", "file_content": "package dev.samstevens.totp.time; import dev.samstevens.totp.exceptions.TimeProviderException; import java.time.Instant; public class SystemTimeProvider implements TimeProvider { @Override public long getTime() throws TimeProviderException { return Instant.now().getEpochSecond(); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 20, "chunk_id": 0, "prompt": {"main_file_path": "java-totp-master/java-totp-master/totp/src/test/java/dev/samstevens/totp/secret/DefaultSecretGeneratorTest.java", "main_file_content": "package dev.samstevens.totp.secret; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.*; public class DefaultSecretGeneratorTest { @Test public void testSecretGenerated() { DefaultSecretGenerator generator = new DefaultSecretGenerator(); String secret = generator.generate(); assertNotNull(secret); assertTrue(secret.length() > 0); } @Test public void testCharacterLengths() { for (int charCount : new int[]{16, 32, 64, 128}) { DefaultSecretGenerator generator = new DefaultSecretGenerator(charCount); String secret = generator.generate(); assertEquals(charCount, secret.length()); } } @Test public void testValidBase32Encoded() { DefaultSecretGenerator generator = new DefaultSecretGenerator(); String secret = generator.generate(); assertTrue(secret.matches(\"^[A-Z2-7]+=*$\")); assertEquals(0, secret.length() % 8); } }", "dependencies": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/secret/DefaultSecretGenerator.java", "file_content": "package dev.samstevens.totp.secret; import org.apache.commons.codec.binary.Base32; import java.security.SecureRandom; @SuppressWarnings(\"WeakerAccess\") public class DefaultSecretGenerator implements SecretGenerator { private final SecureRandom randomBytes = new SecureRandom(); private final static Base32 encoder = new Base32(); private final int numCharacters; public DefaultSecretGenerator() { this.numCharacters = 32; } public DefaultSecretGenerator(int numCharacters) { this.numCharacters = numCharacters; } @Override public String generate() { return new String(encoder.encode(getRandomBytes())); } private byte[] getRandomBytes() { byte[] bytes = new byte[(numCharacters * 5) / 8]; randomBytes.nextBytes(bytes); return bytes; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "java-totp-master/java-totp-master/totp/src/main/java/dev/samstevens/totp/secret/DefaultSecretGenerator.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "DefaultSecretGenerator uses a hardcoded Base32 encoder. Changing the encoding algorithm requires modifying the class instead of extending it."}, {"principle": "Dependency Inversion", "justification": "DefaultSecretGenerator directly depends on the concrete Base32 class from Apache Commons instead of an abstraction for encoding."}]}]}
{"project_id": 21, "chunk_id": 0, "prompt": {"main_file_path": "Hotel-Reservation-System-using-JDBC-main/src/App.java", "main_file_content": "import java.util.List; import java.util.ListIterator; import java.util.Scanner; import in.model.Guest; import in.service.ServiceP; public class App { public static void main(String[] args) { Scanner sc = new Scanner(System.in); ServiceP service = new ServiceP(); soutl(\"\") while (true) { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") sout(\"\") int choice = sc.nextInt(); sc.nextLine(); switch (choice) { case 0: sc.close(); service.Exit(); System.exit(0); break; case 1: sout(\"\") String guestName = sc.nextLine(); int room_number; boolean roomStatus; do { sout(\"\") room_number = sc.nextInt(); roomStatus = service.checkRoomNumber(room_number); if (roomStatus) soutl(\"\") if(room_number == 0) soutl(\"\") } while ( roomStatus || room_number == 0); sc.nextLine(); sout(\"\") String contact_number = sc.nextLine(); Guest g = new Guest(guestName, room_number, contact_number); service.reserveRoom(g); break; case 2: List<Guest> viewReservations = service.viewReservations(); if (viewReservations.isEmpty()) { soutl(\"\") } ListIterator<Guest> listIterator = viewReservations.listIterator(); while (listIterator.hasNext()) { soutl(\"\") soutl(\"\") } soutl(\"\") break; case 3: sout(\"\") int id = sc.nextInt(); soutl(\"\") break; case 4: sout(\"\") id = sc.nextInt(); if(service.checkById(id)){ soutl(\"\") break; } sc.nextLine(); sout(\"\") guestName = sc.nextLine(); do { sout(\"\") room_number = sc.nextInt(); roomStatus = service.checkRoomNumber(room_number); if (roomStatus) soutl(\"\") if(room_number == 0) soutl(\"\") } while ( roomStatus || room_number == 0); sc.nextLine(); sout(\"\") contact_number = sc.nextLine(); g = new Guest(guestName, room_number, contact_number); String status = (service.updateReservation(id, g)) ? \"Successfully Updated\" : \"Unsuccessful due to some error\"; soutl(\"\") break; case 5: sout(\"\") id = sc.nextInt(); if (service.checkById(id)) { soutl(\"\") break; } status = (service.deleteReservation(id)) ? \"Successfully Deleted\":\"Unsuccessful due to some error\"; soutl(\"\") break; default: soutl(\"\") } } } }", "dependencies": [{"file_path": "Hotel-Reservation-System-using-JDBC-main/src/in/model/Guest.java", "file_content": "package in.model; import java.time.LocalDateTime; public class Guest { private int id; private String guest_name; private int room_number; private String contact_number; private LocalDateTime reservation_date; public Guest(String guest_name, int room_number, String contact_number) { this.guest_name = guest_name; this.room_number = room_number; this.contact_number = contact_number; } public Guest(int id, String guest_name, int room_number, String contact_number, LocalDateTime reservation_date) { this(guest_name,room_number,contact_number); this.id = id; this.reservation_date = reservation_date; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getGuest_name() { return guest_name; } public void setGuest_name(String guest_name) { this.guest_name = guest_name; } public int getRoom_number() { return room_number; } public void setRoom_number(int room_number) { this.room_number = room_number; } public String getContact_number() { return contact_number; } public void setContact_number(String contact_number) { this.contact_number = contact_number; } public LocalDateTime getReservation_date() { return reservation_date; } public void setReservation_date(LocalDateTime reservation_date) { this.reservation_date = reservation_date; } @Override public String toString() { return \"Guest [id=\" + id + \", guest_name=\" + guest_name + \", room_number=\" + room_number + \", contact_number=\" + contact_number + \", reservation_date=\" + reservation_date.toLocalDate() + \"]\"; } }"}, {"file_path": "Hotel-Reservation-System-using-JDBC-main/src/in/service/ServiceP.java", "file_content": "package in.service; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import java.sql.Timestamp; import java.time.LocalDateTime; import java.util.ArrayList; import java.util.List; import in.manage.ConnectionProvider; import in.model.Guest; public class ServiceP { Connection con; public ServiceP() { ConnectionProvider p = new ConnectionProvider(); con = p.creaConnection(); } public boolean reserveRoom(Guest g) { String q = \"INSERT INTO reservations(guest_name,room_number,contact_number) VALUES(?,?,?)\"; try { PreparedStatement pst = con.prepareStatement(q); pst.setString(1, g.getGuest_name()); pst.setInt(2, g.getRoom_number()); pst.setString(3, g.getContact_number()); int rowEffect = pst.executeUpdate(); pst.close(); return rowEffect > 0; } catch (SQLException e) { soutl(\"\") } return false; } public List<Guest> viewReservations() { List<Guest> guests = new ArrayList<>(); try { Statement st = con.createStatement(); ResultSet rs = st.executeQuery(\"SELECT * FROM reservations;\"); while (rs.next()) { int id = rs.getInt(\"reservation_id\"); String name = rs.getString(\"guest_name\"); int room_number = rs.getInt(\"room_number\"); String contact_number = rs.getString(\"contact_number\"); Timestamp tp = rs.getTimestamp(\"reservation_date\"); LocalDateTime date = tp.toLocalDateTime(); Guest g = new Guest(id, name, room_number, contact_number, date); guests.add(g); } rs.close(); } catch (SQLException e) { soutl(\"\") } return guests; } public int getRoomNumber(int id) { int roomNumber = -1; String query = \"SELECT room_number FROM reservations WHERE reservation_id = ?\"; try { PreparedStatement pst = con.prepareStatement(query); pst.setInt(1, id); ResultSet rs = pst.executeQuery(); if (rs.next()) { roomNumber = rs.getInt(\"room_number\"); } rs.close(); pst.close(); } catch (SQLException e) { soutl(\"\") } return roomNumber; } public boolean updateReservation(int id, Guest g) { boolean status = false; String query = \"UPDATE reservations SET guest_name = ?, room_number = ?, contact_number = ? WHERE reservation_id = ?\"; try { PreparedStatement pst = con.prepareStatement(query); pst.setString(1, g.getGuest_name()); pst.setInt(2, g.getRoom_number()); pst.setString(3, g.getContact_number()); pst.setInt(4, id); int rowsAffected = pst.executeUpdate(); status = rowsAffected > 0; pst.close(); } catch (SQLException e) { soutl(\"\") } return status; } public boolean deleteReservation(int id) { boolean status = false; String query = \"DELETE FROM reservations WHERE reservation_id = ?\"; try { PreparedStatement pst = con.prepareStatement(query); pst.setInt(1, id); int rowsAffected = pst.executeUpdate(); status = rowsAffected > 0; } catch (SQLException e) { soutl(\"\") } return status; } public void Exit(){ try { con.close(); soutl(\"\") } catch (SQLException e) { e.printStackTrace(); } } public boolean checkById(int id) { int roomNumber = getRoomNumber(id); return roomNumber == -1; } public boolean checkRoomNumber(int room_number) { int count = 0; String query = \"select count(guest_name) from reservations where room_number =?\"; try (PreparedStatement pst = con.prepareStatement(query)) { pst.setInt(1, room_number); ResultSet rs = pst.executeQuery(); if (rs.next()) { count = rs.getInt(1); } } catch (SQLException e) { e.printStackTrace(); } return count > 0; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Hotel-Reservation-System-using-JDBC-main/src/App.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The App class handles multiple responsibilities: user input handling, menu presentation, and controlling application flow, which violates SRP by having more than one reason to change."}, {"principle": "Dependency Inversion", "justification": "App directly instantiates the concrete ServiceP class instead of depending on an abstraction, violating DIP by coupling high-level modules to low-level implementations."}]}, {"file_path": "Hotel-Reservation-System-using-JDBC-main/src/in/service/ServiceP.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "ServiceP manages database connections, executes CRUD operations, and implements business logic (e.g., checkRoomNumber), violating SRP by combining multiple responsibilities."}, {"principle": "Open-Closed", "justification": "ServiceP is not designed for extension (e.g., adding new reservation behaviors requires modifying existing code), violating OCP by failing to allow closed modification."}, {"principle": "Dependency Inversion", "justification": "ServiceP directly instantiates ConnectionProvider, a concrete low-level module, violating DIP by not depending on abstractions for database connectivity."}]}]}
{"project_id": 21, "chunk_id": 0, "prompt": {"main_file_path": "Hotel-Reservation-System-using-JDBC-main/src/in/model/Guest.java", "main_file_content": "package in.model; import java.time.LocalDateTime; public class Guest { private int id; private String guest_name; private int room_number; private String contact_number; private LocalDateTime reservation_date; public Guest(String guest_name, int room_number, String contact_number) { this.guest_name = guest_name; this.room_number = room_number; this.contact_number = contact_number; } public Guest(int id, String guest_name, int room_number, String contact_number, LocalDateTime reservation_date) { this(guest_name,room_number,contact_number); this.id = id; this.reservation_date = reservation_date; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getGuest_name() { return guest_name; } public void setGuest_name(String guest_name) { this.guest_name = guest_name; } public int getRoom_number() { return room_number; } public void setRoom_number(int room_number) { this.room_number = room_number; } public String getContact_number() { return contact_number; } public void setContact_number(String contact_number) { this.contact_number = contact_number; } public LocalDateTime getReservation_date() { return reservation_date; } public void setReservation_date(LocalDateTime reservation_date) { this.reservation_date = reservation_date; } @Override public String toString() { return \"Guest [id=\" + id + \", guest_name=\" + guest_name + \", room_number=\" + room_number + \", contact_number=\" + contact_number + \", reservation_date=\" + reservation_date.toLocalDate() + \"]\"; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Hotel-Reservation-System-using-JDBC-main/src/in/model/Guest.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Guest class handles data storage (properties) and formatting (toString), which are two distinct responsibilities. Formatting logic should be decoupled into a separate class."}]}]}
{"project_id": 21, "chunk_id": 0, "prompt": {"main_file_path": "Hotel-Reservation-System-using-JDBC-main/src/in/manage/ConnectionProvider.java", "main_file_content": "package in.manage; import java.sql.Connection; import java.sql.DriverManager; import java.sql.SQLException; import java.util.Properties; public class ConnectionProvider { static Connection conn; private String url =\"jdbc:mysql: private String user =\"${DB_USER}\"; private String password=\"${DB_PASSWORD}\"; public ConnectionProvider(){ System.setProperty(\"DB_HOST\", \"localhost\"); System.setProperty(\"DB_PORT\", \"3306\"); System.setProperty(\"DB_NAME\", \"hotel_db\"); System.setProperty(\"DB_USER\",\"root\"); System.setProperty(\"DB_PASSWORD\", \"sql@24\"); url = replacePlaceholders(url); user = replacePlaceholders(user); password = replacePlaceholders(password); } public Connection creaConnection() { if (conn != null) { return conn; } try { Class.forName(\"com.mysql.cj.jdbc.Driver\"); } catch (ClassNotFoundException ce) { ce.getMessage(); } try { conn = DriverManager.getConnection(url, user, password); } catch (SQLException e) { soutl(\"\") } return conn; } private String replacePlaceholders(String input) { Properties props = System.getProperties(); for (String key : props.stringPropertyNames()) { input = input.replace(\"${\" + key + \"}\", props.getProperty(key)); } return input; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Hotel-Reservation-System-using-JDBC-main/src/in/manage/ConnectionProvider.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The class handles both connection configuration (setting system properties, replacing placeholders) and connection creation, violating SRP by having multiple responsibilities."}, {"principle": "Dependency Inversion", "justification": "High-level connection creation directly depends on low-level concrete JDBC DriverManager and MySQL driver, instead of abstractions like DataSource interfaces."}]}]}
{"project_id": 21, "chunk_id": 0, "prompt": {"main_file_path": "Hotel-Reservation-System-using-JDBC-main/src/in/service/ServiceP.java", "main_file_content": "package in.service; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import java.sql.Timestamp; import java.time.LocalDateTime; import java.util.ArrayList; import java.util.List; import in.manage.ConnectionProvider; import in.model.Guest; public class ServiceP { Connection con; public ServiceP() { ConnectionProvider p = new ConnectionProvider(); con = p.creaConnection(); } public boolean reserveRoom(Guest g) { String q = \"INSERT INTO reservations(guest_name,room_number,contact_number) VALUES(?,?,?)\"; try { PreparedStatement pst = con.prepareStatement(q); pst.setString(1, g.getGuest_name()); pst.setInt(2, g.getRoom_number()); pst.setString(3, g.getContact_number()); int rowEffect = pst.executeUpdate(); pst.close(); return rowEffect > 0; } catch (SQLException e) { soutl(\"\") } return false; } public List<Guest> viewReservations() { List<Guest> guests = new ArrayList<>(); try { Statement st = con.createStatement(); ResultSet rs = st.executeQuery(\"SELECT * FROM reservations;\"); while (rs.next()) { int id = rs.getInt(\"reservation_id\"); String name = rs.getString(\"guest_name\"); int room_number = rs.getInt(\"room_number\"); String contact_number = rs.getString(\"contact_number\"); Timestamp tp = rs.getTimestamp(\"reservation_date\"); LocalDateTime date = tp.toLocalDateTime(); Guest g = new Guest(id, name, room_number, contact_number, date); guests.add(g); } rs.close(); } catch (SQLException e) { soutl(\"\") } return guests; } public int getRoomNumber(int id) { int roomNumber = -1; String query = \"SELECT room_number FROM reservations WHERE reservation_id = ?\"; try { PreparedStatement pst = con.prepareStatement(query); pst.setInt(1, id); ResultSet rs = pst.executeQuery(); if (rs.next()) { roomNumber = rs.getInt(\"room_number\"); } rs.close(); pst.close(); } catch (SQLException e) { soutl(\"\") } return roomNumber; } public boolean updateReservation(int id, Guest g) { boolean status = false; String query = \"UPDATE reservations SET guest_name = ?, room_number = ?, contact_number = ? WHERE reservation_id = ?\"; try { PreparedStatement pst = con.prepareStatement(query); pst.setString(1, g.getGuest_name()); pst.setInt(2, g.getRoom_number()); pst.setString(3, g.getContact_number()); pst.setInt(4, id); int rowsAffected = pst.executeUpdate(); status = rowsAffected > 0; pst.close(); } catch (SQLException e) { soutl(\"\") } return status; } public boolean deleteReservation(int id) { boolean status = false; String query = \"DELETE FROM reservations WHERE reservation_id = ?\"; try { PreparedStatement pst = con.prepareStatement(query); pst.setInt(1, id); int rowsAffected = pst.executeUpdate(); status = rowsAffected > 0; } catch (SQLException e) { soutl(\"\") } return status; } public void Exit(){ try { con.close(); soutl(\"\") } catch (SQLException e) { e.printStackTrace(); } } public boolean checkById(int id) { int roomNumber = getRoomNumber(id); return roomNumber == -1; } public boolean checkRoomNumber(int room_number) { int count = 0; String query = \"select count(guest_name) from reservations where room_number =?\"; try (PreparedStatement pst = con.prepareStatement(query)) { pst.setInt(1, room_number); ResultSet rs = pst.executeQuery(); if (rs.next()) { count = rs.getInt(1); } } catch (SQLException e) { e.printStackTrace(); } return count > 0; } }", "dependencies": [{"file_path": "Hotel-Reservation-System-using-JDBC-main/src/in/manage/ConnectionProvider.java", "file_content": "package in.manage; import java.sql.Connection; import java.sql.DriverManager; import java.sql.SQLException; import java.util.Properties; public class ConnectionProvider { static Connection conn; private String url =\"jdbc:mysql: private String user =\"${DB_USER}\"; private String password=\"${DB_PASSWORD}\"; public ConnectionProvider(){ System.setProperty(\"DB_HOST\", \"localhost\"); System.setProperty(\"DB_PORT\", \"3306\"); System.setProperty(\"DB_NAME\", \"hotel_db\"); System.setProperty(\"DB_USER\",\"root\"); System.setProperty(\"DB_PASSWORD\", \"sql@24\"); url = replacePlaceholders(url); user = replacePlaceholders(user); password = replacePlaceholders(password); } public Connection creaConnection() { if (conn != null) { return conn; } try { Class.forName(\"com.mysql.cj.jdbc.Driver\"); } catch (ClassNotFoundException ce) { ce.getMessage(); } try { conn = DriverManager.getConnection(url, user, password); } catch (SQLException e) { soutl(\"\") } return conn; } private String replacePlaceholders(String input) { Properties props = System.getProperties(); for (String key : props.stringPropertyNames()) { input = input.replace(\"${\" + key + \"}\", props.getProperty(key)); } return input; } }"}, {"file_path": "Hotel-Reservation-System-using-JDBC-main/src/in/model/Guest.java", "file_content": "package in.model; import java.time.LocalDateTime; public class Guest { private int id; private String guest_name; private int room_number; private String contact_number; private LocalDateTime reservation_date; public Guest(String guest_name, int room_number, String contact_number) { this.guest_name = guest_name; this.room_number = room_number; this.contact_number = contact_number; } public Guest(int id, String guest_name, int room_number, String contact_number, LocalDateTime reservation_date) { this(guest_name,room_number,contact_number); this.id = id; this.reservation_date = reservation_date; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getGuest_name() { return guest_name; } public void setGuest_name(String guest_name) { this.guest_name = guest_name; } public int getRoom_number() { return room_number; } public void setRoom_number(int room_number) { this.room_number = room_number; } public String getContact_number() { return contact_number; } public void setContact_number(String contact_number) { this.contact_number = contact_number; } public LocalDateTime getReservation_date() { return reservation_date; } public void setReservation_date(LocalDateTime reservation_date) { this.reservation_date = reservation_date; } @Override public String toString() { return \"Guest [id=\" + id + \", guest_name=\" + guest_name + \", room_number=\" + room_number + \", contact_number=\" + contact_number + \", reservation_date=\" + reservation_date.toLocalDate() + \"]\"; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Hotel-Reservation-System-using-JDBC-main/src/in/service/ServiceP.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "ServiceP handles database connection management, CRUD operations, and reservation validation. Combining persistence logic, business rules, and connection lifecycle management violates SRP."}, {"principle": "Dependency Inversion", "justification": "ServiceP directly instantiates ConnectionProvider (concrete class) in its constructor. High-level modules should depend on abstractions for database connections, not concrete implementations."}]}, {"file_path": "Hotel-Reservation-System-using-JDBC-main/src/in/manage/ConnectionProvider.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "ConnectionProvider handles both connection pooling and environment configuration (system property management). These are two distinct responsibilities that should be separated."}]}]}
{"project_id": 25, "chunk_id": 0, "prompt": {"main_file_path": "Project_Register_Customers-main/Project_Register_Customers-main/src/main/java/com/api/registercustomers/RegisterCustomersApplication.java", "main_file_content": "package com.api.registercustomers; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @SpringBootApplication @RestController public class RegisterCustomersApplication { public static void main(String[] args) { SpringApplication.run(RegisterCustomersApplication.class, args); } @GetMapping(\"/\") public String index() { return \"Ol\u00e1 mundo!\"; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Project_Register_Customers-main/Project_Register_Customers-main/src/main/java/com/api/registercustomers/RegisterCustomersApplication.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The class combines application bootstrapping (SpringApplication.run) and request handling (@RestController/@GetMapping), violating SRP by having multiple responsibilities."}]}]}
{"project_id": 25, "chunk_id": 0, "prompt": {"main_file_path": "Project_Register_Customers-main/Project_Register_Customers-main/src/main/java/com/api/registercustomers/repositories/CustomerRepository.java", "main_file_content": "package com.api.registercustomers.repositories; import java.util.UUID; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.stereotype.Repository; import com.api.registercustomers.models.CustomerModel; @Repository public interface CustomerRepository extends JpaRepository<CustomerModel, UUID> { }", "dependencies": [{"file_path": "Project_Register_Customers-main/Project_Register_Customers-main/src/main/java/com/api/registercustomers/models/CustomerModel.java", "file_content": "package com.api.registercustomers.models; import jakarta.persistence.Column; import jakarta.persistence.Entity; import jakarta.persistence.GeneratedValue; import jakarta.persistence.GenerationType; import jakarta.persistence.Id; import jakarta.persistence.Table; import java.io.Serializable; import java.util.UUID; @Entity @Table(name = \"TB_CUSTOMER\") public class CustomerModel implements Serializable{ private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.AUTO) private UUID id; @Column(nullable = false, length = 60) private String nome; @Column(nullable = false, length = 60) private String sobrenome; @Column(nullable = false, length = 3) private String idade; @Column(nullable = false, length = 20) private String tipoCustomer; public UUID getId() { return id; } public void setId(UUID id) { this.id = id; } public String getNome() { return nome; } public void setNome(String nome) { this.nome = nome; } public String getSobrenome() { return sobrenome; } public void setSobrenome(String sobrenome) { this.sobrenome = sobrenome; } public String getIdade() { return idade; } public void setIdade(String idade) { this.idade = idade; } public String getTipoCustomer() { return tipoCustomer; } public void setTipoCustomer(String tipoCustomer) { this.tipoCustomer = tipoCustomer; } public static long getSerialversionuid() { return serialVersionUID; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 25, "chunk_id": 0, "prompt": {"main_file_path": "Project_Register_Customers-main/Project_Register_Customers-main/src/main/java/com/api/registercustomers/models/CustomerModel.java", "main_file_content": "package com.api.registercustomers.models; import jakarta.persistence.Column; import jakarta.persistence.Entity; import jakarta.persistence.GeneratedValue; import jakarta.persistence.GenerationType; import jakarta.persistence.Id; import jakarta.persistence.Table; import java.io.Serializable; import java.util.UUID; @Entity @Table(name = \"TB_CUSTOMER\") public class CustomerModel implements Serializable{ private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.AUTO) private UUID id; @Column(nullable = false, length = 60) private String nome; @Column(nullable = false, length = 60) private String sobrenome; @Column(nullable = false, length = 3) private String idade; @Column(nullable = false, length = 20) private String tipoCustomer; public UUID getId() { return id; } public void setId(UUID id) { this.id = id; } public String getNome() { return nome; } public void setNome(String nome) { this.nome = nome; } public String getSobrenome() { return sobrenome; } public void setSobrenome(String sobrenome) { this.sobrenome = sobrenome; } public String getIdade() { return idade; } public void setIdade(String idade) { this.idade = idade; } public String getTipoCustomer() { return tipoCustomer; } public void setTipoCustomer(String tipoCustomer) { this.tipoCustomer = tipoCustomer; } public static long getSerialversionuid() { return serialVersionUID; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Project_Register_Customers-main/Project_Register_Customers-main/src/main/java/com/api/registercustomers/models/CustomerModel.java", "violatedPrinciples": []}]}
{"project_id": 25, "chunk_id": 0, "prompt": {"main_file_path": "Project_Register_Customers-main/Project_Register_Customers-main/src/main/java/com/api/registercustomers/dtos/CustomerDTO.java", "main_file_content": "package com.api.registercustomers.dtos; import jakarta.validation.constraints.NotBlank; public class CustomerDTO { @NotBlank private String nome; @NotBlank private String sobrenome; @NotBlank private String idade; @NotBlank private String tipoCustomer; public String getNome() { return nome; } public void setNome(String nome) { this.nome = nome; } public String getSobrenome() { return sobrenome; } public void setSobrenome(String sobrenome) { this.sobrenome = sobrenome; } public String getIdade() { return idade; } public void setIdade(String idade) { this.idade = idade; } public String getTipoCustomer() { return tipoCustomer; } public void setTipoCustomer(String tipoCustomer) { this.tipoCustomer = tipoCustomer; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Project_Register_Customers-main/Project_Register_Customers-main/src/main/java/com/api/registercustomers/dtos/CustomerDTO.java", "violatedPrinciples": []}]}
{"project_id": 25, "chunk_id": 0, "prompt": {"main_file_path": "Project_Register_Customers-main/Project_Register_Customers-main/src/main/java/com/api/registercustomers/controllers/CustomerController.java", "main_file_content": "package com.api.registercustomers.controllers; import java.util.List; import java.util.Optional; import java.util.UUID; import org.springframework.beans.BeanUtils; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.CrossOrigin; import org.springframework.web.bind.annotation.DeleteMapping; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.PutMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import com.api.registercustomers.dtos.CustomerDTO; import com.api.registercustomers.models.CustomerModel; import com.api.registercustomers.services.CustomerService; import jakarta.validation.Valid; @RestController @CrossOrigin(origins = \"*\", maxAge = 3600) @RequestMapping(\"/customers\") public class CustomerController { final CustomerService customerService; public CustomerController(CustomerService customerService) { this.customerService = customerService; } @PostMapping public ResponseEntity<Object> saveCustomer(@RequestBody @Valid CustomerDTO customerDTO) { var customerModel = new CustomerModel(); BeanUtils.copyProperties(customerDTO, customerModel); return ResponseEntity.status(HttpStatus.CREATED).body(customerService.save(customerModel)); } @GetMapping public ResponseEntity<List<CustomerModel>> getAllCustomers(){ return ResponseEntity.status(HttpStatus.OK).body(customerService.findAll()); } @GetMapping(\"/{id}\") public ResponseEntity<Object> getOneCustomer(@PathVariable(value = \"id\") UUID id) { Optional<CustomerModel> customerModelOptional = customerService.findById(id); if(!customerModelOptional.isPresent()) { return ResponseEntity.status(HttpStatus.NOT_FOUND).body(\"Cliente n\u00e3o encontrado!\"); } return ResponseEntity.status(HttpStatus.OK).body(customerModelOptional.get()); } @PutMapping(\"/{id}\") public ResponseEntity<Object> update(@PathVariable(value = \"id\") UUID id, @RequestBody @Valid CustomerDTO customerDto) { Optional<CustomerModel> customerModelOptional = customerService.findById(id); if(!customerModelOptional.isPresent()) { return ResponseEntity.status(HttpStatus.NOT_FOUND).body(\"Cliente n\u00e3o encontrado!\"); } var customerModel = customerModelOptional.get(); customerModel.setIdade(customerDto.getIdade()); customerModel.setNome(customerDto.getNome()); customerModel.setSobrenome(customerDto.getSobrenome()); customerModel.setTipoCustomer(customerDto.getTipoCustomer()); return ResponseEntity.status(HttpStatus.OK).body(customerService.save(customerModel)); } @DeleteMapping(\"/{id}\") public ResponseEntity<Object> deleteCustomer(@PathVariable(value = \"id\") UUID id){ Optional<CustomerModel> customerModelOptional = customerService.findById(id); if(!customerModelOptional.isPresent()) { return ResponseEntity.status(HttpStatus.OK).body(\"Cliente n\u00e3o encontrado!\"); } customerService.delete(customerModelOptional.get()); return ResponseEntity.status(HttpStatus.OK).body(\"Cliente deletado com sucesso!\"); } }", "dependencies": [{"file_path": "Project_Register_Customers-main/Project_Register_Customers-main/src/main/java/com/api/registercustomers/dtos/CustomerDTO.java", "file_content": "package com.api.registercustomers.dtos; import jakarta.validation.constraints.NotBlank; public class CustomerDTO { @NotBlank private String nome; @NotBlank private String sobrenome; @NotBlank private String idade; @NotBlank private String tipoCustomer; public String getNome() { return nome; } public void setNome(String nome) { this.nome = nome; } public String getSobrenome() { return sobrenome; } public void setSobrenome(String sobrenome) { this.sobrenome = sobrenome; } public String getIdade() { return idade; } public void setIdade(String idade) { this.idade = idade; } public String getTipoCustomer() { return tipoCustomer; } public void setTipoCustomer(String tipoCustomer) { this.tipoCustomer = tipoCustomer; } }"}, {"file_path": "Project_Register_Customers-main/Project_Register_Customers-main/src/main/java/com/api/registercustomers/models/CustomerModel.java", "file_content": "package com.api.registercustomers.models; import jakarta.persistence.Column; import jakarta.persistence.Entity; import jakarta.persistence.GeneratedValue; import jakarta.persistence.GenerationType; import jakarta.persistence.Id; import jakarta.persistence.Table; import java.io.Serializable; import java.util.UUID; @Entity @Table(name = \"TB_CUSTOMER\") public class CustomerModel implements Serializable{ private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.AUTO) private UUID id; @Column(nullable = false, length = 60) private String nome; @Column(nullable = false, length = 60) private String sobrenome; @Column(nullable = false, length = 3) private String idade; @Column(nullable = false, length = 20) private String tipoCustomer; public UUID getId() { return id; } public void setId(UUID id) { this.id = id; } public String getNome() { return nome; } public void setNome(String nome) { this.nome = nome; } public String getSobrenome() { return sobrenome; } public void setSobrenome(String sobrenome) { this.sobrenome = sobrenome; } public String getIdade() { return idade; } public void setIdade(String idade) { this.idade = idade; } public String getTipoCustomer() { return tipoCustomer; } public void setTipoCustomer(String tipoCustomer) { this.tipoCustomer = tipoCustomer; } public static long getSerialversionuid() { return serialVersionUID; } }"}, {"file_path": "Project_Register_Customers-main/Project_Register_Customers-main/src/main/java/com/api/registercustomers/services/CustomerService.java", "file_content": "package com.api.registercustomers.services; import java.util.List; import java.util.Optional; import java.util.UUID; import org.springframework.stereotype.Service; import com.api.registercustomers.models.CustomerModel; import com.api.registercustomers.repositories.CustomerRepository; import jakarta.transaction.Transactional; @Service public class CustomerService { final CustomerRepository customerRepository; public CustomerService(CustomerRepository customerRepository) { this.customerRepository = customerRepository; } @Transactional public CustomerModel save(CustomerModel customerModel) { return customerRepository.save(customerModel); } public List<CustomerModel> findAll() { return customerRepository.findAll(); } public Optional<CustomerModel> findById(UUID id) { return customerRepository.findById(id); } @Transactional public void delete(CustomerModel customerModel) { customerRepository.delete(customerModel); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Project_Register_Customers-main/Project_Register_Customers-main/src/main/java/com/api/registercustomers/controllers/CustomerController.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "CustomerController handles HTTP request coordination, DTO-to-model conversion, and direct field updates, exceeding a single responsibility."}, {"principle": "Dependency Inversion", "justification": "CustomerController depends directly on concrete CustomerService instead of an abstraction (interface)."}]}]}
{"project_id": 25, "chunk_id": 0, "prompt": {"main_file_path": "Project_Register_Customers-main/Project_Register_Customers-main/src/main/java/com/api/registercustomers/services/CustomerService.java", "main_file_content": "package com.api.registercustomers.services; import java.util.List; import java.util.Optional; import java.util.UUID; import org.springframework.stereotype.Service; import com.api.registercustomers.models.CustomerModel; import com.api.registercustomers.repositories.CustomerRepository; import jakarta.transaction.Transactional; @Service public class CustomerService { final CustomerRepository customerRepository; public CustomerService(CustomerRepository customerRepository) { this.customerRepository = customerRepository; } @Transactional public CustomerModel save(CustomerModel customerModel) { return customerRepository.save(customerModel); } public List<CustomerModel> findAll() { return customerRepository.findAll(); } public Optional<CustomerModel> findById(UUID id) { return customerRepository.findById(id); } @Transactional public void delete(CustomerModel customerModel) { customerRepository.delete(customerModel); } }", "dependencies": [{"file_path": "Project_Register_Customers-main/Project_Register_Customers-main/src/main/java/com/api/registercustomers/models/CustomerModel.java", "file_content": "package com.api.registercustomers.models; import jakarta.persistence.Column; import jakarta.persistence.Entity; import jakarta.persistence.GeneratedValue; import jakarta.persistence.GenerationType; import jakarta.persistence.Id; import jakarta.persistence.Table; import java.io.Serializable; import java.util.UUID; @Entity @Table(name = \"TB_CUSTOMER\") public class CustomerModel implements Serializable{ private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.AUTO) private UUID id; @Column(nullable = false, length = 60) private String nome; @Column(nullable = false, length = 60) private String sobrenome; @Column(nullable = false, length = 3) private String idade; @Column(nullable = false, length = 20) private String tipoCustomer; public UUID getId() { return id; } public void setId(UUID id) { this.id = id; } public String getNome() { return nome; } public void setNome(String nome) { this.nome = nome; } public String getSobrenome() { return sobrenome; } public void setSobrenome(String sobrenome) { this.sobrenome = sobrenome; } public String getIdade() { return idade; } public void setIdade(String idade) { this.idade = idade; } public String getTipoCustomer() { return tipoCustomer; } public void setTipoCustomer(String tipoCustomer) { this.tipoCustomer = tipoCustomer; } public static long getSerialversionuid() { return serialVersionUID; } }"}, {"file_path": "Project_Register_Customers-main/Project_Register_Customers-main/src/main/java/com/api/registercustomers/repositories/CustomerRepository.java", "file_content": "package com.api.registercustomers.repositories; import java.util.UUID; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.stereotype.Repository; import com.api.registercustomers.models.CustomerModel; @Repository public interface CustomerRepository extends JpaRepository<CustomerModel, UUID> { }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Project_Register_Customers-main/Project_Register_Customers-main/src/main/java/com/api/registercustomers/services/CustomerService.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "CustomerService is not open for extension without modification. Adding new customer management logic would require changing the class directly, as it lacks abstraction layers like interfaces or inheritance hooks."}, {"principle": "Interface Segregation", "justification": "Clients of CustomerService must depend on all its methods (save, findAll, etc.) even if they use only a subset. No dedicated interfaces exist to segregate method groups."}]}]}
{"project_id": 25, "chunk_id": 0, "prompt": {"main_file_path": "Project_Register_Customers-main/Project_Register_Customers-main/src/test/java/com/api/registercustomers/RegisterCustomersApplicationTests.java", "main_file_content": "package com.api.registercustomers; import org.junit.jupiter.api.Test; import org.springframework.boot.test.context.SpringBootTest; @SpringBootTest class RegisterCustomersApplicationTests { @Test void contextLoads() { } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 26, "chunk_id": 0, "prompt": {"main_file_path": "Donor-NGO Matcher/Java-Project-main/src/DirectBackMenu.java", "main_file_content": "import java.io.IOException; import java.util.Scanner; public class DirectBackMenu{ public static void directBack(String name,int flag) throws Exception { Scanner sc = new Scanner(System.in); soutl(\"\") String tempChoice = sc.nextLine(); int choice = Integer.parseInt(tempChoice); if(choice == 1 && flag==1){ DonorMenu.welcomeDonor(name); } else if(choice == 1 && flag==2){ NgoMenu.welcomeNgo(name); } else{ System.exit(0); } sc.close(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Donor-NGO Matcher/Java-Project-main/src/DirectBackMenu.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The DirectBackMenu class handles user input parsing, decision logic, and flow control. These multiple responsibilities violate SRP, as the class has more than one reason to change."}, {"principle": "Open-Closed", "justification": "Adding a new menu type (e.g., flag=3) requires modifying the existing conditional logic in DirectBackMenu. This violates OCP, as the class is not closed for modification."}, {"principle": "Dependency Inversion", "justification": "DirectBackMenu directly depends on concrete classes DonorMenu and NgoMenu instead of abstractions. High-level modules should depend on interfaces, not concrete implementations."}]}]}
{"project_id": 26, "chunk_id": 0, "prompt": {"main_file_path": "Donor-NGO Matcher/Java-Project-main/src/DonorMenu.java", "main_file_content": "import java.util.*; import java.io.*; public class DonorMenu extends Donor{ private static final Scanner sc = new Scanner(System.in); public static void welcomeDonor(String name) throws Exception { String menu= (\"\\n||\" +\"\\n Welcome Donor \"+name+\" \" +\"\\n||\" +\"\\n| Enter 1: To Enter the aids to be donated |\" +\"\\n| Enter 2: To view all the aids donated to DC |\" +\"\\n| Enter 3: To view all the aids donated delivered to NGO |\" +\"\\n||\"); soutl(\"\") int choice= sc.nextInt(); switch (choice){ case(1): enterAids(sc, name); break; case(2): showAvailableAids(name,0); break; case(3): ShowHistory.viewAidsHistory(name,0); break; } DirectBackMenu.directBack(name,1); sc.close(); } public static void enterAids(Scanner sc, String name) throws IOException{ sc = new Scanner(System.in); soutl(\"\") soutl(\"\") String itemName = sc.nextLine(); soutl(\"\") int quantity = sc.nextInt(); soutl(\"\") if(quantity>0){ Donor set = new Donor(name,itemName,quantity); set.saveDonorAids(); soutl(\"\") } else{ soutl(\"\") enterAids(sc, name); } } public static void showAvailableAids(String name,int flag){ File file = new File(\"src/Documentation/DonatedItems.csv\"); try{ Scanner input = new Scanner(file); soutl(\"\") System.out.format(\"|%10s |%11s |%10s|\",\"Name \",\"Aid\",\"Quantity\"); soutl(\"\") boolean found = false; do{ String data = input.nextLine(); List<String> source = Arrays.asList(data.split(\",\")); String list = Arrays.toString(source.toArray()).replace(\"[\", \" \").replace(\"]\", \" \").replace(\",\", \" \"); if (list.contains(name) && flag==0){ String[] temp = list.split(\"\\\\s+\"); System.out.printf(\"| %10s |%11s |%10s|\",temp[1],temp[2],temp[3]); soutl(\"\") found = true; } else if(flag==1){ String[] temp = list.split(\"\\\\s+\"); System.out.printf(\"| %10s |%11s |%10s|\",temp[1],temp[2],temp[3]); soutl(\"\") found =true; } } while(input.hasNextLine()); if(!found){ System.out.printf(\"| %10s |%11s |%10s |%10s |%10s |%10s|\",\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"); soutl(\"\") soutl(\"\") } } catch (Exception e){ soutl(\"\") soutl(\"\") soutl(\"\") } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Donor-NGO Matcher/Java-Project-main/src/DonorMenu.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "DonorMenu handles multiple responsibilities: managing user menus, input handling, file I/O operations, and business logic for donations. These distinct concerns should be separated into different classes."}, {"principle": "Open-Closed", "justification": "The switch statement in welcomeDonor requires modification to add new menu options. The class is not closed for extension but requires direct code changes to add functionality."}, {"principle": "Dependency Inversion", "justification": "DonorMenu directly depends on concrete classes like Donor and File instead of abstractions. High-level modules (e.g., menu logic) should not depend on low-level implementation details like file handling."}]}]}
{"project_id": 26, "chunk_id": 0, "prompt": {"main_file_path": "Donor-NGO Matcher/Java-Project-main/src/ShowHistory.java", "main_file_content": "import java.util.*; import java.io.*; public class ShowHistory { public static void viewAidsHistory(String name,int flag){ String path; if(flag==2){ path = \"src/Documentation/AfterQ.csv\"; flag=1; } else if (flag==3){ path = \"src/Documentation/AfterPq.csv\"; flag=1; } else{ path = \"src/Documentation/Donor&NgoMatched.csv\"; } File file = new File(path); boolean found = false; try{ Scanner input = new Scanner(file); soutl(\"\") System.out.format(\"|%10s |%11s |%10s |%10s |%10s |%10s |%10s|\",\"Donor \",\"PhoneNumber\",\"Aid\",\"Quantity\",\"Ngo\",\"Manpower\",\"Status\"); soutl(\"\") do{ String data = input.nextLine(); List<String> source = Arrays.asList(data.split(\",\")); String list = Arrays.toString(source.toArray()).replace(\"[\", \"\").replace(\"]\", \"\").replace(\",\", \" \"); if (list.contains(name) && flag==0){ String[] temp = list.split(\"\\\\s+\"); System.out.printf(\"| %10s |%11s |%10s |%10s |%10s |%10s |%10s|\",temp[0],temp[1],temp[2],temp[3],temp[4],temp[5],temp[6]); sout(\"\") found = true; } else if(flag==1){ String[] temp = list.split(\"\\\\s+\"); if(temp[5].equals(\"0\")){ temp[4] = \"-\"; temp[5] = \"-\"; } System.out.printf(\"| %10s |%11s |%10s |%10s |%10s |%10s |%10s|\",temp[0],temp[1],temp[2],temp[3],temp[4],temp[5],temp[6]); sout(\"\") found = true; } } while(input.hasNextLine()); if(!found){ System.out.printf(\"| %10s |%11s |%10s |%10s |%10s |%10s |%10s|\",\"X\",\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"); soutl(\"\") soutl(\"\") } input.close(); }catch (Exception e){ System.out.printf(\"| %10s |%11s |%10s |%10s |%10s |%10s |%10s|\",\"X\",\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"); soutl(\"\") soutl(\"\") } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Donor-NGO Matcher/Java-Project-main/src/ShowHistory.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The ShowHistory class handles multiple responsibilities: file I/O, data parsing, and UI formatting. Changes to file paths, data structure, or output format would all require modifying this single class."}, {"principle": "Open-Closed", "justification": "The class is not open for extension; adding new flag-based behaviors (e.g., new CSV paths) requires modifying existing conditional logic in viewAidsHistory instead of extending via abstractions."}]}]}
{"project_id": 26, "chunk_id": 0, "prompt": {"main_file_path": "Donor-NGO Matcher/Java-Project-main/src/LoginSystem.java", "main_file_content": "import java.util.*; import java.io.*; public class LoginSystem { public static void authenticateUser(Scanner sc, int flag) throws Exception { sc = new Scanner(System.in); ArrayList<String> credentials = Credentials.readCredsFromFile(flag); soutl(\"\") soutl(\"\") String tempname=sc.nextLine(); soutl(\"\") String temppassword=sc.nextLine(); boolean check=false; for (int i = 0; i<credentials.size();i++){ check = credentials.get(i).equals(tempname+\" \"+temppassword); if(check) { soutl(\"\") String[] temp = credentials.get(i).split(\"\\\\s\"); tempname=temp[0]; if(flag==1){ DonorMenu.welcomeDonor(tempname); } else if(flag==2){ NgoMenu.welcomeNgo(tempname); } break; } } if(!check){ soutl(\"\") authenticateUser(sc,flag); } } public static void createNewUsers(int flag) throws IOException { Scanner sc = new Scanner(System.in); soutl(\"\") soutl(\"\") String username = sc.nextLine(); soutl(\"\") String password = sc.nextLine(); soutl(\"\") String temppassword= sc.nextLine(); int num; if(flag==1){ soutl(\"\") } else{ soutl(\"\") } num = sc.nextInt(); soutl(\"\") do{ if (temppassword.equals(password)){ break; } else{ soutl(\"\") temppassword= sc.nextLine(); } }while(temppassword!=password); Credentials.saveCredsToFile(sc, flag, username, password, num); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Donor-NGO Matcher/Java-Project-main/src/LoginSystem.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "LoginSystem handles user authentication, user creation, file I/O operations, and direct menu navigation, violating SRP by managing multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Adding a new user type (e.g., Admin) requires modifying conditional logic in authenticateUser instead of extending via abstraction, violating OCP."}, {"principle": "Dependency Inversion", "justification": "LoginSystem directly depends on concrete classes (Credentials, DonorMenu, NgoMenu) instead of abstractions, violating DIP by coupling high-level and low-level modules."}]}]}
{"project_id": 26, "chunk_id": 0, "prompt": {"main_file_path": "Donor-NGO Matcher/Java-Project-main/src/QSimulator.java", "main_file_content": "import java.util.*; import java.io.*; import java.nio.file.*; public class QSimulator { public static void startQSimulator() throws Exception { soutl(\"\") List<String> lines = Files.readAllLines(Paths.get(\"src/Documentation/Donor&NgoMatched.csv\")); ArrayList<MatchedClass> qarrlist = new ArrayList<MatchedClass>(); ShowHistory.viewAidsHistory(\"null\",1); for(int i = 0; i < lines.size();i++) { String[] things = lines.get(i).split(\",\"); MatchedClass data1 = new MatchedClass(things[0], things[1], things[2], things[3], things[4], Integer.parseInt(things[5]), things[6]); qarrlist.add(data1); } ArrayList<String> allNgos = new ArrayList<String>(); for(int i = 0; i < qarrlist.size(); i++){ if(!qarrlist.get(i).ngoName.equals(\"0\")) allNgos.add(qarrlist.get(i).ngoName); } Queue<String> queue = new LinkedList<String>(); int choice; Scanner scan = new Scanner(System.in); Scanner scan2 = new Scanner(System.in); boolean brktheloop = false; do{ String menu = \"\"\" || | Press 1 for enqueue | | Press 2 for dequeue | | Press 3 to exit | ||\"\"\"; soutl(\"\") choice = scan.nextInt(); String ngoname; boolean found = false; switch(choice) { case (1): soutl(\"\") ngoname = scan2.nextLine(); found = allNgos.contains(ngoname); if(found) queue.add(ngoname); else soutl(\"\") break; case (2): if(queue.size() > 0){ String nowname = queue.remove(); soutl(\"\") String path = \"src/Documentation/AfterQ.csv\"; QAfterDeque.updatefiledq(path, qarrlist, nowname, 2); } else soutl(\"\") break; case (3): brktheloop = true; break; default: soutl(\"\") throw new IOException(); } if(brktheloop) break; } while(choice != 3); scan.close(); scan2.close(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Donor-NGO Matcher/Java-Project-main/src/QSimulator.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The QSimulator class handles file I/O, queue management, user input processing, and business logic coordination. This combines multiple responsibilities like data parsing, UI interaction, and workflow control into one class."}, {"principle": "Open-Closed", "justification": "The class cannot be extended to support new queue operations or data sources without modifying its existing code. All behaviors are hardcoded in the startQSimulator method with no abstraction for variation points."}, {"principle": "Dependency Inversion", "justification": "High-level method startQSimulator directly depends on concrete implementations like ShowHistory, QAfterDeque, and MatchedClass instead of abstractions. Low-level details are tightly coupled to the business logic."}]}]}
{"project_id": 26, "chunk_id": 0, "prompt": {"main_file_path": "Donor-NGO Matcher/Java-Project-main/src/Matching.java", "main_file_content": "import java.io.IOException; import java.util.*; public class Matching extends MatchAlgorithm{ private static final Scanner sc = new Scanner(System.in); public static void filter() throws IOException{ ArrayList<String> donatedaids = Donor.donatedaids(); ArrayList<String> requiredaids = Ngo.requestedaids(); ArrayList<String> dName = new ArrayList<String>(); ArrayList<String> dAids = new ArrayList<String>(); ArrayList<Integer> dQty = new ArrayList<Integer>(); ArrayList<String> fName = new ArrayList<String>(); ArrayList<String> fAids = new ArrayList<String>(); ArrayList<Integer> fQty = new ArrayList<Integer>(); ArrayList<String> nName = new ArrayList<String>(); ArrayList<String> nAids = new ArrayList<String>(); ArrayList<Integer> nQty = new ArrayList<Integer>(); ArrayList<String> nStatus = new ArrayList<String>(); for (String requiredaid : requiredaids) { String[] temp = requiredaid.split(\"\\\\s\"); String status = temp[3]; if (status.contains(\"unsatisfied\")) { nName.add(temp[0]); nAids.add(temp[1]); int Qty = Integer.parseInt(temp[2]); nQty.add(Qty); nStatus.add(temp[3]); } } soutl(\"\") System.out.format(\"|%10s |%11s |%10s|\",\"Name \",\"Aid\",\"Quantity\"); soutl(\"\") for(int i=0; i< nAids.size();i++){ String[] temp = requiredaids.get(i).split(\"\\\\s+\"); System.out.printf(\"| %10s |%11s |%10s|\",temp[0],temp[1],temp[2]); soutl(\"\") } soutl(\"\") soutl(\"\") soutl(\"\") String name = sc.nextLine(); int flag=0; for (String donatedaid : donatedaids) { String[] temp = donatedaid.split(\"\\\\s+\"); String aids = temp[1]; int Qty = Integer.parseInt(temp[2]); if (aids.equals(name)) { dName.add(temp[0]); dAids.add(aids); dQty.add(Qty); flag = 1; } else { fName.add(temp[0]); fAids.add(aids); fQty.add(Qty); } } if(flag==0){ soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") } else{ WriteBack.updateDonor(fName, fAids, fQty,0); runAlgo(name, dName, dAids, dQty, nName, nAids, nQty, nStatus); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Donor-NGO Matcher/Java-Project-main/src/Matching.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Matching class handles input processing, data filtering, output formatting, and business logic coordination. These multiple responsibilities violate SRP as they represent more than one reason for change."}, {"principle": "Open-Closed", "justification": "The filter() method contains hardcoded logic for processing donations/requests. New matching requirements would require direct modifications to this class rather than extension."}, {"principle": "Dependency Inversion", "justification": "High-level matching logic directly depends on concrete implementations (Donor, Ngo, WriteBack). No abstractions are used for these dependencies, creating tight coupling."}]}]}
{"project_id": 26, "chunk_id": 0, "prompt": {"main_file_path": "Donor-NGO Matcher/Java-Project-main/src/DcMenu.java", "main_file_content": "import java.util.*; import java.io.IOException; public class DcMenu { private static final Scanner sc = new Scanner(System.in); public static void showDcMenu() throws Exception { soutl(\"\") int choice = sc.nextInt(); switch (choice) { case 1: DonorMenu.showAvailableAids(\"null\",1); break; case 2: NgoMenu.showStatus(\"null\",1); break; case 3: Matching.filter(); WriteBack.updateDonorAndNgo(); break; case 4: SimulationMenu.Simulation(); break; case 5: soutl(\"\") show(sc,0); break; case 6: soutl(\"\") show(sc,0); break; case 7: show(sc,1); break; } sc.close(); } public static void show(Scanner sc, int flag){ sc = new Scanner(System.in); if(flag==0){ String str = sc.nextLine(); ShowHistory.viewAidsHistory(str,0); } else if(flag==1){ ShowHistory.viewAidsHistory(\"null\",1); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Donor-NGO Matcher/Java-Project-main/src/DcMenu.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "DcMenu handles multiple responsibilities: menu display, user input parsing, and directly invoking operations across DonorMenu, NgoMenu, Matching, WriteBack, SimulationMenu, and ShowHistory. Changes in any of these areas would require modifying the class."}, {"principle": "Open-Closed", "justification": "Adding new menu options requires modifying the switch-case logic in showDcMenu() instead of extending through abstractions. The class is not closed for modification."}, {"principle": "Dependency Inversion", "justification": "DcMenu directly depends on concrete implementations (DonorMenu, NgoMenu, Matching, etc.) instead of abstractions. High-level policy logic is tightly coupled to low-level modules."}]}]}
{"project_id": 26, "chunk_id": 0, "prompt": {"main_file_path": "Donor-NGO Matcher/Java-Project-main/src/Credentials.java", "main_file_content": "import java.io.FileWriter; import java.io.IOException; import java.nio.file.Files; import java.nio.file.Paths; import java.util.ArrayList; import java.util.List; import java.util.Scanner; public class Credentials { private static String username; public Credentials(){ } public static ArrayList<String> readCredsFromFile(int flag){ ArrayList<String> credentials = new ArrayList<>(); List<String> lines = new ArrayList<>(); try{ if(flag==1){ lines = Files.readAllLines(Paths.get(\"src/credentials/DonorCredentials.csv\")); } else if(flag==2){ lines = Files.readAllLines(Paths.get(\"src/credentials/NgoCredentials.csv\")); } for (String line : lines) { String[] items = line.split(\",\"); username = items[0]; String password = items[1]; credentials.add(username + \" \" + password); } }catch(Exception e){ soutl(\"\") } return credentials; } public static void saveCredsToFile(Scanner sc, int flag, String name, String password, int num) throws IOException { ArrayList<String> credentials = readCredsFromFile(flag); int innerFlag=0; for (String credential : credentials) { String[] items = credential.split(\",\"); String[] temp = items[0].split(\"\\\\s\"); username = temp[0]; if (username.equals(name)) { innerFlag = 1; } } if(innerFlag==1){ soutl(\"\") soutl(\"\") soutl(\"\") LoginSystem.createNewUsers(flag); } else{ if(flag==1){ try{ String filename= \"src/credentials/DonorCredentials.csv\"; FileWriter fw = new FileWriter(filename,true); fw.write(\"\\n\"+name+\",\"+password+\",\"+num); fw.close(); soutl(\"\") }catch(IOException ioe){ System.err.println(\"IOException: \" + ioe.getMessage()); } } else if(flag==2){ try{ String filename= \"src/credentials/NgoCredentials.csv\"; FileWriter fw = new FileWriter(filename,true); fw.write(\"\\n\"+name+\",\"+password+\",\"+num); fw.close(); }catch(IOException ioe){ System.err.println(\"IOException: \" + ioe.getMessage()); } } } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Donor-NGO Matcher/Java-Project-main/src/Credentials.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Credentials class handles multiple responsibilities: reading credentials from files, saving credentials to files, and validating user existence. These are distinct functionalities that should be separated."}, {"principle": "Open-Closed", "justification": "Adding new credential storage types (e.g., databases) would require modifying existing methods (e.g., readCredsFromFile/saveCredsToFile) instead of extending via abstractions, violating OCP."}, {"principle": "Dependency Inversion", "justification": "Credentials directly depends on concrete low-level file operations (FileWriter, Files.readAllLines) without abstractions. High-level modules should depend on abstractions, not implementations."}]}]}
{"project_id": 26, "chunk_id": 0, "prompt": {"main_file_path": "Donor-NGO Matcher/Java-Project-main/src/NgoComparator.java", "main_file_content": "import java.util.Comparator; public class NgoComparator implements Comparator<NgoClass>{ public int compare(NgoClass n1, NgoClass n2) { if (n1.ngoMan < n2.ngoMan) return 1; else if (n1.ngoMan > n2.ngoMan) return -1; return 0; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Donor-NGO Matcher/Java-Project-main/src/NgoComparator.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "NgoComparator directly depends on concrete NgoClass. High-level comparators should depend on abstractions (interfaces) rather than concrete implementations."}]}]}
{"project_id": 26, "chunk_id": 0, "prompt": {"main_file_path": "Donor-NGO Matcher/Java-Project-main/src/Start.java", "main_file_content": "import java.io.IOException; import java.util.*; public class Start { static Scanner sc = new Scanner(System.in); public static void main(String[] args) throws Exception { String menu = \"\"\" || | Welcome to our Aid Distribution System | | To proceed please choose an option below | || |1-Proceed to Register a new user | |2-Proceed as a Donor: | |3-Proceed as a Non-Government Organization: | |4-Proceed as a Distribution Center | |0-To Exit | ||\"\"\"; soutl(\"\") int choice = sc.nextInt(); switch(choice){ case(1): soutl(\"\") int ch = sc.nextInt(); LoginSystem.createNewUsers(ch); main(args); break; case(2): LoginSystem.authenticateUser(sc,1); break; case(3): LoginSystem.authenticateUser(sc,2); break; case(4): DcMenu.showDcMenu(); break; case(0): soutl(\"\") System.exit(0); break; default: throw new IOException(); } sc.close(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Donor-NGO Matcher/Java-Project-main/src/Start.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Start class handles multiple responsibilities including user input, menu display, and navigation control, leading to more than one reason to change."}, {"principle": "Open-Closed", "justification": "Adding new menu options requires modifying the existing switch-case block in the Start class instead of extending through abstractions."}, {"principle": "Dependency Inversion", "justification": "High-level Start class directly depends on concrete low-level modules (LoginSystem, DcMenu) instead of abstractions, creating tight coupling."}]}]}
{"project_id": 26, "chunk_id": 0, "prompt": {"main_file_path": "Donor-NGO Matcher/Java-Project-main/src/MatchedClass.java", "main_file_content": "public class MatchedClass{ String dName; String dPhone; String aidType; String aidQty; String ngoName; int ngoMan; String status; MatchedClass(String dName, String dPhone, String aidType, String aidQty, String ngoName, int ngoMan, String status){ this.dName = dName; this.dPhone = dPhone; this.aidType = aidType; this.aidQty = aidQty; this.ngoName = ngoName; this.ngoMan = ngoMan; this.status = status; } public void setStatus(String status){ this.status = status; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Donor-NGO Matcher/Java-Project-main/src/MatchedClass.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "MatchedClass handles multiple responsibilities: storing donor data (dName, dPhone), aid details (aidType, aidQty), NGO data (ngoName, ngoMan), and match status. Changes to any of these unrelated domains would require modifying this class."}]}]}
{"project_id": 26, "chunk_id": 0, "prompt": {"main_file_path": "Donor-NGO Matcher/Java-Project-main/src/Donor.java", "main_file_content": "import java.io.IOException; import java.util.ArrayList; import java.util.List; import java.nio.file.Files; import java.nio.file.Paths; public class Donor{ private String name; private String itemName; private int quantity; public Donor(){} public Donor(String name,String itemName, int qty){ this.name = name; this.itemName = itemName; quantity = qty; } public void saveDonorAids() throws IOException{ ArrayList<String> data = donatedaids(); ArrayList<String> dName = new ArrayList<String>(); ArrayList<String> dAids = new ArrayList<String>(); ArrayList<Integer> dQty = new ArrayList<Integer>(); int flag=0; WriteBack.store(name, itemName, quantity, \"0\", false); for (String datum : data) { String[] temp = datum.split(\"\\\\s\"); String nameDonor = temp[0]; String aids = temp[1]; int qty = Integer.parseInt(temp[2]); if (nameDonor.equals(name) && aids.equals(itemName)) { qty += quantity; flag = 1; } dName.add(nameDonor); dAids.add(aids); dQty.add(qty); } if(flag==0){ dName.add(name); dAids.add(itemName); dQty.add(quantity); } WriteBack.updateDonor(dName, dAids, dQty,0); } public static ArrayList<String> donatedaids() throws IOException{ ArrayList<String> previousAids= new ArrayList<>(); List<String>lines = Files.readAllLines(Paths.get(\"src/Documentation/DonatedItems.csv\")); for(int i =0; i<lines.size();i++){ String[] items = lines.get(i).split(\",\"); String name = items[0]; String aids = items[1]; String quantity = items[2]; previousAids.add(name+\" \"+aids+\" \"+quantity); } return previousAids; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Donor-NGO Matcher/Java-Project-main/src/Donor.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Donor class handles donor data management, file I/O operations (reading/writing CSV), and coordinates updates via WriteBack, combining multiple responsibilities."}, {"principle": "Dependency Inversion", "justification": "High-level donor management logic directly depends on concrete WriteBack implementation for storage instead of abstractions. Direct file system access (Files/Paths) also violates DIP despite being built-in."}]}]}
{"project_id": 26, "chunk_id": 0, "prompt": {"main_file_path": "Donor-NGO Matcher/Java-Project-main/src/MatchAlgorithm.java", "main_file_content": "import java.io.IOException; import java.util.ArrayList; import java.util.Collections; public class MatchAlgorithm { public static void runAlgo(String name, ArrayList<String> dName, ArrayList<String> dAids ,ArrayList<Integer> dQty, ArrayList<String> nName, ArrayList<String> nAids, ArrayList<Integer> nQty, ArrayList<String> nStatus) throws IOException{ for(int i =0; i< nName.size();i++){ if(name.equals(nAids.get(i))){ sortArray(dName, dAids, dQty); if(dQty.get(0) == 0){ break; } if(nQty.get(i)<=dQty.get(0)){ WriteBack.store(dName.get(i), dAids.get(i), nQty.get(i), nName.get(i), true); dQty.set(0,dQty.get(0)-nQty.get(i)); nQty.set(i,0); nStatus.set(i,\"satisfied\"); break; } else{ for(int j=0; j< dQty.size();j++){ if(nQty.get(i)<=dQty.get(j)){ dQty.set(j,dQty.get(j)-nQty.get(i)); if(dQty.get(j)!=0){ WriteBack.store(dName.get(j), dAids.get(j), nQty.get(i), nName.get(i), true); } nQty.set(i,0); nStatus.set(i,\"satisfied\"); break; } else{ WriteBack.store(dName.get(j), dAids.get(j), dQty.get(j), nName.get(i), true); nQty.set(i,nQty.get(i)-dQty.get(j)); dQty.set(j,0); } } } } } WriteBack.updateDonor(dName, dAids, dQty,1); WriteBack.updateNgo(nName, nAids, nQty, nStatus); } public static void sortArray(ArrayList<String> dName,ArrayList<String> dAids, ArrayList<Integer> dQty){ for(int i=0;i<dQty.size()-1;i++){ for(int j=i+1;j<dQty.size();j++){ if(dQty.get(i)<dQty.get(j)){ Collections.swap(dQty,i,j); Collections.swap(dName,i,j); Collections.swap(dAids,i,j); } } } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Donor-NGO Matcher/Java-Project-main/src/MatchAlgorithm.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "MatchAlgorithm handles sorting, donation matching, quantity updates, and I/O operations via WriteBack, indicating multiple responsibilities."}, {"principle": "Open-Closed", "justification": "The algorithm logic is static and cannot be extended without modifying MatchAlgorithm's code directly."}, {"principle": "Dependency Inversion", "justification": "MatchAlgorithm directly depends on the concrete WriteBack class instead of abstractions for I/O operations."}]}]}
{"project_id": 26, "chunk_id": 0, "prompt": {"main_file_path": "Donor-NGO Matcher/Java-Project-main/src/WriteBack.java", "main_file_content": "import java.io.*; import java.nio.file.Files; import java.nio.file.Paths; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.Scanner; public class WriteBack { public static void store(String dName, String dAids ,int dQty, String nName, boolean flag) throws IOException{ List<String> lines = Files.readAllLines(Paths.get(\"src/credentials/DonorCredentials.csv\")); String phono = \"\"; String status = \"Reserved\"; for (String line : lines) { String[] items = line.split(\",\"); if (dName.equals(items[0])) { phono = items[2]; } } lines = Files.readAllLines(Paths.get(\"src/credentials/NgoCredentials.csv\")); String manpower = \"\"; for (String line : lines) { String[] items = line.split(\",\"); if (nName.equals(items[0])) { manpower = items[2]; } else if (nName.equals(\"0\")) { manpower = nName; status = \"Available\"; } } String path = \"src/Documentation/Donor&NgoMatched.csv\"; try (FileWriter fw = new FileWriter(path,true)){ fw.write(dName + \",\" + phono + \",\" + dAids + \",\" + dQty + \",\" + nName + \",\" + manpower + \",\" + status+\"\\n\"); if(flag){ soutl(\"\") soutl(\"\") System.out.format(\"|%10s |%11s |%10s |%10s |%10s |%10s |%10s|\",\"Donor \",\"PhoneNumber\",\"Aid\",\"Quantity\",\"Ngo\",\"Manpower\",\"Status\"); soutl(\"\") System.out.printf(\"| %10s |%11s |%10s |%10s |%10s |%10s |%10s|\",dName, phono, dAids, dQty, nName, manpower, status); soutl(\"\") } } catch(Exception e){ soutl(\"\") } } public static void updateDonor(ArrayList<String> dName, ArrayList<String> dAids, ArrayList<Integer> dQty, int flag){ String path = \"src/Documentation/DonatedItems.csv\"; if(flag==0){ try( FileWriter fw = new FileWriter(path)){ for(int i=0; i<dQty.size(); i++){ fw.write(dName.get(i) +\",\" + dAids.get(i) + \",\" + dQty.get(i) + \"\\n\"); } fw.close(); }catch(Exception e){ soutl(\"\") } } else{ try( FileWriter fw = new FileWriter(path,true)){ for(int i=0; i<dQty.size(); i++){ if(dQty.get(i)!=0){ fw.write(dName.get(i) +\",\" + dAids.get(i) + \",\" + dQty.get(i) + \"\\n\"); } } fw.close(); }catch(Exception e){ soutl(\"\") } } } public static void updateNgo(ArrayList<String> nName, ArrayList<String> nAids,ArrayList<Integer> nQty, ArrayList<String> nStatus){ try{ String path = \"src/Documentation/NgoDemands.csv\"; FileWriter fw = new FileWriter(path); for(int i = 1; i < nStatus.size();i++){ if(nStatus.get(i).equals(\"unsatisfied\")){ fw.write(nName.get(i) +\",\"+ nAids.get(i)+ \",\" + nQty.get(i)+\",\"+ nStatus.get(i) + \"\\n\"); } } fw.close(); }catch(Exception e){ soutl(\"\") } } public static void updateDonorAndNgo(){ try{ String path= \"src/Documentation/Donor&NgoMatched.csv\"; List<String>lines = Files.readAllLines(Paths.get(\"src/Documentation/Donor&NgoMatched.csv\")); FileWriter fw = new FileWriter(path); fw.close(); int i =0; do { String[] items = lines.get(i).split(\",\"); String name = items[0]; String aids = items[2]; int quantity = Integer.parseInt(items[3]); String ngoName = items[4]; String status = items[6]; if (!status.equals(\"Available\")) { store(name, aids, quantity, ngoName, false); } i++; }while(i<lines.size()); ArrayList<String> data = Donor.donatedaids(); for (int j=0; j<data.size(); j++) { String[] items = data.get(j).split(\"\\\\s+\"); String name = items[0]; String aids = items[1]; int quantity = Integer.parseInt(items[2]); store(name, aids, quantity, \"0\", false); } }catch(Exception e){ soutl(\"\") } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Donor-NGO Matcher/Java-Project-main/src/WriteBack.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The WriteBack class handles multiple responsibilities: reading/writing CSV files, updating donor/NGO data, and formatting console output. This violates SRP as it has multiple reasons to change."}, {"principle": "Open-Closed", "justification": "The class is not open for extension but closed for modification. Adding new data sources or output formats would require modifying existing methods instead of extending via abstractions."}]}]}
{"project_id": 26, "chunk_id": 0, "prompt": {"main_file_path": "Donor-NGO Matcher/Java-Project-main/src/PqSimulator.java", "main_file_content": "import java.util.*; import java.io.*; import java.nio.file.*; public class PqSimulator{ public static void startPqSimulator() throws Exception { soutl(\"\") List<String> lines = Files.readAllLines(Paths.get(\"src/Documentation/Donor&NgoMatched.csv\")); ArrayList<MatchedClass> ngoarr = new ArrayList<MatchedClass>(); Map<String, Integer> map = new HashMap<String, Integer>(); ShowHistory.viewAidsHistory(\"null\",1); for(int i = 0; i < lines.size();i++) { String[] things = lines.get(i).split(\",\"); MatchedClass data1 = new MatchedClass(things[0], things[1], things[2], things[3], things[4], Integer.parseInt(things[5]), things[6]); ngoarr.add(data1); map.put(ngoarr.get(i).ngoName, ngoarr.get(i).ngoMan); } ArrayList<String> allNgos = new ArrayList<String>(); for (MatchedClass MatchedClass : ngoarr) { if (!MatchedClass.ngoName.equals(\"0\")) allNgos.add(MatchedClass.ngoName); } PriorityQueue<NgoClass> pq = new PriorityQueue<NgoClass>(5, new NgoComparator()); int choice; Scanner scan = new Scanner(System.in); Scanner scan2 = new Scanner(System.in); boolean brktheloop = false; do{ String menu = \"\"\" || | Press 1 for enqueue | | Press 2 for dequeue | | Press 3 to exit | ||\"\"\"; soutl(\"\") choice = scan.nextInt(); String ngoname; boolean found = false; switch(choice) { case (1): soutl(\"\") ngoname = scan2.nextLine(); found = allNgos.contains(ngoname); if(found){ NgoClass ngo1 = new NgoClass(ngoname, map.get(ngoname)); pq.add(ngo1); } else soutl(\"\") break; case (2): if(pq.size() > 0){ String nowname = pq.poll().ngoName; soutl(\"\") String path = \"src/Documentation/AfterPq.csv\"; QAfterDeque.updatefiledq(path, ngoarr, nowname, 3); } else{ soutl(\"\") } break; case (3): brktheloop = true; break; default: soutl(\"\") throw new IOException(); } if(brktheloop) break; } while(choice != 3); scan.close(); scan2.close(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Donor-NGO Matcher/Java-Project-main/src/PqSimulator.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The PqSimulator class handles file I/O, data parsing, priority queue management, user interaction, and CSV updates. These multiple responsibilities violate SRP."}, {"principle": "Open-Closed", "justification": "Adding new queueing strategies or data sources would require modifying startPqSimulator() directly. No abstractions exist to extend behavior without code changes."}, {"principle": "Dependency Inversion", "justification": "High-level queue logic directly instantiates low-level NgoClass and NgoComparator. Dependencies on concrete implementations rather than abstractions violate DIP."}]}]}
{"project_id": 26, "chunk_id": 0, "prompt": {"main_file_path": "Donor-NGO Matcher/Java-Project-main/src/NgoMenu.java", "main_file_content": "import java.util.*; import java.io.*; public class NgoMenu extends Ngo{ private static final Scanner sc = new Scanner(System.in); public static void welcomeNgo(String name) throws Exception { soutl(\"\") int choice = sc.nextInt(); switch (choice) { case (1): enterRequiredAids(sc, name); break; case(2): showStatus(name,0); break; case (3): ShowHistory.viewAidsHistory(name,0); break; } DirectBackMenu.directBack(name,2); sc.close(); } public static void enterRequiredAids(Scanner sc, String name) throws IOException{ sc = new Scanner(System.in); soutl(\"\") soutl(\"\") String amount=sc.nextLine(); soutl(\"\") int qty=sc.nextInt(); soutl(\"\") if(qty>0){ Ngo set = new Ngo(name,amount, qty, \"unsatisfied\"); set.saveNgoDemands(); soutl(\"\") } else{ soutl(\"\") enterRequiredAids(sc, name); } } public static void showStatus(String name, int flag){ File file = new File(\"src/Documentation/NgoDemands.csv\"); boolean found = false ; try{ Scanner input = new Scanner(file); soutl(\"\") System.out.format(\"|%10s |%11s |%10s|\",\"Name \",\"Aid\",\"Quantity\"); soutl(\"\") do{ String data = input.nextLine(); List<String> source = Arrays.asList(data.split(\",\")); String list = Arrays.toString(source.toArray()).replace(\"[\", \" \").replace(\"]\", \" \").replace(\",\", \" \"); if (list.contains(name) && list.contains(\"unsatisfied\") && flag==0){ String[] temp = list.split(\"\\\\s+\"); System.out.printf(\"| %10s |%11s |%10s|\",temp[1],temp[2],temp[3]); soutl(\"\") found = true; } else if(flag==1){ String[] temp = list.split(\"\\\\s+\"); System.out.printf(\"| %10s |%11s |%10s|\",temp[1],temp[2],temp[3]); soutl(\"\") found = true; } } while(input.hasNextLine()); if(!found){ System.out.printf(\"| %10s |%11s |%10s |%10s |%10s |%10s|\",\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"); soutl(\"\") soutl(\"\") } } catch (Exception e){ soutl(\"\") soutl(\"\") soutl(\"\") } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Donor-NGO Matcher/Java-Project-main/src/NgoMenu.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "NgoMenu handles user input processing, business logic execution (enterRequiredAids), file I/O operations (showStatus), and menu navigation. These are multiple distinct responsibilities within a single class."}, {"principle": "Open-Closed", "justification": "The switch statement in welcomeNgo requires modification to add new menu options. The class is not closed for modification when new functionality is needed."}, {"principle": "Dependency Inversion", "justification": "NgoMenu directly instantiates the concrete Ngo class and depends on low-level file operations (File, Scanner). High-level modules should depend on abstractions rather than concrete implementations."}]}]}
{"project_id": 26, "chunk_id": 0, "prompt": {"main_file_path": "Donor-NGO Matcher/Java-Project-main/src/Ngo.java", "main_file_content": "import java.io.IOException; import java.util.ArrayList; import java.util.List; import java.nio.file.Files; import java.nio.file.Paths; public class Ngo { private String name; private String aids; private int quantity; private String status; public Ngo() {}; public Ngo(String name, String aids, int q, String status) { this.name = name; this.aids = aids; quantity = q; this.status = status; } public void saveNgoDemands() throws IOException{ ArrayList<String> data = requestedaids(); ArrayList<String> nName = new ArrayList<String>(); ArrayList<String> nAids = new ArrayList<String>(); ArrayList<Integer> nQty = new ArrayList<Integer>(); ArrayList<String> nStatus = new ArrayList<String>(); int flag=0; for(int i = 0; i < data.size();i++){ String[] temp = data.get(i).split(\"\\\\s\"); String nameNgo = temp[0]; String aidsNgo = temp[1]; int qty = Integer.parseInt(temp[2]); String statusNgo = temp[3]; if(nameNgo.equals(name) && aidsNgo.equals(aids)){ qty += quantity; flag=1; } nName.add(nameNgo); nAids.add(aidsNgo); nQty.add(qty); nStatus.add(statusNgo); } if(flag==0){ nName.add(name); nAids.add(aids); nQty.add(quantity); nStatus.add(status); } WriteBack.updateNgo(nName, nAids, nQty, nStatus); } public static ArrayList<String> requestedaids() throws IOException{ ArrayList<String> required = new ArrayList<>(); List<String>lines = Files.readAllLines(Paths.get(\"src/Documentation/NgoDemands.csv\")); for(int i =0; i<lines.size();i++){ String[] items = lines.get(i).split(\",\"); String ngoName = items[0]; String aidRequired = items[1]; String quantityRequired = items[2]; String status = items[3]; required.add(ngoName+\" \"+aidRequired+\" \"+quantityRequired+ \" \"+ status); } return required; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Donor-NGO Matcher/Java-Project-main/src/Ngo.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Ngo class handles data representation, CSV file reading, and demand updates. Multiple responsibilities violate SRP."}, {"principle": "Open-Closed", "justification": "Modifying data source or update logic requires direct changes to Ngo class. No extension mechanism exists."}, {"principle": "Dependency Inversion", "justification": "Directly depends on concrete WriteBack class and file system access. No abstractions for I/O operations."}]}]}
{"project_id": 26, "chunk_id": 0, "prompt": {"main_file_path": "Donor-NGO Matcher/Java-Project-main/src/QAfterDeque.java", "main_file_content": "import java.io.FileWriter; import java.io.IOException; import java.util.*; public class QAfterDeque { public static void updatefiledq(String path, ArrayList<MatchedClass> arrlist, String ngoname, int flag) throws IOException { for (MatchedClass ngoClass : arrlist) { if (ngoClass.ngoName.equals(ngoname)) { ngoClass.setStatus(\"Collected\"); } } try(FileWriter writer = new FileWriter(path)){ for (MatchedClass ngoClass : arrlist) { if (ngoClass.ngoMan != 0){ writer.write(ngoClass.dName + \",\" + ngoClass.dPhone + \",\" + ngoClass.aidType + \",\" + ngoClass.aidQty + \",\" + ngoClass.ngoName + \",\" + ngoClass.ngoMan + \",\" + ngoClass.status + \"\\n\"); } else{ writer.write(ngoClass.dName + \",\" + ngoClass.dPhone + \",\" + ngoClass.aidType + \",\" + ngoClass.aidQty + \",\" + \"0\" + \",\" + \"0\" + \",\" + ngoClass.status + \"\\n\"); } } }catch(Exception e){ soutl(\"\") } ShowHistory.viewAidsHistory(\"null\",flag); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Donor-NGO Matcher/Java-Project-main/src/QAfterDeque.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "QAfterDeque handles multiple responsibilities: modifying MatchedClass statuses, writing to files, and triggering view history. This violates SRP as there are multiple reasons for the class to change."}, {"principle": "Open-Closed", "justification": "The file-writing logic and status update logic cannot be extended without modifying QAfterDeque's code. This violates OCP since new behaviors require direct code changes."}, {"principle": "Dependency Inversion", "justification": "QAfterDeque directly depends on concrete FileWriter and ShowHistory classes instead of abstractions. High-level modules should not depend on low-level implementations."}]}]}
{"project_id": 26, "chunk_id": 0, "prompt": {"main_file_path": "Donor-NGO Matcher/Java-Project-main/src/NgoClass.java", "main_file_content": "public class NgoClass{ String ngoName; int ngoMan; NgoClass(String ngoName, int ngoMan) { this.ngoName = ngoName; this.ngoMan = ngoMan; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Donor-NGO Matcher/Java-Project-main/src/NgoClass.java", "violatedPrinciples": []}]}
{"project_id": 26, "chunk_id": 0, "prompt": {"main_file_path": "Donor-NGO Matcher/Java-Project-main/src/SimulationMenu.java", "main_file_content": "import java.util.Scanner; public class SimulationMenu { public static void Simulation() throws Exception { Scanner scanner = new Scanner(System.in); String menu = \"\"\" || Welcome to the DC Simulation || | Select the queue mode from the give choices | | Enter 1: First in First out mode | | Enter 2: Priority mode | ||\"\"\"; soutl(\"\") int choice = scanner.nextInt(); switch (choice) { case (1): QSimulator.startQSimulator(); break; case (2): PqSimulator.startPqSimulator(); break; } scanner.close(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Donor-NGO Matcher/Java-Project-main/src/SimulationMenu.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The SimulationMenu class handles both user input/output and simulation control flow. These are two distinct responsibilities that should be separated into different classes."}, {"principle": "Open-Closed", "justification": "The switch statement directly instantiates concrete simulator implementations. Adding new simulation modes requires modifying existing code rather than extending through abstractions."}, {"principle": "Dependency Inversion", "justification": "High-level SimulationMenu directly depends on concrete QSimulator/PqSimulator implementations rather than abstractions. Low-level modules should implement interfaces defined by high-level policy."}]}]}
{"project_id": 28, "chunk_id": 0, "prompt": {"main_file_path": "Motorcyclist-Service-main/Motorcyclist-Service-main/Bike/src/bike/EquipmentBase.java", "main_file_content": "package bike; public abstract class EquipmentBase { private String name; private double price; private double weight; public EquipmentBase(String _name, double _price, double _weight){ this.name = _name; this.price = _price; this.weight = _weight; } public String getName(){ return name; } public void setName(String _name){ this.name = _name; } public double getPrice(){ return price; } public void setPrice(double _price){ this.price = _price; } public double getWeight(){ return weight; } public void setWeight(double _weight){ this.weight = _weight; } public abstract void seeEquipment(); public enum StrValues { A(\"The list of full equipment is empty!\"), B(\"Recheck the entered choice\"), C(\"1) For head\"), D(\"2) For body\"), E(\"3) For legs\"); private final String textRepresentation; StrValues(String textRepresentation) { this.textRepresentation = textRepresentation; } @Override public String toString() { return textRepresentation; } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Motorcyclist-Service-main/Motorcyclist-Service-main/Bike/src/bike/EquipmentBase.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "EquipmentBase handles both equipment properties (name, price, weight) and UI-related string constants (StrValues enum), giving it multiple responsibilities. Changes to equipment data models or UI message formats would require modifying this class."}]}]}
{"project_id": 28, "chunk_id": 0, "prompt": {"main_file_path": "Motorcyclist-Service-main/Motorcyclist-Service-main/Bike/src/bike/BodyEquipment.java", "main_file_content": "package bike; import java.util.ArrayList; import java.util.Comparator; import static bike.Program.bodyEquipment; import static bike.Program.headEquipment; public class BodyEquipment extends EquipmentBase implements Equipmentable { public BodyEquipment(String _name, double _price, double _weight) { super(_name, _price, _weight); } @Override public void seeEquipment() { int numeric = 1; for (EquipmentBase e : bodyEquipment) { sout(\"\") numeric++; } } public void findByRangeOfPrice(double consoleMinPrice, double consoleMaxPrice) { ArrayList<EquipmentBase> newWithNeedPriceBody = new ArrayList<>(); for (EquipmentBase e : headEquipment) { if (e.getPrice() >= consoleMinPrice && e.getPrice() <= consoleMaxPrice) { newWithNeedPriceBody.add(e); } } for (EquipmentBase eqNew : newWithNeedPriceBody) { soutl(\"\") } } @Override public void sortByWeight() { bodyEquipment.sort(Comparator.comparingDouble(EquipmentBase::getWeight)); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Motorcyclist-Service-main/Motorcyclist-Service-main/Bike/src/bike/BodyEquipment.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "BodyEquipment manages both body and head equipment (via headEquipment in findByRangeOfPrice), handles sorting, and displays equipment, indicating multiple responsibilities."}, {"principle": "Dependency Inversion", "justification": "BodyEquipment directly depends on concrete static collections (bodyEquipment, headEquipment) from Program instead of abstractions, creating tight coupling."}]}]}
{"project_id": 28, "chunk_id": 0, "prompt": {"main_file_path": "Motorcyclist-Service-main/Motorcyclist-Service-main/Bike/src/bike/HeadEquipment.java", "main_file_content": "package bike; import java.util.ArrayList; import java.util.Comparator; import static bike.Program.headEquipment; public class HeadEquipment extends EquipmentBase implements Equipmentable { public HeadEquipment(String _name, double _price, double _weight) { super(_name, _price, _weight); } @Override public void seeEquipment() { int numeric = 1; for (EquipmentBase e : headEquipment) { sout(\"\") numeric++; } } @Override public void findByRangeOfPrice(double consoleMinPrice, double consoleMaxPrice) { ArrayList<EquipmentBase> newWithNeedPriceHead = new ArrayList<>(); for (EquipmentBase e : headEquipment) { if (e.getPrice() >= consoleMinPrice && e.getPrice() <= consoleMaxPrice) { newWithNeedPriceHead.add(e); } } for (EquipmentBase eqNew : newWithNeedPriceHead) { soutl(\"\") } } @Override public void sortByWeight() { headEquipment.sort(Comparator.comparingDouble(EquipmentBase::getWeight)); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Motorcyclist-Service-main/Motorcyclist-Service-main/Bike/src/bike/HeadEquipment.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "HeadEquipment manages equipment data (sorting, filtering, displaying) while also representing a single equipment item. These are two distinct responsibilities requiring separate classes."}, {"principle": "Open-Closed", "justification": "Sorting/filtering logic is implemented directly in HeadEquipment. Adding new sorting/filtering criteria would require modifying existing code instead of extending via new classes."}, {"principle": "Dependency Inversion", "justification": "HeadEquipment directly depends on concrete static headEquipment list from Program. High-level classes should depend on abstractions for equipment collections, not concrete implementations."}]}]}
{"project_id": 28, "chunk_id": 0, "prompt": {"main_file_path": "Motorcyclist-Service-main/Motorcyclist-Service-main/Bike/src/bike/LegsEquipment.java", "main_file_content": "package bike; import java.util.ArrayList; import java.util.Comparator; import static bike.Program.headEquipment; import static bike.Program.legsEquipment; public class LegsEquipment extends EquipmentBase implements Equipmentable { public LegsEquipment(String _name, double _price, double _weight) { super(_name, _price, _weight); } @Override public void seeEquipment() { int numeric = 1; for (EquipmentBase e : legsEquipment) { sout(\"\") numeric++; } } public void findByRangeOfPrice(double consoleMinPrice, double consoleMaxPrice) { ArrayList<EquipmentBase> newWithNeedPriceLegs = new ArrayList<>(); for (EquipmentBase e : headEquipment) { if (e.getPrice() >= consoleMinPrice && e.getPrice() <= consoleMaxPrice) { newWithNeedPriceLegs.add(e); } } for (EquipmentBase eqNew : newWithNeedPriceLegs) { soutl(\"\") } } @Override public void sortByWeight() { legsEquipment.sort(Comparator.comparingDouble(EquipmentBase::getWeight)); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Motorcyclist-Service-main/Motorcyclist-Service-main/Bike/src/bike/LegsEquipment.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "LegsEquipment handles multiple responsibilities: managing legsEquipment, filtering headEquipment in findByRangeOfPrice, and sorting. This creates multiple reasons for the class to change."}, {"principle": "Open-Closed", "justification": "Filtering (findByRangeOfPrice) and sorting (sortByWeight) logic is hardcoded. Adding new criteria would require modifying the class instead of extending it."}, {"principle": "Dependency Inversion", "justification": "Directly depends on concrete static lists (headEquipment, legsEquipment) from Program instead of abstractions, violating high-level module independence from low-level details."}]}]}
{"project_id": 28, "chunk_id": 0, "prompt": {"main_file_path": "Motorcyclist-Service-main/Motorcyclist-Service-main/Bike/src/bike/Program.java", "main_file_content": "package bike; import java.util.ArrayList; import java.util.Scanner; public class Program{ public static ArrayList<EquipmentBase> headEquipment = new ArrayList<>(); public static ArrayList<EquipmentBase> bodyEquipment = new ArrayList<>(); public static ArrayList<EquipmentBase> legsEquipment = new ArrayList<>(); static HeadEquipment eqH; static BodyEquipment eqB; static LegsEquipment eqL; public static void main(String[] args) { toMenu(); } public static void toMenu() { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") Scanner consoleChoose = new Scanner(System.in); sout(\"\") String choose = consoleChoose.nextLine(); switch (Integer.parseInt(choose)) { case 1 -> addingEq(); case 2 -> { if (headEquipment.size() != 0 && bodyEquipment.size() != 0 && legsEquipment.size() != 0) { try { deletingEq(); } catch (Exception e) { soutl(\"\") } } else { System.err.println(EquipmentBase.StrValues.A); toMenu(); } } case 3 -> { if (headEquipment.size() != 0 && bodyEquipment.size() != 0 && legsEquipment.size() != 0) { try { seeingAllEq(); } catch (Exception e) { soutl(\"\") } } else { System.err.println(EquipmentBase.StrValues.A); toMenu(); } } case 4 -> { if (headEquipment.size() != 0 && bodyEquipment.size() != 0 && legsEquipment.size() != 0) { try { countingByRangeOfPrice(); } catch (Exception e) { soutl(\"\") } } else { System.err.println(EquipmentBase.StrValues.A); toMenu(); } } case 5 -> { if (headEquipment.size() != 0 && bodyEquipment.size() != 0 && legsEquipment.size() != 0) { try { countingCommonPrice(); } catch (Exception e) { soutl(\"\") } } else { System.err.println(EquipmentBase.StrValues.A); toMenu(); } } case 6 -> { if (headEquipment.size() != 0 && bodyEquipment.size() != 0 && legsEquipment.size() != 0) { try { sortingByWeight(); } catch (Exception e) { soutl(\"\") } } else { System.err.println(EquipmentBase.StrValues.A); toMenu(); } } default -> { sout(\"\") toMenu(); } } } private static void sortingByWeight() { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") Scanner consoleChooseTypeEq = new Scanner(System.in); sout(\"\") String chooseType = consoleChooseTypeEq.nextLine(); switch (Integer.parseInt(chooseType)) { case 1 -> sortingForHead(); case 2 -> sortingForBody(); case 3 -> sortingForLegs(); default -> sout(\"\") } toMenu(); } private static void sortingForLegs() { eqL.sortByWeight(); soutl(\"\") eqL.seeEquipment(); } private static void sortingForBody() { eqB.sortByWeight(); soutl(\"\") eqB.seeEquipment(); } private static void sortingForHead() { eqH.sortByWeight(); soutl(\"\") eqH.seeEquipment(); } private static void countingCommonPrice() { soutl(\"\") toMenu(); } private static void countingByRangeOfPrice() { soutl(\"\") Scanner consoleMinPrice = new Scanner(System.in); String min = consoleMinPrice.nextLine(); soutl(\"\") Scanner consoleMaxPrice = new Scanner(System.in); String max = consoleMaxPrice.nextLine(); eqH.findByRangeOfPrice(Double.parseDouble(String.valueOf(min)),Double.parseDouble(String.valueOf(max))); eqB.findByRangeOfPrice(Double.parseDouble(String.valueOf(min)),Double.parseDouble(String.valueOf(max))); eqL.findByRangeOfPrice(Double.parseDouble(String.valueOf(min)),Double.parseDouble(String.valueOf(max))); toMenu(); } private static void seeingAllEq() { soutl(\"\") eqH.seeEquipment(); soutl(\"\") eqB.seeEquipment(); soutl(\"\") eqL.seeEquipment(); toMenu(); } private static void deletingEq() { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") Scanner consoleChooseTypeEq = new Scanner(System.in); sout(\"\") String chooseType = consoleChooseTypeEq.nextLine(); switch (Integer.parseInt(chooseType)) { case 1 -> deleteFromHead(); case 2 -> deleteFromBody(); case 3 -> deleteFromLegs(); default -> sout(\"\") } toMenu(); } private static void deleteFromHead() { soutl(\"\") eqH.seeEquipment(); Scanner consoleChooseD = new Scanner(System.in); String choose = consoleChooseD.nextLine(); int intChoose = Integer.parseInt(choose); if (intChoose <= headEquipment.size()) { headEquipment.remove(headEquipment.get(intChoose - 1)); } else { sout(\"\") toMenu(); } soutl(\"\") } private static void deleteFromBody() { soutl(\"\") eqB.seeEquipment(); Scanner consoleChooseD = new Scanner(System.in); String choose = consoleChooseD.nextLine(); int intChoose = Integer.parseInt(choose); if (intChoose <= bodyEquipment.size()) { bodyEquipment.remove(bodyEquipment.get(intChoose - 1)); } else { sout(\"\") toMenu(); } soutl(\"\") } private static void deleteFromLegs() { soutl(\"\") eqL.seeEquipment(); Scanner consoleChooseD = new Scanner(System.in); String choose = consoleChooseD.nextLine(); int intChoose = Integer.parseInt(choose); if (intChoose <= legsEquipment.size()) { legsEquipment.remove(legsEquipment.get(intChoose - 1)); } else { sout(\"\") toMenu(); } soutl(\"\") } private static void addingEq() { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") Scanner consoleChooseTypeEq = new Scanner(System.in); sout(\"\") String chooseType = consoleChooseTypeEq.nextLine(); switch (Integer.parseInt(chooseType)) { case 1 -> addToHead(); case 2 -> addToBody(); case 3 -> addToLegs(); default -> sout(\"\") } toMenu(); } private static void addToHead() { soutl(\"\") sout(\"\") Scanner console = new Scanner(System.in); String newName = console.nextLine(); sout(\"\") String newPrice = console.nextLine(); sout(\"\") String newWeight = console.nextLine(); eqH = new HeadEquipment(newName,Double.parseDouble(newPrice),Double.parseDouble(newWeight)); headEquipment.add(eqH); soutl(\"\") } private static void addToBody() { soutl(\"\") sout(\"\") Scanner console = new Scanner(System.in); String newName = console.nextLine(); sout(\"\") String newPrice = console.nextLine(); sout(\"\") String newWeight = console.nextLine(); eqB = new BodyEquipment(newName,Double.parseDouble(newPrice),Double.parseDouble(newWeight)); bodyEquipment.add(eqB); soutl(\"\") } private static void addToLegs() { soutl(\"\") sout(\"\") Scanner console = new Scanner(System.in); String newName = console.nextLine(); sout(\"\") String newPrice = console.nextLine(); sout(\"\") String newWeight = console.nextLine(); eqL = new LegsEquipment(newName,Double.parseDouble(newPrice),Double.parseDouble(newWeight)); legsEquipment.add(eqL); soutl(\"\") } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Motorcyclist-Service-main/Motorcyclist-Service-main/Bike/src/bike/Program.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Program class handles multiple responsibilities: user input, menu navigation, equipment management (adding/deleting/sorting), and price calculations. This violates SRP as it has multiple reasons to change."}, {"principle": "Open-Closed", "justification": "Adding new equipment types or menu options requires modifying existing switch-case blocks and methods in Program.java, violating OCP by not allowing extension without code modification."}, {"principle": "Dependency Inversion", "justification": "Program directly depends on concrete classes (HeadEquipment, BodyEquipment, LegsEquipment) instead of abstractions. High-level modules (e.g., sorting logic) are tightly coupled to low-level implementations."}]}]}
{"project_id": 28, "chunk_id": 0, "prompt": {"main_file_path": "Motorcyclist-Service-main/Motorcyclist-Service-main/Bike/src/bike/Equipmentable.java", "main_file_content": "package bike; import static bike.Program.*; public interface Equipmentable { static double countPrice() { double commonPrice = 0; for (EquipmentBase e : headEquipment) { commonPrice += e.getPrice(); } for (EquipmentBase e : bodyEquipment) { commonPrice += e.getPrice(); } for (EquipmentBase e : legsEquipment) { commonPrice += e.getPrice(); } return commonPrice; } void findByRangeOfPrice(double consoleMinPrice, double consoleMaxPrice); void sortByWeight(); }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Motorcyclist-Service-main/Motorcyclist-Service-main/Bike/src/bike/Equipmentable.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Equipmentable interface handles price calculation and defines equipment management methods, combining multiple responsibilities in a single interface."}, {"principle": "Open-Closed", "justification": "Adding new equipment types requires modifying the countPrice() method's loops, violating the principle of being open for extension but closed for modification."}, {"principle": "Interface Segregation", "justification": "Clients implementing Equipmentable must depend on both findByRangeOfPrice() and sortByWeight() even if they use only one, forcing unnecessary method implementations."}, {"principle": "Dependency Inversion", "justification": "The interface directly depends on concrete static lists (headEquipment, bodyEquipment, legsEquipment) from the Program class instead of abstractions."}]}]}
{"project_id": 29, "chunk_id": 0, "prompt": {"main_file_path": "Java-Project-main/src/DirectBackMenu.java", "main_file_content": "import java.io.IOException; import java.util.Scanner; public class DirectBackMenu{ public static void directBack(String name,int flag) throws Exception { Scanner sc = new Scanner(System.in); soutl(\"\") String tempChoice = sc.nextLine(); int choice = Integer.parseInt(tempChoice); if(choice == 1 && flag==1){ DonorMenu.welcomeDonor(name); } else if(choice == 1 && flag==2){ NgoMenu.welcomeNgo(name); } else{ System.exit(0); } sc.close(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Java-Project-main/src/DirectBackMenu.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The DirectBackMenu class handles input reading, decision-making, and directly invoking different menus, combining multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Adding a new menu type requires modifying the existing conditional logic in directBack, violating open for extension but closed for modification."}, {"principle": "Dependency Inversion", "justification": "DirectBackMenu directly references concrete DonorMenu and NgoMenu classes instead of depending on abstractions."}]}]}
{"project_id": 29, "chunk_id": 0, "prompt": {"main_file_path": "Java-Project-main/src/DonorMenu.java", "main_file_content": "import java.util.*; import java.io.*; public class DonorMenu extends Donor{ private static final Scanner sc = new Scanner(System.in); public static void welcomeDonor(String name) throws Exception { String menu= (\"\\n||\" +\"\\n Welcome Donor \"+name+\" \" +\"\\n||\" +\"\\n| Enter 1: To Enter the aids to be donated |\" +\"\\n| Enter 2: To view all the aids donated to DC |\" +\"\\n| Enter 3: To view all the aids donated delivered to NGO |\" +\"\\n||\"); soutl(\"\") int choice= sc.nextInt(); switch (choice){ case(1): enterAids(sc, name); break; case(2): showAvailableAids(name,0); break; case(3): ShowHistory.viewAidsHistory(name,0); break; } DirectBackMenu.directBack(name,1); sc.close(); } public static void enterAids(Scanner sc, String name) throws IOException{ sc = new Scanner(System.in); soutl(\"\") soutl(\"\") String itemName = sc.nextLine(); soutl(\"\") int quantity = sc.nextInt(); soutl(\"\") if(quantity>0){ Donor set = new Donor(name,itemName,quantity); set.saveDonorAids(); soutl(\"\") } else{ soutl(\"\") enterAids(sc, name); } } public static void showAvailableAids(String name,int flag){ File file = new File(\"src/Documentation/DonatedItems.csv\"); try{ Scanner input = new Scanner(file); soutl(\"\") System.out.format(\"|%10s |%11s |%10s|\",\"Name \",\"Aid\",\"Quantity\"); soutl(\"\") boolean found = false; do{ String data = input.nextLine(); List<String> source = Arrays.asList(data.split(\",\")); String list = Arrays.toString(source.toArray()).replace(\"[\", \" \").replace(\"]\", \" \").replace(\",\", \" \"); if (list.contains(name) && flag==0){ String[] temp = list.split(\"\\\\s+\"); System.out.printf(\"| %10s |%11s |%10s|\",temp[1],temp[2],temp[3]); soutl(\"\") found = true; } else if(flag==1){ String[] temp = list.split(\"\\\\s+\"); System.out.printf(\"| %10s |%11s |%10s|\",temp[1],temp[2],temp[3]); soutl(\"\") found =true; } } while(input.hasNextLine()); if(!found){ System.out.printf(\"| %10s |%11s |%10s |%10s |%10s |%10s|\",\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"); soutl(\"\") soutl(\"\") } } catch (Exception e){ soutl(\"\") soutl(\"\") soutl(\"\") } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Java-Project-main/src/DonorMenu.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "DonorMenu handles user interaction, data input, file I/O, and coordination with other classes, violating SRP by managing multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Adding new menu options requires modifying the switch statement in welcomeDonor, violating OCP as the class isn't extendable without changing existing code."}, {"principle": "Dependency Inversion", "justification": "DonorMenu directly depends on concrete classes Donor, DirectBackMenu, and ShowHistory instead of abstractions, violating DIP by coupling high-level modules to low-level implementations."}]}]}
{"project_id": 29, "chunk_id": 0, "prompt": {"main_file_path": "Java-Project-main/src/ShowHistory.java", "main_file_content": "import java.util.*; import java.io.*; public class ShowHistory { public static void viewAidsHistory(String name,int flag){ String path; if(flag==2){ path = \"src/Documentation/AfterQ.csv\"; flag=1; } else if (flag==3){ path = \"src/Documentation/AfterPq.csv\"; flag=1; } else{ path = \"src/Documentation/Donor&NgoMatched.csv\"; } File file = new File(path); boolean found = false; try{ Scanner input = new Scanner(file); soutl(\"\") System.out.format(\"|%10s |%11s |%10s |%10s |%10s |%10s |%10s|\",\"Donor \",\"PhoneNumber\",\"Aid\",\"Quantity\",\"Ngo\",\"Manpower\",\"Status\"); soutl(\"\") do{ String data = input.nextLine(); List<String> source = Arrays.asList(data.split(\",\")); String list = Arrays.toString(source.toArray()).replace(\"[\", \"\").replace(\"]\", \"\").replace(\",\", \" \"); if (list.contains(name) && flag==0){ String[] temp = list.split(\"\\\\s+\"); System.out.printf(\"| %10s |%11s |%10s |%10s |%10s |%10s |%10s|\",temp[0],temp[1],temp[2],temp[3],temp[4],temp[5],temp[6]); sout(\"\") found = true; } else if(flag==1){ String[] temp = list.split(\"\\\\s+\"); if(temp[5].equals(\"0\")){ temp[4] = \"-\"; temp[5] = \"-\"; } System.out.printf(\"| %10s |%11s |%10s |%10s |%10s |%10s |%10s|\",temp[0],temp[1],temp[2],temp[3],temp[4],temp[5],temp[6]); sout(\"\") found = true; } } while(input.hasNextLine()); if(!found){ System.out.printf(\"| %10s |%11s |%10s |%10s |%10s |%10s |%10s|\",\"X\",\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"); soutl(\"\") soutl(\"\") } input.close(); }catch (Exception e){ System.out.printf(\"| %10s |%11s |%10s |%10s |%10s |%10s |%10s|\",\"X\",\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"); soutl(\"\") soutl(\"\") } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Java-Project-main/src/ShowHistory.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The ShowHistory class handles multiple responsibilities: file path determination, CSV parsing, data processing, and formatted output display. These multiple responsibilities create multiple reasons for the class to change."}, {"principle": "Open-Closed", "justification": "The viewAidsHistory method uses conditional logic (flag checks) to determine file paths and processing behavior. Adding new file types/behaviors would require modifying existing code rather than extending it."}, {"principle": "Dependency Inversion", "justification": "High-level CSV processing logic directly depends on concrete implementations (File, Scanner). No abstractions are used to decouple business logic from low-level file I/O operations."}]}]}
{"project_id": 29, "chunk_id": 0, "prompt": {"main_file_path": "Java-Project-main/src/LoginSystem.java", "main_file_content": "import java.util.*; import java.io.*; public class LoginSystem { public static void authenticateUser(Scanner sc, int flag) throws Exception { sc = new Scanner(System.in); ArrayList<String> credentials = Credentials.readCredsFromFile(flag); soutl(\"\") soutl(\"\") String tempname=sc.nextLine(); soutl(\"\") String temppassword=sc.nextLine(); boolean check=false; for (int i = 0; i<credentials.size();i++){ check = credentials.get(i).equals(tempname+\" \"+temppassword); if(check) { soutl(\"\") String[] temp = credentials.get(i).split(\"\\\\s\"); tempname=temp[0]; if(flag==1){ DonorMenu.welcomeDonor(tempname); } else if(flag==2){ NgoMenu.welcomeNgo(tempname); } break; } } if(!check){ soutl(\"\") authenticateUser(sc,flag); } } public static void createNewUsers(int flag) throws IOException { Scanner sc = new Scanner(System.in); soutl(\"\") soutl(\"\") String username = sc.nextLine(); soutl(\"\") String password = sc.nextLine(); soutl(\"\") String temppassword= sc.nextLine(); int num; if(flag==1){ soutl(\"\") } else{ soutl(\"\") } num = sc.nextInt(); soutl(\"\") do{ if (temppassword.equals(password)){ break; } else{ soutl(\"\") temppassword= sc.nextLine(); } }while(temppassword!=password); Credentials.saveCredsToFile(sc, flag, username, password, num); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Java-Project-main/src/LoginSystem.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "LoginSystem handles user authentication, user creation, file I/O coordination, and input validation. These multiple responsibilities violate SRP."}, {"principle": "Open-Closed", "justification": "Adding a new user type (e.g., Admin) requires modifying authenticateUser's conditional logic instead of extending via abstraction, violating OCP."}, {"principle": "Dependency Inversion", "justification": "LoginSystem directly depends on concrete Credentials, DonorMenu, and NgoMenu classes instead of abstractions, violating DIP for high-level modules."}]}]}
{"project_id": 29, "chunk_id": 0, "prompt": {"main_file_path": "Java-Project-main/src/QSimulator.java", "main_file_content": "import java.util.*; import java.io.*; import java.nio.file.*; public class QSimulator { public static void startQSimulator() throws Exception { soutl(\"\") List<String> lines = Files.readAllLines(Paths.get(\"src/Documentation/Donor&NgoMatched.csv\")); ArrayList<MatchedClass> qarrlist = new ArrayList<MatchedClass>(); ShowHistory.viewAidsHistory(\"null\",1); for(int i = 0; i < lines.size();i++) { String[] things = lines.get(i).split(\",\"); MatchedClass data1 = new MatchedClass(things[0], things[1], things[2], things[3], things[4], Integer.parseInt(things[5]), things[6]); qarrlist.add(data1); } ArrayList<String> allNgos = new ArrayList<String>(); for(int i = 0; i < qarrlist.size(); i++){ if(!qarrlist.get(i).ngoName.equals(\"0\")) allNgos.add(qarrlist.get(i).ngoName); } Queue<String> queue = new LinkedList<String>(); int choice; Scanner scan = new Scanner(System.in); Scanner scan2 = new Scanner(System.in); boolean brktheloop = false; do{ String menu = \"\"\" || | Press 1 for enqueue | | Press 2 for dequeue | | Press 3 to exit | ||\"\"\"; soutl(\"\") choice = scan.nextInt(); String ngoname; boolean found = false; switch(choice) { case (1): soutl(\"\") ngoname = scan2.nextLine(); found = allNgos.contains(ngoname); if(found) queue.add(ngoname); else soutl(\"\") break; case (2): if(queue.size() > 0){ String nowname = queue.remove(); soutl(\"\") String path = \"src/Documentation/AfterQ.csv\"; QAfterDeque.updatefiledq(path, qarrlist, nowname, 2); } else soutl(\"\") break; case (3): brktheloop = true; break; default: soutl(\"\") throw new IOException(); } if(brktheloop) break; } while(choice != 3); scan.close(); scan2.close(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Java-Project-main/src/QSimulator.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "QSimulator handles CSV parsing, queue management, user input processing, and file updates. These are multiple responsibilities that should be split into separate classes."}, {"principle": "Dependency Inversion", "justification": "QSimulator directly depends on concrete implementations (MatchedClass, ShowHistory, QAfterDeque) without abstractions. High-level modules should depend on interfaces instead."}, {"principle": "Open-Closed", "justification": "Adding new queue operations or data sources would require modifying QSimulator's code. No extension mechanisms (e.g., interfaces/inheritance) are provided for closed modification."}]}]}
{"project_id": 29, "chunk_id": 0, "prompt": {"main_file_path": "Java-Project-main/src/Matching.java", "main_file_content": "import java.io.IOException; import java.util.*; public class Matching extends MatchAlgorithm{ private static final Scanner sc = new Scanner(System.in); public static void filter() throws IOException{ ArrayList<String> donatedaids = Donor.donatedaids(); ArrayList<String> requiredaids = Ngo.requestedaids(); ArrayList<String> dName = new ArrayList<String>(); ArrayList<String> dAids = new ArrayList<String>(); ArrayList<Integer> dQty = new ArrayList<Integer>(); ArrayList<String> fName = new ArrayList<String>(); ArrayList<String> fAids = new ArrayList<String>(); ArrayList<Integer> fQty = new ArrayList<Integer>(); ArrayList<String> nName = new ArrayList<String>(); ArrayList<String> nAids = new ArrayList<String>(); ArrayList<Integer> nQty = new ArrayList<Integer>(); ArrayList<String> nStatus = new ArrayList<String>(); for (String requiredaid : requiredaids) { String[] temp = requiredaid.split(\"\\\\s\"); String status = temp[3]; if (status.contains(\"unsatisfied\")) { nName.add(temp[0]); nAids.add(temp[1]); int Qty = Integer.parseInt(temp[2]); nQty.add(Qty); nStatus.add(temp[3]); } } soutl(\"\") System.out.format(\"|%10s |%11s |%10s|\",\"Name \",\"Aid\",\"Quantity\"); soutl(\"\") for(int i=0; i< nAids.size();i++){ String[] temp = requiredaids.get(i).split(\"\\\\s+\"); System.out.printf(\"| %10s |%11s |%10s|\",temp[0],temp[1],temp[2]); soutl(\"\") } soutl(\"\") soutl(\"\") soutl(\"\") String name = sc.nextLine(); int flag=0; for (String donatedaid : donatedaids) { String[] temp = donatedaid.split(\"\\\\s+\"); String aids = temp[1]; int Qty = Integer.parseInt(temp[2]); if (aids.equals(name)) { dName.add(temp[0]); dAids.add(aids); dQty.add(Qty); flag = 1; } else { fName.add(temp[0]); fAids.add(aids); fQty.add(Qty); } } if(flag==0){ soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") } else{ WriteBack.updateDonor(fName, fAids, fQty,0); runAlgo(name, dName, dAids, dQty, nName, nAids, nQty, nStatus); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Java-Project-main/src/Matching.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Matching class handles multiple responsibilities: data filtering, UI interaction (Scanner), output formatting, and coordinating updates. This makes it likely to change for UI, reporting, or algorithm reasons."}, {"principle": "Dependency Inversion", "justification": "Matching directly depends on concrete classes Donor, Ngo, and WriteBack instead of abstractions. High-level matching logic should depend on interfaces, not low-level implementation details."}]}]}
{"project_id": 29, "chunk_id": 0, "prompt": {"main_file_path": "Java-Project-main/src/DcMenu.java", "main_file_content": "import java.util.*; import java.io.IOException; public class DcMenu { private static final Scanner sc = new Scanner(System.in); public static void showDcMenu() throws Exception { soutl(\"\") int choice = sc.nextInt(); switch (choice) { case 1: DonorMenu.showAvailableAids(\"null\",1); break; case 2: NgoMenu.showStatus(\"null\",1); break; case 3: Matching.filter(); WriteBack.updateDonorAndNgo(); break; case 4: SimulationMenu.Simulation(); break; case 5: soutl(\"\") show(sc,0); break; case 6: soutl(\"\") show(sc,0); break; case 7: show(sc,1); break; } sc.close(); } public static void show(Scanner sc, int flag){ sc = new Scanner(System.in); if(flag==0){ String str = sc.nextLine(); ShowHistory.viewAidsHistory(str,0); } else if(flag==1){ ShowHistory.viewAidsHistory(\"null\",1); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Java-Project-main/src/DcMenu.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "DcMenu handles multiple responsibilities: menu display, user input processing, and delegating actions to other classes (DonorMenu, NgoMenu, etc.), which violates SRP by having more than one reason to change."}, {"principle": "Open-Closed", "justification": "Adding a new menu option requires modifying the switch-case block in showDcMenu(), violating OCP as the class is not open for extension without altering existing code."}, {"principle": "Dependency Inversion", "justification": "DcMenu directly depends on concrete low-level modules (DonorMenu, NgoMenu, Matching, etc.) instead of abstractions, violating DIP by coupling high-level policy to implementation details."}]}]}
{"project_id": 29, "chunk_id": 0, "prompt": {"main_file_path": "Java-Project-main/src/Credentials.java", "main_file_content": "import java.io.FileWriter; import java.io.IOException; import java.nio.file.Files; import java.nio.file.Paths; import java.util.ArrayList; import java.util.List; import java.util.Scanner; public class Credentials { private static String username; public Credentials(){ } public static ArrayList<String> readCredsFromFile(int flag){ ArrayList<String> credentials = new ArrayList<>(); List<String> lines = new ArrayList<>(); try{ if(flag==1){ lines = Files.readAllLines(Paths.get(\"src/credentials/DonorCredentials.csv\")); } else if(flag==2){ lines = Files.readAllLines(Paths.get(\"src/credentials/NgoCredentials.csv\")); } for (String line : lines) { String[] items = line.split(\",\"); username = items[0]; String password = items[1]; credentials.add(username + \" \" + password); } }catch(Exception e){ soutl(\"\") } return credentials; } public static void saveCredsToFile(Scanner sc, int flag, String name, String password, int num) throws IOException { ArrayList<String> credentials = readCredsFromFile(flag); int innerFlag=0; for (String credential : credentials) { String[] items = credential.split(\",\"); String[] temp = items[0].split(\"\\\\s\"); username = temp[0]; if (username.equals(name)) { innerFlag = 1; } } if(innerFlag==1){ soutl(\"\") soutl(\"\") soutl(\"\") LoginSystem.createNewUsers(flag); } else{ if(flag==1){ try{ String filename= \"src/credentials/DonorCredentials.csv\"; FileWriter fw = new FileWriter(filename,true); fw.write(\"\\n\"+name+\",\"+password+\",\"+num); fw.close(); soutl(\"\") }catch(IOException ioe){ System.err.println(\"IOException: \" + ioe.getMessage()); } } else if(flag==2){ try{ String filename= \"src/credentials/NgoCredentials.csv\"; FileWriter fw = new FileWriter(filename,true); fw.write(\"\\n\"+name+\",\"+password+\",\"+num); fw.close(); }catch(IOException ioe){ System.err.println(\"IOException: \" + ioe.getMessage()); } } } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Java-Project-main/src/Credentials.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Credentials class handles multiple responsibilities: reading credentials from files, writing credentials to files, and interacting with LoginSystem for user creation. This means multiple reasons to change."}, {"principle": "Open-Closed", "justification": "Using flag parameters to determine file paths and behaviors forces modification of existing code to support new credential types, instead of allowing extension through new classes or strategies."}, {"principle": "Dependency Inversion", "justification": "High-level Credentials class directly depends on concrete LoginSystem and file I/O implementations (FileWriter, Files), rather than abstractions. Low-level details are not decoupled via interfaces."}]}]}
{"project_id": 29, "chunk_id": 0, "prompt": {"main_file_path": "Java-Project-main/src/NgoComparator.java", "main_file_content": "import java.util.Comparator; public class NgoComparator implements Comparator<NgoClass>{ public int compare(NgoClass n1, NgoClass n2) { if (n1.ngoMan < n2.ngoMan) return 1; else if (n1.ngoMan > n2.ngoMan) return -1; return 0; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Java-Project-main/src/NgoComparator.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "NgoComparator directly depends on the concrete NgoClass. High-level modules (comparators) should depend on abstractions, not concrete implementations."}]}]}
{"project_id": 29, "chunk_id": 0, "prompt": {"main_file_path": "Java-Project-main/src/Start.java", "main_file_content": "import java.io.IOException; import java.util.*; public class Start { static Scanner sc = new Scanner(System.in); public static void main(String[] args) throws Exception { String menu = \"\"\" || | Welcome to our Aid Distribution System | | To proceed please choose an option below | || |1-Proceed to Register a new user | |2-Proceed as a Donor: | |3-Proceed as a Non-Government Organization: | |4-Proceed as a Distribution Center | |0-To Exit | ||\"\"\"; soutl(\"\") int choice = sc.nextInt(); switch(choice){ case(1): soutl(\"\") int ch = sc.nextInt(); LoginSystem.createNewUsers(ch); main(args); break; case(2): LoginSystem.authenticateUser(sc,1); break; case(3): LoginSystem.authenticateUser(sc,2); break; case(4): DcMenu.showDcMenu(); break; case(0): soutl(\"\") System.exit(0); break; default: throw new IOException(); } sc.close(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Java-Project-main/src/Start.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Start class handles user input parsing, menu display, application flow control, and directly calls business logic methods. These are multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Adding new menu options requires modifying the switch statement in the Start class instead of extending through abstractions."}, {"principle": "Dependency Inversion", "justification": "High-level Start class directly depends on concrete LoginSystem and DcMenu implementations rather than abstractions, creating tight coupling."}]}]}
{"project_id": 29, "chunk_id": 0, "prompt": {"main_file_path": "Java-Project-main/src/MatchedClass.java", "main_file_content": "public class MatchedClass{ String dName; String dPhone; String aidType; String aidQty; String ngoName; int ngoMan; String status; MatchedClass(String dName, String dPhone, String aidType, String aidQty, String ngoName, int ngoMan, String status){ this.dName = dName; this.dPhone = dPhone; this.aidType = aidType; this.aidQty = aidQty; this.ngoName = ngoName; this.ngoMan = ngoMan; this.status = status; } public void setStatus(String status){ this.status = status; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Java-Project-main/src/MatchedClass.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "MatchedClass manages donor information (dName, dPhone), aid details (aidType, aidQty), NGO details (ngoName, ngoMan), and status handling. Combining multiple distinct responsibilities into one class violates SRP."}]}]}
{"project_id": 29, "chunk_id": 0, "prompt": {"main_file_path": "Java-Project-main/src/Donor.java", "main_file_content": "import java.io.IOException; import java.util.ArrayList; import java.util.List; import java.nio.file.Files; import java.nio.file.Paths; public class Donor{ private String name; private String itemName; private int quantity; public Donor(){} public Donor(String name,String itemName, int qty){ this.name = name; this.itemName = itemName; quantity = qty; } public void saveDonorAids() throws IOException{ ArrayList<String> data = donatedaids(); ArrayList<String> dName = new ArrayList<String>(); ArrayList<String> dAids = new ArrayList<String>(); ArrayList<Integer> dQty = new ArrayList<Integer>(); int flag=0; WriteBack.store(name, itemName, quantity, \"0\", false); for (String datum : data) { String[] temp = datum.split(\"\\\\s\"); String nameDonor = temp[0]; String aids = temp[1]; int qty = Integer.parseInt(temp[2]); if (nameDonor.equals(name) && aids.equals(itemName)) { qty += quantity; flag = 1; } dName.add(nameDonor); dAids.add(aids); dQty.add(qty); } if(flag==0){ dName.add(name); dAids.add(itemName); dQty.add(quantity); } WriteBack.updateDonor(dName, dAids, dQty,0); } public static ArrayList<String> donatedaids() throws IOException{ ArrayList<String> previousAids= new ArrayList<>(); List<String>lines = Files.readAllLines(Paths.get(\"src/Documentation/DonatedItems.csv\")); for(int i =0; i<lines.size();i++){ String[] items = lines.get(i).split(\",\"); String name = items[0]; String aids = items[1]; String quantity = items[2]; previousAids.add(name+\" \"+aids+\" \"+quantity); } return previousAids; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Java-Project-main/src/Donor.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Donor class manages donor data and handles file I/O operations, which are separate responsibilities. Changing data handling or storage logic would require modifying the same class."}, {"principle": "Open-Closed", "justification": "The Donor class directly implements file operations, so extending storage mechanisms requires modifying existing code. Hence, not closed for modification."}, {"principle": "Dependency Inversion", "justification": "Donor depends on concrete WriteBack class and Files instead of abstractions. High-level module depends on low-level implementations directly."}]}]}
{"project_id": 29, "chunk_id": 0, "prompt": {"main_file_path": "Java-Project-main/src/MatchAlgorithm.java", "main_file_content": "import java.io.IOException; import java.util.ArrayList; import java.util.Collections; public class MatchAlgorithm { public static void runAlgo(String name, ArrayList<String> dName, ArrayList<String> dAids ,ArrayList<Integer> dQty, ArrayList<String> nName, ArrayList<String> nAids, ArrayList<Integer> nQty, ArrayList<String> nStatus) throws IOException{ for(int i =0; i< nName.size();i++){ if(name.equals(nAids.get(i))){ sortArray(dName, dAids, dQty); if(dQty.get(0) == 0){ break; } if(nQty.get(i)<=dQty.get(0)){ WriteBack.store(dName.get(i), dAids.get(i), nQty.get(i), nName.get(i), true); dQty.set(0,dQty.get(0)-nQty.get(i)); nQty.set(i,0); nStatus.set(i,\"satisfied\"); break; } else{ for(int j=0; j< dQty.size();j++){ if(nQty.get(i)<=dQty.get(j)){ dQty.set(j,dQty.get(j)-nQty.get(i)); if(dQty.get(j)!=0){ WriteBack.store(dName.get(j), dAids.get(j), nQty.get(i), nName.get(i), true); } nQty.set(i,0); nStatus.set(i,\"satisfied\"); break; } else{ WriteBack.store(dName.get(j), dAids.get(j), dQty.get(j), nName.get(i), true); nQty.set(i,nQty.get(i)-dQty.get(j)); dQty.set(j,0); } } } } } WriteBack.updateDonor(dName, dAids, dQty,1); WriteBack.updateNgo(nName, nAids, nQty, nStatus); } public static void sortArray(ArrayList<String> dName,ArrayList<String> dAids, ArrayList<Integer> dQty){ for(int i=0;i<dQty.size()-1;i++){ for(int j=i+1;j<dQty.size();j++){ if(dQty.get(i)<dQty.get(j)){ Collections.swap(dQty,i,j); Collections.swap(dName,i,j); Collections.swap(dAids,i,j); } } } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Java-Project-main/src/MatchAlgorithm.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "MatchAlgorithm handles both sorting logic and the core matching algorithm, and directly interacts with WriteBack for storage. This combines data processing, sorting, and I/O responsibilities in one class."}, {"principle": "Open-Closed", "justification": "The class uses static methods with procedural logic, making it impossible to extend behavior (e.g., modify sorting or matching rules) without modifying the existing code."}, {"principle": "Dependency Inversion", "justification": "MatchAlgorithm directly depends on the concrete WriteBack class for I/O operations instead of abstractions. High-level algorithm logic is tightly coupled to low-level storage implementation."}]}]}
{"project_id": 29, "chunk_id": 0, "prompt": {"main_file_path": "Java-Project-main/src/WriteBack.java", "main_file_content": "import java.io.*; import java.nio.file.Files; import java.nio.file.Paths; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.Scanner; public class WriteBack { public static void store(String dName, String dAids ,int dQty, String nName, boolean flag) throws IOException{ List<String> lines = Files.readAllLines(Paths.get(\"src/credentials/DonorCredentials.csv\")); String phono = \"\"; String status = \"Reserved\"; for (String line : lines) { String[] items = line.split(\",\"); if (dName.equals(items[0])) { phono = items[2]; } } lines = Files.readAllLines(Paths.get(\"src/credentials/NgoCredentials.csv\")); String manpower = \"\"; for (String line : lines) { String[] items = line.split(\",\"); if (nName.equals(items[0])) { manpower = items[2]; } else if (nName.equals(\"0\")) { manpower = nName; status = \"Available\"; } } String path = \"src/Documentation/Donor&NgoMatched.csv\"; try (FileWriter fw = new FileWriter(path,true)){ fw.write(dName + \",\" + phono + \",\" + dAids + \",\" + dQty + \",\" + nName + \",\" + manpower + \",\" + status+\"\\n\"); if(flag){ soutl(\"\") soutl(\"\") System.out.format(\"|%10s |%11s |%10s |%10s |%10s |%10s |%10s|\",\"Donor \",\"PhoneNumber\",\"Aid\",\"Quantity\",\"Ngo\",\"Manpower\",\"Status\"); soutl(\"\") System.out.printf(\"| %10s |%11s |%10s |%10s |%10s |%10s |%10s|\",dName, phono, dAids, dQty, nName, manpower, status); soutl(\"\") } } catch(Exception e){ soutl(\"\") } } public static void updateDonor(ArrayList<String> dName, ArrayList<String> dAids, ArrayList<Integer> dQty, int flag){ String path = \"src/Documentation/DonatedItems.csv\"; if(flag==0){ try( FileWriter fw = new FileWriter(path)){ for(int i=0; i<dQty.size(); i++){ fw.write(dName.get(i) +\",\" + dAids.get(i) + \",\" + dQty.get(i) + \"\\n\"); } fw.close(); }catch(Exception e){ soutl(\"\") } } else{ try( FileWriter fw = new FileWriter(path,true)){ for(int i=0; i<dQty.size(); i++){ if(dQty.get(i)!=0){ fw.write(dName.get(i) +\",\" + dAids.get(i) + \",\" + dQty.get(i) + \"\\n\"); } } fw.close(); }catch(Exception e){ soutl(\"\") } } } public static void updateNgo(ArrayList<String> nName, ArrayList<String> nAids,ArrayList<Integer> nQty, ArrayList<String> nStatus){ try{ String path = \"src/Documentation/NgoDemands.csv\"; FileWriter fw = new FileWriter(path); for(int i = 1; i < nStatus.size();i++){ if(nStatus.get(i).equals(\"unsatisfied\")){ fw.write(nName.get(i) +\",\"+ nAids.get(i)+ \",\" + nQty.get(i)+\",\"+ nStatus.get(i) + \"\\n\"); } } fw.close(); }catch(Exception e){ soutl(\"\") } } public static void updateDonorAndNgo(){ try{ String path= \"src/Documentation/Donor&NgoMatched.csv\"; List<String>lines = Files.readAllLines(Paths.get(\"src/Documentation/Donor&NgoMatched.csv\")); FileWriter fw = new FileWriter(path); fw.close(); int i =0; do { String[] items = lines.get(i).split(\",\"); String name = items[0]; String aids = items[2]; int quantity = Integer.parseInt(items[3]); String ngoName = items[4]; String status = items[6]; if (!status.equals(\"Available\")) { store(name, aids, quantity, ngoName, false); } i++; }while(i<lines.size()); ArrayList<String> data = Donor.donatedaids(); for (int j=0; j<data.size(); j++) { String[] items = data.get(j).split(\"\\\\s+\"); String name = items[0]; String aids = items[1]; int quantity = Integer.parseInt(items[2]); store(name, aids, quantity, \"0\", false); } }catch(Exception e){ soutl(\"\") } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Java-Project-main/src/WriteBack.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The WriteBack class handles multiple responsibilities: reading/writing files, data processing, and UI formatting. This violates SRP as it has multiple reasons to change (e.g., file I/O logic changes, output formatting changes)."}, {"principle": "Open-Closed", "justification": "The class uses static methods and direct file operations, making it impossible to extend its behavior (e.g., adding new data sources/output formats) without modifying existing code, violating OCP."}, {"principle": "Dependency Inversion", "justification": "The class directly depends on concrete file I/O implementations (e.g., FileWriter, Files.readAllLines) instead of abstractions. High-level logic is tightly coupled to low-level details, violating DIP."}]}]}
{"project_id": 29, "chunk_id": 0, "prompt": {"main_file_path": "Java-Project-main/src/PqSimulator.java", "main_file_content": "import java.util.*; import java.io.*; import java.nio.file.*; public class PqSimulator{ public static void startPqSimulator() throws Exception { soutl(\"\") List<String> lines = Files.readAllLines(Paths.get(\"src/Documentation/Donor&NgoMatched.csv\")); ArrayList<MatchedClass> ngoarr = new ArrayList<MatchedClass>(); Map<String, Integer> map = new HashMap<String, Integer>(); ShowHistory.viewAidsHistory(\"null\",1); for(int i = 0; i < lines.size();i++) { String[] things = lines.get(i).split(\",\"); MatchedClass data1 = new MatchedClass(things[0], things[1], things[2], things[3], things[4], Integer.parseInt(things[5]), things[6]); ngoarr.add(data1); map.put(ngoarr.get(i).ngoName, ngoarr.get(i).ngoMan); } ArrayList<String> allNgos = new ArrayList<String>(); for (MatchedClass MatchedClass : ngoarr) { if (!MatchedClass.ngoName.equals(\"0\")) allNgos.add(MatchedClass.ngoName); } PriorityQueue<NgoClass> pq = new PriorityQueue<NgoClass>(5, new NgoComparator()); int choice; Scanner scan = new Scanner(System.in); Scanner scan2 = new Scanner(System.in); boolean brktheloop = false; do{ String menu = \"\"\" || | Press 1 for enqueue | | Press 2 for dequeue | | Press 3 to exit | ||\"\"\"; soutl(\"\") choice = scan.nextInt(); String ngoname; boolean found = false; switch(choice) { case (1): soutl(\"\") ngoname = scan2.nextLine(); found = allNgos.contains(ngoname); if(found){ NgoClass ngo1 = new NgoClass(ngoname, map.get(ngoname)); pq.add(ngo1); } else soutl(\"\") break; case (2): if(pq.size() > 0){ String nowname = pq.poll().ngoName; soutl(\"\") String path = \"src/Documentation/AfterPq.csv\"; QAfterDeque.updatefiledq(path, ngoarr, nowname, 3); } else{ soutl(\"\") } break; case (3): brktheloop = true; break; default: soutl(\"\") throw new IOException(); } if(brktheloop) break; } while(choice != 3); scan.close(); scan2.close(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Java-Project-main/src/PqSimulator.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "PqSimulator handles file I/O, data parsing, queue management, user input, and UI logic, indicating multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Adding new queue operations (e.g., peek) requires modifying the switch-case in startPqSimulator instead of extending via abstractions."}, {"principle": "Dependency Inversion", "justification": "High-level methods directly instantiate MatchedClass, NgoClass, and NgoComparator without depending on abstractions."}]}]}
{"project_id": 29, "chunk_id": 0, "prompt": {"main_file_path": "Java-Project-main/src/NgoMenu.java", "main_file_content": "import java.util.*; import java.io.*; public class NgoMenu extends Ngo{ private static final Scanner sc = new Scanner(System.in); public static void welcomeNgo(String name) throws Exception { soutl(\"\") int choice = sc.nextInt(); switch (choice) { case (1): enterRequiredAids(sc, name); break; case(2): showStatus(name,0); break; case (3): ShowHistory.viewAidsHistory(name,0); break; } DirectBackMenu.directBack(name,2); sc.close(); } public static void enterRequiredAids(Scanner sc, String name) throws IOException{ sc = new Scanner(System.in); soutl(\"\") soutl(\"\") String amount=sc.nextLine(); soutl(\"\") int qty=sc.nextInt(); soutl(\"\") if(qty>0){ Ngo set = new Ngo(name,amount, qty, \"unsatisfied\"); set.saveNgoDemands(); soutl(\"\") } else{ soutl(\"\") enterRequiredAids(sc, name); } } public static void showStatus(String name, int flag){ File file = new File(\"src/Documentation/NgoDemands.csv\"); boolean found = false ; try{ Scanner input = new Scanner(file); soutl(\"\") System.out.format(\"|%10s |%11s |%10s|\",\"Name \",\"Aid\",\"Quantity\"); soutl(\"\") do{ String data = input.nextLine(); List<String> source = Arrays.asList(data.split(\",\")); String list = Arrays.toString(source.toArray()).replace(\"[\", \" \").replace(\"]\", \" \").replace(\",\", \" \"); if (list.contains(name) && list.contains(\"unsatisfied\") && flag==0){ String[] temp = list.split(\"\\\\s+\"); System.out.printf(\"| %10s |%11s |%10s|\",temp[1],temp[2],temp[3]); soutl(\"\") found = true; } else if(flag==1){ String[] temp = list.split(\"\\\\s+\"); System.out.printf(\"| %10s |%11s |%10s|\",temp[1],temp[2],temp[3]); soutl(\"\") found = true; } } while(input.hasNextLine()); if(!found){ System.out.printf(\"| %10s |%11s |%10s |%10s |%10s |%10s|\",\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"); soutl(\"\") soutl(\"\") } } catch (Exception e){ soutl(\"\") soutl(\"\") soutl(\"\") } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Java-Project-main/src/NgoMenu.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The NgoMenu class handles user input, menu navigation, file operations, and business logic (e.g., enterRequiredAids, showStatus). These are multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Adding new menu options (e.g., a new case in the switch statement) requires modifying the existing welcomeNgo method instead of extending via abstractions."}, {"principle": "Dependency Inversion", "justification": "High-level methods like showStatus directly instantiate low-level modules (File, Scanner). NgoMenu also directly depends on concrete Ngo class instead of abstractions."}]}]}
{"project_id": 29, "chunk_id": 0, "prompt": {"main_file_path": "Java-Project-main/src/Ngo.java", "main_file_content": "import java.io.IOException; import java.util.ArrayList; import java.util.List; import java.nio.file.Files; import java.nio.file.Paths; public class Ngo { private String name; private String aids; private int quantity; private String status; public Ngo() {}; public Ngo(String name, String aids, int q, String status) { this.name = name; this.aids = aids; quantity = q; this.status = status; } public void saveNgoDemands() throws IOException{ ArrayList<String> data = requestedaids(); ArrayList<String> nName = new ArrayList<String>(); ArrayList<String> nAids = new ArrayList<String>(); ArrayList<Integer> nQty = new ArrayList<Integer>(); ArrayList<String> nStatus = new ArrayList<String>(); int flag=0; for(int i = 0; i < data.size();i++){ String[] temp = data.get(i).split(\"\\\\s\"); String nameNgo = temp[0]; String aidsNgo = temp[1]; int qty = Integer.parseInt(temp[2]); String statusNgo = temp[3]; if(nameNgo.equals(name) && aidsNgo.equals(aids)){ qty += quantity; flag=1; } nName.add(nameNgo); nAids.add(aidsNgo); nQty.add(qty); nStatus.add(statusNgo); } if(flag==0){ nName.add(name); nAids.add(aids); nQty.add(quantity); nStatus.add(status); } WriteBack.updateNgo(nName, nAids, nQty, nStatus); } public static ArrayList<String> requestedaids() throws IOException{ ArrayList<String> required = new ArrayList<>(); List<String>lines = Files.readAllLines(Paths.get(\"src/Documentation/NgoDemands.csv\")); for(int i =0; i<lines.size();i++){ String[] items = lines.get(i).split(\",\"); String ngoName = items[0]; String aidRequired = items[1]; String quantityRequired = items[2]; String status = items[3]; required.add(ngoName+\" \"+aidRequired+\" \"+quantityRequired+ \" \"+ status); } return required; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Java-Project-main/src/Ngo.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Ngo class manages NGO data, reads/writes from/to files, and processes demands, handling multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Adding new data processing or persistence methods requires modifying Ngo's existing code instead of extending it."}, {"principle": "Dependency Inversion", "justification": "Ngo directly depends on the concrete WriteBack class instead of an abstraction, violating high-level module dependency rules."}]}]}
{"project_id": 29, "chunk_id": 0, "prompt": {"main_file_path": "Java-Project-main/src/QAfterDeque.java", "main_file_content": "import java.io.FileWriter; import java.io.IOException; import java.util.*; public class QAfterDeque { public static void updatefiledq(String path, ArrayList<MatchedClass> arrlist, String ngoname, int flag) throws IOException { for (MatchedClass ngoClass : arrlist) { if (ngoClass.ngoName.equals(ngoname)) { ngoClass.setStatus(\"Collected\"); } } try(FileWriter writer = new FileWriter(path)){ for (MatchedClass ngoClass : arrlist) { if (ngoClass.ngoMan != 0){ writer.write(ngoClass.dName + \",\" + ngoClass.dPhone + \",\" + ngoClass.aidType + \",\" + ngoClass.aidQty + \",\" + ngoClass.ngoName + \",\" + ngoClass.ngoMan + \",\" + ngoClass.status + \"\\n\"); } else{ writer.write(ngoClass.dName + \",\" + ngoClass.dPhone + \",\" + ngoClass.aidType + \",\" + ngoClass.aidQty + \",\" + \"0\" + \",\" + \"0\" + \",\" + ngoClass.status + \"\\n\"); } } }catch(Exception e){ soutl(\"\") } ShowHistory.viewAidsHistory(\"null\",flag); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Java-Project-main/src/QAfterDeque.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "QAfterDeque.updatefiledq() handles multiple responsibilities: modifying MatchedClass objects, writing to files, and triggering UI updates via ShowHistory. This requires the class to change for data processing, I/O, or UI logic changes."}, {"principle": "Dependency Inversion", "justification": "QAfterDeque directly depends on concrete MatchedClass and ShowHistory implementations rather than abstractions. High-level file writing/logic depends on low-level details without interface isolation."}]}]}
{"project_id": 29, "chunk_id": 0, "prompt": {"main_file_path": "Java-Project-main/src/NgoClass.java", "main_file_content": "public class NgoClass{ String ngoName; int ngoMan; NgoClass(String ngoName, int ngoMan) { this.ngoName = ngoName; this.ngoMan = ngoMan; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 29, "chunk_id": 0, "prompt": {"main_file_path": "Java-Project-main/src/SimulationMenu.java", "main_file_content": "import java.util.Scanner; public class SimulationMenu { public static void Simulation() throws Exception { Scanner scanner = new Scanner(System.in); String menu = \"\"\" || Welcome to the DC Simulation || | Select the queue mode from the give choices | | Enter 1: First in First out mode | | Enter 2: Priority mode | ||\"\"\"; soutl(\"\") int choice = scanner.nextInt(); switch (choice) { case (1): QSimulator.startQSimulator(); break; case (2): PqSimulator.startPqSimulator(); break; } scanner.close(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Java-Project-main/src/SimulationMenu.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The SimulationMenu class handles user input, menu display, and simulator selection, which are multiple responsibilities. It should be split into separate classes for each responsibility."}, {"principle": "Open-Closed", "justification": "Adding a new simulation mode requires modifying the switch statement in the Simulation method. The class is not closed for modification but open for extension via abstraction."}, {"principle": "Dependency Inversion", "justification": "SimulationMenu directly depends on concrete classes QSimulator and PqSimulator instead of abstractions. High-level modules should depend on interfaces, not low-level implementations."}]}]}
{"project_id": 30, "chunk_id": 0, "prompt": {"main_file_path": "VPS-master/VPS-master/src/main/java/com/website/dao/UserDao.java", "main_file_content": "package com.website.dao; import com.website.entities.User; import java.sql.*; public class UserDao { private Connection connection; public UserDao(Connection connection) { this.connection = connection; } public boolean saveUser(User user) { boolean check = false; try { String query = \"insert into users(`name`,email,password,address) values (?,?,?,?)\"; PreparedStatement preparedStatement = this.connection.prepareStatement(query); preparedStatement.setString(1, user.getName()); preparedStatement.setString(2, user.getEmail()); preparedStatement.setString(3, user.getPassword()); preparedStatement.setString(4,user.getAddress()); preparedStatement.executeUpdate(); check = true; } catch (Exception e) { e.printStackTrace(); } return check; } public User getUserByEmailAndPassword(String email, String password) { User user = null; try { String query = \"Select * from users where email = ? and password = ?\"; PreparedStatement preparedStatement = connection.prepareStatement(query); preparedStatement.setString(1, email); preparedStatement.setString(2, password); ResultSet set = preparedStatement.executeQuery(); if (set.next()) { user = new User(); String name = set.getString(\"name\"); user.setName(name); user.setId(set.getInt(\"Id\")); user.setEmail(set.getString(\"email\")); user.setPassword(set.getString(\"password\")); user.setRegDate(set.getTimestamp(\"regdate\")); user.setProfile(set.getString(\"profile\")); user.setProfile(set.getString(\"address\")); } } catch ( Exception e) { e.printStackTrace(); } return user; } }", "dependencies": [{"file_path": "VPS-master/VPS-master/src/main/java/com/website/entities/User.java", "file_content": "package com.website.entities; import java.sql.*; public class User { private int id; private String name; private String email; private String password; private Timestamp regDate; private String profile; private String address; public User(int id, String name, String email, String password, Timestamp regDate) { this.id = id; this.name = name; this.email = email; this.password = password; this.regDate = regDate; } public User(){ } public User(String name, String email, String password) { this.name = name; this.email = email; this.password = password; this.regDate = regDate; } public User(String name, String email, String password, String address) { } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public Timestamp getRegDate() { return regDate; } public void setRegDate(Timestamp regDate) { this.regDate = regDate; } public String getProfile() { return profile; } public void setProfile(String profile) { this.profile = profile; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "VPS-master/VPS-master/src/main/java/com/website/dao/UserDao.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "UserDao handles both user persistence logic and direct database interaction (SQL queries, connection management), which are separate responsibilities."}, {"principle": "Open-Closed", "justification": "UserDao cannot be extended to support new query types or data sources without modifying its existing code (e.g., adding new methods)."}, {"principle": "Dependency Inversion", "justification": "UserDao directly depends on the low-level java.sql.Connection implementation instead of depending on an abstraction for database connections."}]}, {"file_path": "VPS-master/VPS-master/src/main/java/com/website/entities/User.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "User class has multiple constructors with inconsistent initialization logic (e.g., empty constructor, partial field initialization), indicating fragmented responsibility."}]}]}
{"project_id": 30, "chunk_id": 0, "prompt": {"main_file_path": "VPS-master/VPS-master/src/main/java/com/website/servlets/RegisterServlet.java", "main_file_content": "package com.website.servlets; import com.website.dao.UserDao; import com.website.entities.User; import com.website.helper.ConnectionProvider; import javax.servlet.*; import javax.servlet.annotation.MultipartConfig; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.PrintWriter; @MultipartConfig public class RegisterServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.setContentType(\"text/html;charset=UTF-8\"); try (PrintWriter out = resp.getWriter()) { String check = req.getParameter(\"user_check\"); if(check == null){ out.println(\"Please accept the terms and conditions\"); } else{ String name = req.getParameter(\"user_name\"); String email = req.getParameter(\"user_email\"); String password = req.getParameter(\"user_password\"); String address = req.getParameter(\"user_address\"); User user = new User(name,email,password,address); UserDao dao = new UserDao(ConnectionProvider.getConnection()); if (dao.saveUser(user)){ out.println(\"done\"); } else { out.println(\"error\"); } } }catch (Exception e){ e.printStackTrace(); } } }", "dependencies": [{"file_path": "VPS-master/VPS-master/src/main/java/com/website/dao/UserDao.java", "file_content": "package com.website.dao; import com.website.entities.User; import java.sql.*; public class UserDao { private Connection connection; public UserDao(Connection connection) { this.connection = connection; } public boolean saveUser(User user) { boolean check = false; try { String query = \"insert into users(`name`,email,password,address) values (?,?,?,?)\"; PreparedStatement preparedStatement = this.connection.prepareStatement(query); preparedStatement.setString(1, user.getName()); preparedStatement.setString(2, user.getEmail()); preparedStatement.setString(3, user.getPassword()); preparedStatement.setString(4,user.getAddress()); preparedStatement.executeUpdate(); check = true; } catch (Exception e) { e.printStackTrace(); } return check; } public User getUserByEmailAndPassword(String email, String password) { User user = null; try { String query = \"Select * from users where email = ? and password = ?\"; PreparedStatement preparedStatement = connection.prepareStatement(query); preparedStatement.setString(1, email); preparedStatement.setString(2, password); ResultSet set = preparedStatement.executeQuery(); if (set.next()) { user = new User(); String name = set.getString(\"name\"); user.setName(name); user.setId(set.getInt(\"Id\")); user.setEmail(set.getString(\"email\")); user.setPassword(set.getString(\"password\")); user.setRegDate(set.getTimestamp(\"regdate\")); user.setProfile(set.getString(\"profile\")); user.setProfile(set.getString(\"address\")); } } catch ( Exception e) { e.printStackTrace(); } return user; } }"}, {"file_path": "VPS-master/VPS-master/src/main/java/com/website/entities/User.java", "file_content": "package com.website.entities; import java.sql.*; public class User { private int id; private String name; private String email; private String password; private Timestamp regDate; private String profile; private String address; public User(int id, String name, String email, String password, Timestamp regDate) { this.id = id; this.name = name; this.email = email; this.password = password; this.regDate = regDate; } public User(){ } public User(String name, String email, String password) { this.name = name; this.email = email; this.password = password; this.regDate = regDate; } public User(String name, String email, String password, String address) { } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public Timestamp getRegDate() { return regDate; } public void setRegDate(Timestamp regDate) { this.regDate = regDate; } public String getProfile() { return profile; } public void setProfile(String profile) { this.profile = profile; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } }"}, {"file_path": "VPS-master/VPS-master/src/main/java/com/website/helper/ConnectionProvider.java", "file_content": "package com.website.helper; import java.sql.*; public class ConnectionProvider { private static Connection connection; private final static String URL = \"jdbc:mysql: private final static String username = \"root\"; private final static String password = \"7983909427\"; public static Connection getConnection() { try{ if(connection == null) { Class.forName(\"com.mysql.jdbc.Driver\"); connection = DriverManager .getConnection(URL, username, password); } }catch(Exception e){ e.printStackTrace(); } return connection; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "VPS-master/VPS-master/src/main/java/com/website/servlets/RegisterServlet.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "RegisterServlet handles HTTP request processing, user data validation, database interaction, and response generation, violating SRP by managing multiple responsibilities."}, {"principle": "Dependency Inversion", "justification": "RegisterServlet directly instantiates concrete UserDao and depends on ConnectionProvider, a low-level module, instead of abstractions."}]}, {"file_path": "VPS-master/VPS-master/src/main/java/com/website/dao/UserDao.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "UserDao is not extendable without modification (e.g., adding new database operations requires changing its code)."}, {"principle": "Interface Segregation", "justification": "Clients using UserDao must depend on both saveUser and getUserByEmailAndPassword even if they use only one method."}]}]}
{"project_id": 30, "chunk_id": 0, "prompt": {"main_file_path": "VPS-master/VPS-master/src/main/java/com/website/servlets/LoginServlet.java", "main_file_content": "package com.website.servlets; import com.website.dao.UserDao; import com.website.entities.User; import com.website.helper.ConnectionProvider; import javax.servlet.*; import javax.servlet.http.*; import java.io.IOException; import java.io.PrintWriter; public class LoginServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.setContentType(\"text/html;charset=UTF-8\"); try (PrintWriter out = resp.getWriter()) { String email = req.getParameter(\"email\"); String password = req.getParameter(\"password\"); UserDao dao = new UserDao(ConnectionProvider.getConnection()); User user = dao.getUserByEmailAndPassword(email , password); if (user == null){ out.println(\"Invalid Details... Please register yourself first\"); } else { HttpSession httpSession = req.getSession(); httpSession.setAttribute(\"currentUser\", user); resp.sendRedirect(\"profile.jsp\"); } } } }", "dependencies": [{"file_path": "VPS-master/VPS-master/src/main/java/com/website/dao/UserDao.java", "file_content": "package com.website.dao; import com.website.entities.User; import java.sql.*; public class UserDao { private Connection connection; public UserDao(Connection connection) { this.connection = connection; } public boolean saveUser(User user) { boolean check = false; try { String query = \"insert into users(`name`,email,password,address) values (?,?,?,?)\"; PreparedStatement preparedStatement = this.connection.prepareStatement(query); preparedStatement.setString(1, user.getName()); preparedStatement.setString(2, user.getEmail()); preparedStatement.setString(3, user.getPassword()); preparedStatement.setString(4,user.getAddress()); preparedStatement.executeUpdate(); check = true; } catch (Exception e) { e.printStackTrace(); } return check; } public User getUserByEmailAndPassword(String email, String password) { User user = null; try { String query = \"Select * from users where email = ? and password = ?\"; PreparedStatement preparedStatement = connection.prepareStatement(query); preparedStatement.setString(1, email); preparedStatement.setString(2, password); ResultSet set = preparedStatement.executeQuery(); if (set.next()) { user = new User(); String name = set.getString(\"name\"); user.setName(name); user.setId(set.getInt(\"Id\")); user.setEmail(set.getString(\"email\")); user.setPassword(set.getString(\"password\")); user.setRegDate(set.getTimestamp(\"regdate\")); user.setProfile(set.getString(\"profile\")); user.setProfile(set.getString(\"address\")); } } catch ( Exception e) { e.printStackTrace(); } return user; } }"}, {"file_path": "VPS-master/VPS-master/src/main/java/com/website/entities/User.java", "file_content": "package com.website.entities; import java.sql.*; public class User { private int id; private String name; private String email; private String password; private Timestamp regDate; private String profile; private String address; public User(int id, String name, String email, String password, Timestamp regDate) { this.id = id; this.name = name; this.email = email; this.password = password; this.regDate = regDate; } public User(){ } public User(String name, String email, String password) { this.name = name; this.email = email; this.password = password; this.regDate = regDate; } public User(String name, String email, String password, String address) { } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public Timestamp getRegDate() { return regDate; } public void setRegDate(Timestamp regDate) { this.regDate = regDate; } public String getProfile() { return profile; } public void setProfile(String profile) { this.profile = profile; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } }"}, {"file_path": "VPS-master/VPS-master/src/main/java/com/website/helper/ConnectionProvider.java", "file_content": "package com.website.helper; import java.sql.*; public class ConnectionProvider { private static Connection connection; private final static String URL = \"jdbc:mysql: private final static String username = \"root\"; private final static String password = \"7983909427\"; public static Connection getConnection() { try{ if(connection == null) { Class.forName(\"com.mysql.jdbc.Driver\"); connection = DriverManager .getConnection(URL, username, password); } }catch(Exception e){ e.printStackTrace(); } return connection; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "VPS-master/VPS-master/src/main/java/com/website/servlets/LoginServlet.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "LoginServlet handles HTTP request processing, user authentication, session management, and response redirection. Changes to any of these responsibilities require modifying the class."}, {"principle": "Dependency Inversion", "justification": "LoginServlet directly instantiates concrete UserDao and ConnectionProvider. High-level modules should depend on abstractions, not low-level implementations like these."}]}, {"file_path": "VPS-master/VPS-master/src/main/java/com/website/dao/UserDao.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "UserDao manages both user persistence (saveUser) and retrieval (getUserByEmailAndPassword). Changes to either operation would require modifying the class."}]}]}
{"project_id": 30, "chunk_id": 0, "prompt": {"main_file_path": "VPS-master/VPS-master/src/main/java/com/website/helper/ConnectionProvider.java", "main_file_content": "package com.website.helper; import java.sql.*; public class ConnectionProvider { private static Connection connection; private final static String URL = \"jdbc:mysql: private final static String username = \"root\"; private final static String password = \"7983909427\"; public static Connection getConnection() { try{ if(connection == null) { Class.forName(\"com.mysql.jdbc.Driver\"); connection = DriverManager .getConnection(URL, username, password); } }catch(Exception e){ e.printStackTrace(); } return connection; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "VPS-master/VPS-master/src/main/java/com/website/helper/ConnectionProvider.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "The class is not closed for modification since changing the connection creation logic (e.g., switching to a connection pool) requires altering the existing code. It also directly hardcodes database configuration, preventing extension without changes."}, {"principle": "Dependency Inversion", "justification": "The high-level ConnectionProvider directly depends on concrete JDBC classes (DriverManager) instead of abstractions (e.g., DataSource). Low-level database details are tightly coupled, violating abstraction requirements."}]}]}
{"project_id": 30, "chunk_id": 0, "prompt": {"main_file_path": "VPS-master/VPS-master/src/main/java/com/website/entities/User.java", "main_file_content": "package com.website.entities; import java.sql.*; public class User { private int id; private String name; private String email; private String password; private Timestamp regDate; private String profile; private String address; public User(int id, String name, String email, String password, Timestamp regDate) { this.id = id; this.name = name; this.email = email; this.password = password; this.regDate = regDate; } public User(){ } public User(String name, String email, String password) { this.name = name; this.email = email; this.password = password; this.regDate = regDate; } public User(String name, String email, String password, String address) { } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public Timestamp getRegDate() { return regDate; } public void setRegDate(Timestamp regDate) { this.regDate = regDate; } public String getProfile() { return profile; } public void setProfile(String profile) { this.profile = profile; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "VPS-master/VPS-master/src/main/java/com/website/entities/User.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The User class handles user data management, including database-specific fields like regDate (Timestamp), which introduces persistence concerns beyond a pure data model responsibility."}, {"principle": "Open-Closed", "justification": "The class is not designed for extension (e.g., no abstractions or protected methods) and would require modification to add new user types or behaviors."}]}]}
{"project_id": 31, "chunk_id": 0, "prompt": {"main_file_path": "rex-weather-master/rex-weather-master/app/src/main/java/mu/node/rexweather/app/WeatherActivity.java", "main_file_content": "package mu.node.rexweather.app; import android.app.Activity; import android.app.Fragment; import android.content.Context; import android.location.Location; import android.location.LocationManager; import android.os.Bundle; import android.support.v4.widget.SwipeRefreshLayout; import android.util.Log; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.ArrayAdapter; import android.widget.ListView; import android.widget.TextView; import org.apache.http.HttpException; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.concurrent.TimeUnit; import java.util.concurrent.TimeoutException; import de.keyboardsurfer.android.widget.crouton.Crouton; import de.keyboardsurfer.android.widget.crouton.Style; import mu.node.rexweather.app.Helpers.DayFormatter; import mu.node.rexweather.app.Helpers.TemperatureFormatter; import mu.node.rexweather.app.Models.CurrentWeather; import mu.node.rexweather.app.Models.WeatherForecast; import mu.node.rexweather.app.Services.LocationService; import mu.node.rexweather.app.Services.WeatherService; import retrofit.RetrofitError; import rx.Observable; import rx.Subscriber; import rx.android.schedulers.AndroidSchedulers; import rx.functions.Func1; import rx.functions.Func2; import rx.schedulers.Schedulers; import rx.subscriptions.CompositeSubscription; public class WeatherActivity extends Activity { @Override protected void onCreate(final Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_weather); if (savedInstanceState == null) { getFragmentManager().beginTransaction() .add(R.id.container, new WeatherFragment()) .commit(); } } public static class WeatherFragment extends Fragment { private static final String KEY_CURRENT_WEATHER = \"key_current_weather\"; private static final String KEY_WEATHER_FORECASTS = \"key_weather_forecasts\"; private static final long LOCATION_TIMEOUT_SECONDS = 20; private static final String TAG = WeatherFragment.class.getCanonicalName(); private CompositeSubscription mCompositeSubscription; private SwipeRefreshLayout mSwipeRefreshLayout; private TextView mLocationNameTextView; private TextView mCurrentTemperatureTextView; private ListView mForecastListView; private TextView mAttributionTextView; @Override public View onCreateView(final LayoutInflater inflater, final ViewGroup container, final Bundle savedInstanceState) { mCompositeSubscription = new CompositeSubscription(); final View rootView = inflater.inflate(R.layout.fragment_weather, container, false); mLocationNameTextView = (TextView) rootView.findViewById(R.id.location_name); mCurrentTemperatureTextView = (TextView) rootView .findViewById(R.id.current_temperature); mForecastListView = (ListView) rootView.findViewById(R.id.weather_forecast_list); final WeatherForecastListAdapter adapter = new WeatherForecastListAdapter( new ArrayList<WeatherForecast>(), getActivity()); mForecastListView.setAdapter(adapter); mAttributionTextView = (TextView) rootView.findViewById(R.id.attribution); mAttributionTextView.setVisibility(View.INVISIBLE); mSwipeRefreshLayout = (SwipeRefreshLayout) rootView .findViewById(R.id.swipe_refresh_container); mSwipeRefreshLayout.setColorSchemeResources(R.color.brand_main, android.R.color.black, R.color.brand_main, android.R.color.black); mSwipeRefreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() { @Override public void onRefresh() { updateWeather(); } }); updateWeather(); return rootView; } @Override public void onDestroyView() { mCompositeSubscription.unsubscribe(); super.onDestroyView(); } private class WeatherForecastListAdapter extends ArrayAdapter { public WeatherForecastListAdapter(final List<WeatherForecast> weatherForecasts, final Context context) { super(context, 0, weatherForecasts); } @Override public boolean isEnabled(final int position) { return false; } @Override public View getView(final int position, View convertView, final ViewGroup parent) { ViewHolder viewHolder; if (convertView == null) { final LayoutInflater layoutInflater = LayoutInflater.from(getContext()); convertView = layoutInflater.inflate(R.layout.weather_forecast_list_item, null); viewHolder = new ViewHolder(); viewHolder.dayTextView = (TextView) convertView.findViewById(R.id.day); viewHolder.descriptionTextView = (TextView) convertView .findViewById(R.id.description); viewHolder.maximumTemperatureTextView = (TextView) convertView .findViewById(R.id.maximum_temperature); viewHolder.minimumTemperatureTextView = (TextView) convertView .findViewById(R.id.minimum_temperature); convertView.setTag(viewHolder); } else { viewHolder = (ViewHolder) convertView.getTag(); } final WeatherForecast weatherForecast = (WeatherForecast) getItem(position); final DayFormatter dayFormatter = new DayFormatter(getActivity()); final String day = dayFormatter.format(weatherForecast.getTimestamp()); viewHolder.dayTextView.setText(day); viewHolder.descriptionTextView.setText(weatherForecast.getDescription()); viewHolder.maximumTemperatureTextView.setText( TemperatureFormatter.format(weatherForecast.getMaximumTemperature())); viewHolder.minimumTemperatureTextView.setText( TemperatureFormatter.format(weatherForecast.getMinimumTemperature())); return convertView; } private class ViewHolder { private TextView dayTextView; private TextView descriptionTextView; private TextView maximumTemperatureTextView; private TextView minimumTemperatureTextView; } } private void updateWeather() { mSwipeRefreshLayout.setRefreshing(true); final LocationManager locationManager = (LocationManager) getActivity() .getSystemService(Context.LOCATION_SERVICE); final LocationService locationService = new LocationService(locationManager); final Observable fetchDataObservable = locationService.getLocation() .timeout(LOCATION_TIMEOUT_SECONDS, TimeUnit.SECONDS) .flatMap(new Func1<Location, Observable<HashMap<String, WeatherForecast>>>() { @Override public Observable<HashMap<String, WeatherForecast>> call(final Location location) { final WeatherService weatherService = new WeatherService(); final double longitude = location.getLongitude(); final double latitude = location.getLatitude(); return Observable.zip( weatherService.fetchCurrentWeather(longitude, latitude), weatherService.fetchWeatherForecasts(longitude, latitude), new Func2<CurrentWeather, List<WeatherForecast>, HashMap<String, WeatherForecast>>() { @Override public HashMap call(final CurrentWeather currentWeather, final List<WeatherForecast> weatherForecasts) { HashMap weatherData = new HashMap(); weatherData.put(KEY_CURRENT_WEATHER, currentWeather); weatherData.put(KEY_WEATHER_FORECASTS, weatherForecasts); return weatherData; } } ); } }); mCompositeSubscription.add(fetchDataObservable .subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber<HashMap<String, WeatherForecast>>() { @Override public void onNext(final HashMap<String, WeatherForecast> weatherData) { final CurrentWeather currentWeather = (CurrentWeather) weatherData .get(KEY_CURRENT_WEATHER); mLocationNameTextView.setText(currentWeather.getLocationName()); mCurrentTemperatureTextView.setText( TemperatureFormatter.format(currentWeather.getTemperature())); final List<WeatherForecast> weatherForecasts = (List<WeatherForecast>) weatherData.get(KEY_WEATHER_FORECASTS); final WeatherForecastListAdapter adapter = (WeatherForecastListAdapter) mForecastListView.getAdapter(); adapter.clear(); adapter.addAll(weatherForecasts); } @Override public void onCompleted() { mSwipeRefreshLayout.setRefreshing(false); mAttributionTextView.setVisibility(View.VISIBLE); } @Override public void onError(final Throwable error) { mSwipeRefreshLayout.setRefreshing(false); if (error instanceof TimeoutException) { Crouton.makeText(getActivity(), R.string.error_location_unavailable, Style.ALERT).show(); } else if (error instanceof RetrofitError || error instanceof HttpException) { Crouton.makeText(getActivity(), R.string.error_fetch_weather, Style.ALERT).show(); } else { Log.e(TAG, error.getMessage()); error.printStackTrace(); throw new RuntimeException(\"See inner exception\"); } } }) ); } } }", "dependencies": [{"file_path": "rex-weather-master/rex-weather-master/app/src/main/java/mu/node/rexweather/app/Helpers/DayFormatter.java", "file_content": "package mu.node.rexweather.app.Helpers; import android.content.Context; import java.text.SimpleDateFormat; import java.util.Date; import mu.node.rexweather.app.R; public class DayFormatter { private final static long MILLISECONDS_IN_SECONDS = 1000; private final Context mContext; public DayFormatter(Context context) { mContext = context; } public String format(final long unixTimestamp) { final long milliseconds = unixTimestamp * MILLISECONDS_IN_SECONDS; String day; if (isToday(milliseconds)) { day = mContext.getResources().getString(R.string.today); } else if (isTomorrow(milliseconds)) { day = mContext.getResources().getString(R.string.tomorrow); } else { day = getDayOfWeek(milliseconds); } return day; } private String getDayOfWeek(final long milliseconds) { return new SimpleDateFormat(\"EEEE\").format(new Date(milliseconds)); } private boolean isToday(final long milliseconds) { final SimpleDateFormat dayInYearFormat = new SimpleDateFormat(\"yyyyD\"); final String nowHash = dayInYearFormat.format(new Date()); final String comparisonHash = dayInYearFormat.format(new Date(milliseconds)); return nowHash.equals(comparisonHash); } private boolean isTomorrow(final long milliseconds) { final SimpleDateFormat dayInYearFormat = new SimpleDateFormat(\"yyyyD\"); final int tomorrowHash = Integer.parseInt(dayInYearFormat.format(new Date())) + 1; final int comparisonHash = Integer.parseInt(dayInYearFormat.format(new Date(milliseconds))); return comparisonHash == tomorrowHash; } }"}, {"file_path": "rex-weather-master/rex-weather-master/app/src/main/java/mu/node/rexweather/app/Helpers/TemperatureFormatter.java", "file_content": "package mu.node.rexweather.app.Helpers; public class TemperatureFormatter { public static String format(float temperature) { return String.valueOf(Math.round(temperature)) + \"\u00b0\"; } }"}, {"file_path": "rex-weather-master/rex-weather-master/app/src/main/java/mu/node/rexweather/app/Models/CurrentWeather.java", "file_content": "package mu.node.rexweather.app.Models; public class CurrentWeather extends WeatherForecast { private final float mTemperature; public CurrentWeather(final String locationName, final long timestamp, final String description, final float temperature, final float minimumTemperature, final float maximumTemperature) { super(locationName, timestamp, description, minimumTemperature, maximumTemperature); mTemperature = temperature; } public float getTemperature() { return mTemperature; } }"}, {"file_path": "rex-weather-master/rex-weather-master/app/src/main/java/mu/node/rexweather/app/Models/WeatherForecast.java", "file_content": "package mu.node.rexweather.app.Models; public class WeatherForecast { private final String mLocationName; private final long mTimestamp; private final String mDescription; private final float mMinimumTemperature; private final float mMaximumTemperature; public WeatherForecast(final String locationName, final long timestamp, final String description, final float minimumTemperature, final float maximumTemperature) { mLocationName = locationName; mTimestamp = timestamp; mMinimumTemperature = minimumTemperature; mMaximumTemperature = maximumTemperature; mDescription = description; } public String getLocationName() { return mLocationName; } public long getTimestamp() { return mTimestamp; } public String getDescription() { return mDescription; } public float getMinimumTemperature() { return mMinimumTemperature; } public float getMaximumTemperature() { return mMaximumTemperature; } }"}, {"file_path": "rex-weather-master/rex-weather-master/app/src/main/java/mu/node/rexweather/app/Services/LocationService.java", "file_content": "package mu.node.rexweather.app.Services; import android.location.Criteria; import android.location.Location; import android.location.LocationListener; import android.location.LocationManager; import android.os.Bundle; import android.os.Looper; import rx.Observable; import rx.Subscriber; public class LocationService { private final LocationManager mLocationManager; public LocationService(LocationManager locationManager) { mLocationManager = locationManager; } public Observable<Location> getLocation() { return Observable.create(new Observable.OnSubscribe<Location>() { @Override public void call(final Subscriber<? super Location> subscriber) { final LocationListener locationListener = new LocationListener() { public void onLocationChanged(final Location location) { subscriber.onNext(location); subscriber.onCompleted(); Looper.myLooper().quit(); } public void onStatusChanged(String provider, int status, Bundle extras) { } public void onProviderEnabled(String provider) { } public void onProviderDisabled(String provider) { } }; final Criteria locationCriteria = new Criteria(); locationCriteria.setAccuracy(Criteria.ACCURACY_COARSE); locationCriteria.setPowerRequirement(Criteria.POWER_LOW); final String locationProvider = mLocationManager .getBestProvider(locationCriteria, true); Looper.prepare(); mLocationManager.requestSingleUpdate(locationProvider, locationListener, Looper.myLooper()); Looper.loop(); } }); } }"}, {"file_path": "rex-weather-master/rex-weather-master/app/src/main/java/mu/node/rexweather/app/Services/WeatherService.java", "file_content": "package mu.node.rexweather.app.Services; import com.google.gson.annotations.SerializedName; import org.apache.http.HttpException; import java.util.ArrayList; import java.util.List; import mu.node.rexweather.app.Models.CurrentWeather; import mu.node.rexweather.app.Models.WeatherForecast; import retrofit.RequestInterceptor; import retrofit.RestAdapter; import retrofit.http.GET; import retrofit.http.Query; import rx.Observable; import rx.functions.Func1; public class WeatherService { private static final String WEB_SERVICE_BASE_URL = \"http: private static final String API_KEY = \"insert your api key here\"; private final OpenWeatherMapWebService mWebService; public WeatherService() { RequestInterceptor requestInterceptor = new RequestInterceptor() { @Override public void intercept(RequestInterceptor.RequestFacade request) { request.addHeader(\"Accept\", \"application/json\"); } }; RestAdapter restAdapter = new RestAdapter.Builder() .setEndpoint(WEB_SERVICE_BASE_URL) .setRequestInterceptor(requestInterceptor) .setLogLevel(RestAdapter.LogLevel.FULL) .build(); mWebService = restAdapter.create(OpenWeatherMapWebService.class); } private interface OpenWeatherMapWebService { @GET(\"/weather?units=metric&apikey=\" + API_KEY) Observable<CurrentWeatherDataEnvelope> fetchCurrentWeather(@Query(\"lon\") double longitude, @Query(\"lat\") double latitude); @GET(\"/forecast/daily?units=metric&cnt=7&apikey=\" + API_KEY) Observable<WeatherForecastListDataEnvelope> fetchWeatherForecasts( @Query(\"lon\") double longitude, @Query(\"lat\") double latitude); } public Observable<CurrentWeather> fetchCurrentWeather(final double longitude, final double latitude) { return mWebService.fetchCurrentWeather(longitude, latitude) .flatMap(new Func1<CurrentWeatherDataEnvelope, Observable<? extends CurrentWeatherDataEnvelope>>() { @Override public Observable<? extends CurrentWeatherDataEnvelope> call( final CurrentWeatherDataEnvelope data) { return data.filterWebServiceErrors(); } }).map(new Func1<CurrentWeatherDataEnvelope, CurrentWeather>() { @Override public CurrentWeather call(final CurrentWeatherDataEnvelope data) { return new CurrentWeather(data.locationName, data.timestamp, data.weather.get(0).description, data.main.temp, data.main.temp_min, data.main.temp_max); } }); } public Observable<List<WeatherForecast>> fetchWeatherForecasts(final double longitude, final double latitude) { return mWebService.fetchWeatherForecasts(longitude, latitude) .flatMap(new Func1<WeatherForecastListDataEnvelope, Observable<? extends WeatherForecastListDataEnvelope>>() { @Override public Observable<? extends WeatherForecastListDataEnvelope> call( final WeatherForecastListDataEnvelope listData) { return listData.filterWebServiceErrors(); } }).map(new Func1<WeatherForecastListDataEnvelope, List<WeatherForecast>>() { @Override public List<WeatherForecast> call(final WeatherForecastListDataEnvelope listData) { final ArrayList<WeatherForecast> weatherForecasts = new ArrayList<>(); for (WeatherForecastListDataEnvelope.ForecastDataEnvelope data : listData.list) { final WeatherForecast weatherForecast = new WeatherForecast( listData.city.name, data.timestamp, data.weather.get(0).description, data.temp.min, data.temp.max); weatherForecasts.add(weatherForecast); } return weatherForecasts; } }); } private class WeatherDataEnvelope { @SerializedName(\"cod\") private int httpCode; class Weather { public String description; } public Observable filterWebServiceErrors() { if (httpCode == 200) { return Observable.just(this); } else { return Observable.error( new HttpException(\"There was a problem fetching the weather data.\")); } } } private class CurrentWeatherDataEnvelope extends WeatherDataEnvelope { @SerializedName(\"name\") public String locationName; @SerializedName(\"dt\") public long timestamp; public ArrayList<Weather> weather; public Main main; class Main { public float temp; public float temp_min; public float temp_max; } } private class WeatherForecastListDataEnvelope extends WeatherDataEnvelope { public Location city; public ArrayList<ForecastDataEnvelope> list; class Location { public String name; } class ForecastDataEnvelope { @SerializedName(\"dt\") public long timestamp; public Temperature temp; public ArrayList<Weather> weather; } class Temperature { public float min; public float max; } } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "rex-weather-master/rex-weather-master/app/src/main/java/mu/node/rexweather/app/WeatherActivity.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "WeatherFragment handles UI updates, data fetching, and data adaptation. Changes in any of these responsibilities would require modifying the class."}, {"principle": "Dependency Inversion", "justification": "WeatherFragment directly instantiates concrete LocationService and WeatherService. High-level modules should depend on abstractions rather than concrete implementations."}]}, {"file_path": "rex-weather-master/rex-weather-master/app/src/main/java/mu/node/rexweather/app/Models/CurrentWeather.java", "violatedPrinciples": [{"principle": "Liskov", "justification": "CurrentWeather inherits from WeatherForecast but represents a semantically distinct concept (current weather vs. forecast), violating substitutability."}]}]}
{"project_id": 31, "chunk_id": 0, "prompt": {"main_file_path": "rex-weather-master/rex-weather-master/app/src/main/java/mu/node/rexweather/app/Models/WeatherForecast.java", "main_file_content": "package mu.node.rexweather.app.Models; public class WeatherForecast { private final String mLocationName; private final long mTimestamp; private final String mDescription; private final float mMinimumTemperature; private final float mMaximumTemperature; public WeatherForecast(final String locationName, final long timestamp, final String description, final float minimumTemperature, final float maximumTemperature) { mLocationName = locationName; mTimestamp = timestamp; mMinimumTemperature = minimumTemperature; mMaximumTemperature = maximumTemperature; mDescription = description; } public String getLocationName() { return mLocationName; } public long getTimestamp() { return mTimestamp; } public String getDescription() { return mDescription; } public float getMinimumTemperature() { return mMinimumTemperature; } public float getMaximumTemperature() { return mMaximumTemperature; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "rex-weather-master/rex-weather-master/app/src/main/java/mu/node/rexweather/app/Models/WeatherForecast.java", "violatedPrinciples": []}]}
{"project_id": 31, "chunk_id": 0, "prompt": {"main_file_path": "rex-weather-master/rex-weather-master/app/src/main/java/mu/node/rexweather/app/Models/CurrentWeather.java", "main_file_content": "package mu.node.rexweather.app.Models; public class CurrentWeather extends WeatherForecast { private final float mTemperature; public CurrentWeather(final String locationName, final long timestamp, final String description, final float temperature, final float minimumTemperature, final float maximumTemperature) { super(locationName, timestamp, description, minimumTemperature, maximumTemperature); mTemperature = temperature; } public float getTemperature() { return mTemperature; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "rex-weather-master/rex-weather-master/app/src/main/java/mu/node/rexweather/app/Models/CurrentWeather.java", "violatedPrinciples": []}]}
{"project_id": 31, "chunk_id": 0, "prompt": {"main_file_path": "rex-weather-master/rex-weather-master/app/src/main/java/mu/node/rexweather/app/Helpers/TemperatureFormatter.java", "main_file_content": "package mu.node.rexweather.app.Helpers; public class TemperatureFormatter { public static String format(float temperature) { return String.valueOf(Math.round(temperature)) + \"\u00b0\"; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "rex-weather-master/rex-weather-master/app/src/main/java/mu/node/rexweather/app/Helpers/TemperatureFormatter.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "The TemperatureFormatter class is not extendable without modification since it uses a static method. To alter formatting behavior, one must modify the existing code rather than extending the class."}]}]}
{"project_id": 31, "chunk_id": 0, "prompt": {"main_file_path": "rex-weather-master/rex-weather-master/app/src/main/java/mu/node/rexweather/app/Helpers/DayFormatter.java", "main_file_content": "package mu.node.rexweather.app.Helpers; import android.content.Context; import java.text.SimpleDateFormat; import java.util.Date; import mu.node.rexweather.app.R; public class DayFormatter { private final static long MILLISECONDS_IN_SECONDS = 1000; private final Context mContext; public DayFormatter(Context context) { mContext = context; } public String format(final long unixTimestamp) { final long milliseconds = unixTimestamp * MILLISECONDS_IN_SECONDS; String day; if (isToday(milliseconds)) { day = mContext.getResources().getString(R.string.today); } else if (isTomorrow(milliseconds)) { day = mContext.getResources().getString(R.string.tomorrow); } else { day = getDayOfWeek(milliseconds); } return day; } private String getDayOfWeek(final long milliseconds) { return new SimpleDateFormat(\"EEEE\").format(new Date(milliseconds)); } private boolean isToday(final long milliseconds) { final SimpleDateFormat dayInYearFormat = new SimpleDateFormat(\"yyyyD\"); final String nowHash = dayInYearFormat.format(new Date()); final String comparisonHash = dayInYearFormat.format(new Date(milliseconds)); return nowHash.equals(comparisonHash); } private boolean isTomorrow(final long milliseconds) { final SimpleDateFormat dayInYearFormat = new SimpleDateFormat(\"yyyyD\"); final int tomorrowHash = Integer.parseInt(dayInYearFormat.format(new Date())) + 1; final int comparisonHash = Integer.parseInt(dayInYearFormat.format(new Date(milliseconds))); return comparisonHash == tomorrowHash; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "rex-weather-master/rex-weather-master/app/src/main/java/mu/node/rexweather/app/Helpers/DayFormatter.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "Adding new date conditions (e.g., 'yesterday') requires modifying the format() method instead of extending via abstractions."}, {"principle": "Dependency Inversion", "justification": "DayFormatter directly depends on the concrete Android Context class instead of an abstraction, violating high-level module independence."}]}]}
{"project_id": 31, "chunk_id": 0, "prompt": {"main_file_path": "rex-weather-master/rex-weather-master/app/src/main/java/mu/node/rexweather/app/Services/LocationService.java", "main_file_content": "package mu.node.rexweather.app.Services; import android.location.Criteria; import android.location.Location; import android.location.LocationListener; import android.location.LocationManager; import android.os.Bundle; import android.os.Looper; import rx.Observable; import rx.Subscriber; public class LocationService { private final LocationManager mLocationManager; public LocationService(LocationManager locationManager) { mLocationManager = locationManager; } public Observable<Location> getLocation() { return Observable.create(new Observable.OnSubscribe<Location>() { @Override public void call(final Subscriber<? super Location> subscriber) { final LocationListener locationListener = new LocationListener() { public void onLocationChanged(final Location location) { subscriber.onNext(location); subscriber.onCompleted(); Looper.myLooper().quit(); } public void onStatusChanged(String provider, int status, Bundle extras) { } public void onProviderEnabled(String provider) { } public void onProviderDisabled(String provider) { } }; final Criteria locationCriteria = new Criteria(); locationCriteria.setAccuracy(Criteria.ACCURACY_COARSE); locationCriteria.setPowerRequirement(Criteria.POWER_LOW); final String locationProvider = mLocationManager .getBestProvider(locationCriteria, true); Looper.prepare(); mLocationManager.requestSingleUpdate(locationProvider, locationListener, Looper.myLooper()); Looper.loop(); } }); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "rex-weather-master/rex-weather-master/app/src/main/java/mu/node/rexweather/app/Services/LocationService.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The LocationService class manages location retrieval, Looper handling, Rx observable creation, and criteria setup, indicating multiple responsibilities beyond just coordinating location data."}, {"principle": "Open-Closed", "justification": "The class cannot be extended to modify location-fetching behavior (e.g., criteria or update logic) without altering its existing code, violating OCP."}]}]}
{"project_id": 31, "chunk_id": 0, "prompt": {"main_file_path": "rex-weather-master/rex-weather-master/app/src/main/java/mu/node/rexweather/app/Services/WeatherService.java", "main_file_content": "package mu.node.rexweather.app.Services; import com.google.gson.annotations.SerializedName; import org.apache.http.HttpException; import java.util.ArrayList; import java.util.List; import mu.node.rexweather.app.Models.CurrentWeather; import mu.node.rexweather.app.Models.WeatherForecast; import retrofit.RequestInterceptor; import retrofit.RestAdapter; import retrofit.http.GET; import retrofit.http.Query; import rx.Observable; import rx.functions.Func1; public class WeatherService { private static final String WEB_SERVICE_BASE_URL = \"http: private static final String API_KEY = \"insert your api key here\"; private final OpenWeatherMapWebService mWebService; public WeatherService() { RequestInterceptor requestInterceptor = new RequestInterceptor() { @Override public void intercept(RequestInterceptor.RequestFacade request) { request.addHeader(\"Accept\", \"application/json\"); } }; RestAdapter restAdapter = new RestAdapter.Builder() .setEndpoint(WEB_SERVICE_BASE_URL) .setRequestInterceptor(requestInterceptor) .setLogLevel(RestAdapter.LogLevel.FULL) .build(); mWebService = restAdapter.create(OpenWeatherMapWebService.class); } private interface OpenWeatherMapWebService { @GET(\"/weather?units=metric&apikey=\" + API_KEY) Observable<CurrentWeatherDataEnvelope> fetchCurrentWeather(@Query(\"lon\") double longitude, @Query(\"lat\") double latitude); @GET(\"/forecast/daily?units=metric&cnt=7&apikey=\" + API_KEY) Observable<WeatherForecastListDataEnvelope> fetchWeatherForecasts( @Query(\"lon\") double longitude, @Query(\"lat\") double latitude); } public Observable<CurrentWeather> fetchCurrentWeather(final double longitude, final double latitude) { return mWebService.fetchCurrentWeather(longitude, latitude) .flatMap(new Func1<CurrentWeatherDataEnvelope, Observable<? extends CurrentWeatherDataEnvelope>>() { @Override public Observable<? extends CurrentWeatherDataEnvelope> call( final CurrentWeatherDataEnvelope data) { return data.filterWebServiceErrors(); } }).map(new Func1<CurrentWeatherDataEnvelope, CurrentWeather>() { @Override public CurrentWeather call(final CurrentWeatherDataEnvelope data) { return new CurrentWeather(data.locationName, data.timestamp, data.weather.get(0).description, data.main.temp, data.main.temp_min, data.main.temp_max); } }); } public Observable<List<WeatherForecast>> fetchWeatherForecasts(final double longitude, final double latitude) { return mWebService.fetchWeatherForecasts(longitude, latitude) .flatMap(new Func1<WeatherForecastListDataEnvelope, Observable<? extends WeatherForecastListDataEnvelope>>() { @Override public Observable<? extends WeatherForecastListDataEnvelope> call( final WeatherForecastListDataEnvelope listData) { return listData.filterWebServiceErrors(); } }).map(new Func1<WeatherForecastListDataEnvelope, List<WeatherForecast>>() { @Override public List<WeatherForecast> call(final WeatherForecastListDataEnvelope listData) { final ArrayList<WeatherForecast> weatherForecasts = new ArrayList<>(); for (WeatherForecastListDataEnvelope.ForecastDataEnvelope data : listData.list) { final WeatherForecast weatherForecast = new WeatherForecast( listData.city.name, data.timestamp, data.weather.get(0).description, data.temp.min, data.temp.max); weatherForecasts.add(weatherForecast); } return weatherForecasts; } }); } private class WeatherDataEnvelope { @SerializedName(\"cod\") private int httpCode; class Weather { public String description; } public Observable filterWebServiceErrors() { if (httpCode == 200) { return Observable.just(this); } else { return Observable.error( new HttpException(\"There was a problem fetching the weather data.\")); } } } private class CurrentWeatherDataEnvelope extends WeatherDataEnvelope { @SerializedName(\"name\") public String locationName; @SerializedName(\"dt\") public long timestamp; public ArrayList<Weather> weather; public Main main; class Main { public float temp; public float temp_min; public float temp_max; } } private class WeatherForecastListDataEnvelope extends WeatherDataEnvelope { public Location city; public ArrayList<ForecastDataEnvelope> list; class Location { public String name; } class ForecastDataEnvelope { @SerializedName(\"dt\") public long timestamp; public Temperature temp; public ArrayList<Weather> weather; } class Temperature { public float min; public float max; } } }", "dependencies": [{"file_path": "rex-weather-master/rex-weather-master/app/src/main/java/mu/node/rexweather/app/Models/CurrentWeather.java", "file_content": "package mu.node.rexweather.app.Models; public class CurrentWeather extends WeatherForecast { private final float mTemperature; public CurrentWeather(final String locationName, final long timestamp, final String description, final float temperature, final float minimumTemperature, final float maximumTemperature) { super(locationName, timestamp, description, minimumTemperature, maximumTemperature); mTemperature = temperature; } public float getTemperature() { return mTemperature; } }"}, {"file_path": "rex-weather-master/rex-weather-master/app/src/main/java/mu/node/rexweather/app/Models/WeatherForecast.java", "file_content": "package mu.node.rexweather.app.Models; public class WeatherForecast { private final String mLocationName; private final long mTimestamp; private final String mDescription; private final float mMinimumTemperature; private final float mMaximumTemperature; public WeatherForecast(final String locationName, final long timestamp, final String description, final float minimumTemperature, final float maximumTemperature) { mLocationName = locationName; mTimestamp = timestamp; mMinimumTemperature = minimumTemperature; mMaximumTemperature = maximumTemperature; mDescription = description; } public String getLocationName() { return mLocationName; } public long getTimestamp() { return mTimestamp; } public String getDescription() { return mDescription; } public float getMinimumTemperature() { return mMinimumTemperature; } public float getMaximumTemperature() { return mMaximumTemperature; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "rex-weather-master/rex-weather-master/app/src/main/java/mu/node/rexweather/app/Services/WeatherService.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "WeatherService initializes web service components, maps data, and processes API errors, handling multiple responsibilities beyond a single reason to change."}, {"principle": "Open-Closed", "justification": "Adding support for new weather data sources requires modifying WeatherService instead of extending it, violating OCP."}, {"principle": "Dependency Inversion", "justification": "WeatherService directly constructs low-level Retrofit components (RestAdapter) instead of depending on abstractions, violating DIP."}]}, {"file_path": "rex-weather-master/rex-weather-master/app/src/main/java/mu/node/rexweather/app/Models/CurrentWeather.java", "violatedPrinciples": [{"principle": "Liskov", "justification": "CurrentWeather inherits from WeatherForecast but represents a distinct concept (current vs. forecasted weather), breaking substitutability required by LSP."}]}]}
{"project_id": 33, "chunk_id": 0, "prompt": {"main_file_path": "Scientific-Calculator-master/src/Calculator.java", "main_file_content": "import java.awt.EventQueue; import javax.swing.JFrame; import javax.swing.JLabel; import java.awt.Font; import javax.swing.JTextField; import javax.swing.JButton; import javax.swing.JRadioButton; import java.awt.event.ActionListener; import java.awt.event.ActionEvent; import java.awt.Color; import javax.swing.ButtonGroup; import javax.swing.UIManager; public class Calculator { private JFrame frame; private JTextField textField; double first; double second; double result; String operation; String answer; private final ButtonGroup buttonGroup = new ButtonGroup(); public static void main(String[] args) { EventQueue.invokeLater(new Runnable() { public void run() { try { Calculator window = new Calculator(); window.frame.setVisible(true); } catch (Exception e) { e.printStackTrace(); } } }); } public Calculator() { initialize(); } private void initialize() { frame = new JFrame(); frame.setBounds(100, 100, 331, 537); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.getContentPane().setLayout(null); JLabel lblScientificCalculator = new JLabel(\"Scientific Calculator\"); lblScientificCalculator.setForeground(new Color(0, 0, 102)); lblScientificCalculator.setFont(new Font(\"Tahoma\", Font.BOLD, 29)); lblScientificCalculator.setBounds(10, 10, 297, 37); frame.getContentPane().add(lblScientificCalculator); textField = new JTextField(); textField.setFont(new Font(\"Tahoma\", Font.BOLD, 13)); textField.setBounds(10, 57, 297, 51); frame.getContentPane().add(textField); textField.setColumns(10); JButton btnRoot = new JButton(\"\\u221A\"); btnRoot.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { double a= Math.sqrt(Double.parseDouble(textField.getText())); textField.setText(\"\"); textField.setText(textField.getText()+a); } }); btnRoot.setFont(new Font(\"Tahoma\", Font.PLAIN, 16)); btnRoot.setBounds(10, 141, 60, 51); frame.getContentPane().add(btnRoot); JButton btnRev = new JButton(\"1/x\"); btnRev.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { double a= 1/(Double.parseDouble(textField.getText())); textField.setText(\"\"); textField.setText(textField.getText()+a); } }); btnRev.setFont(new Font(\"Tahoma\", Font.PLAIN, 15)); btnRev.setBounds(10, 192, 60, 51); frame.getContentPane().add(btnRev); JButton btnFact = new JButton(\"n!\"); btnFact.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { double a = Double.parseDouble(textField.getText()); double fact=1; while(a!=0) { fact=fact*a; a--; } textField.setText(\"\"); textField.setText(textField.getText()+fact); } }); btnFact.setFont(new Font(\"Tahoma\", Font.PLAIN, 21)); btnFact.setBounds(10, 396, 60, 51); frame.getContentPane().add(btnFact); JButton btnPM = new JButton(\"+/-\"); btnPM.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { double a = Double.parseDouble(String.valueOf(textField.getText())); a=a*(-1); textField.setText(String.valueOf(a)); } }); btnPM.setFont(new Font(\"Tahoma\", Font.PLAIN, 14)); btnPM.setBounds(10, 447, 60, 51); frame.getContentPane().add(btnPM); JButton btn7 = new JButton(\"7\"); btn7.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { String number= textField.getText()+btn7.getText(); textField.setText(number); } }); btn7.setFont(new Font(\"Tahoma\", Font.BOLD, 22)); btn7.setBounds(70, 294, 60, 51); frame.getContentPane().add(btn7); JButton btn4 = new JButton(\"4\"); btn4.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { String number= textField.getText()+btn4.getText(); textField.setText(number); } }); btn4.setFont(new Font(\"Tahoma\", Font.BOLD, 22)); btn4.setBounds(70, 345, 60, 51); frame.getContentPane().add(btn4); JButton btn1 = new JButton(\"1\"); btn1.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { String number= textField.getText()+btn1.getText(); textField.setText(number); } }); btn1.setFont(new Font(\"Tahoma\", Font.BOLD, 22)); btn1.setBounds(70, 396, 60, 51); frame.getContentPane().add(btn1); JButton btnSin = new JButton(\"sin\"); btnSin.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { double a= Math.sin(Double.parseDouble(textField.getText())); textField.setText(\"\"); textField.setText(textField.getText()+a); } }); btnSin.setFont(new Font(\"Tahoma\", Font.PLAIN, 18)); btnSin.setBounds(130, 141, 60, 51); frame.getContentPane().add(btnSin); JButton btn8 = new JButton(\"8\"); btn8.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { String number= textField.getText()+btn8.getText(); textField.setText(number); } }); btn8.setFont(new Font(\"Tahoma\", Font.BOLD, 22)); btn8.setBounds(130, 294, 60, 51); frame.getContentPane().add(btn8); JButton btn5 = new JButton(\"5\"); btn5.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { String number= textField.getText()+btn5.getText(); textField.setText(number); } }); btn5.setFont(new Font(\"Tahoma\", Font.BOLD, 22)); btn5.setBounds(130, 345, 60, 51); frame.getContentPane().add(btn5); JButton btn2 = new JButton(\"2\"); btn2.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { String number= textField.getText()+btn2.getText(); textField.setText(number); } }); btn2.setFont(new Font(\"Tahoma\", Font.BOLD, 22)); btn2.setBounds(130, 396, 60, 51); frame.getContentPane().add(btn2); JButton btn0 = new JButton(\"0\"); btn0.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { String number= textField.getText()+btn0.getText(); textField.setText(number); } }); btn0.setFont(new Font(\"Tahoma\", Font.BOLD, 22)); btn0.setBounds(70, 447, 120, 51); frame.getContentPane().add(btn0); JButton btnB = new JButton(\"\\uF0E7\"); btnB.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { String backSpace=null; if(textField.getText().length()>0) { StringBuilder str = new StringBuilder(textField.getText()); str.deleteCharAt(textField.getText().length()-1); backSpace= str.toString(); textField.setText(backSpace); } } }); btnB.setFont(new Font(\"Wingdings\", Font.PLAIN, 22)); btnB.setBounds(190, 243, 60, 51); frame.getContentPane().add(btnB); JButton btn9 = new JButton(\"9\"); btn9.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { String number= textField.getText()+btn9.getText(); textField.setText(number); } }); btn9.setFont(new Font(\"Tahoma\", Font.BOLD, 22)); btn9.setBounds(190, 294, 60, 51); frame.getContentPane().add(btn9); JButton btn6 = new JButton(\"6\"); btn6.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { String number= textField.getText()+btn6.getText(); textField.setText(number); } }); btn6.setFont(new Font(\"Tahoma\", Font.BOLD, 22)); btn6.setBounds(190, 345, 60, 51); frame.getContentPane().add(btn6); JButton btn3 = new JButton(\"3\"); btn3.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { String number= textField.getText()+btn3.getText(); textField.setText(number); } }); btn3.setFont(new Font(\"Tahoma\", Font.BOLD, 22)); btn3.setBounds(190, 396, 60, 51); frame.getContentPane().add(btn3); JButton btnDot = new JButton(\".\"); btnDot.setFont(new Font(\"Tahoma\", Font.BOLD, 22)); btnDot.setBounds(190, 447, 60, 51); frame.getContentPane().add(btnDot); JButton btnEqual = new JButton(\"=\"); btnEqual.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { second = Double.parseDouble(textField.getText()); if(operation==\"+\") { result=first+second; answer= String.format(\"%.2f\", result); textField.setText(answer); } else if(operation==\"-\") { result=first-second; answer= String.format(\"%.2f\", result); textField.setText(answer); } else if(operation==\"*\") { result=first*second; answer= String.format(\"%.2f\", result); textField.setText(answer); } else if(operation==\"/\") { result=first/second; answer= String.format(\"%.2f\", result); textField.setText(answer); } else if(operation==\"%\") { result=first%second; answer= String.format(\"%.2f\", result); textField.setText(answer); } else if(operation==\"x^y\") { double resultt=1; for(int i=0;i<second;i++) { resultt=first*resultt; } answer= String.format(\"%.2f\", resultt); textField.setText(answer); } } }); btnEqual.setFont(new Font(\"Tahoma\", Font.PLAIN, 22)); btnEqual.setBounds(250, 447, 60, 51); frame.getContentPane().add(btnEqual); JButton btnSum = new JButton(\"+\"); btnSum.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { first=Double.parseDouble(textField.getText()); textField.setText(null); operation=\"+\"; } }); btnSum.setFont(new Font(\"Tahoma\", Font.PLAIN, 22)); btnSum.setBounds(250, 243, 60, 51); frame.getContentPane().add(btnSum); JButton btnMinus = new JButton(\"-\"); btnMinus.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { first=Double.parseDouble(textField.getText()); textField.setText(null); operation=\"-\"; } }); btnMinus.setFont(new Font(\"Tahoma\", Font.PLAIN, 22)); btnMinus.setBounds(250, 294, 60, 51); frame.getContentPane().add(btnMinus); JButton btnMpy = new JButton(\"*\"); btnMpy.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { first=Double.parseDouble(textField.getText()); textField.setText(null); operation=\"*\"; } }); btnMpy.setFont(new Font(\"Tahoma\", Font.PLAIN, 22)); btnMpy.setBounds(250, 345, 60, 51); frame.getContentPane().add(btnMpy); JButton btnDivide = new JButton(\"/\"); btnDivide.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { first=Double.parseDouble(textField.getText()); textField.setText(null); operation=\"/\"; } }); btnDivide.setFont(new Font(\"Tahoma\", Font.PLAIN, 22)); btnDivide.setBounds(250, 396, 60, 51); frame.getContentPane().add(btnDivide); JButton btnPow = new JButton(\"x^y\"); btnPow.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { first=Double.parseDouble(textField.getText()); textField.setText(null); operation=\"x^y\"; } }); btnPow.setFont(new Font(\"Tahoma\", Font.PLAIN, 14)); btnPow.setBounds(10, 243, 60, 51); frame.getContentPane().add(btnPow); JButton btnMod = new JButton(\"%\"); btnMod.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { first=Double.parseDouble(textField.getText()); textField.setText(null); operation=\"%\"; } }); btnMod.setFont(new Font(\"Tahoma\", Font.BOLD, 20)); btnMod.setBounds(70, 243, 60, 51); frame.getContentPane().add(btnMod); JButton btnC = new JButton(\"C\"); btnC.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { textField.setText(null); } }); btnC.setFont(new Font(\"Tahoma\", Font.BOLD, 22)); btnC.setBounds(130, 243, 60, 51); frame.getContentPane().add(btnC); JButton btnCube = new JButton(\"x^3\"); btnCube.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { double a= (Double.parseDouble(textField.getText())); a=a*a*a; textField.setText(\"\"); textField.setText(textField.getText()+a); } }); btnCube.setFont(new Font(\"Tahoma\", Font.PLAIN, 13)); btnCube.setBounds(10, 294, 60, 51); frame.getContentPane().add(btnCube); JButton btnSqr = new JButton(\"x^2\"); btnSqr.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { double a= (Double.parseDouble(textField.getText())); a=a*a; textField.setText(\"\"); textField.setText(textField.getText()+a); } }); btnSqr.setFont(new Font(\"Tahoma\", Font.PLAIN, 15)); btnSqr.setBounds(10, 345, 60, 51); frame.getContentPane().add(btnSqr); JButton btnCos = new JButton(\"cos\"); btnCos.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { double a= Math.cos(Double.parseDouble(textField.getText())); textField.setText(\"\"); textField.setText(textField.getText()+a); } }); btnCos.setFont(new Font(\"Tahoma\", Font.PLAIN, 18)); btnCos.setBounds(190, 141, 60, 51); frame.getContentPane().add(btnCos); JButton btnTan = new JButton(\"tan\"); btnTan.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { double a= Math.tan(Double.parseDouble(textField.getText())); textField.setText(\"\"); textField.setText(textField.getText()+a); } }); btnTan.setFont(new Font(\"Tahoma\", Font.PLAIN, 18)); btnTan.setBounds(250, 141, 60, 51); frame.getContentPane().add(btnTan); JButton btnTanh = new JButton(\"tanh\"); btnTanh.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { double a= Math.tanh(Double.parseDouble(textField.getText())); textField.setText(\"\"); textField.setText(textField.getText()+a); } }); btnTanh.setFont(new Font(\"Tahoma\", Font.PLAIN, 13)); btnTanh.setBounds(250, 192, 60, 51); frame.getContentPane().add(btnTanh); JButton btnCosh = new JButton(\"cosh\"); btnCosh.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { double a= Math.cosh(Double.parseDouble(textField.getText())); textField.setText(\"\"); textField.setText(textField.getText()+a); } }); btnCosh.setFont(new Font(\"Tahoma\", Font.PLAIN, 13)); btnCosh.setBounds(190, 192, 60, 51); frame.getContentPane().add(btnCosh); JButton btnSinh = new JButton(\"sinh\"); btnSinh.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { double a= Math.sinh(Double.parseDouble(textField.getText())); textField.setText(\"\"); textField.setText(textField.getText()+a); } }); btnSinh.setFont(new Font(\"Tahoma\", Font.PLAIN, 14)); btnSinh.setBounds(130, 192, 60, 51); frame.getContentPane().add(btnSinh); JButton btnLog = new JButton(\"Log\"); btnLog.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { double a= Math.log(Double.parseDouble(textField.getText())); textField.setText(\"\"); textField.setText(textField.getText()+a); } }); btnLog.setFont(new Font(\"Tahoma\", Font.PLAIN, 14)); btnLog.setBounds(70, 192, 60, 51); frame.getContentPane().add(btnLog); JButton btnE = new JButton(\"e^x\"); btnE.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { double a= Math.exp(Double.parseDouble(textField.getText())); textField.setText(\"\"); textField.setText(textField.getText()+a); } }); btnE.setFont(new Font(\"Tahoma\", Font.PLAIN, 15)); btnE.setBounds(70, 141, 60, 51); frame.getContentPane().add(btnE); JRadioButton rdbtnOn = new JRadioButton(\"On\"); rdbtnOn.setSelected(true); rdbtnOn.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { btn0.setEnabled(true); btn1.setEnabled(true); btn2.setEnabled(true); btn3.setEnabled(true); btn4.setEnabled(true); btn5.setEnabled(true); btn6.setEnabled(true); btn7.setEnabled(true); btn8.setEnabled(true); btn9.setEnabled(true); btnEqual.setEnabled(true); btnSum.setEnabled(true); btnMinus.setEnabled(true); btnMpy.setEnabled(true); btnDivide.setEnabled(true); btnMod.setEnabled(true); btnSin.setEnabled(true); btnSinh.setEnabled(true); btnCos.setEnabled(true); btnCosh.setEnabled(true); btnTan.setEnabled(true); btnTanh.setEnabled(true); btnLog.setEnabled(true); btnE.setEnabled(true); btnB.setEnabled(true); btnC.setEnabled(true); btnRoot.setEnabled(true); btnPM.setEnabled(true); btnCube.setEnabled(true); btnSqr.setEnabled(true); btnPow.setEnabled(true); btnRev.setEnabled(true); btnFact.setEnabled(true); btnDot.setEnabled(true); } }); buttonGroup.add(rdbtnOn); rdbtnOn.setFont(new Font(\"Tahoma\", Font.PLAIN, 14)); rdbtnOn.setBounds(10, 114, 43, 21); frame.getContentPane().add(rdbtnOn); JRadioButton rdbtnOff = new JRadioButton(\"Off\"); rdbtnOff.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { btn0.setEnabled(false); btn1.setEnabled(false); btn2.setEnabled(false); btn3.setEnabled(false); btn4.setEnabled(false); btn5.setEnabled(false); btn6.setEnabled(false); btn7.setEnabled(false); btn8.setEnabled(false); btn9.setEnabled(false); btnEqual.setEnabled(false); btnSum.setEnabled(false); btnMinus.setEnabled(false); btnMpy.setEnabled(false); btnDivide.setEnabled(false); btnMod.setEnabled(false); btnSin.setEnabled(false); btnSinh.setEnabled(false); btnCos.setEnabled(false); btnCosh.setEnabled(false); btnTan.setEnabled(false); btnTanh.setEnabled(false); btnLog.setEnabled(false); btnE.setEnabled(false); btnB.setEnabled(false); btnC.setEnabled(false); btnRoot.setEnabled(false); btnPM.setEnabled(false); btnCube.setEnabled(false); btnSqr.setEnabled(false); btnPow.setEnabled(false); btnRev.setEnabled(false); btnFact.setEnabled(false); btnDot.setEnabled(false); } }); buttonGroup.add(rdbtnOff); rdbtnOff.setFont(new Font(\"Tahoma\", Font.PLAIN, 14)); rdbtnOff.setBounds(70, 114, 51, 21); frame.getContentPane().add(rdbtnOff); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Scientific-Calculator-master/src/Calculator.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Calculator class handles UI setup, event handling, and mathematical operations. It manages multiple responsibilities like layout configuration, button actions, and calculation logic, violating SRP."}, {"principle": "Open-Closed", "justification": "Adding new operations (e.g., a new math function) requires modifying the initialize() method to add buttons and logic directly. The class is not extendable without altering existing code, violating OCP."}]}]}
{"project_id": 33, "chunk_id": 0, "prompt": {"main_file_path": "Scientific-Calculator-master/Scientific-Calculator-master/src/Calculator.java", "main_file_content": "import java.awt.EventQueue; import javax.swing.JFrame; import javax.swing.JLabel; import java.awt.Font; import javax.swing.JTextField; import javax.swing.JButton; import javax.swing.JRadioButton; import java.awt.event.ActionListener; import java.awt.event.ActionEvent; import java.awt.Color; import javax.swing.ButtonGroup; import javax.swing.UIManager; public class Calculator { private JFrame frame; private JTextField textField; double first; double second; double result; String operation; String answer; private final ButtonGroup buttonGroup = new ButtonGroup(); public static void main(String[] args) { EventQueue.invokeLater(new Runnable() { public void run() { try { Calculator window = new Calculator(); window.frame.setVisible(true); } catch (Exception e) { e.printStackTrace(); } } }); } public Calculator() { initialize(); } private void initialize() { frame = new JFrame(); frame.setBounds(100, 100, 331, 537); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.getContentPane().setLayout(null); JLabel lblScientificCalculator = new JLabel(\"Scientific Calculator\"); lblScientificCalculator.setForeground(new Color(0, 0, 102)); lblScientificCalculator.setFont(new Font(\"Tahoma\", Font.BOLD, 29)); lblScientificCalculator.setBounds(10, 10, 297, 37); frame.getContentPane().add(lblScientificCalculator); textField = new JTextField(); textField.setFont(new Font(\"Tahoma\", Font.BOLD, 13)); textField.setBounds(10, 57, 297, 51); frame.getContentPane().add(textField); textField.setColumns(10); JButton btnRoot = new JButton(\"\\u221A\"); btnRoot.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { double a= Math.sqrt(Double.parseDouble(textField.getText())); textField.setText(\"\"); textField.setText(textField.getText()+a); } }); btnRoot.setFont(new Font(\"Tahoma\", Font.PLAIN, 16)); btnRoot.setBounds(10, 141, 60, 51); frame.getContentPane().add(btnRoot); JButton btnRev = new JButton(\"1/x\"); btnRev.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { double a= 1/(Double.parseDouble(textField.getText())); textField.setText(\"\"); textField.setText(textField.getText()+a); } }); btnRev.setFont(new Font(\"Tahoma\", Font.PLAIN, 15)); btnRev.setBounds(10, 192, 60, 51); frame.getContentPane().add(btnRev); JButton btnFact = new JButton(\"n!\"); btnFact.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { double a = Double.parseDouble(textField.getText()); double fact=1; while(a!=0) { fact=fact*a; a--; } textField.setText(\"\"); textField.setText(textField.getText()+fact); } }); btnFact.setFont(new Font(\"Tahoma\", Font.PLAIN, 21)); btnFact.setBounds(10, 396, 60, 51); frame.getContentPane().add(btnFact); JButton btnPM = new JButton(\"+/-\"); btnPM.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { double a = Double.parseDouble(String.valueOf(textField.getText())); a=a*(-1); textField.setText(String.valueOf(a)); } }); btnPM.setFont(new Font(\"Tahoma\", Font.PLAIN, 14)); btnPM.setBounds(10, 447, 60, 51); frame.getContentPane().add(btnPM); JButton btn7 = new JButton(\"7\"); btn7.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { String number= textField.getText()+btn7.getText(); textField.setText(number); } }); btn7.setFont(new Font(\"Tahoma\", Font.BOLD, 22)); btn7.setBounds(70, 294, 60, 51); frame.getContentPane().add(btn7); JButton btn4 = new JButton(\"4\"); btn4.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { String number= textField.getText()+btn4.getText(); textField.setText(number); } }); btn4.setFont(new Font(\"Tahoma\", Font.BOLD, 22)); btn4.setBounds(70, 345, 60, 51); frame.getContentPane().add(btn4); JButton btn1 = new JButton(\"1\"); btn1.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { String number= textField.getText()+btn1.getText(); textField.setText(number); } }); btn1.setFont(new Font(\"Tahoma\", Font.BOLD, 22)); btn1.setBounds(70, 396, 60, 51); frame.getContentPane().add(btn1); JButton btnSin = new JButton(\"sin\"); btnSin.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { double a= Math.sin(Double.parseDouble(textField.getText())); textField.setText(\"\"); textField.setText(textField.getText()+a); } }); btnSin.setFont(new Font(\"Tahoma\", Font.PLAIN, 18)); btnSin.setBounds(130, 141, 60, 51); frame.getContentPane().add(btnSin); JButton btn8 = new JButton(\"8\"); btn8.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { String number= textField.getText()+btn8.getText(); textField.setText(number); } }); btn8.setFont(new Font(\"Tahoma\", Font.BOLD, 22)); btn8.setBounds(130, 294, 60, 51); frame.getContentPane().add(btn8); JButton btn5 = new JButton(\"5\"); btn5.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { String number= textField.getText()+btn5.getText(); textField.setText(number); } }); btn5.setFont(new Font(\"Tahoma\", Font.BOLD, 22)); btn5.setBounds(130, 345, 60, 51); frame.getContentPane().add(btn5); JButton btn2 = new JButton(\"2\"); btn2.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { String number= textField.getText()+btn2.getText(); textField.setText(number); } }); btn2.setFont(new Font(\"Tahoma\", Font.BOLD, 22)); btn2.setBounds(130, 396, 60, 51); frame.getContentPane().add(btn2); JButton btn0 = new JButton(\"0\"); btn0.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { String number= textField.getText()+btn0.getText(); textField.setText(number); } }); btn0.setFont(new Font(\"Tahoma\", Font.BOLD, 22)); btn0.setBounds(70, 447, 120, 51); frame.getContentPane().add(btn0); JButton btnB = new JButton(\"\\uF0E7\"); btnB.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { String backSpace=null; if(textField.getText().length()>0) { StringBuilder str = new StringBuilder(textField.getText()); str.deleteCharAt(textField.getText().length()-1); backSpace= str.toString(); textField.setText(backSpace); } } }); btnB.setFont(new Font(\"Wingdings\", Font.PLAIN, 22)); btnB.setBounds(190, 243, 60, 51); frame.getContentPane().add(btnB); JButton btn9 = new JButton(\"9\"); btn9.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { String number= textField.getText()+btn9.getText(); textField.setText(number); } }); btn9.setFont(new Font(\"Tahoma\", Font.BOLD, 22)); btn9.setBounds(190, 294, 60, 51); frame.getContentPane().add(btn9); JButton btn6 = new JButton(\"6\"); btn6.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { String number= textField.getText()+btn6.getText(); textField.setText(number); } }); btn6.setFont(new Font(\"Tahoma\", Font.BOLD, 22)); btn6.setBounds(190, 345, 60, 51); frame.getContentPane().add(btn6); JButton btn3 = new JButton(\"3\"); btn3.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { String number= textField.getText()+btn3.getText(); textField.setText(number); } }); btn3.setFont(new Font(\"Tahoma\", Font.BOLD, 22)); btn3.setBounds(190, 396, 60, 51); frame.getContentPane().add(btn3); JButton btnDot = new JButton(\".\"); btnDot.setFont(new Font(\"Tahoma\", Font.BOLD, 22)); btnDot.setBounds(190, 447, 60, 51); frame.getContentPane().add(btnDot); JButton btnEqual = new JButton(\"=\"); btnEqual.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { second = Double.parseDouble(textField.getText()); if(operation==\"+\") { result=first+second; answer= String.format(\"%.2f\", result); textField.setText(answer); } else if(operation==\"-\") { result=first-second; answer= String.format(\"%.2f\", result); textField.setText(answer); } else if(operation==\"*\") { result=first*second; answer= String.format(\"%.2f\", result); textField.setText(answer); } else if(operation==\"/\") { result=first/second; answer= String.format(\"%.2f\", result); textField.setText(answer); } else if(operation==\"%\") { result=first%second; answer= String.format(\"%.2f\", result); textField.setText(answer); } else if(operation==\"x^y\") { double resultt=1; for(int i=0;i<second;i++) { resultt=first*resultt; } answer= String.format(\"%.2f\", resultt); textField.setText(answer); } } }); btnEqual.setFont(new Font(\"Tahoma\", Font.PLAIN, 22)); btnEqual.setBounds(250, 447, 60, 51); frame.getContentPane().add(btnEqual); JButton btnSum = new JButton(\"+\"); btnSum.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { first=Double.parseDouble(textField.getText()); textField.setText(null); operation=\"+\"; } }); btnSum.setFont(new Font(\"Tahoma\", Font.PLAIN, 22)); btnSum.setBounds(250, 243, 60, 51); frame.getContentPane().add(btnSum); JButton btnMinus = new JButton(\"-\"); btnMinus.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { first=Double.parseDouble(textField.getText()); textField.setText(null); operation=\"-\"; } }); btnMinus.setFont(new Font(\"Tahoma\", Font.PLAIN, 22)); btnMinus.setBounds(250, 294, 60, 51); frame.getContentPane().add(btnMinus); JButton btnMpy = new JButton(\"*\"); btnMpy.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { first=Double.parseDouble(textField.getText()); textField.setText(null); operation=\"*\"; } }); btnMpy.setFont(new Font(\"Tahoma\", Font.PLAIN, 22)); btnMpy.setBounds(250, 345, 60, 51); frame.getContentPane().add(btnMpy); JButton btnDivide = new JButton(\"/\"); btnDivide.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { first=Double.parseDouble(textField.getText()); textField.setText(null); operation=\"/\"; } }); btnDivide.setFont(new Font(\"Tahoma\", Font.PLAIN, 22)); btnDivide.setBounds(250, 396, 60, 51); frame.getContentPane().add(btnDivide); JButton btnPow = new JButton(\"x^y\"); btnPow.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { first=Double.parseDouble(textField.getText()); textField.setText(null); operation=\"x^y\"; } }); btnPow.setFont(new Font(\"Tahoma\", Font.PLAIN, 14)); btnPow.setBounds(10, 243, 60, 51); frame.getContentPane().add(btnPow); JButton btnMod = new JButton(\"%\"); btnMod.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { first=Double.parseDouble(textField.getText()); textField.setText(null); operation=\"%\"; } }); btnMod.setFont(new Font(\"Tahoma\", Font.BOLD, 20)); btnMod.setBounds(70, 243, 60, 51); frame.getContentPane().add(btnMod); JButton btnC = new JButton(\"C\"); btnC.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { textField.setText(null); } }); btnC.setFont(new Font(\"Tahoma\", Font.BOLD, 22)); btnC.setBounds(130, 243, 60, 51); frame.getContentPane().add(btnC); JButton btnCube = new JButton(\"x^3\"); btnCube.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { double a= (Double.parseDouble(textField.getText())); a=a*a*a; textField.setText(\"\"); textField.setText(textField.getText()+a); } }); btnCube.setFont(new Font(\"Tahoma\", Font.PLAIN, 13)); btnCube.setBounds(10, 294, 60, 51); frame.getContentPane().add(btnCube); JButton btnSqr = new JButton(\"x^2\"); btnSqr.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { double a= (Double.parseDouble(textField.getText())); a=a*a; textField.setText(\"\"); textField.setText(textField.getText()+a); } }); btnSqr.setFont(new Font(\"Tahoma\", Font.PLAIN, 15)); btnSqr.setBounds(10, 345, 60, 51); frame.getContentPane().add(btnSqr); JButton btnCos = new JButton(\"cos\"); btnCos.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { double a= Math.cos(Double.parseDouble(textField.getText())); textField.setText(\"\"); textField.setText(textField.getText()+a); } }); btnCos.setFont(new Font(\"Tahoma\", Font.PLAIN, 18)); btnCos.setBounds(190, 141, 60, 51); frame.getContentPane().add(btnCos); JButton btnTan = new JButton(\"tan\"); btnTan.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { double a= Math.tan(Double.parseDouble(textField.getText())); textField.setText(\"\"); textField.setText(textField.getText()+a); } }); btnTan.setFont(new Font(\"Tahoma\", Font.PLAIN, 18)); btnTan.setBounds(250, 141, 60, 51); frame.getContentPane().add(btnTan); JButton btnTanh = new JButton(\"tanh\"); btnTanh.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { double a= Math.tanh(Double.parseDouble(textField.getText())); textField.setText(\"\"); textField.setText(textField.getText()+a); } }); btnTanh.setFont(new Font(\"Tahoma\", Font.PLAIN, 13)); btnTanh.setBounds(250, 192, 60, 51); frame.getContentPane().add(btnTanh); JButton btnCosh = new JButton(\"cosh\"); btnCosh.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { double a= Math.cosh(Double.parseDouble(textField.getText())); textField.setText(\"\"); textField.setText(textField.getText()+a); } }); btnCosh.setFont(new Font(\"Tahoma\", Font.PLAIN, 13)); btnCosh.setBounds(190, 192, 60, 51); frame.getContentPane().add(btnCosh); JButton btnSinh = new JButton(\"sinh\"); btnSinh.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { double a= Math.sinh(Double.parseDouble(textField.getText())); textField.setText(\"\"); textField.setText(textField.getText()+a); } }); btnSinh.setFont(new Font(\"Tahoma\", Font.PLAIN, 14)); btnSinh.setBounds(130, 192, 60, 51); frame.getContentPane().add(btnSinh); JButton btnLog = new JButton(\"Log\"); btnLog.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { double a= Math.log(Double.parseDouble(textField.getText())); textField.setText(\"\"); textField.setText(textField.getText()+a); } }); btnLog.setFont(new Font(\"Tahoma\", Font.PLAIN, 14)); btnLog.setBounds(70, 192, 60, 51); frame.getContentPane().add(btnLog); JButton btnE = new JButton(\"e^x\"); btnE.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { double a= Math.exp(Double.parseDouble(textField.getText())); textField.setText(\"\"); textField.setText(textField.getText()+a); } }); btnE.setFont(new Font(\"Tahoma\", Font.PLAIN, 15)); btnE.setBounds(70, 141, 60, 51); frame.getContentPane().add(btnE); JRadioButton rdbtnOn = new JRadioButton(\"On\"); rdbtnOn.setSelected(true); rdbtnOn.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { btn0.setEnabled(true); btn1.setEnabled(true); btn2.setEnabled(true); btn3.setEnabled(true); btn4.setEnabled(true); btn5.setEnabled(true); btn6.setEnabled(true); btn7.setEnabled(true); btn8.setEnabled(true); btn9.setEnabled(true); btnEqual.setEnabled(true); btnSum.setEnabled(true); btnMinus.setEnabled(true); btnMpy.setEnabled(true); btnDivide.setEnabled(true); btnMod.setEnabled(true); btnSin.setEnabled(true); btnSinh.setEnabled(true); btnCos.setEnabled(true); btnCosh.setEnabled(true); btnTan.setEnabled(true); btnTanh.setEnabled(true); btnLog.setEnabled(true); btnE.setEnabled(true); btnB.setEnabled(true); btnC.setEnabled(true); btnRoot.setEnabled(true); btnPM.setEnabled(true); btnCube.setEnabled(true); btnSqr.setEnabled(true); btnPow.setEnabled(true); btnRev.setEnabled(true); btnFact.setEnabled(true); btnDot.setEnabled(true); } }); buttonGroup.add(rdbtnOn); rdbtnOn.setFont(new Font(\"Tahoma\", Font.PLAIN, 14)); rdbtnOn.setBounds(10, 114, 43, 21); frame.getContentPane().add(rdbtnOn); JRadioButton rdbtnOff = new JRadioButton(\"Off\"); rdbtnOff.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { btn0.setEnabled(false); btn1.setEnabled(false); btn2.setEnabled(false); btn3.setEnabled(false); btn4.setEnabled(false); btn5.setEnabled(false); btn6.setEnabled(false); btn7.setEnabled(false); btn8.setEnabled(false); btn9.setEnabled(false); btnEqual.setEnabled(false); btnSum.setEnabled(false); btnMinus.setEnabled(false); btnMpy.setEnabled(false); btnDivide.setEnabled(false); btnMod.setEnabled(false); btnSin.setEnabled(false); btnSinh.setEnabled(false); btnCos.setEnabled(false); btnCosh.setEnabled(false); btnTan.setEnabled(false); btnTanh.setEnabled(false); btnLog.setEnabled(false); btnE.setEnabled(false); btnB.setEnabled(false); btnC.setEnabled(false); btnRoot.setEnabled(false); btnPM.setEnabled(false); btnCube.setEnabled(false); btnSqr.setEnabled(false); btnPow.setEnabled(false); btnRev.setEnabled(false); btnFact.setEnabled(false); btnDot.setEnabled(false); } }); buttonGroup.add(rdbtnOff); rdbtnOff.setFont(new Font(\"Tahoma\", Font.PLAIN, 14)); rdbtnOff.setBounds(70, 114, 51, 21); frame.getContentPane().add(rdbtnOff); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Scientific-Calculator-master/Scientific-Calculator-master/src/Calculator.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Calculator class handles UI setup, event handling, and mathematical operations, violating SRP by managing multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Adding new operations requires modifying existing code (e.g., adding new buttons/actions in initialize()), violating OCP's extension without modification rule."}, {"principle": "Dependency Inversion", "justification": "High-level Calculator directly depends on concrete Swing UI components and embeds business logic, instead of depending on abstractions for calculations."}]}]}
{"project_id": 39, "chunk_id": 0, "prompt": {"main_file_path": "Car-Rental-System-master/src/Main.java", "main_file_content": "import java.util.ArrayList; import java.util.List; import java.util.Scanner; class Car { private String carId; private String brand; private String model; private double basePricePerDay; private boolean isAvailable; public Car(String carId, String brand, String model, double basePricePerDay) { this.carId = carId; this.brand = brand; this.model = model; this.basePricePerDay = basePricePerDay; this.isAvailable = true; } public String getCarId() { return carId; } public String getBrand() { return brand; } public String getModel() { return model; } public double calculatePrice(int rentalDays) { return basePricePerDay * rentalDays; } public boolean isAvailable() { return isAvailable; } public void rent() { isAvailable = false; } public void returnCar() { isAvailable = true; } } class Customer { private String customerId; private String name; public Customer(String customerId, String name) { this.customerId = customerId; this.name = name; } public String getCustomerId() { return customerId; } public String getName() { return name; } } class Rental { private Car car; private Customer customer; private int days; public Rental(Car car, Customer customer, int days) { this.car = car; this.customer = customer; this.days = days; } public Car getCar() { return car; } public Customer getCustomer() { return customer; } public int getDays() { return days; } } class CarRentalSystem { private List<Car> cars; private List<Customer> customers; private List<Rental> rentals; public CarRentalSystem() { cars = new ArrayList<>(); customers = new ArrayList<>(); rentals = new ArrayList<>(); } public void addCar(Car car) { cars.add(car); } public void addCustomer(Customer customer) { customers.add(customer); } public void rentCar(Car car, Customer customer, int days) { if (car.isAvailable()) { car.rent(); rentals.add(new Rental(car, customer, days)); } else { soutl(\"\") } } public void returnCar(Car car) { car.returnCar(); Rental rentalToRemove = null; for (Rental rental : rentals) { if (rental.getCar() == car) { rentalToRemove = rental; break; } } if (rentalToRemove != null) { rentals.remove(rentalToRemove); } else { soutl(\"\") } } public void menu() { Scanner scanner = new Scanner(System.in); while (true) { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") sout(\"\") int choice = scanner.nextInt(); scanner.nextLine(); if (choice == 1) { soutl(\"\") sout(\"\") String customerName = scanner.nextLine(); soutl(\"\") for (Car car : cars) { if (car.isAvailable()) { soutl(\"\") } } sout(\"\") String carId = scanner.nextLine(); sout(\"\") int rentalDays = scanner.nextInt(); scanner.nextLine(); Customer newCustomer = new Customer(\"CUS\" + (customers.size() + 1), customerName); addCustomer(newCustomer); Car selectedCar = null; for (Car car : cars) { if (car.getCarId().equals(carId) && car.isAvailable()) { selectedCar = car; break; } } if (selectedCar != null) { double totalPrice = selectedCar.calculatePrice(rentalDays); soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") System.out.printf(\"Total Price: $%.2f%n\", totalPrice); sout(\"\") String confirm = scanner.nextLine(); if (confirm.equalsIgnoreCase(\"Y\")) { rentCar(selectedCar, newCustomer, rentalDays); soutl(\"\") } else { soutl(\"\") } } else { soutl(\"\") } } else if (choice == 2) { soutl(\"\") sout(\"\") String carId = scanner.nextLine(); Car carToReturn = null; for (Car car : cars) { if (car.getCarId().equals(carId) && !car.isAvailable()) { carToReturn = car; break; } } if (carToReturn != null) { Customer customer = null; for (Rental rental : rentals) { if (rental.getCar() == carToReturn) { customer = rental.getCustomer(); break; } } if (customer != null) { returnCar(carToReturn); soutl(\"\") } else { soutl(\"\") } } else { soutl(\"\") } } else if (choice == 3) { break; } else { soutl(\"\") } } soutl(\"\") } } public class Main{ public static void main(String[] args) { CarRentalSystem rentalSystem = new CarRentalSystem(); Car car1 = new Car(\"C01\", \"Toyota\", \"Camry\", 60.0); Car car2 = new Car(\"C02\", \"Honda\", \"Accord\", 70.0); Car car3 = new Car(\"C03\", \"Mahindra\", \"Thar\", 150.0); Car car4 = new Car(\"C04\", \"Ford\", \"Mustang\", 120.0); Car car5 = new Car(\"C05\", \"Chevrolet\", \"Cruze\", 80.0); Car car6 = new Car(\"C06\", \"BMW\", \"X5\", 200.0); Car car7 = new Car(\"C07\", \"Mercedes-Benz\", \"E-Class\", 180.0); Car car8 = new Car(\"C08\", \"Audi\", \"Q7\", 220.0); Car car9 = new Car(\"C09\", \"Nissan\", \"Altima\", 75.0); Car car10 = new Car(\"C10\", \"Hyundai\", \"Tucson\", 90.0); rentalSystem.addCar(car1); rentalSystem.addCar(car2); rentalSystem.addCar(car3); rentalSystem.addCar(car4); rentalSystem.addCar(car5); rentalSystem.addCar(car6); rentalSystem.addCar(car7); rentalSystem.addCar(car8); rentalSystem.addCar(car9); rentalSystem.addCar(car10); rentalSystem.menu(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Car-Rental-System-master/src/Main.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The CarRentalSystem class manages cars, customers, rentals, and directly handles user input/output via Scanner. Combining business logic, data management, and UI in one class violates SRP."}, {"principle": "Open-Closed", "justification": "Adding new car types (e.g., electric cars with dynamic pricing) would require modifying CarRentalSystem's rentCar/returnCar logic. No abstractions allow extension without changing existing code."}, {"principle": "Dependency Inversion", "justification": "CarRentalSystem directly depends on concrete Car, Customer, and Rental classes. High-level modules should depend on abstractions (e.g., interfaces like RentableEntity) rather than low-level implementations."}]}]}
{"project_id": 39, "chunk_id": 0, "prompt": {"main_file_path": "Car-Rental-System-master/Car-Rental-System-master/src/Main.java", "main_file_content": "import java.util.ArrayList; import java.util.List; import java.util.Scanner; class Car { private String carId; private String brand; private String model; private double basePricePerDay; private boolean isAvailable; public Car(String carId, String brand, String model, double basePricePerDay) { this.carId = carId; this.brand = brand; this.model = model; this.basePricePerDay = basePricePerDay; this.isAvailable = true; } public String getCarId() { return carId; } public String getBrand() { return brand; } public String getModel() { return model; } public double calculatePrice(int rentalDays) { return basePricePerDay * rentalDays; } public boolean isAvailable() { return isAvailable; } public void rent() { isAvailable = false; } public void returnCar() { isAvailable = true; } } class Customer { private String customerId; private String name; public Customer(String customerId, String name) { this.customerId = customerId; this.name = name; } public String getCustomerId() { return customerId; } public String getName() { return name; } } class Rental { private Car car; private Customer customer; private int days; public Rental(Car car, Customer customer, int days) { this.car = car; this.customer = customer; this.days = days; } public Car getCar() { return car; } public Customer getCustomer() { return customer; } public int getDays() { return days; } } class CarRentalSystem { private List<Car> cars; private List<Customer> customers; private List<Rental> rentals; public CarRentalSystem() { cars = new ArrayList<>(); customers = new ArrayList<>(); rentals = new ArrayList<>(); } public void addCar(Car car) { cars.add(car); } public void addCustomer(Customer customer) { customers.add(customer); } public void rentCar(Car car, Customer customer, int days) { if (car.isAvailable()) { car.rent(); rentals.add(new Rental(car, customer, days)); } else { soutl(\"\") } } public void returnCar(Car car) { car.returnCar(); Rental rentalToRemove = null; for (Rental rental : rentals) { if (rental.getCar() == car) { rentalToRemove = rental; break; } } if (rentalToRemove != null) { rentals.remove(rentalToRemove); } else { soutl(\"\") } } public void menu() { Scanner scanner = new Scanner(System.in); while (true) { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") sout(\"\") int choice = scanner.nextInt(); scanner.nextLine(); if (choice == 1) { soutl(\"\") sout(\"\") String customerName = scanner.nextLine(); soutl(\"\") for (Car car : cars) { if (car.isAvailable()) { soutl(\"\") } } sout(\"\") String carId = scanner.nextLine(); sout(\"\") int rentalDays = scanner.nextInt(); scanner.nextLine(); Customer newCustomer = new Customer(\"CUS\" + (customers.size() + 1), customerName); addCustomer(newCustomer); Car selectedCar = null; for (Car car : cars) { if (car.getCarId().equals(carId) && car.isAvailable()) { selectedCar = car; break; } } if (selectedCar != null) { double totalPrice = selectedCar.calculatePrice(rentalDays); soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") System.out.printf(\"Total Price: $%.2f%n\", totalPrice); sout(\"\") String confirm = scanner.nextLine(); if (confirm.equalsIgnoreCase(\"Y\")) { rentCar(selectedCar, newCustomer, rentalDays); soutl(\"\") } else { soutl(\"\") } } else { soutl(\"\") } } else if (choice == 2) { soutl(\"\") sout(\"\") String carId = scanner.nextLine(); Car carToReturn = null; for (Car car : cars) { if (car.getCarId().equals(carId) && !car.isAvailable()) { carToReturn = car; break; } } if (carToReturn != null) { Customer customer = null; for (Rental rental : rentals) { if (rental.getCar() == carToReturn) { customer = rental.getCustomer(); break; } } if (customer != null) { returnCar(carToReturn); soutl(\"\") } else { soutl(\"\") } } else { soutl(\"\") } } else if (choice == 3) { break; } else { soutl(\"\") } } soutl(\"\") } } public class Main{ public static void main(String[] args) { CarRentalSystem rentalSystem = new CarRentalSystem(); Car car1 = new Car(\"C01\", \"Toyota\", \"Camry\", 60.0); Car car2 = new Car(\"C02\", \"Honda\", \"Accord\", 70.0); Car car3 = new Car(\"C03\", \"Mahindra\", \"Thar\", 150.0); Car car4 = new Car(\"C04\", \"Ford\", \"Mustang\", 120.0); Car car5 = new Car(\"C05\", \"Chevrolet\", \"Cruze\", 80.0); Car car6 = new Car(\"C06\", \"BMW\", \"X5\", 200.0); Car car7 = new Car(\"C07\", \"Mercedes-Benz\", \"E-Class\", 180.0); Car car8 = new Car(\"C08\", \"Audi\", \"Q7\", 220.0); Car car9 = new Car(\"C09\", \"Nissan\", \"Altima\", 75.0); Car car10 = new Car(\"C10\", \"Hyundai\", \"Tucson\", 90.0); rentalSystem.addCar(car1); rentalSystem.addCar(car2); rentalSystem.addCar(car3); rentalSystem.addCar(car4); rentalSystem.addCar(car5); rentalSystem.addCar(car6); rentalSystem.addCar(car7); rentalSystem.addCar(car8); rentalSystem.addCar(car9); rentalSystem.addCar(car10); rentalSystem.menu(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Car-Rental-System-master/Car-Rental-System-master/src/Main.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The CarRentalSystem class handles user interaction (via Scanner), business logic (renting/returning cars), and data management (lists of cars, customers, rentals), violating SRP by having multiple responsibilities."}, {"principle": "Open-Closed", "justification": "CarRentalSystem and Car classes are not extendable without modification (e.g., adding new car types or rental behaviors requires changing existing code), violating OCP."}, {"principle": "Dependency Inversion", "justification": "CarRentalSystem directly depends on concrete classes (Car, Customer, Rental) instead of abstractions, and low-level modules (e.g., Car) do not implement abstractions, violating DIP."}]}]}
{"project_id": 40, "chunk_id": 0, "prompt": {"main_file_path": "darts-java-master/src/main/java/darts/DoubleArrayTrie.java", "main_file_content": "package darts; import java.io.BufferedInputStream; import java.io.BufferedOutputStream; import java.io.DataInputStream; import java.io.DataOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.util.ArrayList; import java.util.List; public class DoubleArrayTrie { private final static int BUF_SIZE = 16384; private final static int UNIT_SIZE = 8; private static class Node { int code; int depth; int left; int right; }; private int check[]; private int base[]; private boolean used[]; private int size; private int allocSize; private List<String> key; private int keySize; private int length[]; private int value[]; private int progress; private int nextCheckPos; int error_; private int resize(int newSize) { int[] base2 = new int[newSize]; int[] check2 = new int[newSize]; boolean used2[] = new boolean[newSize]; if (allocSize > 0) { System.arraycopy(base, 0, base2, 0, allocSize); System.arraycopy(check, 0, check2, 0, allocSize); System.arraycopy(used2, 0, used2, 0, allocSize); } base = base2; check = check2; used = used2; return allocSize = newSize; } private int fetch(Node parent, List<Node> siblings) { if (error_ < 0) return 0; int prev = 0; for (int i = parent.left; i < parent.right; i++) { if ((length != null ? length[i] : key.get(i).length()) < parent.depth) continue; String tmp = key.get(i); int cur = 0; if ((length != null ? length[i] : tmp.length()) != parent.depth) cur = (int) tmp.charAt(parent.depth) + 1; if (prev > cur) { error_ = -3; return 0; } if (cur != prev || siblings.size() == 0) { Node tmp_node = new Node(); tmp_node.depth = parent.depth + 1; tmp_node.code = cur; tmp_node.left = i; if (siblings.size() != 0) siblings.get(siblings.size() - 1).right = i; siblings.add(tmp_node); } prev = cur; } if (siblings.size() != 0) siblings.get(siblings.size() - 1).right = parent.right; return siblings.size(); } private int insert(List<Node> siblings) { if (error_ < 0) return 0; int begin = 0; int pos = ((siblings.get(0).code + 1 > nextCheckPos) ? siblings.get(0).code + 1 : nextCheckPos) - 1; int nonzero_num = 0; int first = 0; if (allocSize <= pos) resize(pos + 1); outer: while (true) { pos++; if (allocSize <= pos) resize(pos + 1); if (check[pos] != 0) { nonzero_num++; continue; } else if (first == 0) { nextCheckPos = pos; first = 1; } begin = pos - siblings.get(0).code; if (allocSize <= (begin + siblings.get(siblings.size() - 1).code)) { double l = (1.05 > 1.0 * keySize / (progress + 1)) ? 1.05 : 1.0 * keySize / (progress + 1); resize((int) (allocSize * l)); } if (used[begin]) continue; for (int i = 1; i < siblings.size(); i++) if (check[begin + siblings.get(i).code] != 0) continue outer; break; } if (1.0 * nonzero_num / (pos - nextCheckPos + 1) >= 0.95) nextCheckPos = pos; used[begin] = true; size = (size > begin + siblings.get(siblings.size() - 1).code + 1) ? size : begin + siblings.get(siblings.size() - 1).code + 1; for (int i = 0; i < siblings.size(); i++) check[begin + siblings.get(i).code] = begin; for (int i = 0; i < siblings.size(); i++) { List<Node> new_siblings = new ArrayList<Node>(); if (fetch(siblings.get(i), new_siblings) == 0) { base[begin + siblings.get(i).code] = (value != null) ? (-value[siblings .get(i).left] - 1) : (-siblings.get(i).left - 1); if (value != null && (-value[siblings.get(i).left] - 1) >= 0) { error_ = -2; return 0; } progress++; } else { int h = insert(new_siblings); base[begin + siblings.get(i).code] = h; } } return begin; } public DoubleArrayTrie() { check = null; base = null; used = null; size = 0; allocSize = 0; error_ = 0; } void clear() { check = null; base = null; used = null; allocSize = 0; size = 0; } public int getUnitSize() { return UNIT_SIZE; } public int getSize() { return size; } public int getTotalSize() { return size * UNIT_SIZE; } public int getNonzeroSize() { int result = 0; for (int i = 0; i < size; i++) if (check[i] != 0) result++; return result; } public int build(List<String> key) { return build(key, null, null, key.size()); } public int build(List<String> _key, int _length[], int _value[], int _keySize) { if (_keySize > _key.size() || _key == null) return 0; key = _key; length = _length; keySize = _keySize; value = _value; progress = 0; resize(65536 * 32); base[0] = 1; nextCheckPos = 0; Node root_node = new Node(); root_node.left = 0; root_node.right = keySize; root_node.depth = 0; List<Node> siblings = new ArrayList<Node>(); fetch(root_node, siblings); insert(siblings); used = null; key = null; return error_; } public void open(String fileName) throws IOException { File file = new File(fileName); size = (int) file.length() / UNIT_SIZE; check = new int[size]; base = new int[size]; DataInputStream is = null; try { is = new DataInputStream(new BufferedInputStream( new FileInputStream(file), BUF_SIZE)); for (int i = 0; i < size; i++) { base[i] = is.readInt(); check[i] = is.readInt(); } } finally { if (is != null) is.close(); } } public void save(String fileName) throws IOException { DataOutputStream out = null; try { out = new DataOutputStream(new BufferedOutputStream( new FileOutputStream(fileName))); for (int i = 0; i < size; i++) { out.writeInt(base[i]); out.writeInt(check[i]); } out.close(); } finally { if (out != null) out.close(); } } public int exactMatchSearch(String key) { return exactMatchSearch(key, 0, 0, 0); } public int exactMatchSearch(String key, int pos, int len, int nodePos) { if (len <= 0) len = key.length(); if (nodePos <= 0) nodePos = 0; int result = -1; char[] keyChars = key.toCharArray(); int b = base[nodePos]; int p; for (int i = pos; i < len; i++) { p = b + (int) (keyChars[i]) + 1; if (b == check[p]) b = base[p]; else return result; } p = b; int n = base[p]; if (b == check[p] && n < 0) { result = -n - 1; } return result; } public List<Integer> commonPrefixSearch(String key) { return commonPrefixSearch(key, 0, 0, 0); } public List<Integer> commonPrefixSearch(String key, int pos, int len, int nodePos) { if (len <= 0) len = key.length(); if (nodePos <= 0) nodePos = 0; List<Integer> result = new ArrayList<Integer>(); char[] keyChars = key.toCharArray(); int b = base[nodePos]; int n; int p; for (int i = pos; i < len; i++) { p = b; n = base[p]; if (b == check[p] && n < 0) { result.add(-n - 1); } p = b + (int) (keyChars[i]) + 1; if (b == check[p]) b = base[p]; else return result; } p = b; n = base[p]; if (b == check[p] && n < 0) { result.add(-n - 1); } return result; } public void dump() { for (int i = 0; i < size; i++) { System.err.println(\"i: \" + i + \" [\" + base[i] + \", \" + check[i] + \"]\"); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "darts-java-master/src/main/java/darts/DoubleArrayTrie.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The DoubleArrayTrie class manages trie construction, file I/O operations, and search functionalities, indicating multiple responsibilities."}, {"principle": "Open-Closed", "justification": "The class does not support extension for new trie behaviors without modifying existing code (e.g., private methods like fetch/insert prevent overriding)."}]}]}
{"project_id": 40, "chunk_id": 0, "prompt": {"main_file_path": "darts-java-master/darts-java-master/src/main/java/darts/DoubleArrayTrie.java", "main_file_content": "package darts; import java.io.BufferedInputStream; import java.io.BufferedOutputStream; import java.io.DataInputStream; import java.io.DataOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.util.ArrayList; import java.util.List; public class DoubleArrayTrie { private final static int BUF_SIZE = 16384; private final static int UNIT_SIZE = 8; private static class Node { int code; int depth; int left; int right; }; private int check[]; private int base[]; private boolean used[]; private int size; private int allocSize; private List<String> key; private int keySize; private int length[]; private int value[]; private int progress; private int nextCheckPos; int error_; private int resize(int newSize) { int[] base2 = new int[newSize]; int[] check2 = new int[newSize]; boolean used2[] = new boolean[newSize]; if (allocSize > 0) { System.arraycopy(base, 0, base2, 0, allocSize); System.arraycopy(check, 0, check2, 0, allocSize); System.arraycopy(used2, 0, used2, 0, allocSize); } base = base2; check = check2; used = used2; return allocSize = newSize; } private int fetch(Node parent, List<Node> siblings) { if (error_ < 0) return 0; int prev = 0; for (int i = parent.left; i < parent.right; i++) { if ((length != null ? length[i] : key.get(i).length()) < parent.depth) continue; String tmp = key.get(i); int cur = 0; if ((length != null ? length[i] : tmp.length()) != parent.depth) cur = (int) tmp.charAt(parent.depth) + 1; if (prev > cur) { error_ = -3; return 0; } if (cur != prev || siblings.size() == 0) { Node tmp_node = new Node(); tmp_node.depth = parent.depth + 1; tmp_node.code = cur; tmp_node.left = i; if (siblings.size() != 0) siblings.get(siblings.size() - 1).right = i; siblings.add(tmp_node); } prev = cur; } if (siblings.size() != 0) siblings.get(siblings.size() - 1).right = parent.right; return siblings.size(); } private int insert(List<Node> siblings) { if (error_ < 0) return 0; int begin = 0; int pos = ((siblings.get(0).code + 1 > nextCheckPos) ? siblings.get(0).code + 1 : nextCheckPos) - 1; int nonzero_num = 0; int first = 0; if (allocSize <= pos) resize(pos + 1); outer: while (true) { pos++; if (allocSize <= pos) resize(pos + 1); if (check[pos] != 0) { nonzero_num++; continue; } else if (first == 0) { nextCheckPos = pos; first = 1; } begin = pos - siblings.get(0).code; if (allocSize <= (begin + siblings.get(siblings.size() - 1).code)) { double l = (1.05 > 1.0 * keySize / (progress + 1)) ? 1.05 : 1.0 * keySize / (progress + 1); resize((int) (allocSize * l)); } if (used[begin]) continue; for (int i = 1; i < siblings.size(); i++) if (check[begin + siblings.get(i).code] != 0) continue outer; break; } if (1.0 * nonzero_num / (pos - nextCheckPos + 1) >= 0.95) nextCheckPos = pos; used[begin] = true; size = (size > begin + siblings.get(siblings.size() - 1).code + 1) ? size : begin + siblings.get(siblings.size() - 1).code + 1; for (int i = 0; i < siblings.size(); i++) check[begin + siblings.get(i).code] = begin; for (int i = 0; i < siblings.size(); i++) { List<Node> new_siblings = new ArrayList<Node>(); if (fetch(siblings.get(i), new_siblings) == 0) { base[begin + siblings.get(i).code] = (value != null) ? (-value[siblings .get(i).left] - 1) : (-siblings.get(i).left - 1); if (value != null && (-value[siblings.get(i).left] - 1) >= 0) { error_ = -2; return 0; } progress++; } else { int h = insert(new_siblings); base[begin + siblings.get(i).code] = h; } } return begin; } public DoubleArrayTrie() { check = null; base = null; used = null; size = 0; allocSize = 0; error_ = 0; } void clear() { check = null; base = null; used = null; allocSize = 0; size = 0; } public int getUnitSize() { return UNIT_SIZE; } public int getSize() { return size; } public int getTotalSize() { return size * UNIT_SIZE; } public int getNonzeroSize() { int result = 0; for (int i = 0; i < size; i++) if (check[i] != 0) result++; return result; } public int build(List<String> key) { return build(key, null, null, key.size()); } public int build(List<String> _key, int _length[], int _value[], int _keySize) { if (_keySize > _key.size() || _key == null) return 0; key = _key; length = _length; keySize = _keySize; value = _value; progress = 0; resize(65536 * 32); base[0] = 1; nextCheckPos = 0; Node root_node = new Node(); root_node.left = 0; root_node.right = keySize; root_node.depth = 0; List<Node> siblings = new ArrayList<Node>(); fetch(root_node, siblings); insert(siblings); used = null; key = null; return error_; } public void open(String fileName) throws IOException { File file = new File(fileName); size = (int) file.length() / UNIT_SIZE; check = new int[size]; base = new int[size]; DataInputStream is = null; try { is = new DataInputStream(new BufferedInputStream( new FileInputStream(file), BUF_SIZE)); for (int i = 0; i < size; i++) { base[i] = is.readInt(); check[i] = is.readInt(); } } finally { if (is != null) is.close(); } } public void save(String fileName) throws IOException { DataOutputStream out = null; try { out = new DataOutputStream(new BufferedOutputStream( new FileOutputStream(fileName))); for (int i = 0; i < size; i++) { out.writeInt(base[i]); out.writeInt(check[i]); } out.close(); } finally { if (out != null) out.close(); } } public int exactMatchSearch(String key) { return exactMatchSearch(key, 0, 0, 0); } public int exactMatchSearch(String key, int pos, int len, int nodePos) { if (len <= 0) len = key.length(); if (nodePos <= 0) nodePos = 0; int result = -1; char[] keyChars = key.toCharArray(); int b = base[nodePos]; int p; for (int i = pos; i < len; i++) { p = b + (int) (keyChars[i]) + 1; if (b == check[p]) b = base[p]; else return result; } p = b; int n = base[p]; if (b == check[p] && n < 0) { result = -n - 1; } return result; } public List<Integer> commonPrefixSearch(String key) { return commonPrefixSearch(key, 0, 0, 0); } public List<Integer> commonPrefixSearch(String key, int pos, int len, int nodePos) { if (len <= 0) len = key.length(); if (nodePos <= 0) nodePos = 0; List<Integer> result = new ArrayList<Integer>(); char[] keyChars = key.toCharArray(); int b = base[nodePos]; int n; int p; for (int i = pos; i < len; i++) { p = b; n = base[p]; if (b == check[p] && n < 0) { result.add(-n - 1); } p = b + (int) (keyChars[i]) + 1; if (b == check[p]) b = base[p]; else return result; } p = b; n = base[p]; if (b == check[p] && n < 0) { result.add(-n - 1); } return result; } public void dump() { for (int i = 0; i < size; i++) { System.err.println(\"i: \" + i + \" [\" + base[i] + \", \" + check[i] + \"]\"); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "darts-java-master/darts-java-master/src/main/java/darts/DoubleArrayTrie.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The class handles multiple responsibilities: trie construction, file I/O operations, and search functionalities. This consolidation of distinct tasks into one class violates SRP."}, {"principle": "Open-Closed", "justification": "The class is not designed for extension without modification. Adding new trie-building strategies or I/O methods would require altering existing code, violating OCP."}]}]}
{"project_id": 42, "chunk_id": 0, "prompt": {"main_file_path": "Enigma-main/Enigma-main/Rotor.java", "main_file_content": "public class Rotor { private String map; private int shift; private char notch; final static String reflector = \"YRUHQSLDPXNGOKMIEBFZCWVJAT\"; public static final String[] romanNumerals = {\"I\", \"II\", \"III\", \"IV\", \"V\"}; public Rotor(String roman, String shiftLetter) { if(roman.equalsIgnoreCase(\"I\")) { setMap(Affine.mapa); setNotch('Q'); } else if(roman.equalsIgnoreCase(\"II\")) { setMap(Affine.mapb); setNotch('E'); } else if(roman.equalsIgnoreCase(\"III\")) { setMap(Affine.mapc); setNotch('V'); } else if(roman.equalsIgnoreCase(\"IV\")) { setMap(Affine.mapd); setNotch('J'); } else if(roman.equalsIgnoreCase(\"V\")) { setMap(Affine.mape); setNotch('Z'); } if(shiftLetter.charAt(0) > 90) { shiftLetter = \"Z\"; } else if(shiftLetter.charAt(0) < 65) { shiftLetter = \"A\"; } shift = shiftLetter.charAt(0) - 65; } public boolean shift() { final boolean atNotch = ((int)notch-65 == shift); shift = Caesar.encrypt((\">C\" + \" \" + (char)(shift + 65)).split(\" \")).charAt(0)-65; return atNotch; } public String getMap() { return map; } public void setMap(String map) { this.map = map; } public int getShift() { return shift; } public char getShift(char c) { return (char) (shift+65); } public boolean atNotch() { return ((int)notch-65 == shift); } public void setNotch(char notch) { this.notch = notch; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Enigma-main/Enigma-main/Rotor.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Rotor class handles multiple responsibilities: configuring rotor mappings based on roman numerals, managing shift state, and performing encryption logic via direct dependencies like Affine and Caesar."}, {"principle": "Open-Closed", "justification": "Adding a new rotor type (e.g., VI) requires modifying the constructor's conditional logic instead of extending through abstractions or new classes."}, {"principle": "Dependency Inversion", "justification": "Rotor directly depends on concrete implementations (Affine, Caesar) instead of abstractions. High-level rotor logic is tightly coupled to low-level encryption details."}]}]}
{"project_id": 42, "chunk_id": 0, "prompt": {"main_file_path": "Enigma-main/Enigma-main/Deduction.java", "main_file_content": "public class Deduction { private char key; public Deduction(char key, char coded) { this.key = key; } public void deduce() { } public void run() { } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Enigma-main/Enigma-main/Deduction.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Deduction class has multiple public methods (deduce and run) that may represent distinct responsibilities, implying more than one reason for the class to change."}]}]}
{"project_id": 42, "chunk_id": 0, "prompt": {"main_file_path": "Enigma-main/Enigma-main/Caesar.java", "main_file_content": "public class Caesar{ public static String encrypt(String[] in) { int shift = 1; String out = \"\"; if(in[0].length()>2) { try { shift = (int) Double.parseDouble(in[0].substring(2)); } catch (NumberFormatException exc) { return \"Invalid shift; shift amount must be a number. Type and enter 'help' for help menu.\"; } } for(int i = 1; i < in.length; i++) { for(int j = 0; j < in[i].length(); j++) { if(in[i].charAt(j)!= ' ') { if(in[i].charAt(j) < 65 || in[i].charAt(j) > 90) { return \"Invalid input; message must only contain letters. Type and enter 'help' for help menu.\"; } out += (char)((in[i].charAt(j) - 65 + shift)%26 +65); } } out += \" \"; } return out.substring(0, out.length()-1); } public static String decrypt(String[] in) { int shift = 1; String out = \"\"; if(in[0].length()>2) { try { shift = (int) Double.parseDouble(in[0].substring(2)); } catch (NumberFormatException exc) { return \"Invalid shift; shift amount must be a number. Type and enter 'help' for help menu.\"; } } for(int i = 1; i < in.length; i++) { for(int j = 0; j < in[i].length(); j++) { if(in[i].charAt(j) < 65 || in[i].charAt(j) > 90) { return \"Invalid input; message must only contain letters. Type and enter 'help' for help menu.\"; } while((in[i].charAt(j) - 39 - shift) < 0) { shift -= 26; } out += (char)((in[i].charAt(j) - 39 - shift)%26 + 65); } out += \" \"; } return out.substring(0, out.length()); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Enigma-main/Enigma-main/Caesar.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Caesar class handles encryption, decryption, input validation, shift parsing, and error message generation. These are multiple responsibilities that could change independently."}, {"principle": "Open-Closed", "justification": "The Caesar class cannot be extended without modification (e.g., to add new encryption algorithms). All logic is hardcoded in static methods with no abstraction for variation."}]}]}
{"project_id": 42, "chunk_id": 0, "prompt": {"main_file_path": "Enigma-main/Enigma-main/Decryptor.java", "main_file_content": "import java.util.*; public class Decryptor implements Runnable { private String key; public int count = 0; private String encrypted; private ArrayList<String> deductions; private ArrayList<Integer> deducePosition; public Decryptor(String key, String encrypted) { this.key = key; this.encrypted = encrypted; } public void decrypt() { int count = 1; String current = \"\"; String[] split = new String[17]; split[6] = \"AA\"; split[7] = \"BB\"; split[8] = \"CC\"; split[9] = \"DD\"; split[10] = \"EE\"; split[11] = \"FF\"; split[12] = \"GG\"; split[13] = \"HH\"; split[14] = \"II\"; split[15] = \"JJ\"; split[16] = encrypted; deducePosition = new ArrayList<Integer>(); this.keyPos(); for(int i : deducePosition) { sout(\"\") } soutl(\"\") for(int i = 0; i < 5; i++) { split[0] = Rotor.romanNumerals[i]; for(int j = 0; j < 5; j++) { split[1] = Rotor.romanNumerals[j]; for(int k = 0; k < 5; k++) { split[2] = Rotor.romanNumerals[k]; for(int l = 0; l < 26; l++) { split[3] = \"\" + ((char)(l+65)); for(int m = 0; m < 26; m++) { split[4] = \"\" + ((char)(m+65)); for(int n = 0; n < 26; n++) { split[5] = \"\" + ((char)(n+65)); current = Enigma.enigma(split); sout(\"\") for(String s : split) { sout(\"\") } soutl(\"\") if(current.toUpperCase().contains(key)) { sout(\"\") for(String s : split) { soutl(\"\") } soutl(\"\") count++; } } } } } } } } public void keyPos() { for(int i = 0; i <= encrypted.length()-key.length(); i++) { for(int j = i; j < i + key.length(); j++) { if(encrypted.charAt(j) == key.charAt(j-i)) { j = i + key.length(); } else if(j == (i+key.length()-1)) { deducePosition.add(i); soutl(\"\") } } } } public String deducePlugboard() { char keyChar; char phraseChar; for(int i : deducePosition) { for(int j = i; j < i + key.length(); j++) { Deduction d = new Deduction(key.charAt(j-i), encrypted.charAt(j)); } } return \"\"; } @Override public void run() { } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Enigma-main/Enigma-main/Decryptor.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Decryptor class handles decryption logic, key position determination, plugboard deduction, and thread execution (via Runnable), indicating multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Adding new decryption strategies or algorithms would require modifying the Decryptor class directly instead of extending it through abstractions."}, {"principle": "Dependency Inversion", "justification": "Decryptor directly depends on the concrete Enigma class (via Enigma.enigma()), violating the requirement to depend on abstractions for high-level modules."}]}]}
{"project_id": 42, "chunk_id": 0, "prompt": {"main_file_path": "Enigma-main/Enigma-main/Affine.java", "main_file_content": "public class Affine { static String letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; final static String mapa = \"EKMFLGDQVZNTOWYHXUSPAIBRCJ\"; final static String mapb = \"AJDKSIRUXBLHWTMCQGZNPYFVOE\"; final static String mapc = \"BDFHJLCPRTXVZNYEIWGAKMUSQO\"; final static String mapd = \"ESOVPZJAYQUIRHXLNFTGKDCMWB\"; final static String mape = \"VZBRGITYUPSDNHLXAWMJQOFECK\"; public static String encrypt(String in, String map) { String out = \"\"; for(int i = 0; i < in.length(); i++) { if(in.charAt(i) == ' ') { out += \" \"; } else { if(in.charAt(i) < 65 || in.charAt(i) > 90) { return \"Invalid input; message must only contain letters. Type and enter 'help' for help menu.\"; } out += (map.charAt(letters.indexOf(in.charAt(i)))); } } return out.substring(0, out.length()); } public static String decrypt(String in, String map) { String out = \"\"; for(int i = 0; i < in.length(); i++) { if(in.charAt(i) == ' ') { out += \" \"; } else { if(in.charAt(i) < 65 || in.charAt(i) > 90) { return \"Invalid input; message must only contain letters. Type and enter 'help' for help menu.\"; } out += (letters.charAt(map.indexOf(in.charAt(i)))); } } return out.substring(0, out.length()); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Enigma-main/Enigma-main/Affine.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "The Affine class is not open for extension. Adding new encryption/decryption behaviors requires modifying its static methods instead of extending through abstractions."}, {"principle": "Single Responsibility", "justification": "The Affine class handles encryption, decryption, input validation, and stores multiple mapping configurations, indicating multiple responsibilities."}]}]}
{"project_id": 42, "chunk_id": 0, "prompt": {"main_file_path": "Enigma-main/Enigma-main/Enigma.java", "main_file_content": "import java.util.*; public class Enigma { public static void main(String[]args){ Scanner scan = new Scanner(System.in); boolean quit = false; String in = \"\"; soutl(\"\") while(!quit){ in = scan.nextLine(); quit = processComand(in.toUpperCase()); } soutl(\"\") } public static boolean processComand(String in) { Rotor[] rotors = new Rotor[3]; String temp = \"\"; String encrypted = \"\"; if(in.equalsIgnoreCase(\"quit\")) { return true; } if(!in.contains(\" \")) { return false; } String[] split = in.toUpperCase().split(\" \"); if((Rotor.romanNumerals[0].equals(split[0]) || Rotor.romanNumerals[1].equals(split[0]) || Rotor.romanNumerals[2].equals(split[0]) || Rotor.romanNumerals[3].equals(split[0]) || Rotor.romanNumerals[4].equals(split[0])) && split.length > 16) { soutl(\"\") } else{ if(split[0].length() < 2) { return false; } if(split[0].substring(0,2).equalsIgnoreCase(\">C\")) { soutl(\"\") } else if (split[0].substring(0,2).equalsIgnoreCase(\"<C\")) { soutl(\"\") } if(split[0].substring(0,2).equalsIgnoreCase(\">A\")) { soutl(\"\") } else if (split[0].substring(0,2).equalsIgnoreCase(\"<A\")) { soutl(\"\") } else if(split[0].substring(0,2).equalsIgnoreCase(\">R\")) { soutl(\"\") } else if (split[0].substring(0,2).equalsIgnoreCase(\"<R\")) { soutl(\"\") } else if(split[0].equalsIgnoreCase(\"decrypt\") && split.length == 3) { Decryptor bombe = new Decryptor(split[1], split[2]); bombe.decrypt(); } } return false; } public static String enigma(String[] split) { Rotor[] rotors = new Rotor[3]; String temp = \"\"; String encrypted = \"\"; rotors[0] = new Rotor(split[2], split[5]); rotors[1] = new Rotor(split[1], split[4]); rotors[2] = new Rotor(split[0], split[3]); for(int i = 16; i < split.length; i++) { for(int j = 0; j < split[i].length(); j++) { for(int k = 6; k < 16; k++) { if(split[k].contains(split[i].substring(j, j+1))) { split[i] = split[i].substring(0,j) + split[k].charAt(1-split[k].indexOf(split[i].charAt(j))) + split[i].substring(j+1); k = 16; } } if(rotors[1].atNotch()) { rotors[1].shift(); rotors[2].shift(); } if(rotors[0].shift()) { if(rotors[1].shift()) { rotors[2].shift(); } } temp = Caesar.encrypt((\">C\" + rotors[0].getShift() + \" \" + split[i].substring(j, j+1)).split(\" \")); temp = Affine.encrypt(temp, rotors[0].getMap()); temp = Caesar.decrypt((\"<C\" + rotors[0].getShift() + \" \" + temp).split(\" \")); temp = Caesar.encrypt((\">C\" + rotors[1].getShift() + \" \" + temp).split(\" \")); temp = Affine.encrypt(temp, rotors[1].getMap()); temp = Caesar.decrypt((\"<C\" + rotors[1].getShift() + \" \" + temp).split(\" \")); temp = Caesar.encrypt((\">C\" + rotors[2].getShift() + \" \" + temp).split(\" \")); temp = Affine.encrypt(temp, rotors[2].getMap()); temp = Caesar.decrypt((\"<C\" + rotors[2].getShift() + \" \" + temp).split(\" \")); temp = Affine.encrypt(temp, Rotor.reflector); temp = Caesar.encrypt((\">C\" + rotors[2].getShift() + \" \" + temp).split(\" \")); temp = Affine.decrypt(temp, rotors[2].getMap()); temp = Caesar.decrypt((\"<C\" + rotors[2].getShift() + \" \" + temp).split(\" \")); temp = Caesar.encrypt((\">C\" + rotors[1].getShift() + \" \" + temp).split(\" \")); temp = Affine.decrypt(temp, rotors[1].getMap()); temp = Caesar.decrypt((\"<C\" + rotors[1].getShift() + \" \" + temp).split(\" \")); temp = Caesar.encrypt((\">C\" + rotors[0].getShift() + \" \" + temp).split(\" \")); temp = Affine.decrypt(temp, rotors[0].getMap()); temp = Caesar.decrypt((\"<C\" + rotors[0].getShift() + \" \" + temp).split(\" \")); for(int k = 6; k < 16; k++) { if(split[k].contains(\"\" + temp.charAt(0))) { temp = \"\" + split[k].charAt(1-split[k].indexOf(temp.charAt(0))); k = 16; } } encrypted += temp.charAt(0); } } return encrypted; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Enigma-main/Enigma-main/Enigma.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Enigma class handles multiple responsibilities: command processing (processComand), encryption/decryption logic (enigma), and user input/output. This creates multiple reasons for the class to change."}, {"principle": "Open-Closed", "justification": "The processComand method uses explicit string comparisons and conditional branching to handle commands. Adding new command types would require modifying existing code rather than extending through abstractions."}, {"principle": "Dependency Inversion", "justification": "High-level encryption logic in enigma directly instantiates low-level components like Rotor and depends on concrete Affine/Caesar classes. No abstractions are used to decouple dependencies."}]}]}
{"project_id": 44, "chunk_id": 0, "prompt": {"main_file_path": "Email-Admin-master/src/com/neelp/EmailApp.java", "main_file_content": "package com.neelp; import javax.swing.*; public class EmailApp { public static boolean isNumeric(String str) { try { Double.parseDouble(str); return true; } catch(NumberFormatException e){ return false; } } public static void addInfo(Employees employees, int numEmployees) { for(int i = 0; i < numEmployees; i++){ String firstName = JOptionPane.showInputDialog( null, \"Enter first name: \", \"Email Administration Application\", JOptionPane.NO_OPTION ); String lastName = JOptionPane.showInputDialog( null, \"Enter last name: \", \"Email Administration Application\", JOptionPane.NO_OPTION ); employees.add(new Email(firstName, lastName)); employees.get(i).setAltEmail(\"example@example.com\"); if(i<numEmployees-1) JOptionPane.showMessageDialog( null, \" Add the next employee\", \"Email Administration Application\", JOptionPane.NO_OPTION ); } } public static void main(String[] args) { Employees employees = new Employees(); int numEmployees = 0; try { numEmployees = Integer.parseInt( JOptionPane.showInputDialog( null, \"How many employees would you like to add?\", \"Email Administration Application\", JOptionPane.OK_CANCEL_OPTION ) ); } catch(Exception e) { String s = JOptionPane.showInputDialog( null, \"Please enter a valid number\\nDor type cancel to abort operation\", \"Email Administration Application\", JOptionPane.INFORMATION_MESSAGE ); if(isNumeric(s)) { numEmployees = Integer.parseInt(s); } else { System.exit(0); } } addInfo(employees, numEmployees); employees.getEmpArr(); System.exit(0); } }", "dependencies": [{"file_path": "Email-Admin-master/src/com/neelp/Employees.java", "file_content": "package com.neelp; import javax.swing.*; import java.util.ArrayList; public class Employees extends ArrayList<Email>{ public Employees() { super(); JOptionPane.showMessageDialog(null, startUp(), \"Email Administration Application\", JOptionPane.INFORMATION_MESSAGE ); } public boolean add(Email e) { return super.add(e); } public void getEmpArr(){ for(Email i : this){ JOptionPane.showMessageDialog(null,i.display()); } } public String startUp() { return \"EMAIL ADMINISTRATION SOFTWARE \" + \"\\n\\n\" + \" starting...\"; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Email-Admin-master/src/com/neelp/EmailApp.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "EmailApp handles user input, input validation, employee addition logic, and application flow, violating SRP by managing multiple responsibilities."}, {"principle": "Dependency Inversion", "justification": "EmailApp directly depends on concrete classes Employees and Email instead of abstractions, making high-level modules reliant on low-level implementations."}]}, {"file_path": "Email-Admin-master/src/com/neelp/Employees.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Employees combines data storage (ArrayList<Email>) with UI logic (JOptionPane dialogs), violating SRP by mixing two distinct responsibilities."}, {"principle": "Open-Closed", "justification": "Employees is not extensible for new behaviors (e.g., alternative storage or UI) without modifying its existing code, violating OCP."}]}]}
{"project_id": 44, "chunk_id": 0, "prompt": {"main_file_path": "Email-Admin-master/src/com/neelp/Email.java", "main_file_content": "package com.neelp; import javax.swing.*; public class Email { private final String firstName; private final String lastName; private final String department; private final String email; private String password; private String alternateEmail; public Email(String firstName, String lastName) { this.firstName = firstName; this.lastName = lastName; JOptionPane.showMessageDialog(null,\"Name : \" + firstName + \" \" + lastName); this.department = setDepartment(); JOptionPane.showMessageDialog(null, \"Department: \" + this.department); String company = \"company.com\"; if(department.equals(\"\")){ email = firstName.toLowerCase() + \".\" + lastName.toLowerCase() + \"@\" + \"\" + company; } else { email = firstName.toLowerCase() + \".\" + lastName.toLowerCase() + \"@\" + this.department.toLowerCase() + \"-\" + company; } } private String setDepartment(){ int depChoice = Integer.parseInt( JOptionPane.showInputDialog( null, \"Department:\\n1:\\tSales \\n2:\\tDevelopment\\n3:\\tAccounting\\n0:\\tNone of the above\\n \" , \"Email Administration Application\", JOptionPane.QUESTION_MESSAGE ) ); switch(depChoice){ case 1: return \"Sales\"; case 2: return \"Development\"; case 3: return \"Accounting\"; default: return \"\"; } } private String genPassword(int len){ String letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghisjklmnopqrtsuvwxyz!@#$%&.\"; char[] pass = new char[len]; for(int i = 0; i < pass.length; i++){ int random = (int)(Math.random()*(letters.length())); pass[i] = letters.charAt(random); } return new String(pass); } public void setAltEmail(String newEmail){ this.alternateEmail = newEmail; } public String display(){ int mailboxCapacity = 750; return \"Name: \" + firstName + \" \" + lastName + \"\\nDepartment: \" + department + \"\\nCompany email: \" + email + \"\\nPassword : \" + genPassword(12) + \"\\nMailbox capacity: \" + mailboxCapacity + \" gb\" + \"\\nAlternate email: \" + alternateEmail; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Email-Admin-master/src/com/neelp/Email.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Email class handles multiple responsibilities: user input handling via JOptionPane, department selection, email generation, password generation, and data display. Changes to any of these would require modifying the class."}, {"principle": "Open-Closed", "justification": "Adding new departments requires modifying the switch statement in setDepartment(). The class cannot be extended for new department types without altering existing code."}, {"principle": "Dependency Inversion", "justification": "High-level Email class directly depends on concrete JOptionPane for UI interactions and handles password generation internally instead of depending on abstractions."}]}]}
{"project_id": 44, "chunk_id": 0, "prompt": {"main_file_path": "Email-Admin-master/src/com/neelp/Employees.java", "main_file_content": "package com.neelp; import javax.swing.*; import java.util.ArrayList; public class Employees extends ArrayList<Email>{ public Employees() { super(); JOptionPane.showMessageDialog(null, startUp(), \"Email Administration Application\", JOptionPane.INFORMATION_MESSAGE ); } public boolean add(Email e) { return super.add(e); } public void getEmpArr(){ for(Email i : this){ JOptionPane.showMessageDialog(null,i.display()); } } public String startUp() { return \"EMAIL ADMINISTRATION SOFTWARE \" + \"\\n\\n\" + \" starting...\"; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Email-Admin-master/src/com/neelp/Employees.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Employees class manages email storage and handles GUI dialogs, combining data management and UI responsibilities."}, {"principle": "Liskov", "justification": "Subclassing ArrayList while adding GUI behavior in the constructor breaks base class expectations, making substitution unsafe."}]}]}
{"project_id": 44, "chunk_id": 0, "prompt": {"main_file_path": "Email-Admin-master/src/com/neelp/writer.java", "main_file_content": "package com.neelp; public class writer { }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 46, "chunk_id": 0, "prompt": {"main_file_path": "WhisperTimeSync-main/WhisperTimeSync-main/src/com/cubAIx/WhisperTimeSync/TokenizedSent.java", "main_file_content": "package com.cubAIx.WhisperTimeSync; import java.util.Vector; public class TokenizedSent { public String text = null; public Vector<Token> tokens = new Vector<Token>(); public TokenizedSent(String aTxt) { text = aTxt; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "WhisperTimeSync-main/WhisperTimeSync-main/src/com/cubAIx/WhisperTimeSync/TokenizedSent.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "TokenizedSent manages both the original text and its tokenization, indicating two responsibilities: data storage and token processing."}]}]}
{"project_id": 46, "chunk_id": 0, "prompt": {"main_file_path": "WhisperTimeSync-main/WhisperTimeSync-main/src/com/cubAIx/WhisperTimeSync/Pair.java", "main_file_content": "package com.cubAIx.WhisperTimeSync; public class Pair { public Token t1 = null; public Token t2 = null; }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "WhisperTimeSync-main/WhisperTimeSync-main/src/com/cubAIx/WhisperTimeSync/Pair.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "Pair directly depends on concrete Token class. High-level modules should depend on abstractions, not concrete implementations."}]}]}
{"project_id": 46, "chunk_id": 0, "prompt": {"main_file_path": "WhisperTimeSync-main/WhisperTimeSync-main/src/com/cubAIx/WhisperTimeSync/TokenizerSimple.java", "main_file_content": "package com.cubAIx.WhisperTimeSync; import java.util.StringTokenizer; import java.util.Vector; import java.util.regex.Matcher; import java.util.regex.Pattern; public class TokenizerSimple { static final String PUNCT_ONLY_STRING_RE = \"[\\r\\n\\t , \u200b\u060c\u061f;:.!?\u00a1\u00bf\u3002\uff1a\uff1f\uff01\uff1b\u061f!\u061b\u060c.\u0640()\\\\[\\\\]{}<>\\\"'\u2018\u2019`\u00b4\u00ab\u00bb\u2039\u203a\u201e\u201c\u201d*/+=|\\\\\u2012\u2013\u2014\u2015\u2011\u20ac$\u00a3\u00a7%#@&\u00b0\u3002\uff1a\uff1f\uff01\uff1b\uff0c\u3001\uff08\uff09-]+\"; public TokenizedSent tokenizeXmlSimple(String aTxt) throws Exception { return tokenizeXmlSimple(aTxt, PUNCT_ONLY_STRING_RE); } public TokenizedSent tokenizeXmlSimple(String aTxt,String aSeparatorChars) throws Exception { TokenizedSent aTS = new TokenizedSent(aTxt); Pattern aPatten = Pattern.compile(\"<[^>]*>\"); Matcher aMatcher = aPatten.matcher(aTS.text); Vector<String> aParts = new Vector<String>(); int aPos = 0; while(aMatcher.find()) { if(aMatcher.start() > aPos) { aParts.add(aTS.text.substring(aPos, aMatcher.start())); aPos = aMatcher.start(); } aParts.add(transcodeFromEntities(aTS.text.substring(aMatcher.start(),aMatcher.end()))); aPos = aMatcher.end(); } if(aPos < aTS.text.length()) { aParts.add(transcodeFromEntities(aTS.text.substring(aPos))); } int aTokPos = 0; String aSubTok = \"\"; aPos = 0; for(String aP : aParts) { if(aP.startsWith(\"<\")) { Token aT = new Token(); aT.token = aP; aT.kind = Token.NSTOKEN_KIND.MARK; aT.charPos = aPos; aT.tokPos = aTokPos; aTS.tokens.add(aT); aPos += aT.token.length(); aTokPos++; continue; } if(aSeparatorChars == null) { for(char aC : aP.toCharArray()) { String aTok = \"\"+aC; if(aTok.matches(PUNCT_ONLY_STRING_RE)) { Token aT = new Token(); aT.token = aTok; aT.kind = Token.NSTOKEN_KIND.PUNCT; aT.charPos = aPos; aT.tokPos = aTokPos; aTS.tokens.add(aT); aPos += aT.token.length(); aTokPos++; continue; } else { Token aT = new Token(); aT.token = aTok; aT.kind = Token.NSTOKEN_KIND.WORD; aT.charPos = aPos; aT.tokPos = aTokPos; aTS.tokens.add(aT); aPos += aT.token.length(); aTokPos++; continue; } } } else{ StringTokenizer aTokenizer = new StringTokenizer(aP,aSeparatorChars,true); while(aTokenizer.hasMoreTokens()) { String aTok = (String)aTokenizer.nextElement(); if(aTok.matches(PUNCT_ONLY_STRING_RE)) { Token aT = new Token(); aT.token = aTok; aT.kind = Token.NSTOKEN_KIND.PUNCT; aT.charPos = aPos; aT.tokPos = aTokPos; aTS.tokens.add(aT); aPos += aT.token.length(); aTokPos++; continue; } else { Token aT = new Token(); aT.token = aTok; aT.kind = Token.NSTOKEN_KIND.WORD; aT.charPos = aPos; aT.tokPos = aTokPos; aTS.tokens.add(aT); aPos += aT.token.length(); aTokPos++; continue; } } } } return aTS; } public static String transcodeFromHTMLSafe(String aStrIn) { return aStrIn.replaceAll(\"&lt;\",\"<\").replaceAll(\"&gt;\",\">\").replaceAll(\"&amp;\",\"&\"); } public static String transcodeFromEntities(String aStrIn) { String aStrOut = transcodeFromHTMLSafe(aStrIn); String aEntity; char aChar; int aPos = 0,aPosStart; while(aPos < aStrOut.length() && (aPos = aStrOut.indexOf(\"&\",aPos)) >= 0){ aPosStart = aPos; aPos++; if(aPos >= aStrOut.length() || aStrOut.charAt(aPos) != '#'){ continue; } aPos++; while(aPos < aStrOut.length() && (\"\" + aStrOut.charAt(aPos)).matches(\"[0-9]\")){ aPos++; } if(aPos >= aStrOut.length() || aStrOut.charAt(aPos) != ';'){ continue; } aPos++; aEntity = aStrOut.substring(aPosStart,aPos); aChar = (char) (Integer.parseInt(aEntity.substring(2, aEntity.length() - 1)) & 0xFFFF); aStrOut = aStrOut.replaceAll(aEntity,\"\" + aChar); aPos = aPosStart + 1; } return aStrOut; } public static void main(String[] args) { try { } catch (Exception e) { e.printStackTrace(System.err); } } }", "dependencies": [{"file_path": "WhisperTimeSync-main/WhisperTimeSync-main/src/com/cubAIx/WhisperTimeSync/TokenizedSent.java", "file_content": "package com.cubAIx.WhisperTimeSync; import java.util.Vector; public class TokenizedSent { public String text = null; public Vector<Token> tokens = new Vector<Token>(); public TokenizedSent(String aTxt) { text = aTxt; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "WhisperTimeSync-main/WhisperTimeSync-main/src/com/cubAIx/WhisperTimeSync/TokenizerSimple.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "TokenizerSimple handles tokenization, HTML/entity transcoding, and XML parsing. These are multiple responsibilities within one class."}, {"principle": "Open-Closed", "justification": "TokenizerSimple cannot be extended for new tokenization rules without modifying its code, as it lacks abstractions for variation points."}, {"principle": "Dependency Inversion", "justification": "TokenizerSimple directly instantiates TokenizedSent (a concrete low-level class) instead of depending on an abstraction."}]}]}
{"project_id": 46, "chunk_id": 0, "prompt": {"main_file_path": "WhisperTimeSync-main/WhisperTimeSync-main/src/com/cubAIx/WhisperTimeSync/CubaixAlignerSimple.java", "main_file_content": "package com.cubAIx.WhisperTimeSync; import java.util.Vector; public class CubaixAlignerSimple { static final boolean _DEBUG = false; static double COST_INCREDIBLE = 1000000; boolean ignoreCase = false; double compressPosFactor = 1.0/100000.0; public CubaixAlignerSimple(boolean aIgnoreCase) { ignoreCase = aIgnoreCase; } public TokenizedSent syncMarks1to2(TokenizedSent aTS1,TokenizedSent aTS2) throws Exception { Vector<Pair> aP12s = align(aTS1, aTS2); TokenizedSent aFused = new TokenizedSent(null); if(_DEBUG) { soutl(\"\") } for(int p = 0;p < aP12s.size();p++) { Pair aP12 = aP12s.elementAt(p); if(_DEBUG) { soutl(\"\") } if(aP12.t1 != null && aP12.t1.kind == Token.NSTOKEN_KIND.MARK) { aFused.tokens.add(aP12.t1); } if(aP12.t2 != null && aP12.t2.kind != Token.NSTOKEN_KIND.MARK) { aFused.tokens.add(aP12.t2); } } return aFused; } public Vector<Pair> align(TokenizedSent aTS1,TokenizedSent aTS2) throws Exception { int[][] aChoices = new int[aTS1.tokens.size()+1][aTS2.tokens.size()+1]; double[][] aCosts = new double[aTS1.tokens.size()+1][aTS2.tokens.size()+1]; aChoices[0][0] = 0; aCosts[0][0] = 0; for(int x = 1;x<aTS1.tokens.size()+1;x++) { aChoices[x][0] = 1; aCosts[x][0] = aCosts[x-1][0]+cost(aTS1.tokens.elementAt(x-1)); } for(int y = 1;y<aTS2.tokens.size()+1;y++) { aChoices[0][y] = 2; aCosts[0][y] = aCosts[0][y-1]+cost(aTS2.tokens.elementAt(y-1)); } for(int x = 1;x<aTS1.tokens.size()+1;x++) { for(int y = 1;y<aTS2.tokens.size()+1;y++) { double aCost = cost(aTS1.tokens.elementAt(x-1),aTS2.tokens.elementAt(y-1)); double aCost0 = aCosts[x-1][y-1]+aCost*0.99; double aCost1 = aCosts[x-1][y]+cost(aTS1.tokens.elementAt(x-1)); double aCost2 = aCosts[x][y-1]+cost(aTS2.tokens.elementAt(y-1)); if(aCost0 <= aCost1 && aCost0 <= aCost2) { aChoices[x][y] = 0; aCosts[x][y] = aCost0; } else if(aCost1 < aCost2) { aChoices[x][y] = 1; aCosts[x][y] = aCost1; } else { aChoices[x][y] = 2; aCosts[x][y] = aCost2; } } } int x = aTS1.tokens.size(); int y = aTS2.tokens.size(); Vector<Pair> aPs = new Vector<Pair>(); while(x > 0 || y > 0) { Pair aP = new Pair(); if(aChoices[x][y] == 0) { aP.t1 = aTS1.tokens.elementAt(--x); aP.t2 = aTS2.tokens.elementAt(--y); } else if(aChoices[x][y] == 1) { aP.t1 = aTS1.tokens.elementAt(--x); } else { aP.t2 = aTS2.tokens.elementAt(--y); } aPs.add(aP); } Vector<Pair> aPOs = new Vector<Pair>(); for(int p = aPs.size()-1;p >= 0;p--) { aPOs.add(aPs.elementAt(p)); } return aPOs; } double cost(Token aT1,Token aT2) { if(aT1.kind != aT2.kind) { return COST_INCREDIBLE; } if(aT1.token.equals(aT2.token) || (ignoreCase && aT1.token.equalsIgnoreCase(aT2.token))) { return 0 +(aT1.tokPos+aT2.tokPos)*compressPosFactor; } if(aT1.token.equalsIgnoreCase(aT2.token)) { return 0.01 +(aT1.tokPos+aT2.tokPos)*compressPosFactor; } if(aT1.token.trim().equalsIgnoreCase(aT2.token.trim())) { return 0.02 +(aT1.tokPos+aT2.tokPos)*compressPosFactor; } String aT1LC = aT1.tokenLC(); String aT2LC = aT2.tokenLC(); if(aT1LC.startsWith(aT2LC) || aT1LC.endsWith(aT2.token.toLowerCase()) || aT2LC.startsWith(aT1LC) || aT2LC.endsWith(aT1LC) || (aT1LC.length() > 2 && aT2LC.length() > 2 && (aT1LC.indexOf(aT2LC) >= 0 || aT2LC.indexOf(aT1LC) >= 0))) { return 1.0 - 2.0*Math.min(aT1.token.length(),aT2.token.length())/(double)(aT1.token.length()+aT2.token.length()) +(aT1.tokPos+aT2.tokPos)*compressPosFactor; } return 2.0 - 2.0*Math.min(aT1.token.length(),aT2.token.length())/(double)(aT1.token.length()+aT2.token.length()) +(aT1.tokPos+aT2.tokPos)*compressPosFactor; } double cost(Token aT) { if(aT.token.trim().length() == 0) { return 0.1; } return 1.0; } }", "dependencies": [{"file_path": "WhisperTimeSync-main/WhisperTimeSync-main/src/com/cubAIx/WhisperTimeSync/TokenizedSent.java", "file_content": "package com.cubAIx.WhisperTimeSync; import java.util.Vector; public class TokenizedSent { public String text = null; public Vector<Token> tokens = new Vector<Token>(); public TokenizedSent(String aTxt) { text = aTxt; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "WhisperTimeSync-main/WhisperTimeSync-main/src/com/cubAIx/WhisperTimeSync/CubaixAlignerSimple.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "CubaixAlignerSimple manages alignment logic, cost calculations, and token synchronization. These multiple responsibilities indicate a violation of SRP."}, {"principle": "Open-Closed", "justification": "The class cannot be extended to modify alignment or cost-calculation behavior without directly altering its code, violating OCP."}, {"principle": "Dependency Inversion", "justification": "CubaixAlignerSimple directly depends on concrete classes TokenizedSent and Token instead of abstractions, violating DIP for high-level modules."}]}]}
{"project_id": 46, "chunk_id": 0, "prompt": {"main_file_path": "WhisperTimeSync-main/WhisperTimeSync-main/src/com/cubAIx/WhisperTimeSync/Token.java", "main_file_content": "package com.cubAIx.WhisperTimeSync; public class Token { public enum NSTOKEN_KIND {UNDEF,MARK,WORD,PUNCT}; public NSTOKEN_KIND kind = NSTOKEN_KIND.UNDEF; public String token = null; private String tokenLC = null; public int charPos = -1; public int tokPos = -1; public final String tokenLC() { if(tokenLC != null) { return tokenLC; } return tokenLC = token.toLowerCase(); } public String getAttr(String aAttr) { if(kind != NSTOKEN_KIND.MARK) { return null; } int aBeg = token.indexOf(aAttr+\"='\"); if(aBeg < 0) { return null; } aBeg += aAttr.length()+2; int aEnd = token.indexOf(\"'\",aBeg); if(aEnd < 0) { return null; } return token.substring(aBeg,aEnd); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "WhisperTimeSync-main/WhisperTimeSync-main/src/com/cubAIx/WhisperTimeSync/Token.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Token class handles both data storage (token, kind, positions) and attribute parsing logic (getAttr method), indicating multiple responsibilities. Changing how attributes are parsed or how token data is stored would require modifying the same class."}]}]}
{"project_id": 46, "chunk_id": 0, "prompt": {"main_file_path": "WhisperTimeSync-main/WhisperTimeSync-main/src/com/cubAIx/WhisperTimeSync/WhisperTimeSync.java", "main_file_content": "package com.cubAIx.WhisperTimeSync; import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.InputStreamReader; import java.io.OutputStreamWriter; public class WhisperTimeSync { static final boolean _DEBUG_INOUT = false; static final boolean _DEBUG_ALIGN = false; public WhisperTimeSync() { } String load(String aPath) throws Exception { StringBuffer aSB = new StringBuffer(); BufferedReader aBR = new BufferedReader( new InputStreamReader(new FileInputStream(aPath) ,\"UTF8\")); String aLine = null; while((aLine = aBR.readLine()) != null) { if(aSB.length() > 0) { aSB.append(\"\\n\"); } aSB.append(aLine); } aBR.close(); return aSB.toString(); } String toXml(String aSrt) { return (\"\\n\"+aSrt.replaceAll(\"\\r*\\n\", \"\\n\")) .replaceAll(\"<\", \"&lt;\").replaceAll(\">\", \"&gt;\") .replaceAll(\"\\n([0-9]+)\\n([0-9]+:[0-9]+:[0-9]+[,.][0-9]+ --&gt; [0-9]+:[0-9]+:[0-9]+[,.][0-9]+)\\n\" , \"<time id='$1' stamp='$2'/>\") .replaceAll(\"\\n([0-9]+:[0-9]+:[0-9]+[,.][0-9]+ --&gt; [0-9]+:[0-9]+:[0-9]+[,.][0-9]+)\\n\" , \"<time id='' stamp='$1'/>\") .replaceAll(\"[ ]+\", \" \") .replaceAll(\"[\\n]+\", \"\\n\"); } public void processFile(String aPathSRT,String aPathTxt,String aLng) throws Exception { String aSrt = load(aPathSRT); String aTxt = load(aPathTxt); String aOut = processString(aSrt,aTxt,aLng); soutl(\"\") BufferedWriter aBW = new BufferedWriter( new OutputStreamWriter(new FileOutputStream(aPathTxt+\".srt\") ,\"UTF8\")); aBW.write(aOut); aBW.flush(); aBW.close(); } public String processString(String aSRT,String aTxt,String aLng) throws Exception { if(_DEBUG_INOUT) { soutl(\"\") soutl(\"\") } String aSrtXml = toXml(aSRT); String aTxtXml = toXml(aTxt); if(_DEBUG_INOUT) { soutl(\"\") soutl(\"\") } String aCutOnRE = aLng.matches(\"(ja|zh|ko)\")?null:\"[ \\n]\"; TokenizerSimple aTokenizer = new TokenizerSimple(); TokenizedSent aSrtTS = aTokenizer.tokenizeXmlSimple(aSrtXml,aCutOnRE); TokenizedSent aTxtTS = aTokenizer.tokenizeXmlSimple(aTxtXml,aCutOnRE); CubaixAlignerSimple aAligner = new CubaixAlignerSimple( true ); TokenizedSent aSyncTS = aAligner.syncMarks1to2(aSrtTS, aTxtTS); StringBuffer aOut = new StringBuffer(); StringBuffer aWaiting = new StringBuffer(); for(Token aT : aSyncTS.tokens) { if(aT.kind == Token.NSTOKEN_KIND.MARK) { String aId = aT.getAttr(\"id\"); String aStamp = aT.getAttr(\"stamp\"); if(aWaiting.length() > 0) { String aPhrase = aWaiting.toString() .replaceAll(\"&lt;\", \"<\") .replaceAll(\"&gt;\", \">\") .trim()+\"\\n\\n\"; aOut.append(aPhrase); if(_DEBUG_ALIGN) { sout(\"\") } aWaiting = new StringBuffer(); } aOut.append(aId+\"\\n\"+aStamp+\"\\n\"); if(_DEBUG_ALIGN) { sout(\"\") } continue; } aWaiting.append(aT.token); } if(aWaiting.length() > 0) { String aPhrase = aWaiting.toString() .replaceAll(\"&lt;\", \"<\") .replaceAll(\"&gt;\", \">\") .trim()+\"\\n\\n\"; aOut.append(aPhrase); if(_DEBUG_ALIGN) { sout(\"\") } } return aOut.toString(); } public static void main(String[] args) { try { new WhisperTimeSync().processFile(args[0], args[1], args[2]); } catch (Exception e) { e.printStackTrace(System.err); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "WhisperTimeSync-main/WhisperTimeSync-main/src/com/cubAIx/WhisperTimeSync/WhisperTimeSync.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The WhisperTimeSync class handles multiple responsibilities: file I/O (load, processFile), XML conversion (toXml), text processing (processString), and coordination of alignment logic. This violates SRP as it has multiple reasons to change."}, {"principle": "Open-Closed", "justification": "The class directly instantiates concrete implementations like TokenizerSimple and CubaixAlignerSimple. Modifying alignment/tokenization behavior requires altering existing code rather than extending via abstractions, violating OCP."}, {"principle": "Dependency Inversion", "justification": "High-level processString method depends directly on low-level modules (TokenizerSimple, CubaixAlignerSimple) instead of abstractions. This creates tight coupling, violating DIP as policy logic depends on implementation details."}]}]}
{"project_id": 47, "chunk_id": 0, "prompt": {"main_file_path": "Railway-Management-main/Railway-Management-main/Main.java", "main_file_content": "import javax.swing.*; import java.awt.*; import java.io.FileWriter; import java.io.IOException; import java.util.*; import java.util.List; class Station { String name; List<Track> tracks = new ArrayList<>(); Station(String name) { this.name = name; } } class Track { Station from; Station to; int distance; Track(Station from, Station to, int distance) { this.from = from; this.to = to; this.distance = distance; } } class Train { String id; String name; Map<Station, String[]> schedule = new LinkedHashMap<>(); int delay; Train(String id, String name) { this.id = id; this.name = name; } } class Booking { Train train; String from; String to; String date; String passengerName; String gender; String seat; String paymentInfo; Booking(Train train, String from, String to, String date, String passengerName, String gender, String seat, String paymentInfo) { this.train = train; this.from = from; this.to = to; this.date = date; this.passengerName = passengerName; this.gender = gender; this.seat = seat; this.paymentInfo = paymentInfo; } } public class Main { private static Map<String, Station> stations = new HashMap<>(); private static Map<String, Train> trains = new HashMap<>(); private static List<Booking> bookings = new ArrayList<>(); private static Train selectedTrain; private static String fromStation; private static String toStation; private static String travelDate; public static void main(String[] args) { setupData(); SwingUtilities.invokeLater(Main::createWelcomePage); } private static void setupData() { Station dhaka = new Station(\"Dhaka\"); Station chittagong = new Station(\"Chittagong\"); Station sylhet = new Station(\"Sylhet\"); Station rajshahi = new Station(\"Rajshahi\"); Station khulna = new Station(\"Khulna\"); Station barisal = new Station(\"Barisal\"); Station rangpur = new Station(\"Rangpur\"); Station coxsbazar = new Station(\"Cox's Bazar\"); Station bogura = new Station(\"Bogura\"); Station comilla = new Station(\"Comilla\"); stations.put(\"Dhaka\", dhaka); stations.put(\"Chittagong\", chittagong); stations.put(\"Sylhet\", sylhet); stations.put(\"Rajshahi\", rajshahi); stations.put(\"Khulna\", khulna); stations.put(\"Barisal\", barisal); stations.put(\"Rangpur\", rangpur); stations.put(\"Cox's Bazar\", coxsbazar); stations.put(\"Bogura\", bogura); stations.put(\"Comilla\", comilla); dhaka.tracks.add(new Track(dhaka, chittagong, 245)); chittagong.tracks.add(new Track(chittagong, dhaka, 245)); dhaka.tracks.add(new Track(dhaka, sylhet, 286)); sylhet.tracks.add(new Track(sylhet, dhaka, 286)); dhaka.tracks.add(new Track(dhaka, rajshahi, 343)); rajshahi.tracks.add(new Track(rajshahi, dhaka, 343)); dhaka.tracks.add(new Track(dhaka, khulna, 335)); khulna.tracks.add(new Track(khulna, dhaka, 335)); dhaka.tracks.add(new Track(dhaka, barisal, 178)); barisal.tracks.add(new Track(barisal, dhaka, 178)); dhaka.tracks.add(new Track(dhaka, rangpur, 296)); rangpur.tracks.add(new Track(rangpur, dhaka, 296)); dhaka.tracks.add(new Track(dhaka, coxsbazar, 414)); coxsbazar.tracks.add(new Track(coxsbazar, dhaka, 414)); dhaka.tracks.add(new Track(dhaka, bogura, 247)); bogura.tracks.add(new Track(bogura, dhaka, 247)); dhaka.tracks.add(new Track(dhaka, comilla, 97)); comilla.tracks.add(new Track(comilla, dhaka, 97)); Train subornoExpress = new Train(\"111\", \"Suborno Express\"); subornoExpress.schedule.put(dhaka, new String[]{\"06:00\", \"06:15\"}); subornoExpress.schedule.put(chittagong, new String[]{\"10:30\", \"10:45\"}); trains.put(\"111\", subornoExpress); Train mohanagarExpress = new Train(\"222\", \"Mohanagar Express\"); mohanagarExpress.schedule.put(dhaka, new String[]{\"07:00\", \"07:15\"}); mohanagarExpress.schedule.put(sylhet, new String[]{\"11:30\", \"11:45\"}); trains.put(\"222\", mohanagarExpress); Train silkCityExpress = new Train(\"333\", \"Silk City Express\"); silkCityExpress.schedule.put(dhaka, new String[]{\"08:00\", \"08:15\"}); silkCityExpress.schedule.put(rajshahi, new String[]{\"12:30\", \"12:45\"}); trains.put(\"333\", silkCityExpress); Train sundarbanExpress = new Train(\"444\", \"Sundarban Express\"); sundarbanExpress.schedule.put(dhaka, new String[]{\"09:00\", \"09:15\"}); sundarbanExpress.schedule.put(khulna, new String[]{\"13:30\", \"13:45\"}); trains.put(\"444\", sundarbanExpress); Train rocketExpress = new Train(\"555\", \"Rocket Express\"); rocketExpress.schedule.put(dhaka, new String[]{\"10:00\", \"10:15\"}); rocketExpress.schedule.put(barisal, new String[]{\"14:30\", \"14:45\"}); trains.put(\"555\", rocketExpress); Train nilSagarExpress = new Train(\"666\", \"Nil Sagar Express\"); nilSagarExpress.schedule.put(dhaka, new String[]{\"11:00\", \"11:15\"}); nilSagarExpress.schedule.put(rangpur, new String[]{\"15:30\", \"15:45\"}); trains.put(\"666\", nilSagarExpress); Train beachExpress = new Train(\"777\", \"Beach Express\"); beachExpress.schedule.put(dhaka, new String[]{\"12:00\", \"12:15\"}); beachExpress.schedule.put(coxsbazar, new String[]{\"16:30\", \"16:45\"}); trains.put(\"777\", beachExpress); } private static void createWelcomePage() { JFrame welcomeFrame = new JFrame(\"Welcome Page\"); welcomeFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); welcomeFrame.setSize(470, 685); welcomeFrame.setLayout(null); JLabel welcomeMessage = new JLabel(\"Welcome To Railway Management System\", SwingConstants.CENTER); welcomeMessage.setBounds(35, 230, 400, 60); welcomeMessage.setFont(new Font(welcomeMessage.getFont().getName(), Font.BOLD, 17)); JButton enterButton = new JButton(\"Enter\"); enterButton.setBounds(175, 380, 80, 30); enterButton.addActionListener(e -> { welcomeFrame.dispose(); createLoginPage(); }); welcomeFrame.add(welcomeMessage); welcomeFrame.add(enterButton); welcomeFrame.setVisible(true); } private static void createLoginPage() { JFrame loginFrame = new JFrame(\"Login Page\"); loginFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); loginFrame.setSize(470, 685); loginFrame.setLayout(null); JLabel headerLabel = new JLabel(\"Railway Management System\", SwingConstants.CENTER); headerLabel.setBounds(35, 130, 400, 60); headerLabel.setFont(new Font(headerLabel.getFont().getName(), Font.PLAIN, 21)); JLabel userLabel = new JLabel(\"Username:\"); userLabel.setBounds(120, 262, 80, 30); JTextField userField = new JTextField(); userField.setBounds(200, 262, 200, 30); JLabel passLabel = new JLabel(\"Password:\"); passLabel.setBounds(120, 326, 80, 30); JPasswordField passField = new JPasswordField(); passField.setBounds(200, 326, 200, 30); JLabel messageLabel = new JLabel(); messageLabel.setBounds(150, 400, 500, 30); JButton loginButton = new JButton(\"Login\"); loginButton.setBounds(175, 380, 80, 30); loginButton.addActionListener(e -> { String username = userField.getText(); String password = new String(passField.getPassword()); if (isValidLogin(username, password)) { loginFrame.dispose(); createSearchPage(); } else { messageLabel.setText(\"Invalid login\"); } }); loginFrame.add(headerLabel); loginFrame.add(userLabel); loginFrame.add(userField); loginFrame.add(passLabel); loginFrame.add(passField); loginFrame.add(messageLabel); loginFrame.add(loginButton); loginFrame.setVisible(true); } private static boolean isValidLogin(String username, String password) { return \"admin\".equals(username) && \"admin\".equals(password); } private static void createSearchPage() { JFrame searchFrame = new JFrame(\"Search Trains\"); searchFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); searchFrame.setSize(470, 685); searchFrame.setLayout(null); JLabel headerLabel = new JLabel(\"Search for Trains\", SwingConstants.CENTER); headerLabel.setBounds(35, 50, 400, 60); headerLabel.setFont(new Font(headerLabel.getFont().getName(), Font.PLAIN, 21)); JLabel fromLabel = new JLabel(\"From:\"); fromLabel.setBounds(60, 150, 100, 30); JTextField fromField = new JTextField(); fromField.setBounds(140, 150, 200, 30); JLabel toLabel = new JLabel(\"To:\"); toLabel.setBounds(60, 200, 100, 30); JTextField toField = new JTextField(); toField.setBounds(140, 200, 200, 30); JLabel dateLabel = new JLabel(\"Date:\"); dateLabel.setBounds(60, 250, 100, 30); JTextField dateField = new JTextField(); dateField.setBounds(140, 250, 200, 30); JButton searchButton = new JButton(\"Search\"); searchButton.setBounds(175, 300, 100, 30); searchButton.addActionListener(e -> { fromStation = fromField.getText(); toStation = toField.getText(); travelDate = dateField.getText(); searchFrame.dispose(); createTrainListPage(); }); searchFrame.add(headerLabel); searchFrame.add(fromLabel); searchFrame.add(fromField); searchFrame.add(toLabel); searchFrame.add(toField); searchFrame.add(dateLabel); searchFrame.add(dateField); searchFrame.add(searchButton); searchFrame.setVisible(true); } private static void createTrainListPage() { JFrame trainListFrame = new JFrame(\"Train List\"); trainListFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); trainListFrame.setSize(470, 685); trainListFrame.setLayout(null); JLabel trainListLabel = new JLabel(\"Available Trains\", SwingConstants.CENTER); trainListLabel.setBounds(35, 20, 400, 60); String[][] data = getTrainData(fromStation, toStation); String[] column = {\"ID\", \"Train Name\", \"Arrival\", \"Departure\"}; JTable trainListTable = new JTable(data, column); trainListTable.setBounds(30, 100, 400, 250); JScrollPane sp = new JScrollPane(trainListTable); sp.setBounds(30, 100, 400, 250); JButton bookButton = new JButton(\"Book\"); bookButton.setBounds(175, 380, 100, 30); bookButton.addActionListener(e -> { int selectedRow = trainListTable.getSelectedRow(); if (selectedRow >= 0) { String selectedTrainId = (String) trainListTable.getValueAt(selectedRow, 0); selectedTrain = trains.get(selectedTrainId); trainListFrame.dispose(); createBookingPage(); } }); JButton backButton = new JButton(\"Back\"); backButton.setBounds(175, 430, 100, 30); backButton.addActionListener(e -> { trainListFrame.dispose(); createSearchPage(); }); trainListFrame.add(trainListLabel); trainListFrame.add(sp); trainListFrame.add(bookButton); trainListFrame.add(backButton); trainListFrame.setVisible(true); } private static String[][] getTrainData(String from, String to) { List<String[]> trainData = new ArrayList<>(); for (Train train : trains.values()) { if (train.schedule.containsKey(stations.get(from)) && train.schedule.containsKey(stations.get(to))) { String[] scheduleFrom = train.schedule.get(stations.get(from)); String[] scheduleTo = train.schedule.get(stations.get(to)); trainData.add(new String[]{train.id, train.name, scheduleFrom[0], scheduleTo[1]}); soutl(\"\") } } return trainData.toArray(new String[0][0]); } private static void createBookingPage() { JFrame bookingFrame = new JFrame(\"Booking Details\"); bookingFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); bookingFrame.setSize(470, 685); bookingFrame.setLayout(null); JLabel headerLabel = new JLabel(\"Passenger Details\", SwingConstants.CENTER); headerLabel.setBounds(35, 20, 400, 60); headerLabel.setFont(new Font(headerLabel.getFont().getName(), Font.PLAIN, 21)); JLabel nameLabel = new JLabel(\"Name:\"); nameLabel.setBounds(60, 100, 100, 30); JTextField nameField = new JTextField(); nameField.setBounds(140, 100, 200, 30); JLabel seatLabel = new JLabel(\"Seat:\"); seatLabel.setBounds(60, 150, 100, 30); JTextField seatField = new JTextField(); seatField.setBounds(140, 150, 200, 30); JLabel paymentLabel = new JLabel(\"Payment Info:\"); paymentLabel.setBounds(60, 200, 100, 30); JTextField paymentField = new JTextField(); paymentField.setBounds(140, 200, 200, 30); JRadioButton maleButton = new JRadioButton (\"Male\"); JRadioButton femaleButton = new JRadioButton(\"Female\"); JLabel messageLabel = new JLabel(\"\"); messageLabel.setBounds(150, 400, 500, 30); maleButton.setBounds(60, 250, 100, 30); femaleButton.setBounds(160, 250, 100, 30); JButton confirmButton = new JButton(\"Confirm\"); confirmButton.setBounds(175, 300, 100, 30); confirmButton.addActionListener(e -> { String passengerName = nameField.getText(); String seat = seatField.getText(); String paymentInfo = paymentField.getText(); String gender = \"\"; if (maleButton.isSelected()) { gender = \"Male\"; } else if (femaleButton.isSelected()) { gender = \"Female\"; } Booking booking = new Booking(selectedTrain, fromStation, toStation, travelDate, passengerName, gender, seat, paymentInfo); bookings.add(booking); updateBookingFile(); bookingFrame.dispose(); createThankYouPage(booking); }); maleButton.addActionListener(e -> { if (maleButton.isSelected()) { femaleButton.setSelected(false); } }); femaleButton.addActionListener(e -> { if (femaleButton.isSelected()) { maleButton.setSelected(false); } }); bookingFrame.add(headerLabel); bookingFrame.add(nameLabel); bookingFrame.add(nameField); bookingFrame.add(seatLabel); bookingFrame.add(seatField); bookingFrame.add(paymentLabel); bookingFrame.add(paymentField); bookingFrame.add(confirmButton); bookingFrame.add(maleButton); bookingFrame.add(femaleButton); bookingFrame.add(messageLabel); bookingFrame.setVisible(true); } private static void updateBookingFile() { try { FileWriter writer = new FileWriter(\"bookings.txt\", true); for (Booking booking : bookings) { writer.write(booking.train.id + \",\" + booking.from + \",\" + booking.to + \",\" + booking.date + \",\" + booking.passengerName + \",\" + booking.gender + \",\" + booking.seat + \",\" + booking.paymentInfo + \"\\n\"); } writer.close(); } catch (IOException e) { e.printStackTrace(); } } private static void createThankYouPage(Booking booking) { JFrame thankYouFrame = new JFrame(\"Thank You\"); thankYouFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); thankYouFrame.setSize(470, 685); thankYouFrame.setLayout(null); JLabel messageLabel = new JLabel(\"Thank you for booking!\", SwingConstants.CENTER); messageLabel.setBounds(35, 100, 400, 60); messageLabel.setFont(new Font(messageLabel.getFont().getName(), Font.BOLD, 21)); JLabel bookingDetailsLabel = new JLabel(\"<html>Booking Details:<br>\" + \"Train: \" + booking.train.name + \"<br>\" + \"From: \" + booking.from + \"<br>\" + \"To: \" + booking.to + \"<br>\" + \"Date: \" + booking.date + \"<br>\" + \"Passenger: \" + booking.passengerName + \"<br>\" + \"Gender: \" + booking.gender + \"<br>\" + \"Seat: \" + booking.seat + \"<br>\" + \"Payment: \" + booking.paymentInfo + \"</html>\", SwingConstants.CENTER); bookingDetailsLabel.setBounds(35, 200, 400, 200); thankYouFrame.add(messageLabel); thankYouFrame.add(bookingDetailsLabel); thankYouFrame.setVisible(true); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Railway-Management-main/Railway-Management-main/Main.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Main class handles GUI creation, data initialization, business logic (bookings), and file I/O, violating SRP by managing multiple unrelated responsibilities."}, {"principle": "Open-Closed", "justification": "Adding new features (e.g., UI components, data sources) requires modifying existing methods in Main instead of extending through abstractions, violating OCP."}, {"principle": "Dependency Inversion", "justification": "High-level modules (e.g., booking logic) directly depend on low-level modules (FileWriter, Swing components) without abstractions, violating DIP."}]}]}
{"project_id": 52, "chunk_id": 0, "prompt": {"main_file_path": "cadastroDeProdutos-main/src/ProdutoController.java", "main_file_content": "import java.util.ArrayList; import java.util.List; public class ProdutoController { List<Produtos> produtos = new ArrayList<>(); public void adicionar(Produtos cp) { produtos.add(cp); } public void imprimeProdutos() { produtos.forEach((p) -> { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") }); } public void imprimeProdutos(Integer id) { produtos.forEach((p) -> { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") }); } public void imprimeProdutos(String nome) { produtos.forEach((p) -> { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") }); } public void imprimeProdutos(Double valor) { produtos.forEach((p) -> { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") }); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "cadastroDeProdutos-main/src/ProdutoController.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "ProdutoController manages product storage and handles multiple printing formats. This combines data management and presentation logic, giving it more than one responsibility."}, {"principle": "Open-Closed", "justification": "Adding a new product printing method (e.g., filtering by a new attribute) requires modifying ProdutoController by adding a new method, violating OCP's requirement to extend via new code instead of modification."}, {"principle": "Dependency Inversion", "justification": "ProdutoController directly depends on the concrete Produtos class. High-level modules should depend on abstractions (e.g., an interface), not concrete implementations."}]}]}
{"project_id": 52, "chunk_id": 0, "prompt": {"main_file_path": "cadastroDeProdutos-main/src/App.java", "main_file_content": "import java.util.Scanner; public class App { public static void main(String[] args) throws Exception { Scanner dados = new Scanner(System.in); Scanner dados1 = new Scanner(System.in); Scanner dados2 = new Scanner(System.in); Scanner dados3 = new Scanner(System.in); Scanner dados4 = new Scanner(System.in); ProdutoController produtoController = new ProdutoController(); Produtos c1 = new Produtos(); Integer id = 0; String nomeProduto = \"\"; String tipo = \"\"; Double valor = 0.0; soutl(\"\") Integer op = 0; sout(\"\") op = dados.nextInt(); while (op == 1) { switch (op) { case 1: soutl(\"\") id = dados1.nextInt(); c1.setId(id); soutl(\"\") nomeProduto = dados2.nextLine(); c1.setNomeProduto(nomeProduto); soutl(\"\") tipo = dados3.nextLine(); c1.setTipoProduto(tipo); soutl(\"\") valor = dados4.nextDouble(); c1.setValor(valor); soutl(\"\") op = dados.nextInt(); produtoController.adicionar(c1); c1 = new Produtos(); break; case 2: break; } } produtoController.imprimeProdutos(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "cadastroDeProdutos-main/src/App.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The App class handles user input, UI flow, and business logic coordination. This combines multiple responsibilities (input handling, workflow management, controller interaction) into a single class."}, {"principle": "Dependency Inversion", "justification": "App directly instantiates concrete ProdutoController and Produtos classes. High-level modules should depend on abstractions rather than concrete implementations."}]}]}
{"project_id": 52, "chunk_id": 0, "prompt": {"main_file_path": "cadastroDeProdutos-main/src/Produtos.java", "main_file_content": "public class Produtos { private Integer id; private Double valor; private String nomeProduto; private String tipo; public int getId() { return id; } public void setId(Integer id) { this.id = id; } public String getTipoProduto() { return tipo; } public void setTipoProduto(String tipo) { this.tipo = tipo; } public String getNomeProduto() { return nomeProduto; } public void setNomeProduto(String nomeProduto) { this.nomeProduto = nomeProduto; } public Double getValor() { return valor; } public void setValor(Double valor) { this.valor = valor; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "cadastroDeProdutos-main/src/Produtos.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Produtos class handles both data management (id, value) and product type categorization (tipo), indicating multiple responsibilities. Changes in product categorization logic would require modifying this class, violating SRP."}]}]}
{"project_id": 53, "chunk_id": 0, "prompt": {"main_file_path": "vehicle-rental-system-main/vehicle-rental-system-main/vehicle rental system/src/VehicleLinkedList.java", "main_file_content": "import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.util.InputMismatchException; import java.util.Scanner; public class VehicleLinkedList { Scanner sc = new Scanner(System.in); class Node { Vehicle vehicle; Node next; Node prev; Node(Vehicle v) { vehicle = v; next = null; prev = null; } } Node Head = null; boolean isLoginValid(int id, String password) { if (id == 777 && password.equals(\"update.com\")) { soutl(\"\") return true; } soutl(\"\") return false; } public Vehicle updateVehicle(int id) { Node temp = Head; while (temp != null) { if (temp.vehicle.getId() == id) { break; } temp = temp.next; } int choice = 0; while (true) { soutl(\"\") boolean validInput = false; while (!validInput) { try { sout(\"\") choice = sc.nextInt(); validInput = true; } catch (InputMismatchException e) { soutl(\"\") sc.next(); } } sc.nextLine(); switch (choice) { case 1: sout(\"\") String type = sc.nextLine(); temp.vehicle.setType(type); soutl(\"\") break; case 2: sout(\"\") String model = sc.nextLine(); temp.vehicle.setModel(model); soutl(\"\") break; case 3: sout(\"\") int year = sc.nextInt(); temp.vehicle.setYear(year); soutl(\"\") break; case 4: sout(\"\") boolean status = sc.nextBoolean(); temp.vehicle.setBooked(status); soutl(\"\") break; case 5: sout(\"\") int price = sc.nextInt(); temp.vehicle.setPrice(price); soutl(\"\") break; case 6: break; default: soutl(\"\") break; } return temp.vehicle; } } void addLast(Vehicle vehicle) { Node n = new Node(vehicle); if (Head == null) { Head = n; } else { Node temp = Head; while (temp.next != null) { temp = temp.next; } temp.next = n; n.prev = temp; } } void displayVehicle() { Node temp = Head; while (temp != null) { Vehicle v = temp.vehicle; soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") temp = temp.next; } } void deleteVehicle(int id) { Node temp = Head; while (temp != null) { if ((temp.vehicle.getId() == id)) { break; } temp = temp.next; } temp.prev.next = temp.next; temp.next.prev = temp.prev; temp.prev = null; temp.next = null; } public void refreshData() throws SQLException { Head = null; String query = \"SELECT * FROM vehicle\"; PreparedStatement pstmt = DatabaseConnector.conn.prepareStatement(query); ResultSet rs = pstmt.executeQuery(); while (rs.next()) { Vehicle v = new Vehicle( rs.getInt(\"v_id\"), rs.getString(\"type\"), rs.getString(\"model\"), rs.getInt(\"year\"), rs.getInt(\"price\"), rs.getBoolean(\"isBooked\")); addLast(v); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "vehicle-rental-system-main/vehicle-rental-system-main/vehicle rental system/src/VehicleLinkedList.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "VehicleLinkedList manages linked list operations, user authentication (isLoginValid), UI input handling (updateVehicle), and database interactions (refreshData), violating the single responsibility principle."}, {"principle": "Open-Closed", "justification": "Adding new update operations in updateVehicle requires modifying the switch statement instead of extending behavior through abstractions, violating the open/closed principle."}, {"principle": "Dependency Inversion", "justification": "High-level module VehicleLinkedList directly depends on concrete DatabaseConnector and creates Vehicle instances, instead of depending on abstractions for database access and vehicle creation."}]}]}
{"project_id": 53, "chunk_id": 0, "prompt": {"main_file_path": "vehicle-rental-system-main/vehicle-rental-system-main/vehicle rental system/src/Vehicle_db.java", "main_file_content": "import java.sql.*; public class Vehicle_db { public Vehicle_db() throws SQLException { } public boolean addVehicle(Vehicle v) { boolean f = false; try { String sql = \"insert into vehicle(v_id,type, model, year,price, isBooked) values(?,?,?,?,?,?)\"; PreparedStatement ps = DatabaseConnector.conn.prepareStatement(sql); ps.setInt(1, v.getId()); ps.setString(2, v.getType()); ps.setString(3, v.getModel()); ps.setInt(4, v.getYear()); ps.setInt(5, v.getPrice()); ps.setBoolean(6, v.isBooked()); int i = ps.executeUpdate(); if (i == 1) { f = true; } } catch (Exception e) { e.printStackTrace(); } return f; } public boolean updateVehicle(Vehicle v) { boolean f = false; try { String sql = \"update vehicle set type=?, model=?, year=?, isBooked=?, price=? where v_id=?\"; PreparedStatement ps = DatabaseConnector.conn.prepareStatement(sql); ps.setString(1, v.getType()); ps.setString(2, v.getModel()); ps.setInt(3, v.getYear()); ps.setBoolean(4, v.isBooked()); ps.setInt(5, v.getPrice()); ps.setInt(6, v.getId()); int i = ps.executeUpdate(); if (i == 1) { f = true; } } catch (Exception e) { e.printStackTrace(); } return f; } public boolean deleteVehicle(int v_id) { boolean f = false; try { String sql = \"delete from vehicle where v_id=?\"; PreparedStatement ps = DatabaseConnector.conn.prepareStatement(sql); ps.setInt(1, v_id); int i = ps.executeUpdate(); if (i == 1) { f = true; } } catch (Exception e) { e.printStackTrace(); } return f; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "vehicle-rental-system-main/vehicle-rental-system-main/vehicle rental system/src/Vehicle_db.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "Adding new database operations requires modifying Vehicle_db class instead of extending it. The class is not closed for modification when new functionality is needed."}, {"principle": "Dependency Inversion", "justification": "Vehicle_db directly depends on concrete DatabaseConnector.conn instead of an abstraction. High-level database operations depend on low-level implementation details."}]}]}
{"project_id": 53, "chunk_id": 0, "prompt": {"main_file_path": "vehicle-rental-system-main/vehicle-rental-system-main/vehicle rental system/src/Customer_db.java", "main_file_content": "import java.sql.*; public class Customer_db { public Customer_db() throws SQLException { super(); } public boolean addCustomer(Customer c) { boolean f = false; try { String sql = \"insert into customer values (?,?,?,?,?,?)\"; PreparedStatement rs = DatabaseConnector.conn.prepareStatement(sql); rs.setInt(1, c.getId()); rs.setString(2, c.getName()); rs.setString(3, c.getEmail()); rs.setString(4, c.getPhone()); rs.setString(5, c.getCity()); rs.setString(6, c.getPassword()); int i = rs.executeUpdate(); if (i == 1) { f = true; } } catch (Exception e) { e.printStackTrace(); } return f; } public boolean updateCustomer(Customer c) { boolean f = false; try { String sql = \"update customer set name=?, email=?, phone=?,password=? where c_id=?\"; PreparedStatement ps = DatabaseConnector.conn.prepareStatement(sql); ps.setString(1, c.getName()); ps.setString(2, c.getEmail()); ps.setString(3, c.getPhone()); ps.setString(4, c.getPassword()); ps.setInt(5, c.getId()); int i = ps.executeUpdate(); if (i == 1) { f = true; } } catch (Exception e) { e.printStackTrace(); } return f; } boolean deleteCustomer(int c_id) throws SQLException { String q = \"delete from Customer where c_id=\" + c_id + \";\"; PreparedStatement ps = DatabaseConnector.conn.prepareStatement(q); if (ps.executeUpdate(q) == 1) { return true; } else { return false; } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "vehicle-rental-system-main/vehicle-rental-system-main/vehicle rental system/src/Customer_db.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "Customer_db directly depends on the concrete DatabaseConnector.conn instead of an abstraction. High-level modules should depend on abstractions, not concrete implementations."}, {"principle": "Single Responsibility", "justification": "Customer_db handles SQL query construction, execution, and database connection management. These are multiple responsibilities that could change for different reasons."}]}]}
{"project_id": 53, "chunk_id": 0, "prompt": {"main_file_path": "vehicle-rental-system-main/vehicle-rental-system-main/vehicle rental system/src/Customer.java", "main_file_content": "public class Customer { private int id; private String name; private String email; private String phone; private String city; private String password; public Customer(int id, String name, String email, String phone, String city, String password) { this.id = id; this.name = name; this.email = email; this.phone = phone; this.city = city; this.password = password; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getPhone() { return phone; } public void setPhone(String phone) { this.phone = phone; } public String getCity() { return city; } public void setCity(String city) { this.city = city; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "vehicle-rental-system-main/vehicle-rental-system-main/vehicle rental system/src/Customer.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Customer class manages customer data (id, name, email, etc.) and directly handles password storage. These are two distinct responsibilities: data modeling and security/authentication logic."}]}]}
{"project_id": 53, "chunk_id": 0, "prompt": {"main_file_path": "vehicle-rental-system-main/vehicle-rental-system-main/vehicle rental system/src/Booking.java", "main_file_content": "import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.util.InputMismatchException; import java.util.Scanner; public class Booking { Scanner sc = new Scanner(System.in); Customer_manager cm; VehicleLinkedList vehicles; static int id; Booking() throws SQLException { cm = new Customer_manager(); vehicles = new VehicleLinkedList(); } public void bookVehicle() throws SQLException { soutl(\"\") boolean bv = true; while (bv) { soutl(\"\") soutl(\"\") soutl(\"\") int choice = 0; boolean validInput = false; while (!validInput) { try { sout(\"\") choice = sc.nextInt(); validInput = true; } catch (InputMismatchException e) { soutl(\"\") sc.next(); } } switch (choice) { case 1: id = cm.register(); book(); break; case 2: id = cm.login(); book(); break; case 3: bv = false; break; default: soutl(\"\") } } } void book() throws SQLException { sc.nextLine(); sout(\"\") String vehicleType = sc.nextLine().toLowerCase(); showVehicleDetailsByType(vehicleType); sout(\"\") int vehicleId = sc.nextInt(); bookVehicleById(vehicleId); } void showVehicleDetailsByType(String vehicleType) throws SQLException { String query = \"SELECT * FROM vehicle WHERE type = ?\"; PreparedStatement pstmt = DatabaseConnector.conn.prepareStatement(query); pstmt.setString(1, vehicleType); ResultSet rs = pstmt.executeQuery(); while (rs.next()) { int id = rs.getInt(\"v_id\"); String type = rs.getString(\"type\"); String model = rs.getString(\"model\"); int year = rs.getInt(\"year\"); int price = rs.getInt(\"price\"); boolean availability = rs.getBoolean(\"isBooked\"); soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") } } void bookVehicleById(int vehicleId) throws SQLException { String query = \"SELECT * FROM vehicle WHERE v_id = ? AND isBooked = false\"; PreparedStatement pstmt = DatabaseConnector.conn.prepareStatement(query); pstmt.setInt(1, vehicleId); ResultSet rs = pstmt.executeQuery(); while (rs.next()) { try { DatabaseConnector.conn.setAutoCommit(false); String updateQuery = \"UPDATE vehicle SET isBooked = true WHERE v_id = ?\"; PreparedStatement updatePstmt = DatabaseConnector.conn.prepareStatement(updateQuery); updatePstmt.setInt(1, vehicleId); updatePstmt.executeUpdate(); vehicles.refreshData(); int customerId = id; insertBookingRecord(vehicleId, customerId); DatabaseConnector.conn.commit(); soutl(\"\") } catch (SQLException e) { DatabaseConnector.conn.rollback(); soutl(\"\") } } } void insertBookingRecord(int vehicleId, int customerId) throws SQLException { sout(\"\") String bookingDate = sc.next(); String query = \"INSERT INTO booking (v_id, c_id, booking_date) VALUES (?, ?, ?)\"; PreparedStatement pstmt = DatabaseConnector.conn.prepareStatement(query); pstmt.setInt(1, vehicleId); pstmt.setInt(2, customerId); pstmt.setString(3, bookingDate); pstmt.executeUpdate(); soutl(\"\") } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "vehicle-rental-system-main/vehicle-rental-system-main/vehicle rental system/src/Booking.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Booking class handles user interaction (Scanner), database operations (PreparedStatement), business logic (booking flow), and coordination of dependencies (Customer_manager, VehicleLinkedList), violating SRP by having multiple responsibilities."}, {"principle": "Open-Closed", "justification": "The bookVehicleById and showVehicleDetailsByType methods directly implement SQL queries. Adding new vehicle types or modifying query logic would require modifying these methods instead of extending behavior through abstractions."}, {"principle": "Dependency Inversion", "justification": "Booking directly instantiates concrete Customer_manager and VehicleLinkedList dependencies in its constructor and uses DatabaseConnector.conn directly. High-level modules should depend on abstractions, not concrete implementations."}]}]}
{"project_id": 53, "chunk_id": 0, "prompt": {"main_file_path": "vehicle-rental-system-main/vehicle-rental-system-main/vehicle rental system/src/BillGenerator.java", "main_file_content": "import java.sql.CallableStatement; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.time.LocalDate; import java.time.format.DateTimeFormatter; import java.time.temporal.ChronoUnit; public class BillGenerator { public BillGenerator() { } public void generateBill(int vehicleId, int customerId) throws Exception { try { DatabaseConnector.conn.setAutoCommit(false); PreparedStatement pstmt = DatabaseConnector.conn .prepareStatement(\"INSERT INTO bills (v_id,c_id, amount) VALUES (?,?, ?)\"); pstmt.setInt(1, vehicleId); pstmt.setInt(2, customerId); pstmt.setDouble(3, calculateBillAmount(vehicleId, customerId)); pstmt.executeUpdate(); soutl(\"\") printBillDetails(vehicleId, customerId); DatabaseConnector.conn.commit(); } catch (SQLException e) { DatabaseConnector.conn.rollback(); soutl(\"\") } } public double calculateBillAmount(int vehicleId, int customerId) throws SQLException { double billAmount = 0.0; try { DatabaseConnector.conn.setAutoCommit(false); PreparedStatement pstmt = DatabaseConnector.conn .prepareStatement(\"SELECT b_id FROM booking WHERE v_id = ? and c_id = ?\"); pstmt.setInt(1, vehicleId); pstmt.setInt(2, customerId); ResultSet resultSet = pstmt.executeQuery(); if (resultSet.next()) { int bookingId = resultSet.getInt(\"b_id\"); CallableStatement cstmt = DatabaseConnector.conn.prepareCall(\"{call calculate_rental_days(?,?,?)}\"); cstmt.setInt(1, bookingId); cstmt.execute(); String b_date = cstmt.getString(2); String r_date = cstmt.getString(3); DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\"); LocalDate bDate = LocalDate.parse(b_date, formatter); LocalDate rDate = LocalDate.parse(r_date, formatter); long rentalDays = ChronoUnit.DAYS.between(bDate, rDate); pstmt = DatabaseConnector.conn.prepareStatement(\"SELECT price FROM vehicle WHERE v_id = ?\"); pstmt.setInt(1, vehicleId); ResultSet rs = pstmt.executeQuery(); if (rs.next()) { int pricePerDay = rs.getInt(\"price\"); billAmount = rentalDays * pricePerDay; } } DatabaseConnector.conn.commit(); } catch (SQLException e) { DatabaseConnector.conn.rollback(); soutl(\"\") } return billAmount; } public void printBillDetails(int vehicleId, int customerId) { try { PreparedStatement pstmt = DatabaseConnector.conn .prepareStatement(\"SELECT amount FROM bills WHERE v_id = ? and c_id = ?\"); pstmt.setInt(1, vehicleId); pstmt.setInt(2, customerId); ResultSet resultSet = pstmt.executeQuery(); if (resultSet.next()) { double billAmount = resultSet.getDouble(\"amount\"); pstmt = DatabaseConnector.conn.prepareStatement(\"SELECT name FROM customer WHERE c_id = ?\"); pstmt.setInt(1, customerId); ResultSet rs = pstmt.executeQuery(); if (rs.next()) { String customerName = rs.getString(\"name\"); pstmt = DatabaseConnector.conn .prepareStatement(\"SELECT model, type FROM vehicle WHERE v_id = ?\"); pstmt.setInt(1, vehicleId); ResultSet rs2 = pstmt.executeQuery(); if (rs2.next()) { String vehicleName = rs2.getString(\"model\"); String vehicleType = rs2.getString(\"type\"); soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") } } } } catch (SQLException e) { soutl(\"\") } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "vehicle-rental-system-main/vehicle-rental-system-main/vehicle rental system/src/BillGenerator.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "BillGenerator handles bill generation, amount calculation, and printing details. Changes in any of these responsibilities would require modifying the class."}, {"principle": "Open-Closed", "justification": "BillGenerator cannot be extended for new billing strategies without modifying its existing code (e.g., calculateBillAmount directly implements calculation logic)."}, {"principle": "Dependency Inversion", "justification": "BillGenerator directly depends on concrete DatabaseConnector instead of abstractions. High-level billing logic is coupled to low-level database implementation."}]}]}
{"project_id": 53, "chunk_id": 0, "prompt": {"main_file_path": "vehicle-rental-system-main/vehicle-rental-system-main/vehicle rental system/src/DatabaseConnector.java", "main_file_content": "import java.sql.*; public class DatabaseConnector { static Connection conn; DatabaseConnector() { try { conn = DriverManager.getConnection(\"jdbc:mysql: if (conn != null) { soutl(\"\") } else { soutl(\"\") } } catch (Exception e) { soutl(\"\") } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "vehicle-rental-system-main/vehicle-rental-system-main/vehicle rental system/src/DatabaseConnector.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The class manages both database connection creation and static instance handling, introducing multiple responsibilities. Changes to connection logic or singleton management would require modifying the same class."}]}]}
{"project_id": 53, "chunk_id": 0, "prompt": {"main_file_path": "vehicle-rental-system-main/vehicle-rental-system-main/vehicle rental system/src/Customer_manager.java", "main_file_content": "import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.util.InputMismatchException; import java.util.Scanner; import java.util.regex.Matcher; import java.util.regex.Pattern; public class Customer_manager { Scanner scanner = new Scanner(System.in); static CustomerLinkedList customers; static Customer_db c_data; static int id = 0; public Customer_manager() throws SQLException { customers = new CustomerLinkedList(); c_data = new Customer_db(); } boolean copyData() throws Exception { boolean f = true; try { String q = \"select * from customer;\"; PreparedStatement ps = DatabaseConnector.conn.prepareStatement(q); ResultSet rs = ps.executeQuery(); while (rs.next()) { id = rs.getInt(1); Customer temp = new Customer(rs.getInt(1), rs.getString(2), rs.getString(3), rs.getString(4), rs.getString(5), rs.getString(6)); customers.addLast(temp); } } catch (Exception e) { f = false; } return f; } public int register() throws SQLException { id++; scanner.nextLine(); sout(\"\") String name = scanner.nextLine(); sout(\"\") String email = scanner.nextLine(); sout(\"\") String city = scanner.nextLine(); String phone; while (true) { sout(\"\") phone = scanner.nextLine(); if (isValidMobileNumber(phone)) { break; } else { soutl(\"\") } } soutl(\"\") sout(\"\") String password = scanner.nextLine(); Customer customer = new Customer(id, name, email, phone, city, password); customers.addLast(customer); soutl(\"\") if (c_data.addCustomer(customer)) { soutl(\"\") } return id; } private boolean isValidMobileNumber(String mobileNumber) { String regex = \"^[0-9]{10}$\"; Pattern pattern = Pattern.compile(regex); Matcher matcher = pattern.matcher(mobileNumber); return matcher.matches(); } public int login() throws SQLException { scanner.nextLine(); sout(\"\") String email = scanner.nextLine(); sout(\"\") String password = scanner.nextLine(); if (customers.loginIsValid(email, password)) { soutl(\"\") } else { soutl(\"\") } return id; } public void login1() throws SQLException { scanner.nextLine(); sout(\"\") String email = scanner.nextLine(); sout(\"\") String password = scanner.nextLine(); if (customers.loginIsValid(email, password)) { soutl(\"\") CustomerInterface2(email, password); } else { soutl(\"\") } } private void CustomerInterface2(String email, String password) throws SQLException { boolean b = true; while (b) { soutl(\"\") soutl(\"\") soutl(\"\") int choice = 0; boolean validInput = false; while (!validInput) { try { sout(\"\") choice = scanner.nextInt(); validInput = true; } catch (InputMismatchException e) { soutl(\"\") scanner.next(); } } switch (choice) { case 1: Customer updatedCustomer = customers.updateCustomer(id); if (updatedCustomer != null) { boolean isUpdated = c_data.updateCustomer(updatedCustomer); if (isUpdated) { soutl(\"\") } else { soutl(\"\") } } else { soutl(\"\") } break; case 2: soutl(\"\") break; case 3: b = false; break; default: soutl(\"\") } } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "vehicle-rental-system-main/vehicle-rental-system-main/vehicle rental system/src/Customer_manager.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Customer_manager class handles multiple responsibilities: database interaction (copyData, register), input validation (isValidMobileNumber), user interface flow (CustomerInterface2), and business logic. This violates SRP as it has more than one reason to change."}, {"principle": "Dependency Inversion", "justification": "High-level module Customer_manager directly depends on low-level concrete classes Customer_db and CustomerLinkedList instead of abstractions. This creates tight coupling, violating DIP's requirement to depend on abstractions."}]}]}
{"project_id": 53, "chunk_id": 0, "prompt": {"main_file_path": "vehicle-rental-system-main/vehicle-rental-system-main/vehicle rental system/src/main.java", "main_file_content": "import java.sql.SQLException; import java.util.InputMismatchException; import java.util.Scanner; class Main { static Customer_manager C_Manager; static Vehicle_manager V_Manager; static Booking b; static Return r; static Scanner sc = new Scanner(System.in); static { try { new DatabaseConnector(); C_Manager = new Customer_manager(); V_Manager = new Vehicle_manager(); b = new Booking(); r = new Return(); C_Manager.copyData(); V_Manager.copyData(); } catch (Exception e) { e.printStackTrace(); } } public static void main(String[] args) throws SQLException { soutl(\"\") while (true) { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") int choice = 0; boolean validInput = false; while (!validInput) { try { sout(\"\") choice = sc.nextInt(); validInput = true; } catch (InputMismatchException e) { soutl(\"\") sc.next(); } } switch (choice) { case 1: Vehicle_manager.vehicles.displayVehicle(); break; case 2: b.bookVehicle(); break; case 3: sc.nextLine(); sout(\"\") String email = sc.nextLine(); sout(\"\") String password = sc.nextLine(); if (Customer_manager.customers.loginIsValid(email, password)) { soutl(\"\") r.returnVehicle(); } else { soutl(\"\") } break; case 4: C_Manager.login1(); break; case 5: V_Manager.VehicleInterface(); break; case 6: soutl(\"\") System.exit(0); break; default: soutl(\"\") break; } } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "vehicle-rental-system-main/vehicle-rental-system-main/vehicle rental system/src/main.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Main class handles UI input, initializes dependencies, manages application flow, and interacts with multiple managers, violating SRP by having multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Adding new functionality (e.g., a new menu option) requires modifying the switch statement in Main, violating OCP as the class isn't open for extension."}, {"principle": "Dependency Inversion", "justification": "Main directly instantiates concrete classes like Customer_manager and Vehicle_manager, violating DIP by depending on low-level modules instead of abstractions."}]}]}
{"project_id": 53, "chunk_id": 0, "prompt": {"main_file_path": "vehicle-rental-system-main/vehicle-rental-system-main/vehicle rental system/src/CustomerLinkedList.java", "main_file_content": "import java.util.InputMismatchException; import java.util.Scanner; public class CustomerLinkedList { static Customer_db customer_data; static Scanner sc = new Scanner(System.in); class Node { Customer customer; Node next; Node prev; Node(Customer c) { customer = c; next = null; prev = null; } } Node Head = null; void displayCustomer(int id, String password) { Node temp = Head; int flag = 0; while (temp != null) { if ((temp.customer.getId() == id) && (temp.customer.getPassword().equals(password))) { flag++; break; } temp = temp.next; } if (flag == 0) { soutl(\"\") } else { Customer c = temp.customer; soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") } } boolean loginIsValid(String email, String password) { Node temp = Head; while (temp != null) { if (temp.customer.getEmail().equals(email) && temp.customer.getPassword().equals(password)) { return true; } temp = temp.next; } return false; } public Customer updateCustomer(int id) { Node temp = Head; while (temp != null) { if (temp.customer.getId() == id) { break; } temp = temp.next; } int choice = 0; while (true) { soutl(\"\") boolean validInput = false; while (!validInput) { try { sout(\"\") choice = sc.nextInt(); validInput = true; } catch (InputMismatchException e) { soutl(\"\") sc.next(); } } sc.nextLine(); switch (choice) { case 1: sout(\"\") String updated_name = sc.nextLine(); temp.customer.setName(updated_name); soutl(\"\") break; case 2: sout(\"\") String updated_email = sc.nextLine(); temp.customer.setEmail(updated_email); soutl(\"\") break; case 3: sout(\"\") String updated_phone = sc.nextLine(); temp.customer.setPhone(updated_phone); soutl(\"\") break; case 4: sout(\"\") String updated_password = sc.nextLine(); temp.customer.setPassword(updated_password); soutl(\"\") break; case 5: break; default: soutl(\"\") break; } return temp.customer; } } void addLast(Customer customer) { Node n = new Node(customer); if (Head == null) { Head = n; } else { Node temp = Head; while (temp.next != null) { temp = temp.next; } temp.next = n; n.prev = temp; } } void deleteCustomer(int id, String password) { Node temp = Head; while (temp != null) { if ((temp.customer.getId() == id) && (temp.customer.getPassword().equals(password))) { break; } temp = temp.next; } temp.prev.next = temp.next; temp.next.prev = temp.prev; temp.prev = null; temp.next = null; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "vehicle-rental-system-main/vehicle-rental-system-main/vehicle rental system/src/CustomerLinkedList.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "CustomerLinkedList manages customer data storage (linked list), handles UI interactions (Scanner), and implements business logic (login validation, updates), violating SRP by having multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Adding new customer update types requires modifying the switch-case in updateCustomer(), violating OCP as the class is not open for extension without modification."}, {"principle": "Dependency Inversion", "justification": "High-level CustomerLinkedList directly depends on concrete Customer_db (implied by static reference) and manages low-level linked list operations, violating DIP by not depending on abstractions."}]}]}
{"project_id": 53, "chunk_id": 0, "prompt": {"main_file_path": "vehicle-rental-system-main/vehicle-rental-system-main/vehicle rental system/src/Return.java", "main_file_content": "import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.util.Scanner; public class Return { Scanner sc = new Scanner(System.in); BillGenerator bill; VehicleLinkedList vehicleLinkedList; Return() throws SQLException { bill = new BillGenerator(); vehicleLinkedList = new VehicleLinkedList(); } public void returnVehicle() throws SQLException { sout(\"\") String customerName = sc.nextLine(); String query = \"SELECT customer.c_id, booking.v_id, booking.b_id FROM customer \" + \"INNER JOIN booking ON customer.c_id = booking.c_id \" + \"WHERE customer.name = ? AND booking.return_date IS NULL;\"; PreparedStatement pstmt = DatabaseConnector.conn.prepareStatement(query); pstmt.setString(1, customerName); ResultSet rs = pstmt.executeQuery(); if (!rs.next()) { soutl(\"\") return; } soutl(\"\") do { int vid = rs.getInt(\"v_id\"); int bookingId = rs.getInt(\"b_id\"); soutl(\"\") } while (rs.next()); sout(\"\") int bookingIdToReturn = sc.nextInt(); sc.nextLine(); pstmt = DatabaseConnector.conn.prepareStatement( \"SELECT v_id, c_id FROM booking WHERE b_id = ? AND return_date IS NULL\"); pstmt.setInt(1, bookingIdToReturn); ResultSet bookingResult = pstmt.executeQuery(); if (!bookingResult.next()) { soutl(\"\") return; } int vid = bookingResult.getInt(\"v_id\"); int cid = bookingResult.getInt(\"c_id\"); try { DatabaseConnector.conn.setAutoCommit(false); query = \"UPDATE booking SET return_date = ? WHERE b_id = ?\"; pstmt = DatabaseConnector.conn.prepareStatement(query); sout(\"\") pstmt.setString(1, sc.nextLine()); pstmt.setInt(2, bookingIdToReturn); pstmt.executeUpdate(); query = \"UPDATE vehicle SET isBooked = false WHERE v_id = ?\"; pstmt = DatabaseConnector.conn.prepareStatement(query); pstmt.setInt(1, vid); pstmt.executeUpdate(); vehicleLinkedList.refreshData(); soutl(\"\") bill.generateBill(vid, cid); DatabaseConnector.conn.commit(); } catch (Exception e) { DatabaseConnector.conn.rollback(); soutl(\"\") } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "vehicle-rental-system-main/vehicle-rental-system-main/vehicle rental system/src/Return.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Return class handles database interactions, return logic, and UI input/output, violating SRP by managing multiple responsibilities."}, {"principle": "Open-Closed", "justification": "The class cannot be extended without modifying its code (e.g., to change return logic), violating OCP."}, {"principle": "Dependency Inversion", "justification": "Return directly depends on concrete classes like BillGenerator and DatabaseConnector instead of abstractions, violating DIP."}]}]}
{"project_id": 53, "chunk_id": 0, "prompt": {"main_file_path": "vehicle-rental-system-main/vehicle-rental-system-main/vehicle rental system/src/Vehicle.java", "main_file_content": "public class Vehicle { int id; String type; String model; int year; int price; boolean isBooked; public Vehicle(int id, String type, String model, int year, int price, boolean isBooked) { this.id = id; this.type = type; this.model = model; this.year = year; this.price = price; this.isBooked = isBooked; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getType() { return type; } public void setType(String type) { this.type = type; } public String getModel() { return model; } public void setModel(String model) { this.model = model; } public int getYear() { return year; } public void setYear(int year) { this.year = year; } public int getPrice() { return price; } public void setPrice(int price) { this.price = price; } public boolean isBooked() { return isBooked; } public void setBooked(boolean booked) { isBooked = booked; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "vehicle-rental-system-main/vehicle-rental-system-main/vehicle rental system/src/Vehicle.java", "violatedPrinciples": []}]}
{"project_id": 53, "chunk_id": 0, "prompt": {"main_file_path": "vehicle-rental-system-main/vehicle-rental-system-main/vehicle rental system/src/Vehicle_manager.java", "main_file_content": "import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.util.InputMismatchException; import java.util.Scanner; public class Vehicle_manager { static VehicleLinkedList vehicles; static Vehicle_db v_data; static int id = 0; Scanner sc = new Scanner(System.in); public Vehicle_manager() throws SQLException { vehicles = new VehicleLinkedList(); v_data = new Vehicle_db(); } void copyData() throws Exception { String q = \"select * from vehicle order by price DESC;\"; PreparedStatement ps = DatabaseConnector.conn.prepareStatement(q); ResultSet rs = ps.executeQuery(); while (rs.next()) { id = rs.getInt(1); Vehicle temp = new Vehicle(rs.getInt(1), rs.getString(2), rs.getString(3), rs.getInt(4), rs.getInt(5), rs.getBoolean(6)); vehicles.addLast(temp); } } public void addVehicle() { id++; sc.nextLine(); soutl(\"\") sout(\"\") String type = sc.nextLine(); sout(\"\") String model = sc.nextLine(); sout(\"\") int year = sc.nextInt(); sout(\"\") int price = sc.nextInt(); sout(\"\") boolean is_available = sc.nextBoolean(); soutl(\"\") vehicles.addLast(new Vehicle(id, type, model, year, price, is_available)); if (v_data.addVehicle(new Vehicle(id, type, model, year, price, is_available))) { soutl(\"\") } } public void login() throws SQLException { sc.nextLine(); sout(\"\") int id = sc.nextInt(); sc.nextLine(); sout(\"\") String password = sc.nextLine(); if (vehicles.isLoginValid(id, password)) { soutl(\"\") VehicleInterface2(id, password); } else { soutl(\"\") } } void VehicleInterface2(int id, String password) throws SQLException { sout(\"\") int id1 = sc.nextInt(); while (true) { soutl(\"\") int choice = 0; boolean validInput = false; while (!validInput) { try { sout(\"\") choice = sc.nextInt(); validInput = true; } catch (InputMismatchException e) { soutl(\"\") sc.next(); } } switch (choice) { case 1: vehicles.deleteVehicle(id1); v_data.deleteVehicle(id1); break; case 2: Vehicle updatedVehicle = vehicles.updateVehicle(id1); if (updatedVehicle != null) { boolean isUpdated = v_data.updateVehicle(updatedVehicle); if (isUpdated) { soutl(\"\") } else { soutl(\"\") } } else { soutl(\"\") } break; case 3: VehicleInterface(); break; default: soutl(\"\") break; } } } void VehicleInterface() throws SQLException { int choice = 0; boolean b = true; while (b) { soutl(\"\") boolean validInput = false; while (!validInput) { try { sout(\"\") choice = sc.nextInt(); validInput = true; } catch (InputMismatchException e) { soutl(\"\") sc.next(); } } switch (choice) { case 1: addVehicle(); break; case 2: login(); break; case 3: b = false; String[] a = {}; Main.main(a); break; default: soutl(\"\") } } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "vehicle-rental-system-main/vehicle-rental-system-main/vehicle rental system/src/Vehicle_manager.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Vehicle_manager handles database operations, user input, and business logic, violating SRP by managing multiple responsibilities that could change independently."}, {"principle": "Dependency Inversion", "justification": "High-level Vehicle_manager directly depends on concrete classes (Vehicle_db, VehicleLinkedList, DatabaseConnector) instead of abstractions, creating tight coupling between modules."}]}]}
{"project_id": 54, "chunk_id": 0, "prompt": {"main_file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/CSStudent.java", "main_file_content": "public class CSStudent extends Student implements Triggerable{ public CSStudent(String name) { super(name, 7, 6, 6, 6, 4); } public void pairWorking(Character friend , Character enemy) throws Exception { this.specialAttack(); int damageAmount = (100 * this.getAttack()) / (100 + enemy.getDefence()); enemy.decreaseHP(damageAmount); int damageAmountFriend = (100 * friend.getAttack()) / (100 + enemy.getDefence()); enemy.decreaseHP(damageAmountFriend); if(enemy.getHP() == 0){ this.increaseEP(4); } } public void support(Character friend) throws Exception { this.specialAttack(); if(friend.isAlive()){ friend.increaseHP(this.getDefence()); } } @Override public void triggerSpecialAttack(Character enemy, Character friend) throws Exception { if(friend.isAlive() && friend.getHP() < friend.getMaxHP()/3 ){ this.support(friend); } else{ this.pairWorking(friend, enemy); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/CSStudent.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The CSStudent class handles multiple responsibilities including special attack execution, damage calculation, EP management, and ally support coordination, which are separate reasons to change."}, {"principle": "Dependency Inversion", "justification": "High-level methods like pairWorking and support directly depend on concrete Character implementations instead of abstractions, violating abstraction dependencies for policy modules."}]}]}
{"project_id": 54, "chunk_id": 0, "prompt": {"main_file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/MonsterParser.java", "main_file_content": "public class MonsterParser { public static Team Parse(String data){ MonsterTeam result = new MonsterTeam(\"\"); String[] monstersData = data.split(\";\"); for (String monsterInfo : monstersData) { String[] monsterDetails = monsterInfo.split(\",|\\\\(|\\\\)\"); String monsterName = monsterDetails[0]; String monsterType = monsterDetails[1]; String monsterLevel = monsterDetails[2]; if(monsterType==\"Minion\") { Minion minion = new Minion(monsterName); minion.setLevel(Integer.parseInt(monsterLevel)); result.addMember(minion); } else if(monsterType==\"Boss\") { Boss boss = new Boss(monsterName); boss.setLevel(Integer.parseInt(monsterLevel)); result.addMember(boss); } } return result; } }", "dependencies": [{"file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/MonsterTeam.java", "file_content": "public class MonsterTeam extends Team{ public MonsterTeam(String name) { super(name); } @Override public void move(Character member, Team enemyTeam) { ((Monster)member).strike(enemyTeam.getRandomAliveMember()); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/MonsterParser.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "Adding a new monster type requires modifying the Parse method's conditional logic, violating OCP as the class is not open for extension without modification."}, {"principle": "Dependency Inversion", "justification": "MonsterParser directly instantiates concrete Minion and Boss classes, violating DIP by depending on low-level modules instead of abstractions."}]}, {"file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/MonsterTeam.java", "violatedPrinciples": [{"principle": "Liskov", "justification": "MonsterTeam's move method assumes all members are Monsters via casting, violating LSP by introducing subtype-specific assumptions that break base type substitutability."}]}]}
{"project_id": 54, "chunk_id": 0, "prompt": {"main_file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/Team.java", "main_file_content": "import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.Random; import java.util.stream.Collectors; public abstract class Team { private String name; private ArrayList<Character> members; public Team(String name){ this.name = name; this.members = new ArrayList<Character>(); } public String getName(){ return name; } public Character[] getMembers(){ return members.toArray(new Character[members.size()]); } public int addMember(Character member){ if(members.contains(member)){ return -1; } else if(members.size()>= 5){ return -2; } else{ members.add(member); return members.size(); } } public ArrayList<Character> getAliveMembers() { ArrayList<Character> aliveMembers = (ArrayList<Character>) this.members .stream() .filter(m -> m.isAlive()) .collect(Collectors.toList()); return aliveMembers; } public Character getAliveMemberByLeastHP() { return Collections.min(this.getAliveMembers(), Comparator.comparing(m -> m.getHP())); } public Character getAliveMemberByHighestAttack(){ return Collections.max(this.getAliveMembers(), Comparator.comparing(m -> m.getAttack())); } public int getAliveMembersCount(){ int aliveMembers = (int)this.members .stream() .filter(m -> m.isAlive()) .count(); return aliveMembers; } public int getDeadMembersCount(){ int deadMembers = this.members.size() - this.getAliveMembersCount(); return deadMembers; } public Character getRandomAliveMember(){ ArrayList<Character> aliveMembers = this.getAliveMembers(); Random random = new Random(); int randomIndex = random.nextInt(aliveMembers.size()); return aliveMembers.get(randomIndex); } public int getMembersCount(){ return members.size(); } public abstract void move(Character member, Team enemyTeam) throws Exception; }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/Team.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Team class manages team composition, tracks member status, and defines abstract move behavior. Handling multiple responsibilities (member management and strategy implementation) violates SRP."}, {"principle": "Dependency Inversion", "justification": "Team depends directly on concrete Character class instead of abstractions. High-level modules (Team) should depend on interfaces, not low-level implementations (Character)."}]}]}
{"project_id": 54, "chunk_id": 0, "prompt": {"main_file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/StudentTeam.java", "main_file_content": "public class StudentTeam extends Team{ public StudentTeam(String name) { super(name); } @Override public void move(Character member, Team enemyTeam) throws Exception { if(member instanceof Student){ Student student = (Student)member; if(student.canUseSpecialAttack()){ if(student instanceof AIStudent){ Character weakestEnemy = enemyTeam.getAliveMemberByLeastHP(); ((AIStudent)student).triggerSpecialAttack(weakestEnemy); } else if(student instanceof CSStudent){ Character weakestFriend = member.getTeam().getAliveMemberByLeastHP(); if(weakestFriend.getHP() < weakestFriend.getMaxHP()/3){ ((CSStudent)student).triggerSpecialAttack(weakestFriend); } else{ Character strongestFriend = member.getTeam().getAliveMemberByHighestAttack(); ((CSStudent)student).triggerSpecialAttack(strongestFriend); } } else if(student instanceof CyberStudent){ ((CyberStudent)student).triggerSpecialAttack(enemyTeam); } else if(student instanceof SEStudent){ Character weakestEnemy = enemyTeam.getAliveMemberByLeastHP(); ((SEStudent)student).triggerSpecialAttack(weakestEnemy); } } } else{ } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/StudentTeam.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The move method in StudentTeam handles multiple responsibilities by implementing conditional logic for different Student subtypes, leading to multiple reasons to change."}, {"principle": "Open-Closed", "justification": "The move method checks concrete Student subtypes, requiring modification when new types are added, violating the closed-for-modification principle."}, {"principle": "Interface Segregation", "justification": "StudentTeam depends on specific methods of various Student subtypes, forcing it to rely on multiple interfaces instead of a single abstraction."}, {"principle": "Dependency Inversion", "justification": "StudentTeam (high-level) directly interacts with low-level Student subtypes instead of abstractions, creating dependency on concrete implementations."}]}]}
{"project_id": 54, "chunk_id": 0, "prompt": {"main_file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/Minion.java", "main_file_content": "import java.util.Random; public class Minion extends Character implements Monster{ public Minion(String name){ super(name, 5, 5, 5, 5); } public void strike(Character enemy){ this.increaseEP(3); if(!enemy.isAlive()){ this.increaseEP(4); } if(enemy instanceof Student){ ((Student)enemy).increaseKP(3); } Random random = new Random(); int randomNumber = random.nextInt(100); if (randomNumber < 75) { SyntaxError(enemy); } if (randomNumber >=75 && randomNumber < 90) { NullPointerException(); } if (randomNumber >= 90) { ArrayIndexOutOfBoundException(enemy); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/Minion.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Minion class's strike() method handles multiple responsibilities: modifying EP/KP, type checking enemies, and generating different exceptions based on random numbers."}, {"principle": "Open-Closed", "justification": "The strike() method checks enemy type using instanceof, requiring modification to handle new enemy types, violating 'closed for modification'."}]}]}
{"project_id": 54, "chunk_id": 0, "prompt": {"main_file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/Battle.java", "main_file_content": "import java.util.ArrayList; import java.util.Comparator; import java.util.stream.Collectors; public class Battle{ private Team team1; private Team team2; public Team fight(Team team1, Team team2) throws Exception { int currentRound = 0; while(currentRound <= 30) { ArrayList<Character> team1Members = (ArrayList<Character>)team1 .getAliveMembers() .stream() .sorted(Comparator.comparing(Character::getSpeed).reversed()) .collect(Collectors.toList()); ArrayList<Character> team2Members = (ArrayList<Character>)team2 .getAliveMembers() .stream() .sorted(Comparator.comparing(Character::getSpeed).reversed()) .collect(Collectors.toList()); for(Character member : team1Members) { team1.move(member, team2); } for(Character member : team2Members) { team2.move(member, team1); } currentRound++; if(team1.getAliveMembersCount()==0) { return team2; } if(team2.getAliveMembersCount()==0) { return team1; } soutl(\"\") soutl(\"\") } return null; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/Battle.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Battle class manages multiple responsibilities: executing battle rounds, sorting team members by speed, checking win conditions, and handling team interactions. This indicates it has more than one reason to change."}, {"principle": "Open-Closed", "justification": "The sorting logic (Comparator.comparing(Character::getSpeed)) is hardcoded. To change the sorting strategy (e.g., by health), the Battle class would require modification instead of being extendable via abstraction."}, {"principle": "Dependency Inversion", "justification": "Battle directly depends on concrete Team and Character classes instead of abstractions. High-level battle logic should depend on interfaces (e.g., TeamInterface), not concrete implementations."}]}]}
{"project_id": 54, "chunk_id": 0, "prompt": {"main_file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/Character.java", "main_file_content": "import java.lang.Math; public class Character{ private String name; private int baseHP; private int baseAtk; private int baseDef; private int baseSpd; private int maxHP; private int currentHP; private int currentEP; private int level = 1; private Team team; public Character(String name, int baseHP, int baseAtk, int baseDef, int baseSpd){ this.name = name; this.baseHP = baseHP; this.baseAtk = baseAtk; this.baseDef = baseDef; this.baseSpd = baseSpd; this.currentHP = getMaxHP(); this.maxHP = getMaxHP(); } public Character(String name, int baseHP, int baseAtk, int baseDef, int baseSpd, Team team){ this(name, baseHP, baseAtk, baseDef, baseSpd); this.team = team; } public String getName(){ return name; } public int getMaxHP(){ return (int)Math.round(baseHP*Math.pow(level, 1.2)); } public int getAttack(){ return (int)Math.round(baseAtk*Math.pow(level, 1.2)); } public int getDefence(){ return (int)Math.round(baseDef*Math.pow(level, 1.2)); } public void increaseDefence(int amount){ baseDef += amount; } public int getSpeed(){ return (int)Math.round(baseSpd*Math.pow(level, 1.2)); } private int targetEP; public int getTargetEP(){ targetEP = (int)Math.round(10*Math.pow(level,1.5)); return targetEP; } public int getHP(){ return currentHP; } public int getEP(){ return currentEP; } public void increaseHP(int amount){ if(currentHP > 0){ currentHP += amount; currentHP = Math.min(currentHP, this.getMaxHP()); } } public void decreaseHP(int amount){ if(currentHP > 0){ currentHP -= amount; currentHP = Math.max(currentHP , 0); } } public void increaseEP(int amount){ currentEP += amount; if(currentEP >= getTargetEP()){ level += 1; currentEP = 0; if(this.isAlive()){ currentHP = getMaxHP(); } } } public Team getTeam(){ return team; } public void setTeam(Team team){ this.team = team; } public Boolean isAlive(){ return this.currentHP > 0; } public double getPowerPoints(){ return (this.getAttack() + this.getDefence())/2.0; } public void setLevel(int level) { this.level = level; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/Character.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Character class handles multiple responsibilities including managing attributes (HP, attack, defense), leveling, team assignment, and state (alive/dead). Each responsibility provides a separate reason to change the class."}, {"principle": "Dependency Inversion", "justification": "The Character class directly depends on the concrete Team class. High-level modules (e.g., Character) should depend on abstractions, not concrete implementations."}]}]}
{"project_id": 54, "chunk_id": 0, "prompt": {"main_file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/SEStudent.java", "main_file_content": "public class SEStudent extends Student implements Triggerable { public SEStudent(String name) { super(name, 8, 5, 8, 4, 10); } public void groupWork(Character enemy) throws Exception { this.specialAttack(); for(Character member : this.getTeam().getMembers()){ if(member.isAlive()){ int damageAmount = (100 * member.getAttack()) / (100 + enemy.getDefence()); enemy.decreaseHP(damageAmount); } } } public void groupDiscussion() throws Exception { this.specialAttack(); for(Character member : this.getTeam().getMembers()){ if(member.isAlive()){ member.increaseHP((this.getDefence())/2); } } } private double getOwnTeamHP(){ double result = 0; int aliveMembers = 0; for(Character member : this.getTeam().getMembers()){ if(member.isAlive()){ result += member.getHP()/member.getMaxHP(); aliveMembers++; } } return result/aliveMembers; } @Override public void triggerSpecialAttack(Character enemy) throws Exception { if(this.getOwnTeamHP() < 0.33){ this.groupDiscussion(); } else{ this.groupWork(enemy); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/SEStudent.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "SEStudent handles multiple responsibilities: managing team HP calculations, group attacks, group healing, and special attack decisions. Combining combat logic, team management, and state evaluation in one class violates SRP."}, {"principle": "Dependency Inversion", "justification": "SEStudent directly depends on concrete Character type in groupWork, groupDiscussion, and triggerSpecialAttack. High-level policy (special attack logic) should depend on abstractions, not concrete implementations."}]}]}
{"project_id": 54, "chunk_id": 0, "prompt": {"main_file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/testMe.java", "main_file_content": "public class testMe { public static void main(String[] args){ Team team = new MonsterTeam(\"name\"); soutl(\"\") } }", "dependencies": [{"file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/MonsterTeam.java", "file_content": "public class MonsterTeam extends Team{ public MonsterTeam(String name) { super(name); } @Override public void move(Character member, Team enemyTeam) { ((Monster)member).strike(enemyTeam.getRandomAliveMember()); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/MonsterTeam.java", "violatedPrinciples": [{"principle": "Liskov", "justification": "MonsterTeam's move method casts Character to Monster, assuming all members are Monsters. This violates LSP as subtypes must be substitutable without altering correctness."}, {"principle": "Dependency Inversion", "justification": "MonsterTeam directly depends on concrete Monster class (strike method). High-level modules should depend on abstractions, not concrete implementations."}]}]}
{"project_id": 54, "chunk_id": 0, "prompt": {"main_file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/Triggerable.java", "main_file_content": "public interface Triggerable { default void triggerSpecialAttack(Character enemy) throws Exception{ } default void triggerSpecialAttack(Character friend, Character enemy) throws Exception{ } default void triggerSpecialAttack(Team enemyTeam) throws Exception{ } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/Triggerable.java", "violatedPrinciples": [{"principle": "Interface Segregation", "justification": "The Triggerable interface declares multiple methods (triggerSpecialAttack with different parameters). Clients implementing this interface may not need all attack variations, forcing unnecessary method dependencies even with default implementations."}]}]}
{"project_id": 54, "chunk_id": 0, "prompt": {"main_file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/MonsterTeam.java", "main_file_content": "public class MonsterTeam extends Team{ public MonsterTeam(String name) { super(name); } @Override public void move(Character member, Team enemyTeam) { ((Monster)member).strike(enemyTeam.getRandomAliveMember()); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/MonsterTeam.java", "violatedPrinciples": [{"principle": "Liskov", "justification": "The move method casts Character to Monster, assuming all Characters are Monsters. Subtypes of Character that are not Monsters would break this assumption, violating LSP."}, {"principle": "Dependency Inversion", "justification": "MonsterTeam directly depends on the concrete Monster class. It should depend on an abstraction (e.g., an interface with strike()) instead of a concrete implementation."}, {"principle": "Open-Closed", "justification": "Adding new Character types requires modifying the move method's casting logic. The class is not open for extension without modification."}]}]}
{"project_id": 54, "chunk_id": 0, "prompt": {"main_file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/Monster.java", "main_file_content": "public interface Monster{ void strike(Character enemy); int getAttack(); int getDefence(); void increaseDefence(int amount); default void SyntaxError(Character enemy){ int attack = (100 * this.getAttack()) / (100 + enemy.getDefence()); enemy.decreaseHP(attack); } default void NullPointerException() { this.increaseDefence(this.getDefence()); } default void ArrayIndexOutOfBoundException(Character enemy) { int attack = 2*((100 * this.getAttack()) / (100 + enemy.getDefence())); enemy.decreaseHP(attack); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/Monster.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Monster interface handles multiple responsibilities: defining the monster contract and providing concrete attack implementations via default methods, leading to multiple reasons to change."}, {"principle": "Open-Closed", "justification": "Adding a new attack type requires modifying the Monster interface directly, violating the requirement to extend behavior without changing existing code."}, {"principle": "Interface Segregation", "justification": "Implementing classes must depend on all methods (e.g., increaseDefence, strike) even if they do not use them, forcing unnecessary dependencies."}, {"principle": "Dependency Inversion", "justification": "Monster depends on the concrete Character class in method parameters instead of abstractions, coupling high-level modules to low-level details."}]}]}
{"project_id": 54, "chunk_id": 0, "prompt": {"main_file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/TowerOfMonsters.java", "main_file_content": "import java.io.BufferedReader; import java.io.File; import java.io.FileReader; import java.io.IOException; public class TowerOfMonsters { public static void main(String[] args) { File inFile = null; if (args.length > 0) { inFile = new File(args[0]); BufferedReader objReader = null; try { String line; objReader = new BufferedReader(new FileReader(inFile)); while ((line = objReader.readLine()) != null) { soutl(\"\") Team team = MonsterParser.Parse(line); soutl(\"\") } } catch (IOException e) { e.printStackTrace(); } finally { try { if (objReader != null) { objReader.close(); } } catch (IOException ex) { ex.printStackTrace(); } } } else { System.err.println(\"Invalid arguments count:\" + args.length); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/TowerOfMonsters.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "TowerOfMonsters handles file I/O, parsing, and application orchestration, indicating multiple responsibilities. Changes to file handling, parsing logic, or workflow would all require modifying this class."}, {"principle": "Dependency Inversion", "justification": "TowerOfMonsters directly instantiates MonsterParser (a concrete implementation) for parsing. High-level modules should depend on abstractions rather than concrete low-level implementations."}]}]}
{"project_id": 54, "chunk_id": 0, "prompt": {"main_file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/CyberStudent.java", "main_file_content": "public class CyberStudent extends Student implements Triggerable{ public CyberStudent(String name) { super(name, 7, 7, 5, 6, 6); } public void cyberAttack(Team enemyTeam) throws Exception { this.specialAttack(); for(Character enemy : enemyTeam.getMembers()){ if(enemy.isAlive()){ int damageAmount = (100 * this.getAttack()) / (100 + enemy.getDefence()); enemy.decreaseHP(damageAmount); if(!enemy.isAlive()){ this.increaseEP(4); } } } } @Override public void triggerSpecialAttack(Team enemyTeam) throws Exception { this.cyberAttack(enemyTeam); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/CyberStudent.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "CyberStudent's cyberAttack method depends on the concrete Team class. High-level modules (CyberStudent) should depend on abstractions rather than concrete implementations."}]}]}
{"project_id": 54, "chunk_id": 0, "prompt": {"main_file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/Student.java", "main_file_content": "public class Student extends Character{ private int maxKP = 0; private int currentKP = 0; public Student(String name, int baseHP, int baseAtk, int baseDef, int baseSpd, int maxKP){ super(name, baseHP, baseAtk, baseDef, baseSpd); this.maxKP = maxKP; } public int getMaxKP(){ return maxKP; } public void increaseKP(int amount){ currentKP += amount; } public void resetKP(){ currentKP = 0; } public void javaProgramming(Character enemy){ this.increaseEP(3); this.increaseKP(1); int damageAmount = (100 * this.getAttack()) / (100 + enemy.getDefence()); enemy.decreaseHP(damageAmount); enemy.increaseEP(2); if(enemy instanceof Student){ ((Student)enemy).increaseKP(3); } if(enemy.getHP() == 0 ){ this.increaseEP(4); } } public void selfStudy(){ this.increaseHP(2); this.increaseEP(6); this.increaseKP(2); } protected void specialAttack() throws Exception { if(currentKP >= maxKP){ this.increaseEP(4); this.resetKP(); } else{ throw new Exception(\"\"); } } public boolean canUseSpecialAttack(){ return currentKP >= maxKP; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/Student.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Student class manages KP, executes attacks (javaProgramming, specialAttack), and handles self-study, indicating multiple responsibilities."}, {"principle": "Liskov", "justification": "Using instanceof to check if enemy is a Student in javaProgramming() violates substitutability, as subtypes of Character may not behave interchangeably."}, {"principle": "Dependency Inversion", "justification": "Student directly extends Character (assumed concrete) and depends on concrete Character parameters, instead of abstractions."}]}]}
{"project_id": 54, "chunk_id": 0, "prompt": {"main_file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/Guild.java", "main_file_content": "import java.util.ArrayList; import java.util.Collection; import java.util.Comparator; import java.util.stream.Collectors; public class Guild { private ArrayList<Character> members; public Guild(){ members = new ArrayList<Character>(); } public void addMember(Character character){ members.add(character); } public Collection<Character> getMembers(){ return members; } public Team getTeam(Team enemyTeam){ ArrayList<Character> newTeamMembers = (ArrayList<Character>)members.stream() .sorted(Comparator.comparing(Character::getPowerPoints)) .collect(Collectors.toList()); Team team = null ; if(enemyTeam instanceof StudentTeam){ team = new MonsterTeam(\"\"); } else if(enemyTeam instanceof MonsterTeam){ team = new StudentTeam(\"\"); } for(int i = newTeamMembers.size() - 1; i >= 0; i++){ if(newTeamMembers.get(i).isAlive()){ team.addMember(newTeamMembers.get(i)); } if(team.getMembersCount() >= 5){ break; } } return team; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/Guild.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Guild class manages members and determines team creation logic based on enemy types, handling multiple responsibilities related to member storage and strategic team assembly."}, {"principle": "Open-Closed", "justification": "getTeam() explicitly checks enemyTeam types and instantiates concrete team subtypes, requiring modification to support new team types instead of extending through abstractions."}, {"principle": "Dependency Inversion", "justification": "High-level Guild directly creates MonsterTeam/StudentTeam instances instead of depending on Team abstractions, coupling policy to implementation details."}]}]}
{"project_id": 54, "chunk_id": 0, "prompt": {"main_file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/AIStudent.java", "main_file_content": "public class AIStudent extends Student implements Triggerable{ public AIStudent(String name) { super(name, 6, 7, 7, 5, 3); } public void machineLearning(Character enemy) throws Exception { this.specialAttack(); int damageAmount = 2 * (100 * this.getAttack()) / (100 + enemy.getDefence()); enemy.decreaseHP(damageAmount); if(!enemy.isAlive()){ this.increaseEP(4); } } public void naturalLanguageProcessing() throws Exception { this.specialAttack(); this.increaseHP(this.getDefence()); } @Override public void triggerSpecialAttack(Character enemy) throws Exception { if(this.getHP() < this.getMaxHP()/2){ this.naturalLanguageProcessing(); } else{ this.machineLearning(enemy); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/AIStudent.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "The triggerSpecialAttack method uses conditional logic to decide which attack to execute. Adding new attack types would require modifying existing code instead of extending it."}, {"principle": "Dependency Inversion", "justification": "AIStudent directly depends on the concrete Character class in method parameters (e.g., machineLearning). High-level modules should depend on abstractions, not concrete implementations."}]}]}
{"project_id": 54, "chunk_id": 0, "prompt": {"main_file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/Boss.java", "main_file_content": "import java.util.Random; public class Boss extends Character implements Monster{ public Boss(String name){ super(name, 8, 7, 8, 7); } public void NoneTermination(Character enemy){ for(Character member : this.getTeam().getMembers()){ if(!member.isAlive()){ member.increaseHP(member.getMaxHP()); } } } public void ConcurrentModificationException(Character enemy){ for(Character member : enemy.getTeam().getMembers()){ if(member.isAlive()){ int attack = (100 * this.getAttack()) / (100 + enemy.getDefence()); enemy.decreaseHP(attack); } } } public void strike(Character enemy){ this.increaseEP(3); if(!enemy.isAlive()){ this.increaseEP(4); } if(enemy instanceof Student){ ((Student)enemy).increaseKP(3); } Random random = new Random(); int randomNumber = random.nextInt(100); if (randomNumber < 50) { SyntaxError(enemy); } else if (randomNumber >=50 && randomNumber < 65) { NullPointerException(); } else if (randomNumber >= 65 && randomNumber < 80) { ArrayIndexOutOfBoundException(enemy);} else if (randomNumber >=80 && randomNumber < 90) { NoneTermination(enemy);} else if (randomNumber >= 90) { ConcurrentModificationException(enemy);} } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "COMP1202-Coursework-main/COMP1202-Coursework-main/Boss.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Boss class handles multiple responsibilities: managing attack strategies (e.g., SyntaxError, NoneTermination), reviving team members, and directly modifying enemy state. These distinct functionalities violate SRP."}, {"principle": "Open-Closed", "justification": "The strike method uses a rigid conditional chain to select attacks. Adding a new attack type requires modifying existing code in strike, violating OCP."}]}]}
{"project_id": 58, "chunk_id": 0, "prompt": {"main_file_path": "Battleship-main/src/Splash.java", "main_file_content": "import java.awt.*; import java.awt.event.*; import javax.swing.*; import Ship.ShipCount; class Splash extends Thread implements ActionListener { static volatile boolean ready = true; private int index; private volatile ShipCount ship; private JWindow window; private Timer timerImg; private Timer timerWait; private JLabel label; public Splash(int index, ShipCount ship, Frame frame) { this.index = index; this.ship = ship; timerImg = new Timer(1000, this); timerWait = new Timer(1000, this); window = new JWindow(frame); label = new JLabel(); window.getContentPane().add(label, BorderLayout.CENTER); window.setSize(500,300); } public void run() { while(ship.allDestroyed == false) { if(ship.destroyed != 0) { runImage(ship.destroyed); ship.destroyed = 0; } } } public void runImage(int imgIndex) { synchronized(ship) { if(index == 1) { label.setIcon(new ImageIcon(\"src/Images/First/\"+imgIndex+\".png\")); label.repaint(); } else { label.setIcon(new ImageIcon(\"src/Images/Second/\"+imgIndex+\".png\")); label.repaint(); } Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize(); Dimension labelSize = label.getPreferredSize(); window.setLocation(screenSize.width/2 - (labelSize.width/2), screenSize.height/2 - (labelSize.height/2)); if(ready == false) { timerWait.start(); } if(ready == true) { ready = false; window.setVisible(true); timerImg.start(); } } } public synchronized void actionPerformed(ActionEvent e) { if(timerWait.isRunning() && ready == true) { ready = false; window.setVisible(true); timerWait.stop(); timerImg.start(); } else if(timerImg.isRunning()) { timerImg.stop(); timerWait.stop(); window.setVisible(false); ready = true; } } }", "dependencies": [{"file_path": "Battleship-main/src/Ship/ShipCount.java", "file_content": "package Ship; import Player.Player; import java.util.*; public class ShipCount { LinkedHashMap<Ship, Boolean> ships = new LinkedHashMap<Ship, Boolean>(); public int destroyed; public boolean allDestroyed; public ShipCount(Player play) { play.getShips().forEach( (i) -> {ships.put(i, false);}); destroyed = 0; allDestroyed = false; } public int destroyedUpdate() { for(Ship i : ships.keySet()) { if(i.destroyed != ships.get(i)) { ships.put(i, true); destroyed = i.n; return i.n; } } return -1; } public boolean allDestroyed() { int count = 0; for(boolean i : ships.values()) if(i == true) count++; if(count == 7) { allDestroyed = true; return true; } else return false; } public Collection<Boolean> getDestroyed() { return ships.values(); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Battleship-main/src/Splash.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Splash class manages UI rendering, thread execution, and event handling simultaneously, indicating multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Splash directly implements image display logic in runImage(), requiring code modification to alter rendering behavior."}, {"principle": "Dependency Inversion", "justification": "Splash directly depends on concrete ShipCount class instead of an abstraction for ship status tracking."}]}]}
{"project_id": 58, "chunk_id": 0, "prompt": {"main_file_path": "Battleship-main/src/MainFrame.java", "main_file_content": "import Player.Computer; import Player.Person; import Player.Player; import Ship.ShipCount; import java.awt.*; import java.awt.event.*; import javax.swing.*; import javax.swing.table.DefaultTableModel; import FileExceptions.BadFileException; import java.util.*; public class MainFrame implements ActionListener { private static MainFrame main = new MainFrame(); private JFrame frame; private JButton buttonM[][]; private JPanel panelM; private JButton buttonE[][]; private JPanel panelE; private JPanel lowPanel; private JPanel highPanel; private JTextArea text; private Player play1; private ShipCount count1; private Player play2; private ShipCount count2; private String infoMess = \"Click any button on the left to start the game.\"; private JTable table; private String[] columnNames; private JScrollPane scrollPane; private boolean endGame; private MainFrame() {} public static MainFrame getMainFrame() { return main; } protected boolean startMain(String protag, String antag) { play1 = new Person(protag); play2 = new Computer(antag); try { play1.createGridMine(); play2.createGridMine(); } catch(BadFileException e) { e.printMessage(); return false; } initiateComponents(); frame.setVisible(true); return true; } private void initiateComponents() { count1 = new ShipCount(play1); count2 = new ShipCount(play2); frame = new JFrame(\"BattleShip\"); buttonM = new JButton[10][10]; panelM = new JPanel(); buttonE = new JButton[10][10]; panelE = new JPanel(); lowPanel = new JPanel(); highPanel = new JPanel(); text = new JTextArea(infoMess,10,25); columnNames = new String[] { \"Length\", play1.getName(), play2.getName() }; table = new JTable(tableContent(), columnNames); scrollPane = new JScrollPane(table, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_NEVER); createPanelM(); createPanelE(); createHighPanel(); createLowPanel(); createFrame(); } public Splash startSplash1() { Splash splash1 = new Splash(1, count2, frame); return splash1; } public Splash startSplash2() { Splash splash2 = new Splash(2, count1, frame); return splash2; } private Object[][] tableContent() { Object[][] data = new Object[7][3]; ArrayList<Integer> sizes = new ArrayList<Integer>(); Collections.addAll(sizes, 5, 4, 3, 2, 2, 1, 1); Iterator<Integer> sizesIt = sizes.iterator(); Iterator<Boolean> count1It = count1.getDestroyed().iterator(); Iterator<Boolean> count2It = count2.getDestroyed().iterator(); for(Object[] obj: data) { obj[0] = sizesIt.next(); obj[1] = count1It.next(); obj[2] = count2It.next(); } return data; } private void createPanelM() { panelM.setLayout(new GridLayout(10, 10)); panelM.setPreferredSize(new Dimension(450, 300)); for(int i = 0; i < 10; i++) { for(int j = 0; j < 10; j++) { buttonM[j][i] = new JButton(); buttonM[j][i].setText(play1.checkBlockM(j,i)); buttonM[j][i].setBackground(Color.WHITE); buttonM[j][i].setEnabled(false); panelM.add(buttonM[j][i]); } } } private void createPanelE() { panelE.setLayout(new GridLayout(10, 10)); panelE.setPreferredSize(new Dimension(450, 300)); for(int i = 0; i < 10; i++) { for(int j = 0; j < 10; j++) { buttonE[j][i] = new JButton(); buttonE[j][i].setText(\".\"); buttonE[j][i].setBackground(Color.WHITE); panelE.add(buttonE[j][i]); buttonE[j][i].setActionCommand(String.valueOf(j)+String.valueOf(i)); buttonE[j][i].addActionListener(this); } } } private void createHighPanel() { highPanel.setSize(150,500); highPanel.setLayout(new FlowLayout()); highPanel.add(panelM); scrollPane.setPreferredSize(new Dimension(300, 136)); highPanel.add(scrollPane); } private void createLowPanel() { lowPanel.add(panelE); text.setEditable(false); lowPanel.add(text); } private void createFrame() { frame.setSize(900,700); frame.setLayout(new GridLayout(2, 1)); frame.add(highPanel); frame.add(lowPanel); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize(); Dimension labelSize = frame.getPreferredSize(); frame.setLocation(screenSize.width/2 - (labelSize.width/2), screenSize.height/2 - (labelSize.height/2)); } public void actionPerformed(ActionEvent e) { if(endGame == true) return; String command = (e.getActionCommand()); text.setText(command); int x = Integer.parseInt(String.valueOf(command.substring(0,1))); int y = Integer.parseInt(String.valueOf(command.substring(1,2))); if(play1.takeAim(play2, x, y)) text.setText(play1.getName() + \" got a successful shot!\\n\"); else text.setText(play1.getName() + \" missed the shot.\\n\"); int updateCount2 = count2.destroyedUpdate(); if(updateCount2 != -1) text.append(play2.getName() + \"'s \" + updateCount2 + \" length ship was destroyed!\\n\"); changeButtonE(x, y); if(play2.takeAim(play1, 0, 0)) text.append(play2.getName() + \" got a successful shot!\\n\"); else text.append(play2.getName() + \" missed the shot.\\n\"); int updateCount1 = count1.destroyedUpdate(); if(updateCount1 != -1) text.append(play1.getName() + \"'s \" + updateCount1 + \" length ship was destroyed!\\n\"); changeButtonM(); updateTable(); checkEnd(); } private void changeButtonE(int x, int y) { String txt = play1.checkBlockE(x,y); buttonE[x][y].setText(txt); buttonE[x][y].setEnabled(false); if(txt.equals(\"X\")) buttonE[x][y].setBackground(new Color(170,255,153)); else buttonE[x][y].setBackground(new Color(204,247,255)); } private void changeButtonM() { for(int i = 0; i < 10; i++) { for(int j = 0; j < 10; j++) { String txt = play2.checkBlockE(j,i); buttonM[j][i].setText(txt); if(txt.equals(\"X\")) buttonM[j][i].setBackground(new Color(255,179,204)); else if(txt.equals(\"+\")) buttonM[j][i].setBackground(new Color(234,230,255)); } } } private void updateTable() { table.setModel(new DefaultTableModel(tableContent(), columnNames)); } private void checkEnd() { if(count1.allDestroyed() && count2.allDestroyed()) { text.append(\"Game ends in draw!\\n\"); endGame = true; } else if(count1.allDestroyed()) { text.append(play2.getName() + \" wins the game!\\n\"); endGame = true; } else if(count2.allDestroyed()) { text.append(play1.getName() + \" wins the game!\\n\"); endGame = true; } } }", "dependencies": [{"file_path": "Battleship-main/src/Player/Computer.java", "file_content": "package Player; import Ship.Ship; import java.util.Random; import FileExceptions.BadFileException; public class Computer extends Player { public Computer(String name) { super(name); } public void createGridMine() throws BadFileException { gridM.create(); Random random = new Random(); int shipN[] = {5, 4, 3, 2, 2, 1, 1}; for(int i:shipN) { boolean next = false; int x = 0; int y = 0; String dir[] = {\"r\", \"d\"}; int dirN = 0; while(next == false) { x = random.nextInt(10); y = random.nextInt(10); dirN = random.nextInt(2); next = gridM.checkShip(i, x, y, dir[dirN]); } Ship temp = new Ship(i, x, y, dir[dirN]); ship.add(temp); gridM.place(temp); } } public boolean takeAim(Player pers, int x, int y) { boolean shot = false; Random random = new Random(); boolean next = false; while(next == false) { x = random.nextInt(10); y = random.nextInt(10); if(gridE.checkShot(x, y) == true) { shot = pers.shot(x, y); gridE.mark(x, y, shot); next = true; } } return shot; } }"}, {"file_path": "Battleship-main/src/Player/Person.java", "file_content": "package Player; import Ship.Ship; import java.io.BufferedReader; import java.io.FileReader; import java.io.IOException; import FileExceptions.BadFileException; public class Person extends Player { public Person(String name) { super(name); } public void createGridMine() throws BadFileException { String fl = \"src/ships.txt\"; gridM.create(); try { FileReader fr = new FileReader(fl); BufferedReader read = new BufferedReader(fr); String line; String coord[] = new String[4]; for(int i = 0; i < 7; i++) { line = read.readLine(); if(line.length() != 7) { fr.close(); read.close(); throw new BadFileException(2); } coord = line.split(\";\"); try { int n = Integer.parseInt(coord[0]); int x = Integer.parseInt(coord[1]); int y = Integer.parseInt(coord[2]); String dir = coord[3]; if(n > 5 || x > 9 || y > 9 || (!dir.equals(\"r\") && !dir.equals(\"d\") && !dir.equals(\"0\"))) { fr.close(); read.close(); throw new BadFileException(2); } Ship temp = new Ship(n, x, y, dir); ship.add(temp); gridM.place(temp); } catch(NullPointerException n) { fr.close(); read.close(); throw new BadFileException(2); } } fr.close(); read.close(); } catch (IOException e) { throw new BadFileException(1); } } public boolean takeAim(Player comp, int x, int y) { boolean shot = comp.shot(x, y); gridE.mark(x, y, shot); return shot; } }"}, {"file_path": "Battleship-main/src/Player/Player.java", "file_content": "package Player; import FileExceptions.BadFileException; import Structure.Gridline; import Ship.Ship; import java.util.*; public abstract class Player { protected Gridline gridM; protected Gridline gridE; protected List<Ship> ship; protected String name; Player(String name) { this.name = name; ship = new ArrayList<>(); gridM = new Gridline(10,10); gridE = new Gridline(10,10); createGridEnem(); } public abstract boolean takeAim(Player pers, int x, int y); public abstract void createGridMine() throws BadFileException; public void createGridEnem() { gridE.create(); } public Gridline gridlineMine() { return gridM; } public boolean shot(int x, int y) { return gridM.shot(x, y); } public String checkBlockM(int x, int y) { return gridM.checkBlock(x, y); } public String checkBlockE(int x, int y) { return gridE.checkBlock(x, y); } public String getName() { return name; } public List<Ship> getShips() { return ship; } }"}, {"file_path": "Battleship-main/src/Ship/ShipCount.java", "file_content": "package Ship; import Player.Player; import java.util.*; public class ShipCount { LinkedHashMap<Ship, Boolean> ships = new LinkedHashMap<Ship, Boolean>(); public int destroyed; public boolean allDestroyed; public ShipCount(Player play) { play.getShips().forEach( (i) -> {ships.put(i, false);}); destroyed = 0; allDestroyed = false; } public int destroyedUpdate() { for(Ship i : ships.keySet()) { if(i.destroyed != ships.get(i)) { ships.put(i, true); destroyed = i.n; return i.n; } } return -1; } public boolean allDestroyed() { int count = 0; for(boolean i : ships.values()) if(i == true) count++; if(count == 7) { allDestroyed = true; return true; } else return false; } public Collection<Boolean> getDestroyed() { return ships.values(); } }"}, {"file_path": "Battleship-main/src/FileExceptions/BadFileException.java", "file_content": "package FileExceptions; import javax.swing.JFrame; import javax.swing.JTextArea; public class BadFileException extends Exception { private static final long serialVersionUID = 8040711871203333974L; private int status; public BadFileException(int status) { this.status = status; } public void printMessage() { JFrame frame = new JFrame(); JTextArea text = new JTextArea(\"\",10,25); frame.setSize(200,100); text.setEditable(false); if(status == 1) text.setText(\"No file found.\"); else if(status == 2) text.setText(\"File's data is incorrect.\"); frame.add(text); frame.setVisible(true); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } }"}, {"file_path": "Battleship-main/src/MainFrame.java", "file_content": "import Player.Computer; import Player.Person; import Player.Player; import Ship.ShipCount; import java.awt.*; import java.awt.event.*; import javax.swing.*; import javax.swing.table.DefaultTableModel; import FileExceptions.BadFileException; import java.util.*; public class MainFrame implements ActionListener { private static MainFrame main = new MainFrame(); private JFrame frame; private JButton buttonM[][]; private JPanel panelM; private JButton buttonE[][]; private JPanel panelE; private JPanel lowPanel; private JPanel highPanel; private JTextArea text; private Player play1; private ShipCount count1; private Player play2; private ShipCount count2; private String infoMess = \"Click any button on the left to start the game.\"; private JTable table; private String[] columnNames; private JScrollPane scrollPane; private boolean endGame; private MainFrame() {} public static MainFrame getMainFrame() { return main; } protected boolean startMain(String protag, String antag) { play1 = new Person(protag); play2 = new Computer(antag); try { play1.createGridMine(); play2.createGridMine(); } catch(BadFileException e) { e.printMessage(); return false; } initiateComponents(); frame.setVisible(true); return true; } private void initiateComponents() { count1 = new ShipCount(play1); count2 = new ShipCount(play2); frame = new JFrame(\"BattleShip\"); buttonM = new JButton[10][10]; panelM = new JPanel(); buttonE = new JButton[10][10]; panelE = new JPanel(); lowPanel = new JPanel(); highPanel = new JPanel(); text = new JTextArea(infoMess,10,25); columnNames = new String[] { \"Length\", play1.getName(), play2.getName() }; table = new JTable(tableContent(), columnNames); scrollPane = new JScrollPane(table, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_NEVER); createPanelM(); createPanelE(); createHighPanel(); createLowPanel(); createFrame(); } public Splash startSplash1() { Splash splash1 = new Splash(1, count2, frame); return splash1; } public Splash startSplash2() { Splash splash2 = new Splash(2, count1, frame); return splash2; } private Object[][] tableContent() { Object[][] data = new Object[7][3]; ArrayList<Integer> sizes = new ArrayList<Integer>(); Collections.addAll(sizes, 5, 4, 3, 2, 2, 1, 1); Iterator<Integer> sizesIt = sizes.iterator(); Iterator<Boolean> count1It = count1.getDestroyed().iterator(); Iterator<Boolean> count2It = count2.getDestroyed().iterator(); for(Object[] obj: data) { obj[0] = sizesIt.next(); obj[1] = count1It.next(); obj[2] = count2It.next(); } return data; } private void createPanelM() { panelM.setLayout(new GridLayout(10, 10)); panelM.setPreferredSize(new Dimension(450, 300)); for(int i = 0; i < 10; i++) { for(int j = 0; j < 10; j++) { buttonM[j][i] = new JButton(); buttonM[j][i].setText(play1.checkBlockM(j,i)); buttonM[j][i].setBackground(Color.WHITE); buttonM[j][i].setEnabled(false); panelM.add(buttonM[j][i]); } } } private void createPanelE() { panelE.setLayout(new GridLayout(10, 10)); panelE.setPreferredSize(new Dimension(450, 300)); for(int i = 0; i < 10; i++) { for(int j = 0; j < 10; j++) { buttonE[j][i] = new JButton(); buttonE[j][i].setText(\".\"); buttonE[j][i].setBackground(Color.WHITE); panelE.add(buttonE[j][i]); buttonE[j][i].setActionCommand(String.valueOf(j)+String.valueOf(i)); buttonE[j][i].addActionListener(this); } } } private void createHighPanel() { highPanel.setSize(150,500); highPanel.setLayout(new FlowLayout()); highPanel.add(panelM); scrollPane.setPreferredSize(new Dimension(300, 136)); highPanel.add(scrollPane); } private void createLowPanel() { lowPanel.add(panelE); text.setEditable(false); lowPanel.add(text); } private void createFrame() { frame.setSize(900,700); frame.setLayout(new GridLayout(2, 1)); frame.add(highPanel); frame.add(lowPanel); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize(); Dimension labelSize = frame.getPreferredSize(); frame.setLocation(screenSize.width/2 - (labelSize.width/2), screenSize.height/2 - (labelSize.height/2)); } public void actionPerformed(ActionEvent e) { if(endGame == true) return; String command = (e.getActionCommand()); text.setText(command); int x = Integer.parseInt(String.valueOf(command.substring(0,1))); int y = Integer.parseInt(String.valueOf(command.substring(1,2))); if(play1.takeAim(play2, x, y)) text.setText(play1.getName() + \" got a successful shot!\\n\"); else text.setText(play1.getName() + \" missed the shot.\\n\"); int updateCount2 = count2.destroyedUpdate(); if(updateCount2 != -1) text.append(play2.getName() + \"'s \" + updateCount2 + \" length ship was destroyed!\\n\"); changeButtonE(x, y); if(play2.takeAim(play1, 0, 0)) text.append(play2.getName() + \" got a successful shot!\\n\"); else text.append(play2.getName() + \" missed the shot.\\n\"); int updateCount1 = count1.destroyedUpdate(); if(updateCount1 != -1) text.append(play1.getName() + \"'s \" + updateCount1 + \" length ship was destroyed!\\n\"); changeButtonM(); updateTable(); checkEnd(); } private void changeButtonE(int x, int y) { String txt = play1.checkBlockE(x,y); buttonE[x][y].setText(txt); buttonE[x][y].setEnabled(false); if(txt.equals(\"X\")) buttonE[x][y].setBackground(new Color(170,255,153)); else buttonE[x][y].setBackground(new Color(204,247,255)); } private void changeButtonM() { for(int i = 0; i < 10; i++) { for(int j = 0; j < 10; j++) { String txt = play2.checkBlockE(j,i); buttonM[j][i].setText(txt); if(txt.equals(\"X\")) buttonM[j][i].setBackground(new Color(255,179,204)); else if(txt.equals(\"+\")) buttonM[j][i].setBackground(new Color(234,230,255)); } } } private void updateTable() { table.setModel(new DefaultTableModel(tableContent(), columnNames)); } private void checkEnd() { if(count1.allDestroyed() && count2.allDestroyed()) { text.append(\"Game ends in draw!\\n\"); endGame = true; } else if(count1.allDestroyed()) { text.append(play2.getName() + \" wins the game!\\n\"); endGame = true; } else if(count2.allDestroyed()) { text.append(play1.getName() + \" wins the game!\\n\"); endGame = true; } } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Battleship-main/src/MainFrame.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "MainFrame handles UI construction, game logic, event handling, and state management. Changes in any of these areas would require modifying the class, violating SRP."}, {"principle": "Dependency Inversion", "justification": "MainFrame directly instantiates concrete Player implementations (Person, Computer) instead of depending on abstractions, creating tight coupling between high-level and low-level modules."}]}, {"file_path": "Battleship-main/src/Player/Computer.java", "violatedPrinciples": [{"principle": "Liskov", "justification": "Computer's takeAim ignores x/y parameters and uses random values, breaking substitutability with Person's parameter-dependent implementation. Clients cannot rely on consistent method behavior across subtypes."}]}, {"file_path": "Battleship-main/src/FileExceptions/BadFileException.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "BadFileException handles both error signaling and UI presentation (creating JFrame/JTextArea). Exception classes should focus on error propagation, not display logic."}]}]}
{"project_id": 58, "chunk_id": 0, "prompt": {"main_file_path": "Battleship-main/src/Game.java", "main_file_content": "public class Game { public static void main(String[] args) { MainFrame mainFrame = MainFrame.getMainFrame(); if(mainFrame.startMain(\"Protagonist\", \"Antagonist\")) { Splash splash1 = mainFrame.startSplash1(); Splash splash2 = mainFrame.startSplash2(); splash1.start(); splash2.start(); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Battleship-main/src/Game.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "The Game class directly instantiates concrete MainFrame and Splash classes without depending on abstractions. High-level modules should depend on interfaces/abstract classes rather than concrete implementations."}]}]}
{"project_id": 58, "chunk_id": 0, "prompt": {"main_file_path": "Battleship-main/src/FileExceptions/BadFileException.java", "main_file_content": "package FileExceptions; import javax.swing.JFrame; import javax.swing.JTextArea; public class BadFileException extends Exception { private static final long serialVersionUID = 8040711871203333974L; private int status; public BadFileException(int status) { this.status = status; } public void printMessage() { JFrame frame = new JFrame(); JTextArea text = new JTextArea(\"\",10,25); frame.setSize(200,100); text.setEditable(false); if(status == 1) text.setText(\"No file found.\"); else if(status == 2) text.setText(\"File's data is incorrect.\"); frame.add(text); frame.setVisible(true); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Battleship-main/src/FileExceptions/BadFileException.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "BadFileException handles both exception logic and UI presentation (creating JFrame, JTextArea). These are two distinct responsibilities, violating SRP."}, {"principle": "Open-Closed", "justification": "Adding a new error status requires modifying printMessage's conditional logic, violating OCP as the class isn't closed for modification."}, {"principle": "Dependency Inversion", "justification": "BadFileException directly instantiates low-level UI components (JFrame, JTextArea) instead of depending on abstractions, violating DIP."}]}]}
{"project_id": 58, "chunk_id": 0, "prompt": {"main_file_path": "Battleship-main/src/Ship/Ship.java", "main_file_content": "package Ship; import Structure.Block; import java.util.*; public class Ship { private List<Block> place; public int n; public int x; public int y; public String dir; public boolean destroyed; private int lives; public Ship(int n, int x, int y, String dir) { this.n = n; this.x = x; this.y = y; this.dir = dir; destroyed = false; place = new ArrayList<>(); lives = n; } public void place(Block block) { place.add(block); } public void shot() { --lives; if(lives == 0) destroyed = true; } }", "dependencies": [{"file_path": "Battleship-main/src/Structure/Block.java", "file_content": "package Structure; import Ship.Ship; public class Block implements Structure { public int x; public int y; public String show; public boolean placed; public boolean shot; public Ship ship; public Block(int x, int y) { this.x = x; this.y = y; create(); } public void create() { show = \".\"; placed = false; shot = false; } public void shot(boolean hit) { shot = true; if(hit == true) show = \"X\"; else show = \"+\"; if(placed == true) ship.shot(); } public void place(Ship ship) { this.ship = ship; placed = true; show = \"O\"; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Battleship-main/src/Ship/Ship.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Ship class manages ship placement, damage tracking, and destruction, which are multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Ship is not designed for extension (e.g., new ship types require modifying existing code)."}, {"principle": "Dependency Inversion", "justification": "Ship depends on concrete Block instead of an abstraction."}]}, {"file_path": "Battleship-main/src/Structure/Block.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Block handles state management, shot handling, and ship placement, multiple responsibilities."}, {"principle": "Dependency Inversion", "justification": "Block depends on concrete Ship instead of an abstraction."}]}]}
{"project_id": 58, "chunk_id": 0, "prompt": {"main_file_path": "Battleship-main/src/Ship/ShipCount.java", "main_file_content": "package Ship; import Player.Player; import java.util.*; public class ShipCount { LinkedHashMap<Ship, Boolean> ships = new LinkedHashMap<Ship, Boolean>(); public int destroyed; public boolean allDestroyed; public ShipCount(Player play) { play.getShips().forEach( (i) -> {ships.put(i, false);}); destroyed = 0; allDestroyed = false; } public int destroyedUpdate() { for(Ship i : ships.keySet()) { if(i.destroyed != ships.get(i)) { ships.put(i, true); destroyed = i.n; return i.n; } } return -1; } public boolean allDestroyed() { int count = 0; for(boolean i : ships.values()) if(i == true) count++; if(count == 7) { allDestroyed = true; return true; } else return false; } public Collection<Boolean> getDestroyed() { return ships.values(); } }", "dependencies": [{"file_path": "Battleship-main/src/Player/Player.java", "file_content": "package Player; import FileExceptions.BadFileException; import Structure.Gridline; import Ship.Ship; import java.util.*; public abstract class Player { protected Gridline gridM; protected Gridline gridE; protected List<Ship> ship; protected String name; Player(String name) { this.name = name; ship = new ArrayList<>(); gridM = new Gridline(10,10); gridE = new Gridline(10,10); createGridEnem(); } public abstract boolean takeAim(Player pers, int x, int y); public abstract void createGridMine() throws BadFileException; public void createGridEnem() { gridE.create(); } public Gridline gridlineMine() { return gridM; } public boolean shot(int x, int y) { return gridM.shot(x, y); } public String checkBlockM(int x, int y) { return gridM.checkBlock(x, y); } public String checkBlockE(int x, int y) { return gridE.checkBlock(x, y); } public String getName() { return name; } public List<Ship> getShips() { return ship; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Battleship-main/src/Ship/ShipCount.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "ShipCount tracks individual ship destruction and checks if all are destroyed. The hard-coded check for 7 destroyed ships introduces a second responsibility, requiring changes if the total ships count varies."}]}]}
{"project_id": 58, "chunk_id": 0, "prompt": {"main_file_path": "Battleship-main/src/Structure/Structure.java", "main_file_content": "package Structure; import Ship.Ship; interface Structure { void place(Ship ship); void create(); }", "dependencies": [{"file_path": "Battleship-main/src/Ship/Ship.java", "file_content": "package Ship; import Structure.Block; import java.util.*; public class Ship { private List<Block> place; public int n; public int x; public int y; public String dir; public boolean destroyed; private int lives; public Ship(int n, int x, int y, String dir) { this.n = n; this.x = x; this.y = y; this.dir = dir; destroyed = false; place = new ArrayList<>(); lives = n; } public void place(Block block) { place.add(block); } public void shot() { --lives; if(lives == 0) destroyed = true; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Battleship-main/src/Ship/Ship.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Ship class manages placement of blocks, tracks lives, and destruction state. These are multiple responsibilities requiring change for different reasons (e.g., placement logic, damage handling)."}, {"principle": "Dependency Inversion", "justification": "Ship directly depends on concrete Structure.Block. High-level Ship should depend on abstractions for blocks, not a concrete implementation from a low-level module."}]}]}
{"project_id": 58, "chunk_id": 0, "prompt": {"main_file_path": "Battleship-main/src/Structure/Gridline.java", "main_file_content": "package Structure; import Ship.Ship; public class Gridline implements Structure { private int x; private int y; private Block grid[][]; public Gridline(int x, int y) { this.x = x; this.y = y; } public void create() { grid = new Block[this.x][this.y]; for(int i = 0; i < this.x; i++) { for(int j = 0; j < this.y; j++) grid[i][j] = new Block(i,j); } } public boolean checkShot(int x, int y) { if(grid[x][y].shot == false) return true; else return false; } public boolean checkShip(int n, int x, int y, String dir) { if(n == 1) return !grid[x][y].placed; if(dir.equals(\"r\") && x+n < 10) { for(int i = 0; i < n; i++) { if(grid[x+i][y].placed == true) return false; } return true; } if(dir.equals(\"d\") && y+n < 10) { for(int i = 0; i < n; i++) { if(grid[x][y+i].placed == true) return false; } return true; } return false; } public String checkBlock(int x, int y) { return grid[x][y].show; } public void place(Ship ship) { int x = ship.x; int y = ship.y; int n = ship.n; String dir = ship.dir; if(n == 1) { grid[x][y].place(ship); ship.place(grid[x][y]); return; } if(dir.equals(\"r\")) { for(int i = 0; i < n; i++) { grid[x+i][y].place(ship); ship.place(grid[x+i][y]); } return; } if(dir.equals(\"d\")) { for(int i = 0; i < n; i++) { grid[x][y+i].place(ship); ship.place(grid[x][y+i]); } return; } } public boolean shot(int x, int y) { grid[x][y].shot(grid[x][y].placed); return grid[x][y].placed; } public void mark(int x, int y, boolean hit) { grid[x][y].shot(hit); } }", "dependencies": [{"file_path": "Battleship-main/src/Ship/Ship.java", "file_content": "package Ship; import Structure.Block; import java.util.*; public class Ship { private List<Block> place; public int n; public int x; public int y; public String dir; public boolean destroyed; private int lives; public Ship(int n, int x, int y, String dir) { this.n = n; this.x = x; this.y = y; this.dir = dir; destroyed = false; place = new ArrayList<>(); lives = n; } public void place(Block block) { place.add(block); } public void shot() { --lives; if(lives == 0) destroyed = true; } }"}, {"file_path": "Battleship-main/src/Structure/Block.java", "file_content": "package Structure; import Ship.Ship; public class Block implements Structure { public int x; public int y; public String show; public boolean placed; public boolean shot; public Ship ship; public Block(int x, int y) { this.x = x; this.y = y; create(); } public void create() { show = \".\"; placed = false; shot = false; } public void shot(boolean hit) { shot = true; if(hit == true) show = \"X\"; else show = \"+\"; if(placed == true) ship.shot(); } public void place(Ship ship) { this.ship = ship; placed = true; show = \"O\"; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Battleship-main/src/Structure/Gridline.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Gridline manages grid creation, shot validation, ship placement, and block interaction. These multiple responsibilities indicate a violation of SRP."}, {"principle": "Open-Closed", "justification": "checkShip and place methods use conditional checks for direction (\"r\" and \"d\"). Adding new directions would require modifying existing code, violating OCP."}, {"principle": "Dependency Inversion", "justification": "Gridline directly instantiates Block and depends on Ship concretions. High-level modules should depend on abstractions, not low-level implementations."}]}, {"file_path": "Battleship-main/src/Ship/Ship.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "Ship directly depends on Block (concrete class) in its place method. High-level modules should not depend on low-level concretions."}]}, {"file_path": "Battleship-main/src/Structure/Block.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "Block directly depends on Ship (concrete class) in its place method. Low-level modules should implement abstractions, not be referenced directly."}]}]}
{"project_id": 58, "chunk_id": 0, "prompt": {"main_file_path": "Battleship-main/src/Structure/Block.java", "main_file_content": "package Structure; import Ship.Ship; public class Block implements Structure { public int x; public int y; public String show; public boolean placed; public boolean shot; public Ship ship; public Block(int x, int y) { this.x = x; this.y = y; create(); } public void create() { show = \".\"; placed = false; shot = false; } public void shot(boolean hit) { shot = true; if(hit == true) show = \"X\"; else show = \"+\"; if(placed == true) ship.shot(); } public void place(Ship ship) { this.ship = ship; placed = true; show = \"O\"; } }", "dependencies": [{"file_path": "Battleship-main/src/Ship/Ship.java", "file_content": "package Ship; import Structure.Block; import java.util.*; public class Ship { private List<Block> place; public int n; public int x; public int y; public String dir; public boolean destroyed; private int lives; public Ship(int n, int x, int y, String dir) { this.n = n; this.x = x; this.y = y; this.dir = dir; destroyed = false; place = new ArrayList<>(); lives = n; } public void place(Block block) { place.add(block); } public void shot() { --lives; if(lives == 0) destroyed = true; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Battleship-main/src/Structure/Block.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Block manages its own state (show, placed, shot) and directly coordinates with Ship by calling ship.shot(), indicating multiple responsibilities."}, {"principle": "Dependency Inversion", "justification": "Block depends on the concrete Ship class (via field and place(Ship) method) instead of an abstraction, violating DIP."}]}, {"file_path": "Battleship-main/src/Ship/Ship.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "Ship directly depends on the concrete Block class (via place(Block) method and List<Block>) instead of an abstraction, violating DIP."}]}]}
{"project_id": 58, "chunk_id": 0, "prompt": {"main_file_path": "Battleship-main/src/Player/Computer.java", "main_file_content": "package Player; import Ship.Ship; import java.util.Random; import FileExceptions.BadFileException; public class Computer extends Player { public Computer(String name) { super(name); } public void createGridMine() throws BadFileException { gridM.create(); Random random = new Random(); int shipN[] = {5, 4, 3, 2, 2, 1, 1}; for(int i:shipN) { boolean next = false; int x = 0; int y = 0; String dir[] = {\"r\", \"d\"}; int dirN = 0; while(next == false) { x = random.nextInt(10); y = random.nextInt(10); dirN = random.nextInt(2); next = gridM.checkShip(i, x, y, dir[dirN]); } Ship temp = new Ship(i, x, y, dir[dirN]); ship.add(temp); gridM.place(temp); } } public boolean takeAim(Player pers, int x, int y) { boolean shot = false; Random random = new Random(); boolean next = false; while(next == false) { x = random.nextInt(10); y = random.nextInt(10); if(gridE.checkShot(x, y) == true) { shot = pers.shot(x, y); gridE.mark(x, y, shot); next = true; } } return shot; } }", "dependencies": [{"file_path": "Battleship-main/src/Ship/Ship.java", "file_content": "package Ship; import Structure.Block; import java.util.*; public class Ship { private List<Block> place; public int n; public int x; public int y; public String dir; public boolean destroyed; private int lives; public Ship(int n, int x, int y, String dir) { this.n = n; this.x = x; this.y = y; this.dir = dir; destroyed = false; place = new ArrayList<>(); lives = n; } public void place(Block block) { place.add(block); } public void shot() { --lives; if(lives == 0) destroyed = true; } }"}, {"file_path": "Battleship-main/src/FileExceptions/BadFileException.java", "file_content": "package FileExceptions; import javax.swing.JFrame; import javax.swing.JTextArea; public class BadFileException extends Exception { private static final long serialVersionUID = 8040711871203333974L; private int status; public BadFileException(int status) { this.status = status; } public void printMessage() { JFrame frame = new JFrame(); JTextArea text = new JTextArea(\"\",10,25); frame.setSize(200,100); text.setEditable(false); if(status == 1) text.setText(\"No file found.\"); else if(status == 2) text.setText(\"File's data is incorrect.\"); frame.add(text); frame.setVisible(true); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Battleship-main/src/Player/Computer.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Computer class handles grid creation, ship placement, and attack logic. These multiple responsibilities increase the likelihood of changes due to unrelated causes."}, {"principle": "Dependency Inversion", "justification": "Computer directly instantiates concrete Ship objects. High-level modules should depend on abstractions rather than concrete implementations."}]}, {"file_path": "Battleship-main/src/FileExceptions/BadFileException.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "BadFileException mixes exception handling with UI presentation (JFrame/JTextArea). Exception classes should not manage user interface components."}]}]}
{"project_id": 58, "chunk_id": 0, "prompt": {"main_file_path": "Battleship-main/src/Player/Person.java", "main_file_content": "package Player; import Ship.Ship; import java.io.BufferedReader; import java.io.FileReader; import java.io.IOException; import FileExceptions.BadFileException; public class Person extends Player { public Person(String name) { super(name); } public void createGridMine() throws BadFileException { String fl = \"src/ships.txt\"; gridM.create(); try { FileReader fr = new FileReader(fl); BufferedReader read = new BufferedReader(fr); String line; String coord[] = new String[4]; for(int i = 0; i < 7; i++) { line = read.readLine(); if(line.length() != 7) { fr.close(); read.close(); throw new BadFileException(2); } coord = line.split(\";\"); try { int n = Integer.parseInt(coord[0]); int x = Integer.parseInt(coord[1]); int y = Integer.parseInt(coord[2]); String dir = coord[3]; if(n > 5 || x > 9 || y > 9 || (!dir.equals(\"r\") && !dir.equals(\"d\") && !dir.equals(\"0\"))) { fr.close(); read.close(); throw new BadFileException(2); } Ship temp = new Ship(n, x, y, dir); ship.add(temp); gridM.place(temp); } catch(NullPointerException n) { fr.close(); read.close(); throw new BadFileException(2); } } fr.close(); read.close(); } catch (IOException e) { throw new BadFileException(1); } } public boolean takeAim(Player comp, int x, int y) { boolean shot = comp.shot(x, y); gridE.mark(x, y, shot); return shot; } }", "dependencies": [{"file_path": "Battleship-main/src/Ship/Ship.java", "file_content": "package Ship; import Structure.Block; import java.util.*; public class Ship { private List<Block> place; public int n; public int x; public int y; public String dir; public boolean destroyed; private int lives; public Ship(int n, int x, int y, String dir) { this.n = n; this.x = x; this.y = y; this.dir = dir; destroyed = false; place = new ArrayList<>(); lives = n; } public void place(Block block) { place.add(block); } public void shot() { --lives; if(lives == 0) destroyed = true; } }"}, {"file_path": "Battleship-main/src/FileExceptions/BadFileException.java", "file_content": "package FileExceptions; import javax.swing.JFrame; import javax.swing.JTextArea; public class BadFileException extends Exception { private static final long serialVersionUID = 8040711871203333974L; private int status; public BadFileException(int status) { this.status = status; } public void printMessage() { JFrame frame = new JFrame(); JTextArea text = new JTextArea(\"\",10,25); frame.setSize(200,100); text.setEditable(false); if(status == 1) text.setText(\"No file found.\"); else if(status == 2) text.setText(\"File's data is incorrect.\"); frame.add(text); frame.setVisible(true); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Battleship-main/src/Player/Person.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The createGridMine method handles file I/O, data validation, ship creation, and grid placement. These multiple responsibilities violate SRP as the class has more than one reason to change."}, {"principle": "Dependency Inversion", "justification": "Person directly instantiates Ship (a concrete implementation) and depends on BadFileException (another concrete class). High-level modules should depend on abstractions rather than concrete implementations."}]}, {"file_path": "Battleship-main/src/FileExceptions/BadFileException.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "BadFileException handles both error encapsulation and UI presentation (creating JFrame/JTextArea). Mixing exception logic with UI concerns violates SRP."}]}]}
{"project_id": 58, "chunk_id": 0, "prompt": {"main_file_path": "Battleship-main/src/Player/Player.java", "main_file_content": "package Player; import FileExceptions.BadFileException; import Structure.Gridline; import Ship.Ship; import java.util.*; public abstract class Player { protected Gridline gridM; protected Gridline gridE; protected List<Ship> ship; protected String name; Player(String name) { this.name = name; ship = new ArrayList<>(); gridM = new Gridline(10,10); gridE = new Gridline(10,10); createGridEnem(); } public abstract boolean takeAim(Player pers, int x, int y); public abstract void createGridMine() throws BadFileException; public void createGridEnem() { gridE.create(); } public Gridline gridlineMine() { return gridM; } public boolean shot(int x, int y) { return gridM.shot(x, y); } public String checkBlockM(int x, int y) { return gridM.checkBlock(x, y); } public String checkBlockE(int x, int y) { return gridE.checkBlock(x, y); } public String getName() { return name; } public List<Ship> getShips() { return ship; } }", "dependencies": [{"file_path": "Battleship-main/src/FileExceptions/BadFileException.java", "file_content": "package FileExceptions; import javax.swing.JFrame; import javax.swing.JTextArea; public class BadFileException extends Exception { private static final long serialVersionUID = 8040711871203333974L; private int status; public BadFileException(int status) { this.status = status; } public void printMessage() { JFrame frame = new JFrame(); JTextArea text = new JTextArea(\"\",10,25); frame.setSize(200,100); text.setEditable(false); if(status == 1) text.setText(\"No file found.\"); else if(status == 2) text.setText(\"File's data is incorrect.\"); frame.add(text); frame.setVisible(true); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } }"}, {"file_path": "Battleship-main/src/Structure/Gridline.java", "file_content": "package Structure; import Ship.Ship; public class Gridline implements Structure { private int x; private int y; private Block grid[][]; public Gridline(int x, int y) { this.x = x; this.y = y; } public void create() { grid = new Block[this.x][this.y]; for(int i = 0; i < this.x; i++) { for(int j = 0; j < this.y; j++) grid[i][j] = new Block(i,j); } } public boolean checkShot(int x, int y) { if(grid[x][y].shot == false) return true; else return false; } public boolean checkShip(int n, int x, int y, String dir) { if(n == 1) return !grid[x][y].placed; if(dir.equals(\"r\") && x+n < 10) { for(int i = 0; i < n; i++) { if(grid[x+i][y].placed == true) return false; } return true; } if(dir.equals(\"d\") && y+n < 10) { for(int i = 0; i < n; i++) { if(grid[x][y+i].placed == true) return false; } return true; } return false; } public String checkBlock(int x, int y) { return grid[x][y].show; } public void place(Ship ship) { int x = ship.x; int y = ship.y; int n = ship.n; String dir = ship.dir; if(n == 1) { grid[x][y].place(ship); ship.place(grid[x][y]); return; } if(dir.equals(\"r\")) { for(int i = 0; i < n; i++) { grid[x+i][y].place(ship); ship.place(grid[x+i][y]); } return; } if(dir.equals(\"d\")) { for(int i = 0; i < n; i++) { grid[x][y+i].place(ship); ship.place(grid[x][y+i]); } return; } } public boolean shot(int x, int y) { grid[x][y].shot(grid[x][y].placed); return grid[x][y].placed; } public void mark(int x, int y, boolean hit) { grid[x][y].shot(hit); } }"}, {"file_path": "Battleship-main/src/Ship/Ship.java", "file_content": "package Ship; import Structure.Block; import java.util.*; public class Ship { private List<Block> place; public int n; public int x; public int y; public String dir; public boolean destroyed; private int lives; public Ship(int n, int x, int y, String dir) { this.n = n; this.x = x; this.y = y; this.dir = dir; destroyed = false; place = new ArrayList<>(); lives = n; } public void place(Block block) { place.add(block); } public void shot() { --lives; if(lives == 0) destroyed = true; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Battleship-main/src/FileExceptions/BadFileException.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "BadFileException handles both exception management and UI rendering (JFrame, JTextArea), combining error handling and user interface responsibilities."}, {"principle": "Dependency Inversion", "justification": "BadFileException directly depends on concrete UI classes (JFrame, JTextArea) instead of abstractions, violating the principle that high-level modules should not depend on low-level implementations."}]}, {"file_path": "Battleship-main/src/Player/Player.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "Player directly depends on concrete implementations (Gridline, Ship) instead of abstractions, violating the rule that high-level modules should depend on interfaces/abstract classes."}]}]}
{"project_id": 60, "chunk_id": 0, "prompt": {"main_file_path": "AirFare-Java-GUI-Project-master/Main.java", "main_file_content": "We want to provide a smooth transport experience for our audience. So we are developing an application for air transportation. Ther are 2 main companies that provide good services to our company. So let's create a program with the interface to show the fare details of these companies for traveling to different cities. Create AirFare as an interface and implement it in Indigo and AirIndia classes to show fair for requested travels. Strictly adhere to the Object-Oriented specifications given in the problem statement. All class names, attribute names and method names should be the same as specified in the problem statement. Create an interface AirFare with the following methods, Method Description public Double showFare(String sourceCity, String destinationCity); An abstract method Create a class Indigo which implements AirFare with the following methods, Method Name Description public Double showFare(String sourceCity, String destinationCity) This method will get the sourceCity and destinationCity as arguments and get the fare between the cities and return the Fare between two cities. public Map<String, Double> getIndigoFares() This method will contain all the fare details between source and destination cities for Indigo. This method will be previously given in the template code. Create a class AirIndia which implements AirFare with the following methods, Method Name Description public Double showFare(String sourceCity, String destinationCity) This method will get the sourceCity and destinationCity as arguments and get the fare between the cities and return the Fare between two cities. public Map<String, Double> getAirIndiaFares() This method will contain all the fare details between source and destination cities for Air India. This method will be previously given in the template code. Create a driver class Main to test the above classes. Input Format: The first input is a string that corresponds to the source city. The second input is a String which corresponds to the destination city. The next input is an integer that corresponds to the airline type. Output Format The output consists of the flight fare. Refer to sample output for formatting specifications. Note: All text in bold corresponds to input and rest corresponds to output. Sample Input and Output 1: Enter the source city: LONDON Enter the destination city: NEWYORK Enter the flight 1.Air India 2.Indigo 2 The fare is 20125.0 Sample Input and Output 2: Enter the source city: LONDON Enter the destination city: NEWYORK Enter the flight 1.Air India 2.Indigo 1 The fare is 21963.0", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "AirFare-Java-GUI-Project-master/Main.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Indigo and AirIndia classes handle both fare calculation and data management, violating SRP by having multiple responsibilities."}, {"principle": "Dependency Inversion", "justification": "Main class directly instantiates concrete Indigo/AirIndia classes, depending on implementations instead of abstractions."}]}]}
{"project_id": 60, "chunk_id": 0, "prompt": {"main_file_path": "AirFare-Java-GUI-Project-master/AirFare/src/main/java/com/sauravhathi/airfare/NewJFrame.java", "main_file_content": "package com.sauravhathi.airfare; import java.util.HashMap; import java.util.Map; import java.util.Scanner; import java.lang.String; interface AirFaree { public Double showFare(String sourceCity, String destinationCity); } class Indigo implements AirFaree { public Map<String, Double> getIndigoFares() { Map<String, Double> fares = new HashMap<String, Double>(); fares.put(\"LONDON-NEWYORK\", 20125D); fares.put(\"LONDON-PARIS\", 4268D); fares.put(\"LONDON-DUBAI\", 21586D); fares.put(\"LONDON-MUMBAI\", 32365D); fares.put(\"NEWYORK-PARIS\", 19853D); fares.put(\"NEWYORK-DUBAI\", 43658D); fares.put(\"NEWYORK-MUMBAI\", 45236D); fares.put(\"PARIS-DUBAI\", 38965D); fares.put(\"PARIS-MUMBAI\", 39812D); fares.put(\"DUBAI-MUMBAI\", 4449D); fares.put(\"NEWYORK-LONDON\", 20125D); fares.put(\"PARIS-LONDON\", 4268D); fares.put(\"DUBAI-LONDON\", 21586D); fares.put(\"MUMBAI-LONDON\", 32365D); fares.put(\"PARIS-NEWYORK\", 19853D); fares.put(\"DUBAI-NEWYORK\", 43658D); fares.put(\"MUMBAI-NEWYORK\", 45236D); fares.put(\"DUBAI-PARIS\", 38965D); fares.put(\"MUMBAI-PARIS\", 39812D); fares.put(\"MUMBAI-DUBAI\", 4449D); return fares; } public Double showFare(String sourceCity, String destinationCity) { Map<String, Double> fares = getIndigoFares(); return fares.get(sourceCity + \"-\" + destinationCity); } } class AirIndia implements AirFaree { public Map<String, Double> getAirIndiaFares() { Map<String, Double> fares = new HashMap<String, Double>(); fares.put(\"LONDON-NEWYORK\", 21963D); fares.put(\"LONDON-PARIS\", 4995D); fares.put(\"LONDON-DUBAI\", 25223D); fares.put(\"LONDON-MUMBAI\", 34990D); fares.put(\"NEWYORK-PARIS\", 20789D); fares.put(\"NEWYORK-DUBAI\", 44210D); fares.put(\"NEWYORK-MUMBAI\", 47337D); fares.put(\"PARIS-DUBAI\", 32547D); fares.put(\"PARIS-MUMBAI\", 40017D); fares.put(\"DUBAI-MUMBAI\", 4999D); fares.put(\"NEWYORK-LONDON\", 21963D); fares.put(\"PARIS-LONDON\", 4995D); fares.put(\"DUBAI-LONDON\", 25223D); fares.put(\"MUMBAI-LONDON\", 34990D); fares.put(\"PARIS-NEWYORK\", 20789D); fares.put(\"DUBAI-NEWYORK\", 44210D); fares.put(\"MUMBAI-NEWYORK\", 47337D); fares.put(\"DUBAI-PARIS\", 32547D); fares.put(\"MUMBAI-PARIS\", 40017D); fares.put(\"MUMBAI-DUBAI\", 4999D); return fares; } public Double showFare(String sourceCity, String destinationCity) { Map<String, Double> fares = getAirIndiaFares(); return fares.get(sourceCity + \"-\" + destinationCity); } } public class NewJFrame extends javax.swing.JFrame { public NewJFrame() { initComponents(); } @SuppressWarnings(\"unchecked\") private void initComponents() { buttonGroup1 = new javax.swing.ButtonGroup(); jLabel1 = new javax.swing.JLabel(); jLabel2 = new javax.swing.JLabel(); jTextField1 = new javax.swing.JTextField(); jLabel3 = new javax.swing.JLabel(); jTextField2 = new javax.swing.JTextField(); jButton1 = new javax.swing.JButton(); jLabel4 = new javax.swing.JLabel(); AirIndiaBtn = new javax.swing.JRadioButton(); IndigoBtn = new javax.swing.JRadioButton(); jLabel5 = new javax.swing.JLabel(); jLabel6 = new javax.swing.JLabel(); setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE); jLabel1.setFont(new java.awt.Font(\"Tahoma\", 1, 24)); jLabel1.setText(\"AirFare\"); jLabel2.setFont(new java.awt.Font(\"Tahoma\", 0, 14)); jLabel2.setText(\"Source City\"); jTextField1.setText(\"Enter the source city\"); jTextField1.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(java.awt.event.ActionEvent evt) { jTextField1ActionPerformed(evt); } }); jLabel3.setFont(new java.awt.Font(\"Tahoma\", 0, 14)); jLabel3.setText(\"Destination City\"); jTextField2.setText(\"Enter the destination city\"); jTextField2.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(java.awt.event.ActionEvent evt) { jTextField2ActionPerformed(evt); } }); jButton1.setBackground(new java.awt.Color(51, 51, 255)); jButton1.setFont(new java.awt.Font(\"Tahoma\", 1, 14)); jButton1.setForeground(new java.awt.Color(255, 255, 255)); jButton1.setText(\"Submit\"); jButton1.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(java.awt.event.ActionEvent evt) { jButton1ActionPerformed(evt); } }); jLabel4.setFont(new java.awt.Font(\"Tahoma\", 0, 12)); jLabel4.setToolTipText(\"\"); jLabel4.setVerticalAlignment(javax.swing.SwingConstants.TOP); buttonGroup1.add(AirIndiaBtn); AirIndiaBtn.setFont(new java.awt.Font(\"Tahoma\", 0, 12)); AirIndiaBtn.setText(\"Air India\"); buttonGroup1.add(IndigoBtn); IndigoBtn.setFont(new java.awt.Font(\"Tahoma\", 0, 12)); IndigoBtn.setText(\"Indigo\"); IndigoBtn.addActionListener(new java.awt.event.ActionListener() { public void actionPerformed(java.awt.event.ActionEvent evt) { IndigoBtnActionPerformed(evt); } }); jLabel5.setFont(new java.awt.Font(\"Tahoma\", 0, 12)); jLabel5.setText(\"The fare is:\"); jLabel6.setFont(new java.awt.Font(\"Tahoma\", 0, 14)); jLabel6.setText(\"Select the Flight\"); javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane()); getContentPane().setLayout(layout); layout.setHorizontalGroup( layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING) .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup() .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE) .addComponent(jLabel1) .addGap(185, 185, 185)) .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup() .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING) .addGroup(layout.createSequentialGroup() .addGap(0, 0, Short.MAX_VALUE) .addComponent(jLabel5) .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED) .addComponent(jLabel4, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)) .addGroup(layout.createSequentialGroup() .addGap(0, 118, Short.MAX_VALUE) .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING) .addGroup(layout.createSequentialGroup() .addComponent(jLabel6, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE) .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED) .addComponent(AirIndiaBtn) .addGap(26, 26, 26) .addComponent(IndigoBtn)) .addGroup(layout.createSequentialGroup() .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING) .addComponent(jLabel2) .addComponent(jLabel3)) .addGap(10, 10, 10) .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING) .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, 144, javax.swing.GroupLayout.PREFERRED_SIZE) .addComponent(jTextField2, javax.swing.GroupLayout.PREFERRED_SIZE, 146, javax.swing.GroupLayout.PREFERRED_SIZE) .addComponent(jButton1)))))) .addGap(97, 97, 97)) ); layout.setVerticalGroup( layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING) .addGroup(layout.createSequentialGroup() .addContainerGap(27, Short.MAX_VALUE) .addComponent(jLabel1) .addGap(26, 26, 26) .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE) .addComponent(jLabel2) .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)) .addGap(18, 18, 18) .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE) .addComponent(jLabel3) .addComponent(jTextField2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)) .addGap(31, 31, 31) .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE) .addComponent(AirIndiaBtn) .addComponent(IndigoBtn) .addComponent(jLabel6)) .addGap(26, 26, 26) .addComponent(jButton1) .addGap(33, 33, 33) .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING) .addComponent(jLabel5) .addComponent(jLabel4, javax.swing.GroupLayout.PREFERRED_SIZE, 22, javax.swing.GroupLayout.PREFERRED_SIZE)) .addGap(32, 32, 32)) ); pack(); } private void jTextField1ActionPerformed(java.awt.event.ActionEvent evt) { } private void jTextField2ActionPerformed(java.awt.event.ActionEvent evt) { } private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) { AirFaree airIndia = new AirIndia(); AirFaree indigo = new Indigo(); String source_city = jTextField1.getText().toUpperCase(); String destination_city = jTextField2.getText().toUpperCase(); if(AirIndiaBtn.isSelected() == true){ jLabel4.setText(String.valueOf(airIndia.showFare(source_city, destination_city))); } else if(IndigoBtn.isSelected() == true){ jLabel4.setText(String.valueOf(indigo.showFare(source_city, destination_city))); } else{ jLabel4.setText(\"select the flight\"); } } private void IndigoBtnActionPerformed(java.awt.event.ActionEvent evt) { } public static void main(String args[]) { try { for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) { if (\"Nimbus\".equals(info.getName())) { javax.swing.UIManager.setLookAndFeel(info.getClassName()); break; } } } catch (ClassNotFoundException ex) { java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex); } catch (InstantiationException ex) { java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex); } catch (IllegalAccessException ex) { java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex); } catch (javax.swing.UnsupportedLookAndFeelException ex) { java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex); } java.awt.EventQueue.invokeLater(new Runnable() { public void run() { new NewJFrame().setVisible(true); } }); } private javax.swing.JRadioButton AirIndiaBtn; private javax.swing.JRadioButton IndigoBtn; private javax.swing.ButtonGroup buttonGroup1; private javax.swing.JButton jButton1; private javax.swing.JLabel jLabel1; private javax.swing.JLabel jLabel2; private javax.swing.JLabel jLabel3; private javax.swing.JLabel jLabel4; private javax.swing.JLabel jLabel5; private javax.swing.JLabel jLabel6; private javax.swing.JTextField jTextField1; private javax.swing.JTextField jTextField2; }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "AirFare-Java-GUI-Project-master/AirFare/src/main/java/com/sauravhathi/airfare/NewJFrame.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "NewJFrame handles GUI construction, user input processing, and direct instantiation of airline fare providers, violating SRP by managing multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Adding a new airline requires modifying NewJFrame's UI and logic, violating OCP as the class is not closed for modification."}, {"principle": "Dependency Inversion", "justification": "NewJFrame directly creates AirIndia/Indigo instances instead of depending on AirFaree abstractions, violating DIP by coupling high-level modules to concrete implementations."}]}]}
{"project_id": 61, "chunk_id": 0, "prompt": {"main_file_path": "University-Portal-Core-Java-main/University-Portal-Core-Java-main/src/com/SetData/SetStudentPassword.java", "main_file_content": "package com.SetData; import java.io.BufferedWriter; import java.io.File; import java.io.FileWriter; import java.io.IOException; import java.util.Scanner; public class SetStudentPassword { public static void main(String[] args){ Scanner scan = new Scanner(System.in); File file = new File(\"StudentPassword.csv\"); sout(\"\") String username = scan.nextLine(); sout(\"\") String password = scan.nextLine(); try { BufferedWriter writer = new BufferedWriter(new FileWriter(file, true)); writer.write(username + \",\" + password + \"\\n\"); writer.close(); } catch (IOException e) { throw new RuntimeException(e); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "University-Portal-Core-Java-main/University-Portal-Core-Java-main/src/com/SetData/SetStudentPassword.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The SetStudentPassword class handles user input, file writing, and password setting logic, combining multiple responsibilities in one class."}, {"principle": "Open-Closed", "justification": "The class is not designed for extension (e.g., closed to adding new password storage mechanisms without modifying its existing code)."}]}]}
{"project_id": 61, "chunk_id": 0, "prompt": {"main_file_path": "University-Portal-Core-Java-main/University-Portal-Core-Java-main/src/com/SetData/SetStudentWaiver.java", "main_file_content": "package com.SetData; import java.io.BufferedWriter; import java.io.File; import java.io.FileWriter; import java.io.IOException; import java.util.Scanner; public class SetStudentWaiver { public static void main(String[] args){ Scanner scan = new Scanner(System.in); File file = new File(\"Result.csv\"); sout(\"\") String username = scan.nextLine(); sout(\"\") double waiver = scan.nextDouble(); sout(\"\") double requiredSGPA = scan.nextDouble(); try { BufferedWriter writer = new BufferedWriter(new FileWriter(file, true)); writer.write(username + \",\" + waiver + \",\" + requiredSGPA + \"\\n\"); writer.close(); } catch (IOException e) { throw new RuntimeException(e); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "University-Portal-Core-Java-main/University-Portal-Core-Java-main/src/com/SetData/SetStudentWaiver.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The SetStudentWaiver class handles multiple responsibilities: reading user input, processing data, and writing to a file. Combining these distinct tasks into a single class violates SRP, as changes to input handling, data processing, or file I/O would all require modifying this class."}]}]}
{"project_id": 61, "chunk_id": 0, "prompt": {"main_file_path": "University-Portal-Core-Java-main/University-Portal-Core-Java-main/src/com/SetData/SetFacultyPassword.java", "main_file_content": "package com.SetData; import java.io.BufferedWriter; import java.io.File; import java.io.FileWriter; import java.io.IOException; import java.util.Scanner; public class SetFacultyPassword { public static void main(String[] args){ Scanner scan = new Scanner(System.in); File file = new File(\"FacultyPassword.csv\"); sout(\"\") String username = scan.nextLine(); sout(\"\") String password = scan.nextLine(); try { BufferedWriter writer = new BufferedWriter(new FileWriter(file, true)); writer.write(username + \",\" + password + \"\\n\"); writer.close(); } catch (IOException e) { throw new RuntimeException(e); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "University-Portal-Core-Java-main/University-Portal-Core-Java-main/src/com/SetData/SetFacultyPassword.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The class handles multiple responsibilities: reading user input, writing to a file, and managing file I/O operations. These should be separated into distinct classes with single purposes."}]}]}
{"project_id": 61, "chunk_id": 0, "prompt": {"main_file_path": "University-Portal-Core-Java-main/University-Portal-Core-Java-main/src/com/Portal/Profile.java", "main_file_content": "package com.Portal; import java.io.*; import java.io.BufferedReader; import java.io.FileReader; import java.io.IOException; import java.util.ArrayList; import java.util.Scanner; public class Profile { String username; String name; String department; String dateOfBirth; String fatherName; String motherName; String bloodGroup; String email; String phone; String address; Profile(){ } Profile(String username,String name,String department,String dateOfBirth,String fatherName,String motherName,String bloodGroup,String phone,String email,String address){ this.username = username; this.name = name; this.department = department; this.dateOfBirth = dateOfBirth; this.fatherName = fatherName; this.motherName = motherName; this.bloodGroup = bloodGroup; this.email = email; this.phone = phone; this.address = address; } static void profile(String userType , String username) throws IOException { Main.clearScreen(); soutl(\"\") soutl(\"\") ArrayList<Profile> users = new ArrayList<>(); File file = new File(userType + \"Information.csv\"); boolean flag = true; BufferedReader br = new BufferedReader(new FileReader(file)); { String data = br.readLine(); while (data != null) { String[] datapart = data.split(\",\"); if(datapart.length>=10) { Profile user = new Profile(datapart[0], datapart[1], datapart[2], datapart[3], datapart[4], datapart[5], datapart[6], datapart[7], datapart[8], datapart[9]); users.add(user); } data = br.readLine(); } } br.close(); for (Profile user : users) { if (user.username.equals(username)) { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") flag = false; break; } } if (flag) { soutl(\"\") } sout(\"\") new Scanner(System.in).nextLine(); } static void update(String userType, String userID) throws IOException { Main.clearScreen(); soutl(\"\") soutl(\"\") Scanner scan = new Scanner(System.in); ArrayList<Profile> users = new ArrayList<>(); File file = new File(userType + \"Information.csv\"); boolean flag = true; BufferedReader br = new BufferedReader(new FileReader(file)); { String data = br.readLine(); while (data != null) { String[] datapart = data.split(\",\"); if(datapart.length>=10) { Profile user = new Profile(datapart[0], datapart[1], datapart[2], datapart[3], datapart[4], datapart[5], datapart[6], datapart[7], datapart[8], datapart[9]); users.add(user); } data = br.readLine(); } } br.close(); for (Profile user : users) { if (user.username.equals(userID)) { while (true) { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") sout(\"\") int option = scan.nextInt(); Scanner scanner = new Scanner(System.in); if (option == 9) { break; } if (option == 1) { sout(\"\") user.name = scanner.nextLine(); } if (option == 2) { sout(\"\") user.dateOfBirth = scanner.nextLine(); } if (option == 3) { sout(\"\") user.fatherName = scanner.nextLine(); } if (option == 4) { sout(\"\") user.motherName = scanner.nextLine(); } if (option == 5) { sout(\"\") user.bloodGroup = scanner.nextLine(); } if (option == 6) { sout(\"\") user.phone = scanner.nextLine(); } if (option == 7) { sout(\"\") user.email = scanner.nextLine(); } if (option == 8) { sout(\"\") user.address = scanner.nextLine(); } } flag = false; BufferedWriter writer = new BufferedWriter(new FileWriter(file)); for (Profile user2 : users) { writer.write(user2.username + \",\" + user2.name + \",\" + user2.department + \",\" + user2.dateOfBirth + \",\" + user2.fatherName + \",\" + user2.motherName + \",\" + user2.bloodGroup + \",\" + user2.phone + \",\" + user2.email + \",\" + user2.address + \"\\n\"); } writer.close(); break; } } if (flag) { Profile user = new Profile(); soutl(\"\") soutl(\"\") sout(\"\") user.name = scan.nextLine(); sout(\"\") user.department = scan.nextLine(); sout(\"\") user.dateOfBirth = scan.nextLine(); sout(\"\") user.fatherName = scan.nextLine(); sout(\"\") user.motherName = scan.nextLine(); sout(\"\") user.bloodGroup = scan.nextLine(); sout(\"\") user.phone = scan.nextLine(); sout(\"\") user.email = scan.nextLine(); sout(\"\") user.address = scan.nextLine(); BufferedWriter writer = new BufferedWriter(new FileWriter(file, true)); writer.write(userID + \",\" + user.name + \",\" + user.department + \",\" + user.dateOfBirth + \",\" + user.fatherName + \",\" + user.motherName + \",\" + user.bloodGroup + \",\" + user.phone + \",\" + user.email + \",\" + user.address + \"\\n\"); writer.close(); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "University-Portal-Core-Java-main/University-Portal-Core-Java-main/src/com/Portal/Profile.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Profile class handles both data representation (storing user profile fields) and file I/O operations (reading/writing CSV files), violating SRP by having multiple responsibilities."}, {"principle": "Open-Closed", "justification": "The class is not open for extension but closed for modification. Adding new profile behaviors (e.g., alternative storage formats) would require modifying existing methods like profile() and update()."}, {"principle": "Dependency Inversion", "justification": "High-level profile management logic directly depends on low-level file system operations (File, BufferedReader, BufferedWriter) without abstractions, despite built-in class exemptions not applying to this direct coupling."}]}]}
{"project_id": 61, "chunk_id": 0, "prompt": {"main_file_path": "University-Portal-Core-Java-main/University-Portal-Core-Java-main/src/com/Portal/PasswordUpdate.java", "main_file_content": "package com.Portal; import java.io.*; import java.util.ArrayList; import java.util.Scanner; public class PasswordUpdate { String username; String password; PasswordUpdate(String username,String password){ this.username = username; this.password = password; } static void change(String userType, String userID) throws IOException { Main.clearScreen(); Scanner scan = new Scanner(System.in); soutl(\"\") soutl(\"\") sout(\"\") String input = scan.next(); boolean flag = true; ArrayList<PasswordUpdate> users = new ArrayList<>(); File file = new File(userType + \"Password.csv\"); BufferedReader br = new BufferedReader(new FileReader(file)); { String data = br.readLine(); while (data != null) { String[] datapart = data.split(\",\"); if(datapart.length>=2) { PasswordUpdate user = new PasswordUpdate(datapart[0], datapart[1]); users.add(user); } data = br.readLine(); } } br.close(); for (PasswordUpdate user : users) { if (user.username.equals(userID) && user.password.equals(input)) { while (true) { sout(\"\") String input2 = scan.next(); sout(\"\") String input3 = scan.next(); if (input2.equals(input3)) { soutl(\"\") user.password = input3; break; } soutl(\"\") } BufferedWriter writer = new BufferedWriter(new FileWriter(file)); for (PasswordUpdate user2 : users) { writer.write(user2.username + \",\" + user2.password + \"\\n\"); } writer.close(); flag = false; break; } } if (flag) { soutl(\"\") } sout(\"\") new Scanner(System.in).nextLine(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "University-Portal-Core-Java-main/University-Portal-Core-Java-main/src/com/Portal/PasswordUpdate.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The PasswordUpdate class handles multiple responsibilities: reading/writing files, user input validation, password update logic. Changes to file handling or password rules would require modifying the same class."}, {"principle": "Open-Closed", "justification": "The class cannot be extended to support new user types or storage mechanisms without modifying existing code (e.g., hardcoded CSV file handling based on userType parameter)."}, {"principle": "Dependency Inversion", "justification": "High-level password management logic directly depends on concrete file system operations (File, FileWriter) instead of abstractions. Low-level IO details are not separated from business logic."}]}]}
{"project_id": 61, "chunk_id": 0, "prompt": {"main_file_path": "University-Portal-Core-Java-main/University-Portal-Core-Java-main/src/com/Portal/Courses.java", "main_file_content": "package com.Portal; import java.io.*; import java.util.ArrayList; import java.util.Scanner; public class Courses { String userID; String course1; String course2; String course3; String course4; Courses(String userID,String course1,String course2,String course3,String course4){ this.userID=userID; this.course1=course1; this.course2=course2; this.course3=course3; this.course4=course4; } static void courses(String userID) throws IOException { Main.clearScreen(); int course = 0; Scanner scan = new Scanner(System.in); soutl(\"\") soutl(\"\") if (userID.equals(\"1001\")) { soutl(\"\") soutl(\"\") soutl(\"\") sout(\"\") Scanner scanner = new Scanner(System.in); int option = scanner.nextInt(); if (option == 1) { course = 1; } else if (option == 2) { course = 2; } } if (userID.equals(\"1002\")) { soutl(\"\") soutl(\"\") soutl(\"\") sout(\"\") Scanner scanner = new Scanner(System.in); int option = scanner.nextInt(); if (option == 1) { course = 3; } else if (option == 2) { course = 4; } } ArrayList<Courses> users = new ArrayList<>(); File file = new File(\"Result.csv\"); BufferedReader br = new BufferedReader(new FileReader(file)); { String data = br.readLine(); while (data != null) { String[] datapart = data.split(\",\"); if(datapart.length>=5) { Courses user = new Courses(datapart[0], datapart[1], datapart[2], datapart[3], datapart[4]); users.add(user); } data = br.readLine(); } } br.close(); while (true) { soutl(\"\") int c = 0; for (Courses user : users) { c++; if (c > 1) { if (course == 1) { soutl(\"\") } else if (course == 2) { soutl(\"\") } else if (course == 3) { soutl(\"\") } else if (course == 4) { soutl(\"\") } } } soutl(\"\") soutl(\"\") sout(\"\") Scanner scanner = new Scanner(System.in); int option = scanner.nextInt(); if (option == 2) { break; } sout(\"\") String input = scan.nextLine(); for (Courses user : users) { if (user.userID.equals(input)) { sout(\"\") if (course == 1) { user.course1 = Grade.gradePoint(scan.nextDouble()); } else if (course == 2) { user.course2 = Grade.gradePoint(scan.nextDouble()); } else if (course == 3) { user.course3 = Grade.gradePoint(scan.nextDouble()); } else if (course == 4) { user.course4 = Grade.gradePoint(scan.nextDouble()); } break; } } BufferedWriter writer = new BufferedWriter(new FileWriter(file)); for (Courses user : users) { writer.write(user.userID + \",\" + user.course1 + \",\" + user.course2 + \",\" + user.course3 + \",\" + user.course4 + \"\\n\"); } writer.close(); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "University-Portal-Core-Java-main/University-Portal-Core-Java-main/src/com/Portal/Courses.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Courses class handles multiple responsibilities: data storage (userID, courses), user input processing, file I/O operations, and business logic for grade updates. Changes in any of these areas require modifying the same class."}, {"principle": "Open-Closed", "justification": "The static courses() method uses conditional checks (userID.equals() and course number comparisons) to determine behavior. Adding new userID-specific logic or course types requires modifying existing code instead of extending through abstractions."}]}]}
{"project_id": 61, "chunk_id": 0, "prompt": {"main_file_path": "University-Portal-Core-Java-main/University-Portal-Core-Java-main/src/com/Portal/Login.java", "main_file_content": "package com.Portal; import java.io.*; import java.io.BufferedReader; import java.io.FileReader; import java.io.IOException; import java.util.ArrayList; import java.util.Scanner; public class Login { String username; String password; Login(String username,String password){ this.username = username; this.password = password; } static void login(String usertype) throws IOException { Main.clearScreen(); Scanner scan = new Scanner(System.in); ArrayList<Login> users = new ArrayList<>(); soutl(\"\") sout(\"\") String username = scan.nextLine(); sout(\"\") String password = scan.next(); boolean flag = true; BufferedReader br = new BufferedReader(new FileReader(usertype + \"Password.csv\")); { String data = br.readLine(); while (data != null) { String[] datapart = data.split(\",\"); Login user = new Login(datapart[0], datapart[1]); users.add(user); data = br.readLine(); } } br.close(); for (Login user : users) { if (user.username.equals(username) && user.password.equals(password)) { if (usertype.equals(\"Student\")) StudentPortal.studentDashboard(username); if (usertype.equals(\"Faculty\")) FacultyPortal.facultyDashboard(username); flag = false; break; } } if (flag) { soutl(\"\") sout(\"\") new Scanner(System.in).nextLine(); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "University-Portal-Core-Java-main/University-Portal-Core-Java-main/src/com/Portal/Login.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Login class handles multiple responsibilities: user authentication, file I/O for credentials, and direct navigation to Student/Faculty dashboards. These should be separated into distinct classes."}, {"principle": "Open-Closed", "justification": "Adding a new user type (e.g., Admin) requires modifying the login method's conditional logic. The class is not closed for modification but open for extension via abstractions."}, {"principle": "Dependency Inversion", "justification": "Login directly depends on concrete StudentPortal/FacultyPortal classes instead of abstractions. High-level authentication logic should depend on interfaces, not low-level implementations."}]}]}
{"project_id": 61, "chunk_id": 0, "prompt": {"main_file_path": "University-Portal-Core-Java-main/University-Portal-Core-Java-main/src/com/Portal/Main.java", "main_file_content": "package com.Portal; import java.io.*; import java.io.IOException; import java.util.Scanner; public class Main { public static void main(String[] args) throws IOException { Scanner scanner = new Scanner(System.in); while (true) { clearScreen(); soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") sout(\"\") int option = scanner.nextInt(); if(option==1) { Login.login(\"Faculty\"); } else if(option==2) { Login.login(\"Student\"); } else if(option==3) { clearScreen(); soutl(\"\") return; } else soutl(\"\") } } static void clearScreen() throws IOException { String os = System.getProperty(\"os.name\").toLowerCase(); if (os.contains(\"win\")) { try { new ProcessBuilder(\"cmd\", \"/c\", \"cls\").inheritIO().start().waitFor(); } catch (InterruptedException e) { throw new RuntimeException(e); } } else if (os.contains(\"nix\") || os.contains(\"nux\") || os.contains(\"mac\")) { sout(\"\") System.out.flush(); } else { soutl(\"\") } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "University-Portal-Core-Java-main/University-Portal-Core-Java-main/src/com/Portal/Main.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Main class handles multiple responsibilities: managing the main application loop, user input processing, and screen clearing logic, which are separate concerns that could change independently."}]}]}
{"project_id": 61, "chunk_id": 0, "prompt": {"main_file_path": "University-Portal-Core-Java-main/University-Portal-Core-Java-main/src/com/Portal/FacultyPortal.java", "main_file_content": "package com.Portal; import java.io.*; import java.util.Scanner; public class FacultyPortal { static void facultyDashboard(String userID) throws IOException { while (true) { Main.clearScreen(); soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") sout(\"\") Scanner scanner = new Scanner(System.in); int option = scanner.nextInt(); if (option == 1) { Profile.profile(\"Faculty\",userID); } else if (option == 2) { Profile.update(\"Faculty\",userID); } else if (option == 3) { PasswordUpdate.change(\"Faculty\",userID); } else if (option == 4) { Courses.courses(userID); } else if (option == 5) { return; } } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "University-Portal-Core-Java-main/University-Portal-Core-Java-main/src/com/Portal/FacultyPortal.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "FacultyPortal handles user input processing, menu display, and routing to different functionalities, indicating multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Adding new menu options requires modifying the existing conditional logic in facultyDashboard instead of extending via abstractions."}, {"principle": "Dependency Inversion", "justification": "FacultyPortal directly depends on concrete classes (Profile, PasswordUpdate, Courses) instead of abstractions, violating high-level module independence."}]}]}
{"project_id": 61, "chunk_id": 0, "prompt": {"main_file_path": "University-Portal-Core-Java-main/University-Portal-Core-Java-main/src/com/Portal/Result.java", "main_file_content": "package com.Portal; import java.io.BufferedReader; import java.io.File; import java.io.FileReader; import java.io.IOException; import java.util.ArrayList; import java.util.Scanner; public class Result { String userID; String course1; String course2; String course3; String course4; Result(String userID,String course1,String course2,String course3,String course4){ this.userID=userID; this.course1=course1; this.course2=course2; this.course3=course3; this.course4=course4; } static void result() throws IOException { Main.clearScreen(); while(true) { Scanner scan = new Scanner(System.in); soutl(\"\") soutl(\"\") soutl(\"\") sout(\"\") Scanner scanner = new Scanner(System.in); int option = scanner.nextInt(); if (option == 2) { break; } soutl(\"\") ArrayList<Result> users = new ArrayList<>(); File file = new File(\"Result.csv\"); BufferedReader br = new BufferedReader(new FileReader(file)); { String data = br.readLine(); while (data != null) { String[] datapart = data.split(\",\"); if(datapart.length>=5) { Result user = new Result(datapart[0], datapart[1], datapart[2], datapart[3], datapart[4]); users.add(user); } data = br.readLine(); } } br.close(); sout(\"\") String input = scan.nextLine(); for (Result user : users) { if (user.userID.equals(input)) { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") } } sout(\"\") new Scanner(System.in).nextLine(); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "University-Portal-Core-Java-main/University-Portal-Core-Java-main/src/com/Portal/Result.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Result class handles multiple responsibilities: data storage (userID, courses), user interface interaction (console I/O), and file processing (reading from CSV)."}, {"principle": "Open-Closed", "justification": "The Result class directly implements CSV file reading. Adding support for new data sources (e.g., databases) would require modifying existing code instead of extending via abstractions."}]}]}
{"project_id": 61, "chunk_id": 0, "prompt": {"main_file_path": "University-Portal-Core-Java-main/University-Portal-Core-Java-main/src/com/Portal/Grade.java", "main_file_content": "package com.Portal; public class Grade { static String gradePoint(double total) { String gradePoint; if (total >= 80) { gradePoint = \"4.00\"; } else if (total >= 75) { gradePoint = \"3.75\"; } else if (total >= 70) { gradePoint = \"3.50\"; } else if (total >= 65) { gradePoint = \"3.25\"; } else if (total >= 60) { gradePoint = \"3.00\"; } else if (total >= 55) { gradePoint = \"2.75\"; } else if (total >= 50) { gradePoint = \"2.50\"; } else if (total >= 45) { gradePoint = \"2.25\"; } else if (total >= 40) { gradePoint = \"2.00\"; } else { gradePoint = \"0.00\"; } return gradePoint; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "University-Portal-Core-Java-main/University-Portal-Core-Java-main/src/com/Portal/Grade.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "The Grade class's gradePoint method uses a rigid if-else chain. Modifying grading logic requires altering existing code, violating OCP as it is not open for extension without change."}]}]}
{"project_id": 61, "chunk_id": 0, "prompt": {"main_file_path": "University-Portal-Core-Java-main/University-Portal-Core-Java-main/src/com/Portal/StudentPortal.java", "main_file_content": "package com.Portal; import java.io.*; import java.util.Scanner; public class StudentPortal { static void studentDashboard(String userID) throws IOException { while (true) { Main.clearScreen(); soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") sout(\"\") Scanner scanner = new Scanner(System.in); int option = scanner.nextInt(); if (option == 1) { Profile.profile(\"Student\",userID); } else if (option == 2) { Profile.update(\"Student\",userID); } else if (option == 3) { PasswordUpdate.change(\"Student\",userID); } else if (option == 4) { Result.result(); } else if (option == 5) { return; } } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "University-Portal-Core-Java-main/University-Portal-Core-Java-main/src/com/Portal/StudentPortal.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "StudentPortal's studentDashboard method handles UI rendering, input processing, and routing to multiple features (profile, password, results), violating SRP by managing multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Adding a new dashboard option (e.g., option 6) requires modifying the studentDashboard method's if-else chain, violating OCP by forcing code changes instead of extension."}, {"principle": "Dependency Inversion", "justification": "StudentPortal directly depends on concrete implementations (Profile, PasswordUpdate, Result) instead of abstractions, violating DIP by coupling high-level logic to low-level details."}]}]}
{"project_id": 63, "chunk_id": 0, "prompt": {"main_file_path": "job_portal-main/job_portal-main/job_portal/job_portal/src/User_DAO.java", "main_file_content": "import java.sql.*; public class User_DAO { private Connection conn; static Statement st; public User_DAO() throws SQLException { this.conn = DB_Connection.conn; st = conn.createStatement(); } void addRequest(int user_id, int[] job_ids) throws SQLException { String q = \"insert into job_request values (?,?,'waiting');\"; PreparedStatement pst = conn.prepareStatement(q); int flag = 0; for (int i : job_ids) { pst.setInt(1, i); pst.setInt(2, user_id); if (pst.executeUpdate() != 1) { soutl(\"\") flag++; } } if (flag == job_ids.length) { soutl(\"\") } } boolean addUser(User u) { boolean b = false; try { CallableStatement cst = conn.prepareCall(\"{call AddUser(?,?,?,?,?,?,?,?)}\"); cst.setInt(1, u.getId()); cst.setString(2, u.getName()); cst.setString(3, u.getEmail()); cst.setString(4, u.getEducation()); cst.setString(5, u.getPreferences()); cst.setString(6, u.getExperience()); cst.setString(7, u.getContactNo()); cst.setString(8, u.getPassword()); cst.execute(); b = true; } catch (Exception e) { soutl(\"\") soutl(\"\") } return b; } public boolean addUser2(User u) { boolean f = false; try { String sql = \"insert into user values (?,?,?,?,?,?,?,?)\"; java.sql.PreparedStatement rs = conn.prepareStatement(sql); rs.setInt(1, u.getId()); rs.setString(2, u.getName()); rs.setString(3, u.getEmail()); rs.setString(4, u.getEducation()); rs.setString(5, u.getPreferences()); rs.setString(6, u.getExperience()); rs.setString(7, u.getContactNo()); rs.setString(8, u.getPassword()); int i = rs.executeUpdate(); if (i == 1) { f = true; } } catch (Exception e) { e.printStackTrace(); } return f; } public boolean updateUser(User u) { boolean f = false; try { String sql = \"update user set name=?, qualification=?, email=?, password=? where id=?\"; PreparedStatement ps = conn.prepareStatement(sql); ps.setString(1, u.getName()); ps.setString(2, u.getEducation()); ps.setString(3, u.getEmail()); ps.setString(4, u.getPassword()); ps.setInt(5, u.getId()); int i = ps.executeUpdate(); if (i == 1) { f = true; } } catch (Exception e) { e.printStackTrace(); } return f; } boolean deleteUser(int id) throws SQLException { String q = \"delete from user where id=\" + id + \";\"; if (st.executeUpdate(q) == 1) { return true; } else { return false; } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "job_portal-main/job_portal-main/job_portal/job_portal/src/User_DAO.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "User_DAO handles multiple responsibilities: managing users (add, update, delete) and job requests (addRequest), violating SRP's single reason to change."}, {"principle": "Open-Closed", "justification": "User_DAO directly implements database operations without abstraction. Adding new functionality (e.g., new user types) requires modifying existing code, violating OCP."}, {"principle": "Dependency Inversion", "justification": "User_DAO directly depends on concrete database connections (DB_Connection.conn) instead of abstractions. High-level modules should depend on interfaces, not low-level implementations."}]}]}
{"project_id": 63, "chunk_id": 0, "prompt": {"main_file_path": "job_portal-main/job_portal-main/job_portal/job_portal/src/Job_DLL.java", "main_file_content": "import java.util.Scanner; public class Job_DLL { static Scanner sc = new Scanner(System.in); public class Node { Job job; Node next; Node prev; Node(Job d) { job = d; next = null; prev = null; } } static Node Head = null; public static int[] giveIDs() { Node temp = Head; int i = 0; while (temp != null) { i++; temp = temp.next; } temp = Head; int[] IDs = new int[i]; i = 0; while (temp != null) { IDs[i++] = temp.job.getId(); temp = temp.next; } return IDs; } public static int getVacancy(int id) { Node temp = Head; int vacancy = 0; while (temp != null) { if (temp.job.getId() == id) { vacancy = temp.job.getVacancy(); break; } temp = temp.next; } return vacancy; } void insertInOrder(Job job) { Node n = new Node(job); if (Head == null) { Head = n; } else if (Head.job.getPoints() <= n.job.getPoints()) { n.next = Head; Head.prev = n; Head = n; } else { Node temp = Head; while (temp.next != null && temp.job.getPoints() > n.job.getPoints()) { temp = temp.next; } n.next = temp.next; n.prev = temp; if (temp.next != null) { temp.next.prev = n; } temp.next = n; } } boolean isLoginValid(int id, String password) { Node temp = Head; while (temp != null) { if (temp.job.getId() == id && temp.job.getPassword().equals(password)) { return true; } temp = temp.next; } return false; } static boolean isJobExist(int id) { int flag = 0; Node temp = Head; while (temp != null) { if (temp.job.getId() == id) { flag = 1; } temp = temp.next; } if (flag != 0) { return true; } else { return false; } } void displayJobs() { Node temp = Head; while (temp != null) { Job t = temp.job; if (t.getStatus().equalsIgnoreCase(\"Available\")) { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") } temp = temp.next; } } void displayJob(int id) { Node temp = Head; int flag = 0; while (temp != null) { if ((temp.job.getId() == id)) { flag++; break; } temp = temp.next; } if (flag == 1) { Job t = temp.job; soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") } else { soutl(\"\") } } public Job updateJob(int id) { Node temp = Head; while (temp != null) { if (temp.job.getId() == id) { break; } temp = temp.next; } soutl(\"\") displayJob(id); int choice = 0; do { soutl(\"\") choice = sc.nextInt(); sc.nextLine(); String updated_value; switch (choice) { case 1: sout(\"\") updated_value = sc.nextLine(); temp.job.setcompany_name(updated_value); break; case 2: soutl(\"\") updated_value = sc.nextLine(); temp.job.setRole(updated_value); break; case 3: sout(\"\") String S_Salary = sc.nextLine(); sout(\"\") String E_Salary = sc.nextLine(); temp.job.setSalary(S_Salary + \" To \" + E_Salary); break; case 4: soutl(\"\") String dummy = sc.nextLine(); if (dummy.equalsIgnoreCase(\"yes\")) { temp.job.setStatus(\"Unavailable\"); soutl(\"\") } else { soutl(\"\") } break; case 5: soutl(\"\") updated_value = sc.nextLine(); temp.job.setLocation(updated_value); break; case 6: soutl(\"\") updated_value = sc.nextLine(); temp.job.setPassword(updated_value); break; case 7: soutl(\"\") int New_vacancy = sc.nextInt(); temp.job.setVacancy(New_vacancy); break; default: soutl(\"\") break; } } while (choice != 8); return temp.job; } void deleteJob(int id, String password) { Node temp = Head; int flag = 0; while (temp != null) { if ((temp.job.getId() == id) && (temp.job.getPassword().equals(password))) { flag++; break; } temp = temp.next; } if (flag == 1) { if (temp.prev != null) { temp.prev.next = temp.next; } if (temp.next != null) { temp.next.prev = temp.prev; } temp.prev = null; temp.next = null; soutl(\"\") } else { soutl(\"\") } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "job_portal-main/job_portal-main/job_portal/job_portal/src/Job_DLL.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Job_DLL class handles multiple responsibilities: managing a doubly linked list, user authentication (isLoginValid), job updates, and UI interactions (displayJobs, displayJob). This violates SRP as it has more than one reason to change."}, {"principle": "Open-Closed", "justification": "Job_DLL is not open for extension. Adding new job management behaviors (e.g., alternative insertion logic) requires modifying existing methods like insertInOrder, violating OCP."}, {"principle": "Dependency Inversion", "justification": "High-level job management logic directly depends on the low-level Node data structure. Job_DLL should depend on abstractions (e.g., a JobRepository interface) rather than a concrete linked list implementation."}]}]}
{"project_id": 63, "chunk_id": 0, "prompt": {"main_file_path": "job_portal-main/job_portal-main/job_portal/job_portal/src/User_DLL.java", "main_file_content": "import java.util.Scanner; class User_DLL { static Scanner sc = new Scanner(System.in); class Node { User user; Node next; Node prev; Node(User d) { user = d; next = null; prev = null; } } static Node Head = null; public static int[] giveIDs() { Node temp = Head; int i = 0; while (temp != null) { i++; temp = temp.next; } temp = Head; int[] IDs = new int[i]; i = 0; while (temp != null) { IDs[i++] = temp.user.getId(); temp = temp.next; } return IDs; } void insertInOrder(User user) { Node n = new Node(user); if (Head == null) { Head = n; } else if (Head.user.getPoints() <= n.user.getPoints()) { n.next = Head; Head.prev = n; Head = n; } else { Node temp = Head; while (temp.next != null && temp.user.getPoints() > n.user.getPoints()) { temp = temp.next; } n.next = temp.next; n.prev = temp; if (temp.next != null) { temp.next.prev = n; } temp.next = n; } } void displayUsers() { Node temp = Head; while (temp != null) { User t = temp.user; soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") temp = temp.next; } } void displayUser(int id) throws Exception { Node temp = Head; int flag = 0; while (temp != null) { if ((temp.user.getId() == id)) { flag++; break; } temp = temp.next; } if (flag == 0) { soutl(\"\") } else { User t = temp.user; soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") } } boolean loginIsValid(int id, String password) { Node temp = Head; while (temp != null) { if (temp.user.getId() == id && temp.user.getPassword().equals(password)) { return true; } temp = temp.next; } return false; } public User updateUser(int id) { Node temp = Head; while (temp != null) { if (temp.user.getId() == id) { break; } temp = temp.next; } int choice = 0; do { soutl(\"\") choice = sc.nextInt(); sc.nextLine(); String updated_value = \"\"; switch (choice) { case 1: soutl(\"\") updated_value = sc.nextLine(); temp.user.setName(updated_value); break; case 2: soutl(\"\") updated_value = sc.nextLine(); temp.user.setEmail(updated_value); break; case 3: soutl(\"\") updated_value = sc.nextLine(); temp.user.setPreferences(updated_value); break; case 4: boolean b1 = false; do { soutl(\"\") soutl(\"\") int education_choice = sc.nextInt(); sc.nextLine(); String programm; switch (education_choice) { case 1: updated_value = \"No formal education\"; break; case 2: updated_value = \"Primary school\"; break; case 3: updated_value = \"Middel school\"; break; case 4: updated_value = \"High School Graduate\"; break; case 5: updated_value = \"Associate's degree\"; break; case 6: soutl(\"\") programm = sc.nextLine(); updated_value = \"Bachelor's degree in \" + programm; break; case 7: soutl(\"\") programm = sc.nextLine(); updated_value = \"Master's degree in \" + programm; break; case 8: soutl(\"\") programm = sc.nextLine(); updated_value = \"Doctoral degree in \" + programm; default: soutl(\"\") b1 = true; break; } } while (b1); temp.user.setEducation(updated_value); break; case 5: boolean b2 = false; do { soutl(\"\") soutl(\"\") int preference_choice = sc.nextInt(); switch (preference_choice) { case 1: updated_value = \"free lancing\"; break; case 2: updated_value = \"remote work\"; break; case 3: updated_value = \"office work\"; break; case 4: updated_value = \"flexible\"; break; default: soutl(\"\") b2 = true; break; } } while (b2); temp.user.setPreferences(updated_value); break; case 6: while (true) { soutl(\"\") String experience_choice = sc.nextLine(); if (experience_choice.equalsIgnoreCase(\"Yes\")) { soutl(\"\") int experience_year = sc.nextInt(); updated_value = experience_year + \" years\"; break; } else if (experience_choice.equalsIgnoreCase(\"no\")) { updated_value = \"No Experience\"; break; } else { soutl(\"\") } } break; case 7: soutl(\"\") updated_value = sc.nextLine(); temp.user.setPassword(updated_value); break; default: if (choice != 8) { soutl(\"\") } break; } } while (choice != 8); return temp.user; } void delete(int id, String password) { Node temp = Head; int flag = 0; while (temp != null) { if ((temp.user.getId() == id) && (temp.user.getPassword().equals(password))) { flag++; break; } temp = temp.next; } if (flag == 1) { if (temp.prev != null) { temp.prev.next = temp.next; } if (temp.next != null) { temp.next.prev = temp.prev; } temp.prev = null; temp.next = null; soutl(\"\") } else { soutl(\"\") } } public static User getUser(int id) { Node temp = Head; int flag = 0; while (temp != null) { if (temp.user.getId() == id) { flag = 1; break; } temp = temp.next; } if (flag == 1) { return temp.user; } else { return null; } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "job_portal-main/job_portal-main/job_portal/job_portal/src/User_DLL.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "User_DLL manages a doubly linked list, handles user input/output via Scanner, and implements user update logic. These are multiple responsibilities requiring separate classes."}, {"principle": "Open-Closed", "justification": "Insertion order logic (e.g., sorting by points) is hardcoded. Adding new sorting strategies requires modifying the existing insertInOrder method."}, {"principle": "Interface Segregation", "justification": "Clients interacting with User_DLL must depend on all methods (e.g., display, login, update), even if they use only a subset, due to lack of segregated interfaces."}, {"principle": "Dependency Inversion", "justification": "User_DLL directly depends on the concrete User class. High-level modules should depend on abstractions (e.g., a User interface), not concrete implementations."}]}]}
{"project_id": 63, "chunk_id": 0, "prompt": {"main_file_path": "job_portal-main/job_portal-main/job_portal/job_portal/src/Job.java", "main_file_content": "class Job { private int id; private String password; private String company_name; private String role; private String salary_range; private String status; private String location; private int vacancy; private int points; public Job(int id, String company_name, String role, String salary_range, String location, int vacancy, String status, String password, int points) { super(); this.id = id; this.company_name = company_name; this.role = role; this.salary_range = salary_range; this.status = status; this.location = location; this.vacancy = vacancy; this.password = password; this.points = points; } public int getId() { return id; } public int getPoints() { return points; } public void setPoints(int point) { this.points = point; } public void setId(int id) { this.id = id; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public String getcompany_name() { return company_name; } public void setcompany_name(String company_name) { this.company_name = company_name; } public String getRole() { return role; } public void setRole(String role) { this.role = role; } public String getSalary() { return salary_range; } public void setSalary(String salary_range) { this.salary_range = salary_range; } public String getStatus() { return status; } public void setStatus(String status) { this.status = status; } public String getLocation() { return location; } public void setLocation(String location) { this.location = location; } public int getVacancy() { return vacancy; } public void setVacancy(int vacancy) { this.vacancy = vacancy; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "job_portal-main/job_portal-main/job_portal/job_portal/src/Job.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Job class manages both job details (company, role, salary) and password/authentication data. These are two distinct responsibilities, requiring separate reasons to change."}]}]}
{"project_id": 63, "chunk_id": 0, "prompt": {"main_file_path": "job_portal-main/job_portal-main/job_portal/job_portal/src/User_Manager.java", "main_file_content": "import java.sql.*; import java.util.*; public class User_Manager { static Scanner scanner = new Scanner(System.in); static User_DLL users; static User_DAO user_data; static int id = 0; public User_Manager() throws Exception { this.users = new User_DLL(); this.user_data = new User_DAO(); } boolean copyData() throws Exception { boolean f = true; try { String q = \"select * from user;\"; ResultSet rs = user_data.st.executeQuery(q); while (rs.next()) { id = rs.getInt(1); User temp = new User(rs.getInt(1), rs.getString(2), rs.getString(3), rs.getString(4), rs.getString(5), rs.getString(6), rs.getString(7), rs.getString(8), getPoints(rs.getString(6), rs.getString(4), rs.getString(5))); users.insertInOrder(temp); } } catch (Exception e) { soutl(\"\") e.printStackTrace(); f = false; } return f; } public static int getPoints(String Experience, String Education, String Preferences) { int ponts = 0; String experience = Experience; String education = Education; String preferences = Preferences; String[] edu = education.split(\" \"); String degree = edu[0]; switch (degree) { case \"Doctoral\": ponts += 20; break; case \"Master's\": ponts += 15; break; case \"Bachelor's\": ponts += 10; break; case \"Associate's\": ponts += 5; break; default: ponts += 0; break; } if (experience.equalsIgnoreCase(\"no experience\") || experience.equalsIgnoreCase(\"fresher\")) { ponts += 0; } else { int experience_years = experience.charAt(0); if (experience_years >= 2 && experience_years < 5) { ponts += 10; } else if (experience_years >= 5) { ponts += 20; } } if (preferences.equalsIgnoreCase(\"flexible\")) { ponts += 10; } else if (preferences.equalsIgnoreCase(\"office work\")) { ponts += 5; } else { ponts += 0; } return ponts; } public void register() throws Exception { id++; scanner.nextLine(); sout(\"\") String name = scanner.nextLine(); sout(\"\") String email = scanner.nextLine(); String education = \"\"; boolean b1 = false; try { do { soutl(\"\") soutl(\"\") int education_choice = scanner.nextInt(); scanner.nextLine(); String programm; switch (education_choice) { case 1: education = \"No formal education\"; break; case 2: education = \"Primary school\"; break; case 3: education = \"Middel school\"; break; case 4: education = \"High School Graduate\"; break; case 5: education = \"Associate's degree\"; break; case 6: soutl(\"\") programm = scanner.nextLine(); education = \"Bachelor's degree in \" + programm; break; case 7: soutl(\"\") programm = scanner.nextLine(); education = \"Master's degree in \" + programm; break; case 8: soutl(\"\") programm = scanner.nextLine(); education = \"Doctoral degree in \" + programm; break; default: soutl(\"\") soutl(\"\") b1 = true; break; } } while (b1); } catch (Exception e) { soutl(\"\") b1 = true; } soutl(\"\") scanner.nextLine(); boolean b4 = true; String contactNo = \"\"; while (b4) { try { sout(\"\") contactNo = scanner.nextLine(); if (!isNumberValid(contactNo)) { soutl(\"\") b4 = true; } else { b4 = false; } } catch (Exception e) { soutl(\"\") b4 = true; } } String experience = \"\"; while (true) { sout(\"\") String experience_choice = scanner.nextLine(); if (experience_choice.equalsIgnoreCase(\"Yes\")) { soutl(\"\") int experience_year = scanner.nextInt(); if (experience_year == 1) { experience = \"fresher\"; } else { experience = experience_year + \" years\"; } break; } else if (experience_choice.equalsIgnoreCase(\"no\")) { experience = \"No Experience\"; break; } else { soutl(\"\") } } boolean b2 = false; String preferences = \"\"; try { do { soutl(\"\") soutl(\"\") int preference_choice = scanner.nextInt(); switch (preference_choice) { case 1: preferences = \"free lancing\"; break; case 2: preferences = \"remote work\"; break; case 3: preferences = \"office work\"; break; case 4: preferences = \"flexible\"; break; default: soutl(\"\") b2 = true; break; } } while (b2); } catch (Exception e) { soutl(\"\") b2 = true; } soutl(\"\") sout(\"\") scanner.nextLine(); String password = scanner.nextLine(); User user = null; user = new User(id, name, email, education, preferences, experience, contactNo, password, getPoints(experience, education, preferences)); users.insertInOrder(user); if (user_data.addUser(user)) { soutl(\"\") } } boolean isNumberValid(String num) { boolean f = true; if (num.length() != 10) { f = false; } else { for (int i = 0; i < num.length(); i++) { char c = num.charAt(i); if (Character.isLetter(c)) { f = false; } } } return f; } void chooseJob2(int user_id) throws Exception { Statement st = DB_Connection.conn.createStatement(); ResultSet temp_rs = st.executeQuery(\"select * from jobs where status='available'\"); int count = 0; while (temp_rs.next()) { count++; } int[] job_ids = new int[count]; count = 0; ResultSet rs = st.executeQuery(\"select id,compony_name,role from jobs where status='available'\"); soutl(\"\") while (rs.next()) { job_ids[count++] = rs.getInt(1); sout(\"\") soutl(\"\") } PreparedStatement pst = DB_Connection.conn.prepareStatement(\"insert into job_request values(?,?,'Waiting')\"); int choice = 0; try { do { soutl(\"\") soutl(\"\") choice = scanner.nextInt(); switch (choice) { case 1: soutl(\"\") int j_id = scanner.nextInt(); st.execute( \"delete from job_request where job_id=\" + j_id + \" and requester_id=\" + user_id + \";\"); if (isJobValid(j_id, job_ids)) { pst.setInt(1, user_id); pst.setInt(2, j_id); soutl(\"\") } else { soutl(\"\") } break; case 2: choice = -1; break; default: soutl(\"\") break; } } while (choice != -1); } catch (Exception e) { soutl(\"\") } } boolean isJobValid(int job_id, int[] jobs) { boolean f = false; for (int i = 0; i < jobs.length; i++) { if (job_id == jobs[i]) { f = true; } } return f; } public void login() throws Exception { boolean b = true; try { sout(\"\") String id1 = scanner.nextLine(); int id = Integer.valueOf(id1); sout(\"\") String password = scanner.nextLine(); if (users.loginIsValid(id, password)) { soutl(\"\") userInterface2(id, password); b = false; } else { soutl(\"\") b = true; } } catch (Exception e) { soutl(\"\") } } public void userInterface2(int id, String password) throws Exception { boolean b = true; while (b) { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") sout(\"\") String option = scanner.nextLine(); switch (option) { case \"1\": chooseJob2(id); break; case \"2\": users.displayUser(id); break; case \"3\": user_data.updateUser(users.updateUser(id)); break; case \"4\": users.delete(id, password); user_data.deleteUser(id); break; case \"5\": b = false; break; default: soutl(\"\") } } } void userInterface() throws Exception { boolean b = true; while (b) { soutl(\"\") soutl(\"\") soutl(\"\") sout(\"\") String option = scanner.nextLine(); switch (option) { case \"1\": register(); break; case \"2\": login(); break; case \"3\": b = false; break; default: soutl(\"\") } } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "job_portal-main/job_portal-main/job_portal/job_portal/src/User_Manager.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "User_Manager handles user registration, login, data copying, job selection, UI interactions, and points calculation. These multiple responsibilities violate SRP as the class has many reasons to change."}, {"principle": "Open-Closed", "justification": "Adding new user types or registration steps requires modifying User_Manager directly instead of extending via abstractions. The class is not closed for modification."}, {"principle": "Dependency Inversion", "justification": "User_Manager directly depends on concrete classes User_DLL and User_DAO instead of abstractions. High-level modules should not depend on low-level implementations."}]}]}
{"project_id": 63, "chunk_id": 0, "prompt": {"main_file_path": "job_portal-main/job_portal-main/job_portal/job_portal/src/Job_Manager.java", "main_file_content": "import java.sql.*; import java.util.*; public class Job_Manager { static Scanner sc = new Scanner(System.in); static Job_DLL jobs; static Job_DAO jobs_data; static int id = 0; static Candidate_DLL temp; public Job_Manager() throws SQLException { this.jobs = new Job_DLL(); temp = new Candidate_DLL(); this.jobs_data = new Job_DAO(DB_Connection.conn); } void copyData() throws Exception { try { String q = \"select * from jobs;\"; ResultSet rs = Job_DAO.st.executeQuery(q); while (rs.next()) { id = rs.getInt(1); Job temp = new Job(rs.getInt(1), rs.getString(2), rs.getString(3), rs.getString(4), rs.getString(5), rs.getInt(6), rs.getString(7), rs.getString(8), getPoints(rs.getString(4))); jobs.insertInOrder(temp); } } catch (Exception e) { soutl(\"\") } } public void postJob() { id++; sc.nextLine(); soutl(\"\") soutl(\"\") String password = sc.nextLine(); soutl(\"\") String cname = sc.nextLine(); soutl(\"\") String crole = sc.nextLine(); String salary = \"\"; boolean b = true; do { try { long temp_salary; soutl(\"\") String salary_type = sc.nextLine(); if (salary_type.equalsIgnoreCase(\"Anual\")) { soutl(\"\") temp_salary = sc.nextLong(); salary = temp_salary + \" LPA\"; } else if (salary_type.equalsIgnoreCase(\"Monthly\")) { soutl(\"\") temp_salary = sc.nextLong(); temp_salary = (temp_salary * 12) / 100000; salary = temp_salary + \" LPA\"; } b = false; } catch (Exception e) { soutl(\"\") soutl(\"\") } } while (b); sc.nextLine(); String status = \"Available\"; soutl(\"\") String caddress = sc.nextLine(); int vacancy = Integer.MIN_VALUE; do { try { soutl(\"\") vacancy = sc.nextInt(); if (vacancy <= 0) { soutl(\"\") } } catch (Exception e) { soutl(\"\") vacancy = Integer.MIN_VALUE; } } while (vacancy <= 0); soutl(\"\") Job temp = new Job(id, cname, crole, salary, caddress, vacancy, status, password, getPoints(salary)); jobs_data.addJobs(temp); jobs.insertInOrder(temp); } public static int getPoints(String salary) { int point = 0; String temp_salary[] = salary.split(\" \"); point = Integer.valueOf(temp_salary[0]); return point; } static void view_candidates2(int job_id) throws Exception { temp.displayUsers(); Statement st = DB_Connection.conn.createStatement(); ResultSet rs1 = st .executeQuery( \"select * from user where id in(select requester_id from job_request where job_id=\" + job_id + \" and status='waiting');\"); while (rs1.next()) { User t = new User(rs1.getInt(1), rs1.getString(2), rs1.getString(3), rs1.getString(4), rs1.getString(5), rs1.getString(6), rs1.getString(7), rs1.getString(8), User_Manager.getPoints(rs1.getString(6), rs1.getString(4), rs1.getString(5))); temp.insertInOrder(t); } temp.displayUsers(); PreparedStatement pst = DB_Connection.conn .prepareStatement( \"update job_request set Status='Selected' where requester_id=? and job_id=\" + job_id); boolean b = true; do { soutl(\"\") String choice = sc.nextLine(); if (choice.equals(\"1\")) { soutl(\"\") try { int candidate_id = sc.nextInt(); sc.nextLine(); pst.setInt(1, candidate_id); if (pst.executeUpdate() > 0) { soutl(\"\") st.execute(\"update jobs set vacancy=vacancy-1 where id=\" + job_id + \";\"); } } catch (Exception e) { soutl(\"\") } } else if (choice.equals(\"2\")) { b = false; } else { soutl(\"\") } } while (b); } public void login() throws Exception { boolean b = true; do { sout(\"\") int id = sc.nextInt(); sc.nextLine(); sout(\"\") String password = sc.nextLine(); if (jobs.isLoginValid(id, password)) { soutl(\"\") JobInterface2(id, password); b = false; } else { soutl(\"\") } } while (b); } void JobInterface2(int id, String password) throws Exception { boolean b = true; do { soutl(\"\") String choice = sc.nextLine(); switch (choice) { case \"1\": jobs.deleteJob(id, password); jobs_data.deleteJob(id); b = false; break; case \"2\": if (jobs_data.updateJob(jobs.updateJob(id))) { soutl(\"\") } else { soutl(\"\") } break; case \"3\": view_candidates2(id); break; case \"4\": b = false; break; default: soutl(\"\") break; } } while (b); } void JobInterface() throws Exception { String choice = \"\"; do { soutl(\"\") choice = sc.nextLine(); switch (choice) { case \"1\": postJob(); break; case \"2\": login(); break; case \"3\": break; default: soutl(\"\") } } while (choice.equalsIgnoreCase(\"3\")); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "job_portal-main/job_portal-main/job_portal/job_portal/src/Job_Manager.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Job_Manager handles job posting, data copying, user login, candidate management, and UI interaction, violating SRP by managing multiple unrelated responsibilities."}, {"principle": "Open-Closed", "justification": "Job_Manager's postJob and other methods directly implement specific logic without abstraction, forcing modification for new job types or workflow changes instead of extension."}, {"principle": "Dependency Inversion", "justification": "Job_Manager directly instantiates concrete classes like Job_DAO, Job_DLL, and Candidate_DLL instead of depending on abstractions, violating DIP for high-level modules."}]}]}
{"project_id": 63, "chunk_id": 0, "prompt": {"main_file_path": "job_portal-main/job_portal-main/job_portal/job_portal/src/User.java", "main_file_content": "class User { private int id; private String name; private String email; private String password; private String education; private String preferences; private String experience; private String contactNo; private int points; public User(int id, String name, String email, String education, String preferences, String experience, String contact_no, String password, int point) { super(); this.id = id; this.name = name; this.email = email; this.password = password; this.education = education; this.preferences = preferences; this.experience = experience; this.contactNo = contact_no; this.points = point; } public void setExperience(String experience) { this.experience = experience; } public int getPoints() { return points; } public void setPoints(int point) { this.points = point; } public String getEducation() { return education; } public void setEducation(String education) { this.education = education; } public User() { super(); } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public String getPreferences() { return preferences; } public void setPreferences(String preferences) { this.preferences = preferences; } public String getExperience() { return experience; } public String getContactNo() { return contactNo; } public void setContactNo(String contactNo) { this.contactNo = contactNo; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "job_portal-main/job_portal-main/job_portal/job_portal/src/User.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The User class handles multiple responsibilities: user authentication (email, password), profile management (education, experience), contact details, and loyalty points. These distinct aspects should be separated into different classes to adhere to a single responsibility."}]}]}
{"project_id": 63, "chunk_id": 0, "prompt": {"main_file_path": "job_portal-main/job_portal-main/job_portal/job_portal/src/DB_Connection.java", "main_file_content": "import java.sql.*; public class DB_Connection { static Connection conn; static Statement st; DB_Connection() { try { conn = DriverManager.getConnection(\"jdbc:mysql: st = conn.createStatement(); if (conn != null) { soutl(\"\") } else { soutl(\"\") } } catch (SQLException e) { soutl(\"\") } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "job_portal-main/job_portal-main/job_portal/job_portal/src/DB_Connection.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The DB_Connection class handles both connection management and statement creation, indicating multiple responsibilities. Static Connection and Statement management further implies broader database control beyond a single purpose."}, {"principle": "Dependency Inversion", "justification": "The class directly depends on the concrete DriverManager for database connections. High-level modules using this class would violate DIP by relying on a low-level implementation instead of an abstraction."}]}]}
{"project_id": 63, "chunk_id": 0, "prompt": {"main_file_path": "job_portal-main/job_portal-main/job_portal/job_portal/src/Job_DAO.java", "main_file_content": "import java.sql.*; public class Job_DAO { private Connection conn; static Statement st; public Job_DAO(Connection connection) throws SQLException { this.conn = connection; st = conn.createStatement(); } Connection getConnection() { return conn; } boolean addJobs(Job j) { boolean b = false; try { CallableStatement ps = conn.prepareCall(\"call AddJob(?,?,?,?,?,?,?,?)\"); ps.setInt(1, j.getId()); ps.setString(2, j.getcompany_name()); ps.setString(3, j.getRole()); ps.setString(4, j.getSalary()); ps.setString(5, j.getLocation()); ps.setInt(6, j.getVacancy()); ps.setString(7, j.getStatus()); ps.setString(8, j.getPassword()); ps.execute(); b = true; } catch (Exception e) { } return b; } public boolean addJobs2(Job j) { boolean f = false; try { String sql = \"insert into jobs(id,compony_name, Role, salary_range, status, location,vacancy,password) values(?,?,?,?,?,?,?,?)\"; PreparedStatement ps = conn.prepareStatement(sql); ps.setInt(1, j.getId()); ps.setString(2, j.getcompany_name()); ps.setString(3, j.getRole()); ps.setString(4, j.getSalary()); ps.setString(5, j.getStatus()); ps.setString(6, j.getLocation()); ps.setInt(7, j.getVacancy()); ps.setString(8, j.getPassword()); int i = ps.executeUpdate(); if (i == 1) { f = true; } } catch (Exception e) { e.printStackTrace(); } return f; } public boolean updateJob(Job j) { boolean f = false; try { String sql = \"update jobs set compony_name=?, Role=?, salary_range=?, status=?, location=? where id=?\"; PreparedStatement ps = conn.prepareStatement(sql); ps.setString(1, j.getcompany_name()); ps.setString(2, j.getRole()); ps.setString(3, j.getSalary()); ps.setString(3, j.getStatus()); ps.setString(4, j.getLocation()); ps.setInt(5, j.getId()); int i = ps.executeUpdate(); if (i == 1) { f = true; } } catch (Exception e) { e.printStackTrace(); } return f; } public boolean deleteJob(int id) { boolean f = false; try { String sql = \"delete from jobs where id=?\"; PreparedStatement ps = conn.prepareStatement(sql); ps.setInt(1, id); int i = ps.executeUpdate(); if (i == 1) { f = true; } } catch (Exception e) { e.printStackTrace(); } return f; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "job_portal-main/job_portal-main/job_portal/job_portal/src/Job_DAO.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Job_DAO handles database connection management, multiple job insertion strategies (stored procedure vs. direct SQL), and CRUD operations, violating the single responsibility principle."}, {"principle": "Open-Closed", "justification": "Adding new job persistence mechanisms (e.g., NoSQL support) requires modifying Job_DAO directly instead of extending through abstractions."}]}]}
{"project_id": 63, "chunk_id": 0, "prompt": {"main_file_path": "job_portal-main/job_portal-main/job_portal/job_portal/src/Candidate_DLL.java", "main_file_content": "import java.util.Scanner; class Candidate_DLL { static Scanner sc = new Scanner(System.in); class Node { User user; Node next; Node prev; Node(User d) { user = d; next = null; prev = null; } } static Node Head = null; public static int[] giveIDs() { Node temp = Head; int i = 0; while (temp != null) { i++; temp = temp.next; } temp = Head; int[] IDs = new int[i]; i = 0; while (temp != null) { IDs[i++] = temp.user.getId(); temp = temp.next; } return IDs; } void insertInOrder(User user) { Node n = new Node(user); if (Head == null) { Head = n; } else if (Head.user.getPoints() <= n.user.getPoints()) { n.next = Head; Head.prev = n; Head = n; } else { Node temp = Head; while (temp.next != null && temp.user.getPoints() > n.user.getPoints()) { temp = temp.next; } n.next = temp.next; n.prev = temp; if (temp.next != null) { temp.next.prev = n; } temp.next = n; } } void displayUsers() { Node temp = Head; while (temp != null) { User t = temp.user; soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") temp = temp.next; } } void displayUser(int id) throws Exception { Node temp = Head; int flag = 0; while (temp != null) { if ((temp.user.getId() == id)) { flag++; break; } temp = temp.next; } if (flag == 0) { soutl(\"\") } else { User t = temp.user; soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") } } public static User getUser(int id) { Node temp = Head; int flag = 0; while (temp != null) { if (temp.user.getId() == id) { flag = 1; break; } temp = temp.next; } if (flag == 1) { return temp.user; } else { return null; } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "job_portal-main/job_portal-main/job_portal/job_portal/src/Candidate_DLL.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Candidate_DLL handles multiple responsibilities: managing a doubly linked list structure, user data insertion logic, UI rendering (display methods), and ID retrieval. These should be separated into distinct classes."}, {"principle": "Open-Closed", "justification": "The insertion logic in insertInOrder and display methods are hardcoded. To change sorting behavior or output formatting, the class must be modified directly instead of being extended via abstractions."}, {"principle": "Dependency Inversion", "justification": "Candidate_DLL directly depends on concrete User objects and its internal Node implementation. High-level list management should depend on abstractions (e.g., interfaces for data storage), not low-level details."}]}]}
{"project_id": 63, "chunk_id": 0, "prompt": {"main_file_path": "job_portal-main/job_portal-main/job_portal/job_portal/src/Main.java", "main_file_content": "import java.util.Scanner; public class Main { static User_Manager U_Manager; static Job_Manager J_Manager; static Scanner sc = new Scanner(System.in); static { try { new DB_Connection(); U_Manager = new User_Manager(); J_Manager = new Job_Manager(); U_Manager.copyData(); J_Manager.copyData(); } catch (Exception e) { soutl(\"\") e.printStackTrace(); } } public static void main(String[] args) throws Exception { soutl(\"\") while (true) { soutl(\"\") String choice = sc.nextLine(); switch (choice) { case \"1\": U_Manager.userInterface(); break; case \"2\": J_Manager.JobInterface(); break; case \"3\": soutl(\"\") U_Manager.users.displayUsers(); soutl(\"\") J_Manager.jobs.displayJobs(); break; case \"4\": soutl(\"\") System.exit(0); break; default: soutl(\"\") break; } } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "job_portal-main/job_portal-main/job_portal/job_portal/src/Main.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Main class handles user input, manages dependencies (User_Manager, Job_Manager, DB_Connection), and orchestrates application flow, violating the single responsibility principle."}, {"principle": "Open-Closed", "justification": "Adding new functionality (e.g., a new manager type) requires modifying Main's code (switch-case, initializations), violating the open-closed principle."}, {"principle": "Dependency Inversion", "justification": "Main directly depends on concrete classes (User_Manager, Job_Manager) instead of abstractions, making high-level modules tightly coupled to low-level implementations."}]}]}
{"project_id": 68, "chunk_id": 0, "prompt": {"main_file_path": "Library-Management-System-master/Library-Management-System-master/Progress.java", "main_file_content": "import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; class Progress { private static JFrame frame; private JProgressBar progressBar; private Timer timer; public Progress() { frame = new JFrame(\"Progress Bar\"); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setSize(350, 200); frame.setUndecorated(true); frame.getRootPane().setBorder(BorderFactory.createLineBorder(new Color(102, 0, 51), 3)); JLabel background = new JLabel(new ImageIcon(\"loginBg.jpg\")); background.setBounds(0, 0, frame.getWidth(), frame.getHeight()); frame.add(background); JLabel headingLabel = new JLabel(\"HD1.0\"); headingLabel.setBounds(100, 28, 380, 60); headingLabel.setFont(new Font(\"Serif\", Font.BOLD, 55)); headingLabel.setForeground(new Color(102, 0, 51)); background.add(headingLabel); progressBar = new JProgressBar(0, 100); progressBar.setBounds(60, 108, 250, 30); progressBar.setStringPainted(true); background.add(progressBar); frame.setLocationRelativeTo(null); frame.setVisible(true); timer = new Timer(50, new ActionListener() { int progress = 0; @Override public void actionPerformed(ActionEvent e) { progressBar.setValue(progress); if (progress == 100) { timer.stop(); frame.dispose(); SwingUtilities.invokeLater(() -> { new Login(); }); } progress++; } }); timer.start(); } public static void main(String[] args) { SwingUtilities.invokeLater(() -> { new Progress(); }); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Library-Management-System-master/Library-Management-System-master/Progress.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Progress class handles UI frame setup, progress bar management, and timer control, indicating multiple responsibilities which require separate reasons to change."}, {"principle": "Open-Closed", "justification": "The class is not designed for extension (e.g., altering progress behavior) without modifying existing code, as it lacks abstractions like interfaces or inheritance hooks."}, {"principle": "Dependency Inversion", "justification": "The Progress class directly instantiates the concrete Login class instead of depending on an abstraction, violating the dependency inversion principle for high-level modules."}]}]}
{"project_id": 68, "chunk_id": 0, "prompt": {"main_file_path": "Library-Management-System-master/Library-Management-System-master/BookStore.java", "main_file_content": "import javax.imageio.ImageIO; import javax.swing.*; import java.awt.*; import java.awt.image.BufferedImage; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.io.IOException; public class BookStore implements ActionListener { private static JFrame f; private static ImageIcon imageIcon; private static JLabel imageLabel; public BookStore() { f = new JFrame(\"Book Store\"); f.setSize(600, 500); f.setLayout(null); Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize(); f.setLocation((int) (screenSize.getWidth() - f.getWidth()) / 2, (int) (screenSize.getHeight() - f.getHeight()) / 2); f.setUndecorated(true); f.getRootPane().setBorder(BorderFactory.createLineBorder(new Color(102, 0, 51), 3)); JLabel heading = new JLabel(\"Book Store\"); heading.setBounds(170, 50, 400, 50); heading.setFont(new Font(\"Serif\", Font.BOLD, 55)); heading.setForeground(new Color(102, 0, 51)); f.add(heading); JButton addbtn = new JButton(\"Add\"); addbtn.setForeground(Color.white); addbtn.setBackground(new Color(63, 137, 255)); addbtn.setBounds(150, 180, 110, 50); f.add(addbtn); addbtn.addActionListener(this); JButton deletebtn = new JButton(\"Delete\"); deletebtn.setForeground(Color.white); deletebtn.setBackground(new Color(201,69,47)); deletebtn.setBounds(340, 180, 110, 50); f.add(deletebtn); deletebtn.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { f.dispose(); new DelBook(); } }); JButton updatebtn = new JButton(\"Update\"); updatebtn.setForeground(Color.white); updatebtn.setBackground(new Color(24, 111, 101)); updatebtn.setBounds(150, 280, 110, 50); f.add(updatebtn); updatebtn.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { f.dispose(); new UpdateBook(); } }); JButton displaybtn = new JButton(\"Display\"); displaybtn.setBackground(new Color(153, 0, 153)); displaybtn.setForeground(Color.white); displaybtn.setBounds(340, 280, 110, 50); f.add(displaybtn); JButton exit = new JButton(\"Exit\"); exit.setForeground(Color.white); exit.setBackground(new Color(64,64,64)); exit.setBounds(150, 380, 110, 50); f.add(exit); JButton login = new JButton(\"Logout\"); login.setForeground(Color.white); login.setBackground(new Color(255,178,102)); login.setBounds(340, 380, 110, 50); f.add(login); exit.addActionListener(e -> System.exit(0)); displaybtn.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { f.dispose(); new Display(); } }); JPanel panel2 = new JPanel(); panel2.setBounds(0, 0, 800, 600); panel2.setLayout(new BorderLayout()); f.add(panel2); try { BufferedImage originalImage = ImageIO.read(getClass().getResource(\"./loginBg.jpg\")); int scaledWidth = 800; int scaledHeight = 600; BufferedImage scaledImage = new BufferedImage(scaledWidth, scaledHeight, BufferedImage.TYPE_INT_RGB); Graphics2D g = scaledImage.createGraphics(); g.drawImage(originalImage, 0, 0, scaledWidth, scaledHeight, null); g.dispose(); imageIcon = new ImageIcon(scaledImage); } catch (IOException e) { e.printStackTrace(); } imageLabel = new JLabel(imageIcon); imageLabel.setBounds(400, 50, 200, 300); panel2.add(imageLabel); f.setVisible(true); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); login.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { f.dispose(); new Login(); } }); } public void actionPerformed(ActionEvent e) { f.dispose(); new AddBook(); } public static void main(String[] args) { SwingUtilities.invokeLater(new Runnable() { public void run() { new BookStore(); } }); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Library-Management-System-master/Library-Management-System-master/BookStore.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The BookStore class handles UI setup, event handling, image loading, and navigation logic, violating SRP by managing multiple unrelated responsibilities that require separate reasons to change."}, {"principle": "Open-Closed", "justification": "Adding new features (e.g., buttons or actions) requires modifying the BookStore class directly instead of extending it through abstractions, violating OCP's requirement for closed modification."}, {"principle": "Dependency Inversion", "justification": "High-level BookStore directly instantiates low-level modules (e.g., DelBook, UpdateBook) instead of depending on abstractions, violating DIP's mandate for inverted dependencies."}]}]}
{"project_id": 68, "chunk_id": 0, "prompt": {"main_file_path": "Library-Management-System-master/Library-Management-System-master/DelBook.java", "main_file_content": "import javax.swing.*; import java.awt.*; import java.awt.event.*; import java.sql.*; class ImagePanel extends JPanel { private Image backgroundImage; public ImagePanel(String imagePath) { backgroundImage = new ImageIcon(imagePath).getImage(); } @Override protected void paintComponent(Graphics g) { super.paintComponent(g); g.drawImage(backgroundImage, 0, 0, this); } } public class DelBook { public DelBook() { JFrame frame = new JFrame(\"Delete a Book\"); frame.setSize(400, 300); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setUndecorated(true); frame.getRootPane().setBorder(BorderFactory.createLineBorder(new Color(102, 0, 51), 3)); frame.setLocationRelativeTo(null); ImagePanel panel = new ImagePanel(\"loginBg.jpg\"); panel.setLayout(null); frame.add(panel); JLabel heading = new JLabel(\"Delete a Book\"); heading.setBounds(130, 30, 200, 50); heading.setFont(new Font(\"Serif\", Font.BOLD, 30)); heading.setForeground(new Color(102, 0, 51)); panel.add(heading); JLabel label = new JLabel(\"Enter Book ID or Book Name to Delete:\"); label.setBounds(40, 100, 340, 30); label.setFont(new Font(\"Serif\", Font.PLAIN, 20)); panel.add(label); JTextField textField = new JTextField(); textField.setBounds(90, 150, 220, 30); panel.add(textField); JButton deleteButton = new JButton(\"Delete\"); deleteButton.setBounds(50, 210, 90, 30); deleteButton.setBackground(new Color(201, 69, 47)); deleteButton.setForeground(Color.WHITE); panel.add(deleteButton); JButton displayButton = new JButton(\"Display\"); displayButton.setBounds(150, 210, 90, 30); displayButton.setBackground(new Color(153, 0, 153)); displayButton.setForeground(Color.WHITE); panel.add(displayButton); JButton cancelButton = new JButton(\"Cancel\"); cancelButton.setBounds(250, 210, 90, 30); cancelButton.setBackground(new Color(64, 64, 64)); cancelButton.setForeground(Color.WHITE); panel.add(cancelButton); deleteButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { String input = textField.getText().trim(); if (!input.isEmpty()) { String url = \"jdbc:mysql: String user = \"root\"; String pwd = \"1234\"; String in = textField.getText(); String query = \"Delete from books where Bid='\" + in + \"' or Bname='\" + in + \"';\"; try { Class.forName(\"com.mysql.cj.jdbc.Driver\"); Connection con = DriverManager.getConnection(url, user, pwd); PreparedStatement ps = con.prepareStatement(query); int rows = ps.executeUpdate(query); if (rows > 0) { JOptionPane.showMessageDialog(null, \"Book removed from Library\"); } else { JOptionPane.showMessageDialog(null, \"No such book available\"); } } catch (Exception ex) { soutl(\"\") } } else { JOptionPane.showMessageDialog(null, \"Please enter Book ID or Name to delete.\"); } } }); displayButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { frame.dispose(); new Display(); } }); cancelButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { frame.dispose(); } }); frame.setVisible(true); } public static void main(String[] args) { SwingUtilities.invokeLater(new Runnable() { public void run() { new DelBook(); } }); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Library-Management-System-master/Library-Management-System-master/DelBook.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "DelBook class handles UI setup, database operations, and event handling, violating SRP by managing multiple responsibilities."}, {"principle": "Open-Closed", "justification": "DelBook directly implements database logic and UI, making extension without modification impossible, violating OCP."}, {"principle": "Dependency Inversion", "justification": "DelBook depends on concrete database classes (DriverManager, Connection) instead of abstractions, violating DIP."}]}]}
{"project_id": 68, "chunk_id": 0, "prompt": {"main_file_path": "Library-Management-System-master/Library-Management-System-master/Register.java", "main_file_content": "import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.image.BufferedImage; import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import javax.imageio.ImageIO; public class Register implements ActionListener { private static JFrame frame; private static JLabel headingLabel; private static JLabel[] labels; private static JTextField[] textFields; private static JLabel plabel, cplabel; private static JPasswordField pass; private static JPasswordField cpass; private static JButton registerButton; private static JButton exitButton; private static ImageIcon imageIcon; private static JLabel imageLabel; public Register() { frame = new JFrame(\"Registration Form\"); frame.setSize(650, 400); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setLocationRelativeTo(null); frame.setLayout(null); frame.setLocation( (Toolkit.getDefaultToolkit().getScreenSize().width - frame.getWidth()) / 2, (Toolkit.getDefaultToolkit().getScreenSize().height - frame.getHeight()) / 2 ); frame.setUndecorated(true); frame.getRootPane().setBorder(BorderFactory.createLineBorder(new Color(102, 0, 51), 3)); headingLabel = new JLabel(\"Registration\"); headingLabel.setBounds(60, 20, 380, 65); headingLabel.setFont(new Font(\"Serif\", Font.BOLD, 55)); headingLabel.setForeground(new Color(102, 0, 51)); frame.add(headingLabel); String[] labelNames = {\"Full Name\", \"Username\", \"Date of Birth\", \"Email Id\"}; labels = new JLabel[labelNames.length]; for (int i = 0; i < labels.length; i++) { labels[i] = new JLabel(labelNames[i]); labels[i].setBounds(60, 100 + i * 35, 120, 20); frame.add(labels[i]); } textFields = new JTextField[labelNames.length]; for (int i = 0; i < textFields.length; i++) { textFields[i] = new JTextField(); textFields[i].setBounds(180, 100 + i * 35, 193, 28); frame.add(textFields[i]); } plabel = new JLabel(\"Password\"); plabel.setBounds(60, 240, 120, 20); frame.add(plabel); cplabel = new JLabel(\"Confirm Password\"); cplabel.setBounds(60, 275, 120, 20); frame.add(cplabel); pass = new JPasswordField(); pass.setBounds(180, 240, 193, 28); frame.add(pass); cpass = new JPasswordField(); cpass.setBounds(180, 275, 193, 28); frame.add(cpass); registerButton = new JButton(\"Register\"); registerButton.setBounds(130, 330, 100, 25); registerButton.setForeground(Color.WHITE); registerButton.setBackground(new Color(0, 153, 153)); registerButton.addActionListener(this); frame.add(registerButton); exitButton = new JButton(\"Exit\"); exitButton.setBounds(240, 330, 80, 25); exitButton.setForeground(Color.WHITE); exitButton.setBackground(new Color(64,64,64)); exitButton.addActionListener(e -> System.exit(0)); frame.add(exitButton); try { BufferedImage originalImage = ImageIO.read(getClass().getResource(\"/register.png\")); int scaledWidth = 200; int scaledHeight = 300; BufferedImage scaledImage = new BufferedImage(scaledWidth, scaledHeight, BufferedImage.TYPE_INT_RGB); Graphics2D g = scaledImage.createGraphics(); g.drawImage(originalImage, 0, 0, scaledWidth, scaledHeight, null); g.dispose(); imageIcon = new ImageIcon(scaledImage); } catch (Exception e) { e.printStackTrace(); } imageLabel = new JLabel(imageIcon); imageLabel.setBounds(400, 50, 200, 300); frame.add(imageLabel); frame.setVisible(true); } @Override public void actionPerformed(ActionEvent e) { if (areFieldsValid()) { String url = \"jdbc:mysql: String mysqluser = \"root\"; String mysqlpasswd = \"1234\"; String insertQuery = \"INSERT INTO login (username, password) VALUES (?, ?)\"; try { Class.forName(\"com.mysql.cj.jdbc.Driver\"); Connection con = DriverManager.getConnection(url, mysqluser, mysqlpasswd); PreparedStatement ps = con.prepareStatement(insertQuery); ps.setString(1, textFields[1].getText()); ps.setString(2, new String(pass.getPassword())); ps.executeUpdate(); JOptionPane.showMessageDialog(null, \"Registration Successful\"); con.close(); frame.dispose(); new Login(); } catch (Exception ex) { JOptionPane.showMessageDialog(null, ex.getMessage()); } } } private boolean areFieldsValid() { for (JTextField textField : textFields) { if (textField.getText().trim().isEmpty()) { JOptionPane.showMessageDialog(null, \"Please fill in all fields.\"); return false; } } String email = textFields[3].getText().trim(); if (!isValidEmail(email)) { JOptionPane.showMessageDialog(null, \"Invalid Email Address\"); return false; } char[] password = pass.getPassword(); char[] confirmPassword = cpass.getPassword(); if (!isPasswordValid(password, confirmPassword)) { JOptionPane.showMessageDialog(null, \"Password and Confirm Password do not match\"); return false; } return true; } private boolean isValidEmail(String email) { String emailPattern = \"^[A-Za-z0-9+_.-]+@(.+)$\"; return email.matches(emailPattern); } private boolean isPasswordValid(char[] password, char[] confirmPassword) { return new String(password).equals(new String(confirmPassword)); } public static void main(String[] args) { SwingUtilities.invokeLater(() -> { new Register(); }); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Library-Management-System-master/Library-Management-System-master/Register.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Register class handles UI setup, input validation, database interactions, and image loading, violating SRP by managing multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Adding new registration fields or validation logic requires modifying existing code instead of extending the class, violating OCP."}, {"principle": "Dependency Inversion", "justification": "Register directly depends on concrete JDBC classes (DriverManager, Connection) instead of abstractions, violating DIP for high-level modules."}]}]}
{"project_id": 68, "chunk_id": 0, "prompt": {"main_file_path": "Library-Management-System-master/Library-Management-System-master/Login.java", "main_file_content": "import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.io.File; import java.io.IOException; import java.sql.*; import javax.imageio.ImageIO; class BackgroundPanel extends JPanel { private Image backgroundImage; public BackgroundPanel(String imagePath) { try { backgroundImage = ImageIO.read(new File(imagePath)); } catch (IOException e) { e.printStackTrace(); } } @Override protected void paintComponent(Graphics g) { super.paintComponent(g); if (backgroundImage != null) { g.drawImage(backgroundImage, 0, 0, getWidth(), getHeight(), this); } } } class Login implements ActionListener { private static JFrame frame; private static JLabel label; private static JTextField user; private static JButton loginButton; private static JButton registerButton; private static JButton exitButton; private static JPasswordField password; public Login() { frame = new JFrame(\"LOGIN PAGE\"); frame.setSize(450, 400); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setLocationRelativeTo(null); BackgroundPanel backgroundPanel = new BackgroundPanel(\"loginBg.jpg\"); backgroundPanel.setLayout(null); frame.setContentPane(backgroundPanel); frame.setLocation( (Toolkit.getDefaultToolkit().getScreenSize().width - frame.getWidth()) / 2, (Toolkit.getDefaultToolkit().getScreenSize().height - frame.getHeight()) / 2 ); frame.setUndecorated(true); frame.getRootPane().setBorder(BorderFactory.createLineBorder(new Color(102, 0, 51), 3)); JLabel headingLabel = new JLabel(\"Login Account\"); headingLabel.setBounds(60, 20, 380, 65); headingLabel.setFont(new Font(\"Serif\", Font.BOLD, 55)); headingLabel.setForeground(new Color(102, 0, 51)); frame.add(headingLabel); label = new JLabel(\"Username\"); label.setBounds(130, 105, 70, 20); frame.add(label); user = new JTextField(); user.setBounds(130, 140, 193, 28); frame.add(user); JLabel passwordLabel = new JLabel(\"Password\"); passwordLabel.setBounds(130, 190, 70, 20); frame.add(passwordLabel); password = new JPasswordField(); password.setBounds(130, 225, 193, 28); frame.add(password); loginButton = new JButton(\"Login\"); loginButton.setBounds(130, 300, 80, 25); loginButton.setForeground(Color.WHITE); loginButton.setBackground(new Color(255,178,102)); loginButton.addActionListener(this); frame.add(loginButton); exitButton = new JButton(\"Exit\"); exitButton.setBounds(230, 300, 80, 25); exitButton.setForeground(Color.WHITE); exitButton.setBackground(new Color(64,64,64)); exitButton.addActionListener(e -> System.exit(0)); frame.add(exitButton); registerButton = new JButton(\"Register\"); registerButton.setBounds(180, 340, 100, 25); registerButton.setForeground(Color.WHITE); registerButton.setBackground(new Color(0, 153, 153)); registerButton.addActionListener(this); frame.add(registerButton); frame.setVisible(true); } @Override public void actionPerformed(ActionEvent e) { if (e.getSource() == loginButton) { String url = \"jdbc:mysql: String mysqluser = \"root\"; String mysqlpasswd = \"1234\"; String pswrd = new String(password.getPassword()); String username = user.getText(); String query = \"SELECT password FROM login WHERE username = ?\"; try { Class.forName(\"com.mysql.cj.jdbc.Driver\"); Connection con = DriverManager.getConnection(url, mysqluser, mysqlpasswd); PreparedStatement ps = con.prepareStatement(query); ps.setString(1, username); ResultSet rs = ps.executeQuery(); if (rs.next()) { String realpasswrd = rs.getString(\"password\"); if (realpasswrd.equals(pswrd)) { JOptionPane.showMessageDialog(null, \"Login Successful\"); frame.dispose(); new BookStore(); } else { JOptionPane.showMessageDialog(null, \"Username or Password mismatch\"); } } else { JOptionPane.showMessageDialog(null, \"Wrong Username\"); } con.close(); } catch (Exception ex) { JOptionPane.showMessageDialog(null, ex.getMessage()); } } if (e.getSource() == registerButton) { frame.dispose(); new Register(); } } public static void main(String[] args) { SwingUtilities.invokeLater(() -> { new Login(); }); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Library-Management-System-master/Library-Management-System-master/Login.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Login class handles UI setup, user authentication (database interaction), and navigation to other components, indicating multiple responsibilities."}, {"principle": "Dependency Inversion", "justification": "Login directly depends on concrete JDBC classes (DriverManager, Connection) instead of abstractions for database access."}]}]}
{"project_id": 68, "chunk_id": 0, "prompt": {"main_file_path": "Library-Management-System-master/Library-Management-System-master/Display.java", "main_file_content": "import javax.swing.*; import javax.swing.table.DefaultTableCellRenderer; import javax.swing.table.DefaultTableModel; import javax.swing.table.TableColumnModel; import java.awt.*; import java.awt.event.*; import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.Statement; public class Display { JFrame f; JTable j; Display() { f = new JFrame(\"Display Records\"); f.setSize(400, 300); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); f.setLocationRelativeTo(null); f.setUndecorated(true); f.getRootPane().setBorder(BorderFactory.createLineBorder(new Color(102, 0, 51), 3)); JLabel heading = new JLabel(\"Book Store\"); heading.setFont(new Font(\"Serif\", Font.BOLD, 32)); heading.setForeground(new Color(102, 0, 51)); heading.setHorizontalAlignment(SwingConstants.CENTER); String[] columnNames = { \"BOOK NAME\", \"BOOK ID\", \"PRICE\", \"AUTHOR NAME\" }; DefaultTableModel model = new DefaultTableModel(columnNames, 0); try { String url = \"jdbc:mysql: String user = \"root\"; String password = \"1234\"; Connection connection = DriverManager.getConnection(url, user, password); Statement statement = connection.createStatement(); String query = \"SELECT Bname, Bid, Price, Author FROM books\"; ResultSet resultSet = statement.executeQuery(query); while (resultSet.next()) { String name = resultSet.getString(\"Bname\"); String id = resultSet.getString(\"Bid\"); String price = resultSet.getString(\"Price\"); String author = resultSet.getString(\"Author\"); model.addRow(new Object[] { name, id, price, author }); } connection.close(); } catch (Exception e) { e.printStackTrace(); } j = new JTable(model); j.setPreferredScrollableViewportSize(new Dimension(300, 100)); j.setFillsViewportHeight(true); TableColumnModel columnModel = j.getColumnModel(); columnModel.getColumn(0).setPreferredWidth(50); columnModel.getColumn(1).setPreferredWidth(1); columnModel.getColumn(2).setPreferredWidth(1); columnModel.getColumn(3).setPreferredWidth(140); DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer(); centerRenderer.setHorizontalAlignment(SwingConstants.CENTER); for (int i = 0; i < j.getColumnCount(); i++) { j.getColumnModel().getColumn(i).setCellRenderer(centerRenderer); } JScrollPane sp = new JScrollPane(j); JPanel bottomPanel = new JPanel(); JButton addButton = new JButton(\"Add\"); addButton.setForeground(Color.WHITE); addButton.setBackground(new Color(63, 137, 255)); addButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { f.dispose(); new AddBook(); } }); JButton deleteButton = new JButton(\"Delete\"); deleteButton.setForeground(Color.WHITE); deleteButton.setBackground(new Color(201,69,47)); deleteButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { f.dispose(); new DelBook(); } }); JButton updateButton = new JButton(\"Update\"); updateButton.setForeground(Color.WHITE); updateButton.setBackground(new Color(24, 111, 101)); updateButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { f.dispose(); new UpdateBook(); } }); JButton logoutButton = new JButton(\"Logout\"); logoutButton.setForeground(Color.WHITE); logoutButton.setBackground(new Color(255,178,102)); logoutButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { f.dispose(); new Login(); } }); JButton exitButton = new JButton(\"Exit\"); exitButton.setForeground(Color.WHITE); exitButton.setBackground(new Color(64,64,64)); exitButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { System.exit(0); } }); bottomPanel.add(addButton); bottomPanel.add(deleteButton); bottomPanel.add(updateButton); bottomPanel.add(logoutButton); bottomPanel.add(exitButton); f.add(heading, BorderLayout.NORTH); f.add(sp, BorderLayout.CENTER); f.add(bottomPanel, BorderLayout.SOUTH); f.setVisible(true); } public static void main(String[] args) { SwingUtilities.invokeLater(new Runnable() { public void run() { new Display(); } }); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Library-Management-System-master/Library-Management-System-master/Display.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Display class handles UI rendering, database operations, and business logic (e.g., button actions), violating SRP by having multiple responsibilities."}, {"principle": "Open-Closed", "justification": "The class cannot be extended without modification (e.g., to add new UI components or data sources), violating OCP."}, {"principle": "Dependency Inversion", "justification": "High-level UI logic directly depends on low-level database implementations (e.g., DriverManager, Connection), violating DIP by lacking abstraction layers."}]}]}
{"project_id": 68, "chunk_id": 0, "prompt": {"main_file_path": "Library-Management-System-master/Library-Management-System-master/AddBook.java", "main_file_content": "import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; public class AddBook { private static JLabel[] labels; private static JTextField[] textFields; public AddBook() { JFrame f = new JFrame(\"Add Book\"); f.setSize(600, 500); f.setLayout(null); f.setUndecorated(true); f.getRootPane().setBorder(BorderFactory.createLineBorder(new Color(102, 0, 51), 3)); f.setLocationRelativeTo(null); ImageIcon background = new ImageIcon(\"loginBg.jpg\"); JLabel backgroundLabel = new JLabel(background); backgroundLabel.setBounds(0, 0, 600, 500); f.add(backgroundLabel); JLabel heading = new JLabel(\"Add Book\"); heading.setBounds(200, 40, 250, 50); heading.setFont(new Font(\"Serif\", Font.BOLD, 52)); heading.setForeground(new Color(102, 0, 51)); backgroundLabel.add(heading); String[] labelNames = { \"BName\", \"Bid\", \"Price\", \"Author\" }; labels = new JLabel[labelNames.length]; textFields = new JTextField[labelNames.length]; for (int i = 0; i < labels.length; i++) { labels[i] = new JLabel(labelNames[i] + \":\"); labels[i].setFont(new Font(\"Serif\", Font.BOLD, 20)); labels[i].setBounds(100, 115 + i * 60, 120, 30); backgroundLabel.add(labels[i]); textFields[i] = new JTextField(); textFields[i].setBounds(230, 115 + i * 60, 260, 30); textFields[i].setFont(new Font(\"Serif\", Font.PLAIN, 18)); backgroundLabel.add(textFields[i]); } JButton btn = new JButton(\"Add Book\"); btn.setBounds(190, 350, 120, 50); btn.setFont(new Font(\"Serif\", Font.BOLD, 15)); btn.setBackground(new Color(63, 137, 255)); btn.setForeground(Color.white); backgroundLabel.add(btn); JButton back = new JButton(\"Back\"); back.setBounds(190, 420, 120, 50); back.setFont(new Font(\"Serif\", Font.BOLD, 15)); backgroundLabel.add(back); back.setBackground(new Color(201, 69, 47)); back.setForeground(Color.white); JButton displaybtn = new JButton(\"Display\"); displaybtn.setFont(new Font(\"Serif\", Font.BOLD, 15)); displaybtn.setBackground(new Color(153, 0, 153)); displaybtn.setForeground(Color.white); displaybtn.setBounds(320, 350, 120, 50); backgroundLabel.add(displaybtn); JButton exit = new JButton(\"Exit\"); exit.setBounds(320, 420, 120, 50); exit.setFont(new Font(\"Serif\", Font.BOLD, 15)); backgroundLabel.add(exit); exit.addActionListener(e -> System.exit(0)); exit.setBackground(new Color(64, 64, 64)); exit.setForeground(Color.white); btn.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String bookName = textFields[0].getText().trim(); String bookId = textFields[1].getText().trim(); String price = textFields[2].getText().trim(); String author = textFields[3].getText().trim(); if (bookName.isEmpty() || bookId.isEmpty() || price.isEmpty() || author.isEmpty()) { JOptionPane.showMessageDialog(null, \"Text field is required!\"); } else if (!price.matches(\"\\\\d+\")) { JOptionPane.showMessageDialog(null, \"Price must be in digits only.\"); } else if (!author.matches(\"^[A-Za-z\\\\s]+$\")) { JOptionPane.showMessageDialog(null, \"Author should contain only letters.\"); } else if (!bookName.matches(\"^[A-Za-z\\\\s]+$\")) { JOptionPane.showMessageDialog(null, \"Book Name should contain only letters.\"); } else { try { String url = \"jdbc:mysql: String user = \"root\"; String password = \"1234\"; Connection connection = DriverManager.getConnection(url, user, password); String query = \"INSERT INTO books (Bid, Bname, Price, Author) VALUES (?, ?, ?, ?)\"; PreparedStatement preparedStatement = connection.prepareStatement(query); preparedStatement.setString(1, bookId); preparedStatement.setString(2, bookName); preparedStatement.setString(3, price); preparedStatement.setString(4, author); int rowsInserted = preparedStatement.executeUpdate(); if (rowsInserted > 0) { f.dispose(); new RecAdded(); } else { JOptionPane.showMessageDialog(null, \"Failed to add the book.\"); } connection.close(); } catch (Exception ex) { ex.printStackTrace(); JOptionPane.showMessageDialog(null, \"Error: \" + ex.getMessage()); } } } }); displaybtn.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { f.dispose(); new Display(); } }); back.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { f.dispose(); new BookStore(); } }); f.setVisible(true); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } public static void main(String[] args) { SwingUtilities.invokeLater(new Runnable() { public void run() { new AddBook(); } }); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Library-Management-System-master/Library-Management-System-master/AddBook.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "AddBook handles GUI construction, input validation, database operations, and navigation logic. Multiple responsibilities increase coupling and violate SRP."}, {"principle": "Open-Closed", "justification": "AddBook cannot be extended to add new validation rules or persistence mechanisms without modifying its source code, violating OCP."}, {"principle": "Dependency Inversion", "justification": "AddBook directly depends on concrete JDBC classes (DriverManager, PreparedStatement) instead of abstractions for database access, violating DIP."}]}]}
{"project_id": 68, "chunk_id": 0, "prompt": {"main_file_path": "Library-Management-System-master/Library-Management-System-master/Test.java", "main_file_content": "import javax.swing.*; import java.awt.*; class Test extends JFrame { JButton b; Test() { b = new JButton(\"Submit\"); add(b); setLayout(new FlowLayout()); setSize(400,400); setLocation(300,100); setVisible(true); } public static void main(String args[]) { new Test(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Library-Management-System-master/Library-Management-System-master/Test.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Test class handles both UI component setup (JFrame configuration, button creation) and application lifecycle management (main method entry point), introducing multiple reasons to change."}]}]}
{"project_id": 68, "chunk_id": 0, "prompt": {"main_file_path": "Library-Management-System-master/Library-Management-System-master/RecAdded.java", "main_file_content": "import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; public class RecAdded { public RecAdded() { JFrame f = new JFrame(\"Record Added\"); f.setLayout(null); f.setContentPane(new JPanel(null)); f.setUndecorated(true); f.getRootPane().setBorder(BorderFactory.createLineBorder(new Color(102, 0, 51), 3)); JPanel panel=new JPanel(); panel.setBounds(0, -25,350,200) ; f.add(panel); ImageIcon img = new ImageIcon(\"./loginBGI.jpg\"); JLabel bck = new JLabel(); bck.setIcon(img); bck.setBounds(0, 0, 350, 200); bck.setLayout(null); panel.add(bck); JLabel label=new JLabel(\"Record Added\"); label.setBounds(230,50,200,40); label.setFont(new Font(\"Serif\", Font.BOLD, 32)); label.setForeground(new Color(102, 0, 51)); bck.add(label); JButton add=new JButton(\"Book Store\"); add.setForeground(Color.white); add.setBackground(new Color(204, 102, 0)); add.setBounds(200,120,110,35); bck.add(add); JButton exit =new JButton(\"Exit\"); exit.setForeground(Color.white); exit.setBackground(new Color(64,64,64)); exit.setBounds(350,120,110,35); bck.add(exit); exit.addActionListener(e -> System.exit(0)); add.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { f.dispose(); new BookStore(); } }); f.setVisible(true); f.setSize(350, 180); Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize(); f.setLocation((int) (screenSize.getWidth() - f.getWidth()) / 2, (int) (screenSize.getHeight() - f.getHeight()) / 2); } public static void main(String[] args) { RecAdded obj = new RecAdded(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Library-Management-System-master/Library-Management-System-master/RecAdded.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The RecAdded class handles multiple responsibilities: UI setup (creating frames, panels, buttons), layout management, and controlling application flow (opening BookStore, exiting)."}, {"principle": "Dependency Inversion", "justification": "High-level module RecAdded directly instantiates concrete BookStore (business logic) without depending on abstractions. Low-level UI components (JFrame, JButton) are allowed exceptions."}]}]}
{"project_id": 68, "chunk_id": 0, "prompt": {"main_file_path": "Library-Management-System-master/Library-Management-System-master/UpdateBook.java", "main_file_content": "import javax.swing.*; import java.awt.*; import java.awt.event.*; import java.sql.*; public class UpdateBook { public UpdateBook() { JFrame frame = new JFrame(\"Update a Book\"); frame.setSize(450, 500); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setLocationRelativeTo(null); frame.setUndecorated(true); frame.getRootPane().setBorder(BorderFactory.createLineBorder(new Color(102, 0, 51), 3)); JPanel panel = new JPanel(null); frame.add(panel); JLabel heading = new JLabel(\"Update a Book\"); heading.setBounds(140, 30, 200, 50); heading.setFont(new Font(\"Serif\", Font.BOLD, 30)); heading.setForeground(new Color(102, 0, 51)); panel.add(heading); JLabel updateLabel = new JLabel(\"Enter Book ID or Name to Update:\"); updateLabel.setBounds(110, 100, 340, 30); updateLabel.setFont(new Font(\"Serif\", Font.PLAIN, 18)); panel.add(updateLabel); JTextField updateField = new JTextField(); updateField.setBounds(130, 150, 220, 30); panel.add(updateField); JLabel bNameLabel = new JLabel(\"Book Name:\"); bNameLabel.setBounds(50, 200, 100, 30); bNameLabel.setFont(new Font(\"Serif\", Font.PLAIN, 18)); panel.add(bNameLabel); JTextField bNameField = new JTextField(); bNameField.setBounds(160, 200, 220, 30); panel.add(bNameField); JLabel bIdLabel = new JLabel(\"Book ID:\"); bIdLabel.setBounds(50, 250, 100, 30); bIdLabel.setFont(new Font(\"Serif\", Font.PLAIN, 18)); panel.add(bIdLabel); JTextField bIdField = new JTextField(); bIdField.setBounds(160, 250, 220, 30); panel.add(bIdField); JLabel priceLabel = new JLabel(\"Price:\"); priceLabel.setBounds(50, 300, 100, 30); priceLabel.setFont(new Font(\"Serif\", Font.PLAIN, 18)); panel.add(priceLabel); JTextField priceField = new JTextField(); priceField.setBounds(160, 300, 220, 30); panel.add(priceField); JLabel authorLabel = new JLabel(\"Author:\"); authorLabel.setBounds(50, 350, 100, 30); authorLabel.setFont(new Font(\"Serif\", Font.PLAIN, 18)); panel.add(authorLabel); JTextField authorField = new JTextField(); authorField.setBounds(160, 350, 220, 30); panel.add(authorField); JButton updateButton = new JButton(\"Update\"); updateButton.setBounds(70, 420, 90, 30); updateButton.setBackground(new Color(24, 111, 101)); updateButton.setForeground(Color.WHITE); panel.add(updateButton); JButton displayButton = new JButton(\"Display\"); displayButton.setBounds(180, 420, 90, 30); displayButton.setBackground(new Color(153, 0, 153)); displayButton.setForeground(Color.WHITE); panel.add(displayButton); JButton cancelButton = new JButton(\"Cancel\"); cancelButton.setBounds(280, 420, 90, 30); cancelButton.setBackground(new Color(64, 64, 64)); cancelButton.setForeground(Color.WHITE); panel.add(cancelButton); updateButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { String input = updateField.getText().trim(); String bName = bNameField.getText().trim(); String bId = bIdField.getText().trim(); String price = priceField.getText().trim(); String author = authorField.getText().trim(); if (!input.isEmpty() && !bName.isEmpty() && !bId.isEmpty() && !price.isEmpty() && !author.isEmpty()) { String url = \"jdbc:mysql: String user = \"root\"; String pwd = \"1234\"; String query = \"UPDATE books SET Bname=?, Bid=?, Price=?, Author=? WHERE Bid=? OR Bname=?\"; try { Class.forName(\"com.mysql.cj.jdbc.Driver\"); Connection con = DriverManager.getConnection(url, user, pwd); PreparedStatement ps = con.prepareStatement(query); ps.setString(1, bName); ps.setString(2, bId); ps.setString(3, price); ps.setString(4, author); ps.setString(5, input); ps.setString(6, input); int rows = ps.executeUpdate(); if (rows > 0) { JOptionPane.showMessageDialog(null, \"Book updated in Library\"); } else { JOptionPane.showMessageDialog(null, \"No such book available\"); } } catch (Exception ex) { soutl(\"\") } } else { JOptionPane.showMessageDialog(null, \"Please fill in all fields.\"); } } }); displayButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { frame.dispose(); new Display(); } }); cancelButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { frame.dispose(); } }); frame.setVisible(true); } public static void main(String[] args) { SwingUtilities.invokeLater(new Runnable() { public void run() { new UpdateBook(); } }); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Library-Management-System-master/Library-Management-System-master/UpdateBook.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The UpdateBook class handles UI construction, database operations, and event handling, violating SRP by managing multiple responsibilities that change for different reasons."}, {"principle": "Open-Closed", "justification": "The class cannot be extended without modifying its code (e.g., to add new update behaviors), as it lacks abstractions like interfaces or inheritance hooks."}, {"principle": "Dependency Inversion", "justification": "High-level database operations directly depend on low-level JDBC implementations (DriverManager, PreparedStatement) without abstractions, violating DIP."}]}]}
{"project_id": 69, "chunk_id": 0, "prompt": {"main_file_path": "java-number-calculator-main/java-number-calculator-main/src/NumberCalculator.java", "main_file_content": "package numbercalculator; import javax.swing.JOptionPane; public class NumberCalculator { public static void main(String[] args) { double[] numbers = new double[6]; double total = 0; for (int i = 0; i < 6; i++) { String input = JOptionPane.showInputDialog(null, \"Enter number \" + (i + 1) + \":\", \"Input Number\", JOptionPane.QUESTION_MESSAGE); try { numbers[i] = Double.parseDouble(input); total += numbers[i]; } catch (NumberFormatException e) { JOptionPane.showMessageDialog(null, \"Invalid input. Please enter a valid number.\", \"Error\", JOptionPane.ERROR_MESSAGE); i--; } } double average = total / 6; StringBuilder output = new StringBuilder(\"Numbers entered:\\n\"); for (double num : numbers) { output.append(num).append(\"\\n\"); } output.append(\"\\nTotal: \").append(total); output.append(\"\\nAverage: \").append(average); JOptionPane.showMessageDialog(null, output.toString(), \"Results\", JOptionPane.INFORMATION_MESSAGE); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "java-number-calculator-main/java-number-calculator-main/src/NumberCalculator.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The NumberCalculator class handles input parsing, data processing, output formatting, and UI interaction. Combining these distinct responsibilities into a single class violates SRP."}, {"principle": "Open-Closed", "justification": "The class cannot be extended to add new calculation types or output formats without modifying its existing code. All logic is hardcoded in the main method, violating OCP."}]}]}
{"project_id": 70, "chunk_id": 0, "prompt": {"main_file_path": "Hotal-managment-system-main/Main.java", "main_file_content": "import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.ArrayList; import java.util.Scanner; class Food implements Serializable { int itemno; int quantity; float price; Food(int itemno,int quantity) { this.itemno=itemno; this.quantity=quantity; switch(itemno) { case 1:price=quantity*50; break; case 2:price=quantity*60; break; case 3:price=quantity*70; break; case 4:price=quantity*30; break; } } } class Singleroom implements Serializable { String name; String contact; String gender; ArrayList<Food> food =new ArrayList<>(); Singleroom() { this.name=\"\"; } Singleroom(String name,String contact,String gender) { this.name=name; this.contact=contact; this.gender=gender; } } class Doubleroom extends Singleroom implements Serializable { String name2; String contact2; String gender2; Doubleroom() { this.name=\"\"; this.name2=\"\"; } Doubleroom(String name,String contact,String gender,String name2,String contact2,String gender2) { this.name=name; this.contact=contact; this.gender=gender; this.name2=name2; this.contact2=contact2; this.gender2=gender2; } } class NotAvailable extends Exception { @Override public String toString() { return \"Not Available !\"; } } class holder implements Serializable { Doubleroom luxury_doublerrom[]=new Doubleroom[10]; Doubleroom deluxe_doublerrom[]=new Doubleroom[20]; Singleroom luxury_singleerrom[]=new Singleroom[10]; Singleroom deluxe_singleerrom[]=new Singleroom[20]; } class Hotel { static holder hotel_ob=new holder(); static Scanner sc = new Scanner(System.in); static void CustDetails(int i,int rn) { String name, contact, gender; String name2 = null, contact2 = null; String gender2=\"\"; sout(\"\") name = sc.next(); sout(\"\") contact=sc.next(); sout(\"\") gender = sc.next(); if(i<3) { sout(\"\") name2 = sc.next(); sout(\"\") contact2=sc.next(); sout(\"\") gender2 = sc.next(); } switch (i) { case 1:hotel_ob.luxury_doublerrom[rn]=new Doubleroom(name,contact,gender,name2,contact2,gender2); break; case 2:hotel_ob.deluxe_doublerrom[rn]=new Doubleroom(name,contact,gender,name2,contact2,gender2); break; case 3:hotel_ob.luxury_singleerrom[rn]=new Singleroom(name,contact,gender); break; case 4:hotel_ob.deluxe_singleerrom[rn]=new Singleroom(name,contact,gender); break; default:soutl(\"\") break; } } static void bookroom(int i) { int j; int rn; soutl(\"\") switch (i) { case 1: for(j=0;j<hotel_ob.luxury_doublerrom.length;j++) { if(hotel_ob.luxury_doublerrom[j]==null) { sout(\"\") } } sout(\"\") try{ rn=sc.nextInt(); rn--; if(hotel_ob.luxury_doublerrom[rn]!=null) throw new NotAvailable(); CustDetails(i,rn); } catch(Exception e) { soutl(\"\") return; } break; case 2: for(j=0;j<hotel_ob.deluxe_doublerrom.length;j++) { if(hotel_ob.deluxe_doublerrom[j]==null) { sout(\"\") } } sout(\"\") try{ rn=sc.nextInt(); rn=rn-11; if(hotel_ob.deluxe_doublerrom[rn]!=null) throw new NotAvailable(); CustDetails(i,rn); } catch(Exception e) { soutl(\"\") return; } break; case 3: for(j=0;j<hotel_ob.luxury_singleerrom.length;j++) { if(hotel_ob.luxury_singleerrom[j]==null) { sout(\"\") } } sout(\"\") try{ rn=sc.nextInt(); rn=rn-31; if(hotel_ob.luxury_singleerrom[rn]!=null) throw new NotAvailable(); CustDetails(i,rn); } catch(Exception e) { soutl(\"\") return; } break; case 4: for(j=0;j<hotel_ob.deluxe_singleerrom.length;j++) { if(hotel_ob.deluxe_singleerrom[j]==null) { sout(\"\") } } sout(\"\") try{ rn=sc.nextInt(); rn=rn-41; if(hotel_ob.deluxe_singleerrom[rn]!=null) throw new NotAvailable(); CustDetails(i,rn); } catch(Exception e) { soutl(\"\") return; } break; default: soutl(\"\") break; } soutl(\"\") } static void features(int i) { switch (i) { case 1:soutl(\"\") break; case 2:soutl(\"\") break; case 3:soutl(\"\") break; case 4:soutl(\"\") break; default: soutl(\"\") break; } } static void availability(int i) { int j,count=0; switch (i) { case 1: for(j=0;j<10;j++) { if(hotel_ob.luxury_doublerrom[j]==null) count++; } break; case 2: for(j=0;j<hotel_ob.deluxe_doublerrom.length;j++) { if(hotel_ob.deluxe_doublerrom[j]==null) count++; } break; case 3: for(j=0;j<hotel_ob.luxury_singleerrom.length;j++) { if(hotel_ob.luxury_singleerrom[j]==null) count++; } break; case 4: for(j=0;j<hotel_ob.deluxe_singleerrom.length;j++) { if(hotel_ob.deluxe_singleerrom[j]==null) count++; } break; default: soutl(\"\") break; } soutl(\"\") } static void bill(int rn,int rtype) { double amount=0; String list[]={\"Sandwich\",\"Pasta\",\"Noodles\",\"Coke\"}; soutl(\"\") soutl(\"\") soutl(\"\") switch(rtype) { case 1: amount+=4000; soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") for(Food obb:hotel_ob.luxury_doublerrom[rn].food) { amount+=obb.price; String format = \"%-10s%-10s%-10s%n\"; System.out.printf(format,list[obb.itemno-1],obb.quantity,obb.price ); } break; case 2:amount+=3000; soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") for(Food obb:hotel_ob.deluxe_doublerrom[rn].food) { amount+=obb.price; String format = \"%-10s%-10s%-10s%n\"; System.out.printf(format,list[obb.itemno-1],obb.quantity,obb.price ); } break; case 3:amount+=2200; soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") for(Food obb:hotel_ob.luxury_singleerrom[rn].food) { amount+=obb.price; String format = \"%-10s%-10s%-10s%n\"; System.out.printf(format,list[obb.itemno-1],obb.quantity,obb.price ); } break; case 4:amount+=1200; soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") for(Food obb: hotel_ob.deluxe_singleerrom[rn].food) { amount+=obb.price; String format = \"%-10s%-10s%-10s%n\"; System.out.printf(format,list[obb.itemno-1],obb.quantity,obb.price ); } break; default: soutl(\"\") } soutl(\"\") } static void deallocate(int rn,int rtype) { int j; char w; switch (rtype) { case 1: if(hotel_ob.luxury_doublerrom[rn]!=null) soutl(\"\") else { soutl(\"\") return; } soutl(\"\") w=sc.next().charAt(0); if(w=='y'||w=='Y') { bill(rn,rtype); hotel_ob.luxury_doublerrom[rn]=null; soutl(\"\") } break; case 2: if(hotel_ob.deluxe_doublerrom[rn]!=null) soutl(\"\") else { soutl(\"\") return; } soutl(\"\") w=sc.next().charAt(0); if(w=='y'||w=='Y') { bill(rn,rtype); hotel_ob.deluxe_doublerrom[rn]=null; soutl(\"\") } break; case 3: if(hotel_ob.luxury_singleerrom[rn]!=null) soutl(\"\") else { soutl(\"\") return; } soutl(\"\") w=sc.next().charAt(0); if(w=='y'||w=='Y') { bill(rn,rtype); hotel_ob.luxury_singleerrom[rn]=null; soutl(\"\") } break; case 4: if(hotel_ob.deluxe_singleerrom[rn]!=null) soutl(\"\") else { soutl(\"\") return; } soutl(\"\") w=sc.next().charAt(0); if(w=='y'||w=='Y') { bill(rn,rtype); hotel_ob.deluxe_singleerrom[rn]=null; soutl(\"\") } break; default: soutl(\"\") break; } } static void order(int rn,int rtype) { int i,q; char wish; try{ soutl(\"\") do { i = sc.nextInt(); sout(\"\") q=sc.nextInt(); switch(rtype){ case 1: hotel_ob.luxury_doublerrom[rn].food.add(new Food(i,q)); break; case 2: hotel_ob.deluxe_doublerrom[rn].food.add(new Food(i,q)); break; case 3: hotel_ob.luxury_singleerrom[rn].food.add(new Food(i,q)); break; case 4: hotel_ob.deluxe_singleerrom[rn].food.add(new Food(i,q)); break; } soutl(\"\") wish=sc.next().charAt(0); }while(wish=='y'||wish=='Y'); } catch(NullPointerException e) { soutl(\"\") } catch(Exception e) { soutl(\"\") } } } class write implements Runnable { holder hotel_ob; write(holder hotel_ob) { this.hotel_ob=hotel_ob; } @Override public void run() { try{ FileOutputStream fout=new FileOutputStream(\"backup\"); ObjectOutputStream oos=new ObjectOutputStream(fout); oos.writeObject(hotel_ob); } catch(Exception e) { soutl(\"\") } } } public class Main { public static void main(String[] args){ try { File f = new File(\"backup\"); if(f.exists()) { FileInputStream fin=new FileInputStream(f); ObjectInputStream ois=new ObjectInputStream(fin); Hotel.hotel_ob=(holder)ois.readObject(); } Scanner sc = new Scanner(System.in); int ch,ch2; char wish; x: do{ soutl(\"\") ch = sc.nextInt(); switch(ch){ case 1: soutl(\"\") ch2 = sc.nextInt(); Hotel.features(ch2); break; case 2:soutl(\"\") ch2 = sc.nextInt(); Hotel.availability(ch2); break; case 3:soutl(\"\") ch2 = sc.nextInt(); Hotel.bookroom(ch2); break; case 4: sout(\"\") ch2 = sc.nextInt(); if(ch2>60) soutl(\"\") else if(ch2>40) Hotel.order(ch2-41,4); else if(ch2>30) Hotel.order(ch2-31,3); else if(ch2>10) Hotel.order(ch2-11,2); else if(ch2>0) Hotel.order(ch2-1,1); else soutl(\"\") break; case 5: sout(\"\") ch2 = sc.nextInt(); if(ch2>60) soutl(\"\") else if(ch2>40) Hotel.deallocate(ch2-41,4); else if(ch2>30) Hotel.deallocate(ch2-31,3); else if(ch2>10) Hotel.deallocate(ch2-11,2); else if(ch2>0) Hotel.deallocate(ch2-1,1); else soutl(\"\") break; case 6:break x; } soutl(\"\") wish=sc.next().charAt(0); if(!(wish=='y'||wish=='Y'||wish=='n'||wish=='N')) { soutl(\"\") soutl(\"\") wish=sc.next().charAt(0); } }while(wish=='y'||wish=='Y'); Thread t=new Thread(new write(Hotel.hotel_ob)); t.start(); } catch(Exception e) { soutl(\"\") } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Hotal-managment-system-main/Main.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Hotel class manages room booking, customer details, billing, food ordering, and data persistence, handling multiple responsibilities instead of a single one."}, {"principle": "Open-Closed", "justification": "Hotel uses switch-case blocks to handle room types; adding a new room type requires modifying existing code instead of extending via abstraction."}, {"principle": "Dependency Inversion", "justification": "Hotel directly depends on concrete holder and room classes (e.g., Doubleroom, Singleroom) instead of abstractions, tightly coupling high-level and low-level modules."}]}]}
{"project_id": 72, "chunk_id": 0, "prompt": {"main_file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/TraceurConfig.java", "main_file_content": "package com.tspoon.traceur; public class TraceurConfig { private final boolean shouldFilterStackTraces; private final Traceur.LogLevel logLevel; public TraceurConfig(boolean shouldFilterStackTraces) { this.shouldFilterStackTraces = shouldFilterStackTraces; this.logLevel = Traceur.LogLevel.SHOW_ALL; } public boolean shouldFilterStackTraces() { return shouldFilterStackTraces; } public Traceur.LogLevel getLogLevel() { return logLevel; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/TraceurConfig.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "TraceurConfig directly depends on the concrete Traceur.LogLevel enum. High-level modules should depend on abstractions, not concrete implementations."}]}]}
{"project_id": 72, "chunk_id": 0, "prompt": {"main_file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/FlowableOnAssemblyConnectable.java", "main_file_content": "package com.tspoon.traceur; import org.reactivestreams.Subscriber; import io.reactivex.disposables.Disposable; import io.reactivex.flowables.ConnectableFlowable; import io.reactivex.functions.Consumer; import io.reactivex.internal.fuseable.ConditionalSubscriber; final class FlowableOnAssemblyConnectable<T> extends ConnectableFlowable<T> { final ConnectableFlowable<T> source; final TraceurException assembled; FlowableOnAssemblyConnectable(ConnectableFlowable<T> source) { this.source = source; this.assembled = TraceurException.create(); } @Override protected void subscribeActual(Subscriber<? super T> s) { if (s instanceof ConditionalSubscriber) { source.subscribe(new FlowableOnAssembly.OnAssemblyConditionalSubscriber<T>((ConditionalSubscriber<? super T>)s, assembled)); } else { source.subscribe(new FlowableOnAssembly.OnAssemblySubscriber<T>(s, assembled)); } } @Override public void connect(Consumer<? super Disposable> connection) { source.connect(connection); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 72, "chunk_id": 0, "prompt": {"main_file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/ObservableOnAssemblyScalarCallable.java", "main_file_content": "package com.tspoon.traceur; import io.reactivex.*; import io.reactivex.internal.fuseable.ScalarCallable; final class ObservableOnAssemblyScalarCallable<T> extends Observable<T> implements ScalarCallable<T> { final ObservableSource<T> source; final TraceurException assembled; ObservableOnAssemblyScalarCallable(ObservableSource<T> source) { this.source = source; this.assembled = TraceurException.create(); } @Override protected void subscribeActual(Observer<? super T> s) { source.subscribe(new ObservableOnAssembly.OnAssemblyObserver<T>(s, assembled)); } @SuppressWarnings(\"unchecked\") @Override public T call() { return ((ScalarCallable<T>)source).call(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/ObservableOnAssemblyScalarCallable.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "The class is declared as final, preventing extension without modification. This violates OCP as new behavior cannot be added through inheritance."}, {"principle": "Liskov", "justification": "The unsafe cast in call() assumes the source is a ScalarCallable, breaking substitutability if the source is not. This introduces runtime risks incompatible with LSP."}]}]}
{"project_id": 72, "chunk_id": 0, "prompt": {"main_file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/MaybeOnAssembly.java", "main_file_content": "package com.tspoon.traceur; import io.reactivex.Maybe; import io.reactivex.MaybeObserver; import io.reactivex.MaybeSource; import io.reactivex.disposables.Disposable; import io.reactivex.internal.disposables.DisposableHelper; final class MaybeOnAssembly<T> extends Maybe<T> { final MaybeSource<T> source; final TraceurException assembled; MaybeOnAssembly(MaybeSource<T> source) { this.source = source; this.assembled = TraceurException.create(); } @Override protected void subscribeActual(MaybeObserver<? super T> s) { source.subscribe(new OnAssemblyMaybeObserver<T>(s, assembled)); } static final class OnAssemblyMaybeObserver<T> implements MaybeObserver<T>, Disposable { final MaybeObserver<? super T> actual; final TraceurException assembled; Disposable d; OnAssemblyMaybeObserver(MaybeObserver<? super T> actual, TraceurException assembled) { this.actual = actual; this.assembled = assembled; } @Override public void onSubscribe(Disposable d) { if (DisposableHelper.validate(this.d, d)) { this.d = d; actual.onSubscribe(this); } } @Override public void onSuccess(T value) { actual.onSuccess(value); } @Override public void onError(Throwable t) { actual.onError(assembled.appendTo(t)); } @Override public void onComplete() { actual.onComplete(); } @Override public boolean isDisposed() { return d.isDisposed(); } @Override public void dispose() { d.dispose(); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/MaybeOnAssembly.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "The MaybeOnAssembly class is declared as final, preventing extension. This violates OCP as the class cannot be adapted without modifying its code."}]}]}
{"project_id": 72, "chunk_id": 0, "prompt": {"main_file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/FlowableOnAssembly.java", "main_file_content": "package com.tspoon.traceur; import org.reactivestreams.Publisher; import org.reactivestreams.Subscriber; import io.reactivex.Flowable; import io.reactivex.internal.fuseable.ConditionalSubscriber; import io.reactivex.internal.fuseable.QueueSubscription; import io.reactivex.internal.subscribers.BasicFuseableConditionalSubscriber; import io.reactivex.internal.subscribers.BasicFuseableSubscriber; final class FlowableOnAssembly<T> extends Flowable<T> { final Publisher<T> source; final TraceurException assembled; FlowableOnAssembly(Publisher<T> source) { this.source = source; this.assembled = TraceurException.create(); } @Override protected void subscribeActual(Subscriber<? super T> s) { if (s instanceof ConditionalSubscriber) { source.subscribe(new OnAssemblyConditionalSubscriber<>((ConditionalSubscriber<? super T>) s, assembled)); } else { source.subscribe(new OnAssemblySubscriber<>(s, assembled)); } } static final class OnAssemblySubscriber<T> extends BasicFuseableSubscriber<T, T> { final TraceurException assembled; OnAssemblySubscriber(Subscriber<? super T> actual, TraceurException assembled) { super(actual); this.assembled = assembled; } @Override public void onNext(T t) { actual.onNext(t); } @Override public void onError(Throwable t) { actual.onError(assembled.appendTo(t)); } @Override public int requestFusion(int mode) { QueueSubscription<T> qs = this.qs; if (qs != null) { int m = qs.requestFusion(mode); sourceMode = m; return m; } return NONE; } @Override public T poll() throws Exception { return qs.poll(); } } public static final class OnAssemblyConditionalSubscriber<T> extends BasicFuseableConditionalSubscriber<T, T> { final TraceurException assembled; OnAssemblyConditionalSubscriber(ConditionalSubscriber<? super T> actual, TraceurException assembled) { super(actual); this.assembled = assembled; } @Override public void onNext(T t) { actual.onNext(t); } @Override public boolean tryOnNext(T t) { return actual.tryOnNext(t); } @Override public void onError(Throwable t) { actual.onError(assembled.appendTo(t)); } @Override public int requestFusion(int mode) { QueueSubscription<T> qs = this.qs; if (qs != null) { int m = qs.requestFusion(mode); sourceMode = m; return m; } return NONE; } @Override public T poll() throws Exception { return qs.poll(); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/FlowableOnAssembly.java", "violatedPrinciples": [{"principle": "Liskov", "justification": "OnAssemblySubscriber and OnAssemblyConditionalSubscriber override onError to modify the exception, altering base behavior. Subtypes may not be substitutable if base expects original error propagation."}]}]}
{"project_id": 72, "chunk_id": 0, "prompt": {"main_file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/MaybeOnAssemblyCallable.java", "main_file_content": "package com.tspoon.traceur; import java.util.concurrent.Callable; import io.reactivex.*; import io.reactivex.exceptions.Exceptions; final class MaybeOnAssemblyCallable<T> extends Maybe<T> implements Callable<T> { final MaybeSource<T> source; final TraceurException assembled; MaybeOnAssemblyCallable(MaybeSource<T> source) { this.source = source; this.assembled = TraceurException.create(); } @Override protected void subscribeActual(MaybeObserver<? super T> s) { source.subscribe(new MaybeOnAssembly.OnAssemblyMaybeObserver<T>(s, assembled)); } @SuppressWarnings(\"unchecked\") @Override public T call() throws Exception { try { return ((Callable<T>)source).call(); } catch (Exception ex) { Exceptions.throwIfFatal(ex); throw (Exception)assembled.appendTo(ex); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/MaybeOnAssemblyCallable.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "The class is declared as final, preventing extension without modifying existing code, thus violating the Open/Closed Principle."}, {"principle": "Dependency Inversion", "justification": "The class directly depends on the concrete TraceurException instead of an abstraction, violating Dependency Inversion Principle."}]}]}
{"project_id": 72, "chunk_id": 0, "prompt": {"main_file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/SingleOnAssemblyCallable.java", "main_file_content": "package com.tspoon.traceur; import java.util.concurrent.Callable; import io.reactivex.*; import io.reactivex.exceptions.Exceptions; final class SingleOnAssemblyCallable<T> extends Single<T> implements Callable<T> { final SingleSource<T> source; final TraceurException assembled; SingleOnAssemblyCallable(SingleSource<T> source) { this.source = source; this.assembled = TraceurException.create(); } @Override protected void subscribeActual(SingleObserver<? super T> s) { source.subscribe(new SingleOnAssembly.OnAssemblySingleObserver<T>(s, assembled)); } @SuppressWarnings(\"unchecked\") @Override public T call() throws Exception { try { return ((Callable<T>)source).call(); } catch (Exception ex) { Exceptions.throwIfFatal(ex); throw (Exception)assembled.appendTo(ex); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/SingleOnAssemblyCallable.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "The class is declared final, preventing extension without modifying existing code, thus violating the Open/Closed Principle."}, {"principle": "Liskov", "justification": "The call() method assumes source is a Callable, risking ClassCastException. Subtype cannot substitute unconditionally for Callable, violating Liskov."}, {"principle": "Dependency Inversion", "justification": "High-level class directly instantiates TraceurException (concrete class) instead of depending on an abstraction, violating Dependency Inversion."}]}]}
{"project_id": 72, "chunk_id": 0, "prompt": {"main_file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/CompletableOnAssemblyScalarCallable.java", "main_file_content": "package com.tspoon.traceur; import io.reactivex.*; import io.reactivex.internal.fuseable.ScalarCallable; final class CompletableOnAssemblyScalarCallable extends Completable implements ScalarCallable<Object> { final CompletableSource source; final TraceurException assembled; CompletableOnAssemblyScalarCallable(CompletableSource source) { this.source = source; this.assembled = TraceurException.create(); } @Override protected void subscribeActual(CompletableObserver s) { source.subscribe(new CompletableOnAssembly.OnAssemblyCompletableObserver(s, assembled)); } @SuppressWarnings(\"unchecked\") @Override public Object call() { return ((ScalarCallable<Object>)source).call(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/CompletableOnAssemblyScalarCallable.java", "violatedPrinciples": [{"principle": "Liskov", "justification": "The class implements ScalarCallable but assumes the source is a ScalarCallable via an unsafe cast. If the source does not implement ScalarCallable, the call() method will throw a ClassCastException, violating substitutability."}]}]}
{"project_id": 72, "chunk_id": 0, "prompt": {"main_file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/TraceurException.java", "main_file_content": "package com.tspoon.traceur; import com.tspoon.traceur.Traceur.LogLevel; import java.util.ArrayList; import java.util.List; public class TraceurException extends RuntimeException { private final boolean shouldFilterStackTraces; private final LogLevel logLevel; public static TraceurException create() { final TraceurConfig config = Traceur.getConfig(); return new TraceurException(config.shouldFilterStackTraces(), config.getLogLevel()); } TraceurException(boolean shouldFilterStackTraces, LogLevel logLevel) { super(\"Debug Exception generated at call site\"); this.shouldFilterStackTraces = shouldFilterStackTraces; this.logLevel = logLevel; this.setStackTrace(createStackTrace()); } public Throwable appendTo(Throwable throwable) { Throwable t = throwable; while (t.getCause() != null) { t = t.getCause(); if (t == this) { return throwable; } if (logLevel == LogLevel.SHOW_ONLY_FIRST && t instanceof TraceurException) { return throwable; } } t.initCause(this); return throwable; } private StackTraceElement[] createStackTrace() { final StackTraceElement[] realStackTrace = Thread.currentThread().getStackTrace(); if (!shouldFilterStackTraces) { return realStackTrace; } final List<StackTraceElement> filtered = new ArrayList<>(realStackTrace.length); for (StackTraceElement element : realStackTrace) { if (filterLine(element)) { filtered.add(element); } } return filtered.toArray(new StackTraceElement[filtered.size()]); } private boolean filterLine(final StackTraceElement element) { final String className = element.getClassName(); if (className.contains(\".Traceur\") || className.contains(\"OnAssembly\") || className.endsWith(\".RxJavaPlugins\")) { return false; } return true; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/TraceurException.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "The create() method directly depends on the concrete Traceur and TraceurConfig classes. High-level modules should depend on abstractions rather than concrete implementations."}]}]}
{"project_id": 72, "chunk_id": 0, "prompt": {"main_file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/RxJavaAssemblyException.java", "main_file_content": "package com.tspoon.traceur; import java.util.HashSet; import java.util.Set; public final class RxJavaAssemblyException extends RuntimeException { private static final long serialVersionUID = -6757520270386306081L; final String stacktrace; public RxJavaAssemblyException() { this.stacktrace = buildStackTrace(); } public static String buildStackTrace() { StringBuilder b = new StringBuilder(); StackTraceElement[] es = Thread.currentThread().getStackTrace(); b.append(\"RxJavaAssemblyException: assembled\\r\\n\"); for (StackTraceElement e : es) { if (filter(e)) { b.append(\"at \").append(e).append(\"\\r\\n\"); } } return b.toString(); } private static boolean filter(StackTraceElement e) { if (e.getLineNumber() == 1) { return false; } String cn = e.getClassName(); if (cn.contains(\"java.lang.Thread\")) { return false; } if (cn.contains(\"junit.runner\") || cn.contains(\"org.junit.internal\") || cn.contains(\"junit4.runner\")) { return false; } if (cn.contains(\"java.lang.reflect\") || cn.contains(\"sun.reflect\")) { return false; } if (cn.contains(\".RxJavaAssemblyException\")) { return false; } if (cn.contains(\"OnAssembly\") || cn.contains(\"RxJavaAssemblyTracking\") || cn.contains(\"RxJavaPlugins\")) { return false; } return true; } public String stacktrace() { return stacktrace; } @Override public synchronized Throwable fillInStackTrace() { return this; } public Throwable appendLast(Throwable ex) { Throwable r = ex; Set<Throwable> memory = new HashSet<Throwable>(); while (ex.getCause() != null) { if (memory.add(ex)) { ex = ex.getCause(); } else { return r; } } try { ex.initCause(this); } catch (Throwable exc) { } return r; } public static RxJavaAssemblyException find(Throwable ex) { Set<Throwable> memory = new HashSet<Throwable>(); while (ex != null) { if (ex instanceof RxJavaAssemblyException) { return (RxJavaAssemblyException) ex; } if (memory.add(ex)) { ex = ex.getCause(); } else { return null; } } return null; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/RxJavaAssemblyException.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The class handles exception creation, stacktrace building/filtering, cause chain manipulation, and exception searching. These are multiple distinct responsibilities beyond a single reason to change."}, {"principle": "Liskov", "justification": "Overriding fillInStackTrace() to return this without populating stacktrace violates behavioral expectations of RuntimeException subclass - callers expect populated stack traces from standard exceptions."}]}]}
{"project_id": 72, "chunk_id": 0, "prompt": {"main_file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/ObservableOnAssembly.java", "main_file_content": "package com.tspoon.traceur; import io.reactivex.Observable; import io.reactivex.ObservableSource; import io.reactivex.Observer; import io.reactivex.internal.fuseable.QueueDisposable; import io.reactivex.internal.observers.BasicFuseableObserver; final class ObservableOnAssembly<T> extends Observable<T> { final ObservableSource<T> source; final TraceurException assembled; ObservableOnAssembly(ObservableSource<T> source) { this.source = source; this.assembled = TraceurException.create(); } @Override protected void subscribeActual(Observer<? super T> s) { source.subscribe(new OnAssemblyObserver<T>(s, assembled)); } static final class OnAssemblyObserver<T> extends BasicFuseableObserver<T, T> { final TraceurException assembled; OnAssemblyObserver(Observer<? super T> actual, TraceurException assembled) { super(actual); this.assembled = assembled; } @Override public void onNext(T t) { actual.onNext(t); } @Override public void onError(Throwable t) { actual.onError(assembled.appendTo(t)); } @Override public int requestFusion(int mode) { QueueDisposable<T> qs = this.qs; if (qs != null) { int m = qs.requestFusion(mode); sourceMode = m; return m; } return NONE; } @Override public T poll() throws Exception { return qs.poll(); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/ObservableOnAssembly.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "The class ObservableOnAssembly is declared as final, preventing extension without modification, thus violating the Open/Closed Principle which requires classes to be open for extension but closed for modification."}]}]}
{"project_id": 72, "chunk_id": 0, "prompt": {"main_file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/ObservableOnAssemblyCallable.java", "main_file_content": "package com.tspoon.traceur; import java.util.concurrent.Callable; import io.reactivex.*; import io.reactivex.exceptions.Exceptions; final class ObservableOnAssemblyCallable<T> extends Observable<T> implements Callable<T> { final ObservableSource<T> source; final TraceurException assembled; ObservableOnAssemblyCallable(ObservableSource<T> source) { this.source = source; this.assembled = TraceurException.create(); } @Override protected void subscribeActual(Observer<? super T> s) { source.subscribe(new ObservableOnAssembly.OnAssemblyObserver<T>(s, assembled)); } @SuppressWarnings(\"unchecked\") @Override public T call() throws Exception { try { return ((Callable<T>)source).call(); } catch (Exception ex) { Exceptions.throwIfFatal(ex); throw (Exception)assembled.appendTo(ex); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/ObservableOnAssemblyCallable.java", "violatedPrinciples": []}]}
{"project_id": 72, "chunk_id": 0, "prompt": {"main_file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/ObservableOnAssemblyConnectable.java", "main_file_content": "package com.tspoon.traceur; import io.reactivex.Observer; import io.reactivex.disposables.Disposable; import io.reactivex.functions.Consumer; import io.reactivex.observables.ConnectableObservable; final class ObservableOnAssemblyConnectable<T> extends ConnectableObservable<T> { final ConnectableObservable<T> source; final TraceurException assembled; ObservableOnAssemblyConnectable(ConnectableObservable<T> source) { this.source = source; this.assembled = TraceurException.create(); } @Override protected void subscribeActual(Observer<? super T> s) { source.subscribe(new ObservableOnAssembly.OnAssemblyObserver<T>(s, assembled)); } @Override public void connect(Consumer<? super Disposable> connection) { source.connect(connection); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/ObservableOnAssemblyConnectable.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "The class is marked as final, preventing extension without modification. This violates the Open-Closed Principle, which requires classes to be open for extension but closed for modification."}]}]}
{"project_id": 72, "chunk_id": 0, "prompt": {"main_file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/Traceur.java", "main_file_content": "package com.tspoon.traceur; import java.util.concurrent.Callable; import io.reactivex.Completable; import io.reactivex.Flowable; import io.reactivex.Maybe; import io.reactivex.Observable; import io.reactivex.Single; import io.reactivex.flowables.ConnectableFlowable; import io.reactivex.functions.Function; import io.reactivex.internal.fuseable.ScalarCallable; import io.reactivex.observables.ConnectableObservable; import io.reactivex.parallel.ParallelFlowable; import io.reactivex.plugins.RxJavaPlugins; public class Traceur { private static TraceurConfig config; private Traceur() { throw new IllegalStateException(\"No instances!\"); } public static void enableLogging() { enableLogging(new TraceurConfig(true)); } @SuppressWarnings({\"unchecked\", \"rawtypes\"}) public synchronized static void enableLogging(TraceurConfig config) { Traceur.config = config; RxJavaPlugins.setOnFlowableAssembly(new Function<Flowable, Flowable>() { @Override public Flowable apply(Flowable f) throws Exception { if (f instanceof Callable) { if (f instanceof ScalarCallable) { return new FlowableOnAssemblyScalarCallable(f); } return new FlowableOnAssemblyCallable(f); } return new FlowableOnAssembly(f); } }); RxJavaPlugins.setOnConnectableFlowableAssembly(new Function<ConnectableFlowable, ConnectableFlowable>() { @Override public ConnectableFlowable apply(ConnectableFlowable f) throws Exception { return new FlowableOnAssemblyConnectable(f); } }); RxJavaPlugins.setOnObservableAssembly(new Function<Observable, Observable>() { @Override public Observable apply(Observable f) throws Exception { if (f instanceof Callable) { if (f instanceof ScalarCallable) { return new ObservableOnAssemblyScalarCallable(f); } return new ObservableOnAssemblyCallable(f); } return new ObservableOnAssembly(f); } }); RxJavaPlugins.setOnConnectableObservableAssembly(new Function<ConnectableObservable, ConnectableObservable>() { @Override public ConnectableObservable apply(ConnectableObservable f) throws Exception { return new ObservableOnAssemblyConnectable(f); } }); RxJavaPlugins.setOnSingleAssembly(new Function<Single, Single>() { @Override public Single apply(Single f) throws Exception { if (f instanceof Callable) { if (f instanceof ScalarCallable) { return new SingleOnAssemblyScalarCallable(f); } return new SingleOnAssemblyCallable(f); } return new SingleOnAssembly(f); } }); RxJavaPlugins.setOnCompletableAssembly(new Function<Completable, Completable>() { @Override public Completable apply(Completable f) throws Exception { if (f instanceof Callable) { if (f instanceof ScalarCallable) { return new CompletableOnAssemblyScalarCallable(f); } return new CompletableOnAssemblyCallable(f); } return new CompletableOnAssembly(f); } }); RxJavaPlugins.setOnMaybeAssembly(new Function<Maybe, Maybe>() { @Override public Maybe apply(Maybe f) throws Exception { if (f instanceof Callable) { if (f instanceof ScalarCallable) { return new MaybeOnAssemblyScalarCallable(f); } return new MaybeOnAssemblyCallable(f); } return new MaybeOnAssembly(f); } }); RxJavaPlugins.setOnParallelAssembly(new Function<ParallelFlowable, ParallelFlowable>() { @Override public ParallelFlowable apply(ParallelFlowable t) throws Exception { return new ParallelFlowableOnAssembly(t); } }); } public static synchronized void disableLogging() { RxJavaPlugins.setOnCompletableAssembly(null); RxJavaPlugins.setOnSingleAssembly(null); RxJavaPlugins.setOnMaybeAssembly(null); RxJavaPlugins.setOnObservableAssembly(null); RxJavaPlugins.setOnFlowableAssembly(null); RxJavaPlugins.setOnConnectableObservableAssembly(null); RxJavaPlugins.setOnConnectableFlowableAssembly(null); RxJavaPlugins.setOnParallelAssembly(null); Traceur.config = null; } public static TraceurConfig getConfig() { return config; } public enum LogLevel { SHOW_ALL, SHOW_ONLY_FIRST, } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/Traceur.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Traceur class manages configuration (enable/disable logging, config storage) and sets up multiple RxJava assembly hooks, handling diverse responsibilities beyond a single reason to change."}, {"principle": "Open-Closed", "justification": "The enableLogging method uses explicit type checks (e.g., instanceof Callable) and conditional logic, requiring modification to support new reactive types instead of extension."}, {"principle": "Dependency Inversion", "justification": "Traceur directly depends on concrete RxJava classes (e.g., Flowable, Observable) and RxJavaPlugins, violating the requirement for high-level modules to depend on abstractions."}]}]}
{"project_id": 72, "chunk_id": 0, "prompt": {"main_file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/FlowableOnAssemblyCallable.java", "main_file_content": "package com.tspoon.traceur; import java.util.concurrent.Callable; import org.reactivestreams.*; import io.reactivex.Flowable; import io.reactivex.exceptions.Exceptions; import io.reactivex.internal.fuseable.ConditionalSubscriber; final class FlowableOnAssemblyCallable<T> extends Flowable<T> implements Callable<T> { final Publisher<T> source; final TraceurException assembled; FlowableOnAssemblyCallable(Publisher<T> source) { this.source = source; this.assembled = TraceurException.create(); } @Override protected void subscribeActual(Subscriber<? super T> s) { if (s instanceof ConditionalSubscriber) { source.subscribe(new FlowableOnAssembly.OnAssemblyConditionalSubscriber<T>((ConditionalSubscriber<? super T>)s, assembled)); } else { source.subscribe(new FlowableOnAssembly.OnAssemblySubscriber<T>(s, assembled)); } } @SuppressWarnings(\"unchecked\") @Override public T call() throws Exception { try { return ((Callable<T>)source).call(); } catch (Exception ex) { Exceptions.throwIfFatal(ex); throw (Exception)assembled.appendTo(ex); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/FlowableOnAssemblyCallable.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The class combines responsibilities of a Flowable (reactive stream handling) and a Callable (result computation), introducing multiple reasons to change."}, {"principle": "Open-Closed", "justification": "The class is declared final, preventing extension without modification, which violates the principle of being open for extension."}]}]}
{"project_id": 72, "chunk_id": 0, "prompt": {"main_file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/MaybeOnAssemblyScalarCallable.java", "main_file_content": "package com.tspoon.traceur; import io.reactivex.*; import io.reactivex.internal.fuseable.ScalarCallable; final class MaybeOnAssemblyScalarCallable<T> extends Maybe<T> implements ScalarCallable<T> { final MaybeSource<T> source; final TraceurException assembled; MaybeOnAssemblyScalarCallable(MaybeSource<T> source) { this.source = source; this.assembled = TraceurException.create(); } @Override protected void subscribeActual(MaybeObserver<? super T> s) { source.subscribe(new MaybeOnAssembly.OnAssemblyMaybeObserver<T>(s, assembled)); } @SuppressWarnings(\"unchecked\") @Override public T call() { return ((ScalarCallable<T>)source).call(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/MaybeOnAssemblyScalarCallable.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "The class is declared as final, preventing extension without modification, thus violating the Open-Closed Principle."}, {"principle": "Dependency Inversion", "justification": "Directly depends on concrete TraceurException instead of an abstraction, violating Dependency Inversion Principle."}]}]}
{"project_id": 72, "chunk_id": 0, "prompt": {"main_file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/CompletableOnAssembly.java", "main_file_content": "package com.tspoon.traceur; import io.reactivex.Completable; import io.reactivex.CompletableObserver; import io.reactivex.CompletableSource; import io.reactivex.disposables.Disposable; import io.reactivex.internal.disposables.DisposableHelper; final class CompletableOnAssembly extends Completable { final CompletableSource source; final TraceurException assembled; CompletableOnAssembly(CompletableSource source) { this.source = source; this.assembled = TraceurException.create(); } @Override protected void subscribeActual(CompletableObserver s) { source.subscribe(new OnAssemblyCompletableObserver(s, assembled)); } static final class OnAssemblyCompletableObserver implements CompletableObserver, Disposable { final CompletableObserver actual; final TraceurException assembled; Disposable d; OnAssemblyCompletableObserver(CompletableObserver actual, TraceurException assembled) { this.actual = actual; this.assembled = assembled; } @Override public void onSubscribe(Disposable d) { if (DisposableHelper.validate(this.d, d)) { this.d = d; actual.onSubscribe(this); } } @Override public void onError(Throwable t) { actual.onError(assembled.appendTo(t)); } @Override public void onComplete() { actual.onComplete(); } @Override public boolean isDisposed() { return d.isDisposed(); } @Override public void dispose() { d.dispose(); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/CompletableOnAssembly.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "The final class CompletableOnAssembly cannot be extended without modifying its code, violating OCP by preventing inheritance-based extension."}]}]}
{"project_id": 72, "chunk_id": 0, "prompt": {"main_file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/CompletableOnAssemblyCallable.java", "main_file_content": "package com.tspoon.traceur; import java.util.concurrent.Callable; import io.reactivex.*; import io.reactivex.exceptions.Exceptions; final class CompletableOnAssemblyCallable extends Completable implements Callable<Object> { final CompletableSource source; final TraceurException assembled; CompletableOnAssemblyCallable(CompletableSource source) { this.source = source; this.assembled = TraceurException.create(); } @Override protected void subscribeActual(CompletableObserver s) { source.subscribe(new CompletableOnAssembly.OnAssemblyCompletableObserver(s, assembled)); } @SuppressWarnings(\"unchecked\") @Override public Object call() throws Exception { try { return ((Callable<Object>)source).call(); } catch (Exception ex) { Exceptions.throwIfFatal(ex); throw (Exception)assembled.appendTo(ex); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/CompletableOnAssemblyCallable.java", "violatedPrinciples": [{"principle": "Liskov", "justification": "The class implements Callable but assumes the source is a Callable, introducing a runtime exception if the source isn't. Subtypes cannot be substituted for Callable without additional constraints."}]}]}
{"project_id": 72, "chunk_id": 0, "prompt": {"main_file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/SingleOnAssemblyScalarCallable.java", "main_file_content": "package com.tspoon.traceur; import io.reactivex.Single; import io.reactivex.SingleObserver; import io.reactivex.SingleSource; import io.reactivex.internal.fuseable.ScalarCallable; final class SingleOnAssemblyScalarCallable<T> extends Single<T> implements ScalarCallable<T> { final SingleSource<T> source; final TraceurException assembled; SingleOnAssemblyScalarCallable(SingleSource<T> source) { this.source = source; this.assembled = TraceurException.create(); } @Override protected void subscribeActual(SingleObserver<? super T> s) { source.subscribe(new SingleOnAssembly.OnAssemblySingleObserver<T>(s, assembled)); } @SuppressWarnings(\"unchecked\") @Override public T call() { return ((ScalarCallable<T>) source).call(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/SingleOnAssemblyScalarCallable.java", "violatedPrinciples": [{"principle": "Liskov", "justification": "The call() method performs an unchecked cast to ScalarCallable, assuming the source implements it. This violates LSP as subtypes (source) might not be substitutable for ScalarCallable, risking runtime exceptions."}]}]}
{"project_id": 72, "chunk_id": 0, "prompt": {"main_file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/FlowableOnAssemblyScalarCallable.java", "main_file_content": "package com.tspoon.traceur; import org.reactivestreams.Publisher; import org.reactivestreams.Subscriber; import io.reactivex.Flowable; import io.reactivex.internal.fuseable.ConditionalSubscriber; import io.reactivex.internal.fuseable.ScalarCallable; final class FlowableOnAssemblyScalarCallable<T> extends Flowable<T> implements ScalarCallable<T> { final Publisher<T> source; final TraceurException assembled; FlowableOnAssemblyScalarCallable(Publisher<T> source) { this.source = source; this.assembled = TraceurException.create(); } @Override protected void subscribeActual(Subscriber<? super T> s) { if (s instanceof ConditionalSubscriber) { source.subscribe(new FlowableOnAssembly.OnAssemblyConditionalSubscriber<T>((ConditionalSubscriber<? super T>) s, assembled)); } else { source.subscribe(new FlowableOnAssembly.OnAssemblySubscriber<T>(s, assembled)); } } @SuppressWarnings(\"unchecked\") @Override public T call() { return ((ScalarCallable<T>) source).call(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/FlowableOnAssemblyScalarCallable.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "The class is marked as final, preventing extension without modification, which violates the Open/Closed Principle."}, {"principle": "Dependency Inversion", "justification": "The class directly instantiates concrete subscriber implementations (OnAssemblySubscriber, OnAssemblyConditionalSubscriber) instead of depending on abstractions."}]}]}
{"project_id": 72, "chunk_id": 0, "prompt": {"main_file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/ParallelFlowableOnAssembly.java", "main_file_content": "package com.tspoon.traceur; import org.reactivestreams.Subscriber; import io.reactivex.internal.fuseable.ConditionalSubscriber; import io.reactivex.parallel.ParallelFlowable; final class ParallelFlowableOnAssembly<T> extends ParallelFlowable<T> { final ParallelFlowable<T> source; final TraceurException assembled; ParallelFlowableOnAssembly(ParallelFlowable<T> source) { this.source = source; this.assembled = TraceurException.create(); } @Override public int parallelism() { return source.parallelism(); } @Override public void subscribe(Subscriber<? super T>[] s) { if (validate(s)) { int n = s.length; @SuppressWarnings(\"unchecked\") Subscriber<? super T>[] parents = new Subscriber[n]; for (int i = 0; i < n; i++) { Subscriber<? super T> z = s[i]; if (z instanceof ConditionalSubscriber) { parents[i] = new FlowableOnAssembly.OnAssemblyConditionalSubscriber<T>((ConditionalSubscriber<? super T>)z, assembled); } else { parents[i] = new FlowableOnAssembly.OnAssemblySubscriber<T>(z, assembled); } } source.subscribe(parents); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/ParallelFlowableOnAssembly.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "High-level module ParallelFlowableOnAssembly directly depends on concrete TraceurException instead of an abstraction. Low-level exceptions should be referenced via abstractions to invert dependencies."}]}]}
{"project_id": 72, "chunk_id": 0, "prompt": {"main_file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/SingleOnAssembly.java", "main_file_content": "package com.tspoon.traceur; import io.reactivex.Single; import io.reactivex.SingleObserver; import io.reactivex.SingleSource; import io.reactivex.disposables.Disposable; import io.reactivex.internal.disposables.DisposableHelper; final class SingleOnAssembly<T> extends Single<T> { final SingleSource<T> source; final TraceurException assembled; SingleOnAssembly(SingleSource<T> source) { this.source = source; this.assembled = TraceurException.create(); } @Override protected void subscribeActual(SingleObserver<? super T> s) { source.subscribe(new OnAssemblySingleObserver<T>(s, assembled)); } static final class OnAssemblySingleObserver<T> implements SingleObserver<T>, Disposable { final SingleObserver<? super T> actual; final TraceurException assembled; Disposable d; OnAssemblySingleObserver(SingleObserver<? super T> actual, TraceurException assembled) { this.actual = actual; this.assembled = assembled; } @Override public void onSubscribe(Disposable d) { if (DisposableHelper.validate(this.d, d)) { this.d = d; actual.onSubscribe(this); } } @Override public void onSuccess(T value) { actual.onSuccess(value); } @Override public void onError(Throwable t) { actual.onError(assembled.appendTo(t)); } @Override public boolean isDisposed() { return d.isDisposed(); } @Override public void dispose() { d.dispose(); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/SingleOnAssembly.java", "violatedPrinciples": []}]}
{"project_id": 72, "chunk_id": 0, "prompt": {"main_file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/RxJavaAssemblyTracking.java", "main_file_content": "package com.tspoon.traceur; import java.util.concurrent.Callable; import java.util.concurrent.atomic.AtomicBoolean; import io.reactivex.*; import io.reactivex.flowables.ConnectableFlowable; import io.reactivex.functions.Function; import io.reactivex.internal.fuseable.ScalarCallable; import io.reactivex.observables.ConnectableObservable; import io.reactivex.parallel.ParallelFlowable; import io.reactivex.plugins.RxJavaPlugins; public final class RxJavaAssemblyTracking { static final AtomicBoolean lock = new AtomicBoolean(); private RxJavaAssemblyTracking() { throw new IllegalStateException(\"No instances!\"); } @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) public static void enable() { if (lock.compareAndSet(false, true)) { RxJavaPlugins.setOnFlowableAssembly(new Function<Flowable, Flowable>() { @Override public Flowable apply(Flowable f) throws Exception { if (f instanceof Callable) { if (f instanceof ScalarCallable) { return new FlowableOnAssemblyScalarCallable(f); } return new FlowableOnAssemblyCallable(f); } return new FlowableOnAssembly(f); } }); RxJavaPlugins.setOnConnectableFlowableAssembly(new Function<ConnectableFlowable, ConnectableFlowable>() { @Override public ConnectableFlowable apply(ConnectableFlowable f) throws Exception { return new FlowableOnAssemblyConnectable(f); } }); RxJavaPlugins.setOnObservableAssembly(new Function<Observable, Observable>() { @Override public Observable apply(Observable f) throws Exception { if (f instanceof Callable) { if (f instanceof ScalarCallable) { return new ObservableOnAssemblyScalarCallable(f); } return new ObservableOnAssemblyCallable(f); } return new ObservableOnAssembly(f); } }); RxJavaPlugins.setOnConnectableObservableAssembly(new Function<ConnectableObservable, ConnectableObservable>() { @Override public ConnectableObservable apply(ConnectableObservable f) throws Exception { return new ObservableOnAssemblyConnectable(f); } }); RxJavaPlugins.setOnSingleAssembly(new Function<Single, Single>() { @Override public Single apply(Single f) throws Exception { if (f instanceof Callable) { if (f instanceof ScalarCallable) { return new SingleOnAssemblyScalarCallable(f); } return new SingleOnAssemblyCallable(f); } return new SingleOnAssembly(f); } }); RxJavaPlugins.setOnCompletableAssembly(new Function<Completable, Completable>() { @Override public Completable apply(Completable f) throws Exception { if (f instanceof Callable) { if (f instanceof ScalarCallable) { return new CompletableOnAssemblyScalarCallable(f); } return new CompletableOnAssemblyCallable(f); } return new CompletableOnAssembly(f); } }); RxJavaPlugins.setOnMaybeAssembly(new Function<Maybe, Maybe>() { @Override public Maybe apply(Maybe f) throws Exception { if (f instanceof Callable) { if (f instanceof ScalarCallable) { return new MaybeOnAssemblyScalarCallable(f); } return new MaybeOnAssemblyCallable(f); } return new MaybeOnAssembly(f); } }); RxJavaPlugins.setOnParallelAssembly(new Function<ParallelFlowable, ParallelFlowable>() { @Override public ParallelFlowable apply(ParallelFlowable t) throws Exception { return new ParallelFlowableOnAssembly(t); } }); lock.set(false); } } public static void disable() { if (lock.compareAndSet(false, true)) { RxJavaPlugins.setOnCompletableAssembly(null); RxJavaPlugins.setOnSingleAssembly(null); RxJavaPlugins.setOnMaybeAssembly(null); RxJavaPlugins.setOnObservableAssembly(null); RxJavaPlugins.setOnFlowableAssembly(null); RxJavaPlugins.setOnConnectableObservableAssembly(null); RxJavaPlugins.setOnConnectableFlowableAssembly(null); RxJavaPlugins.setOnParallelAssembly(null); lock.set(false); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Traceur-master/Traceur-master/traceur/src/main/java/com/tspoon/traceur/RxJavaAssemblyTracking.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "The enable() method uses instanceof checks and creates concrete subclass instances. Modifying behavior for new Rx types requires changing this method rather than extending through abstractions."}, {"principle": "Dependency Inversion", "justification": "High-level assembly tracking logic directly depends on concrete RxJava classes (Flowable, Observable) instead of abstractions. Plugin configuration binds to implementation-specific wrapper classes."}]}]}
{"project_id": 72, "chunk_id": 0, "prompt": {"main_file_path": "Traceur-master/Traceur-master/traceur/src/test/java/com/tspoon/traceur/StreamFactory.java", "main_file_content": "package com.tspoon.traceur; import io.reactivex.Observable; public class StreamFactory { public static Observable<String> createNullPointerExceptionObservable() { return Observable.just(\"Hello\") .map(s -> null); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Traceur-master/Traceur-master/traceur/src/test/java/com/tspoon/traceur/StreamFactory.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "StreamFactory uses a static method to create an Observable, preventing extension through inheritance or composition without modifying existing code, violating OCP."}]}]}
{"project_id": 72, "chunk_id": 0, "prompt": {"main_file_path": "Traceur-master/Traceur-master/traceur/src/test/java/com/tspoon/traceur/TraceurTest.java", "main_file_content": "package com.tspoon.traceur; import org.assertj.core.api.Assertions; import org.junit.After; import org.junit.Test; import java.io.PrintWriter; import java.io.StringWriter; import io.reactivex.annotations.NonNull; import io.reactivex.functions.Consumer; import io.reactivex.functions.Predicate; import static org.assertj.core.api.Assertions.assertThat; public class TraceurTest { @After public void tearDown() { Traceur.disableLogging(); } @Test public void callSiteIsShownInStackTrace() throws Exception { try { StreamFactory.createNullPointerExceptionObservable().blockingFirst(); } catch (Throwable t) { final String exceptionAsString = exceptionAsString(t); printStackTrace(\"Default Stacktrace\", exceptionAsString); assertThat(exceptionAsString).doesNotContain(\"StreamFactory\"); } Traceur.enableLogging(); try { StreamFactory.createNullPointerExceptionObservable().blockingFirst(); Assertions.failBecauseExceptionWasNotThrown(Throwable.class); } catch (Throwable t) { final String exceptionAsString = exceptionAsString(t); printStackTrace(\"Traceur Stacktrace\", exceptionAsString); assertThat(exceptionAsString).contains(\"StreamFactory\"); } } @Test public void filtersStackTraces() throws Exception { Traceur.enableLogging(new TraceurConfig(false)); try { StreamFactory.createNullPointerExceptionObservable().blockingFirst(); Assertions.failBecauseExceptionWasNotThrown(Throwable.class); } catch (Throwable t) { final String exceptionAsString = exceptionAsString(t); printStackTrace(\"Exception without filtering\", exceptionAsString); assertThat(exceptionAsString).contains(\"TraceurException.java\"); assertThat(exceptionAsString).contains(\"ObservableOnAssembly.<init>\"); } Traceur.enableLogging(new TraceurConfig(true)); try { StreamFactory.createNullPointerExceptionObservable().blockingFirst(); Assertions.failBecauseExceptionWasNotThrown(Throwable.class); } catch (Throwable t) { final String exceptionAsString = exceptionAsString(t); printStackTrace(\"Exception with filtering\", exceptionAsString); assertThat(exceptionAsString).doesNotContain(\"TraceurException.java\"); assertThat(exceptionAsString).doesNotContain(\"ObservableOnAssembly.<init>\"); } } @Test public void usingRetryDoesNotFail() { Traceur.enableLogging(); StreamFactory.createNullPointerExceptionObservable() .doOnError(new Consumer<Throwable>() { @Override public void accept(@NonNull Throwable throwable) throws Exception { } }) .retry(1) .test() .assertError(new Predicate<Throwable>() { @Override public boolean test(@NonNull Throwable throwable) throws Exception { return throwable instanceof NullPointerException && throwable.getCause() instanceof TraceurException; } }); } private static void printStackTrace(String sectionName, String exceptionAsString) { printSectionSeparator(sectionName); soutl(\"\") } private static String exceptionAsString(Throwable t) { final StringWriter sw = new StringWriter(); t.printStackTrace(new PrintWriter(sw)); return sw.toString(); } private static void printSectionSeparator(String sectionName) { soutl(\"\") } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 73, "chunk_id": 0, "prompt": {"main_file_path": "Casino-Craps-Game-main/Casino-Craps-Game-main/__SHELL0.java", "main_file_content": "public class __SHELL0 extends bluej.runtime.Shell { public static void run() throws Throwable { java.lang.String[] __bluej_param0 = { }; Craps.main(__bluej_param0); }}", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Casino-Craps-Game-main/Casino-Craps-Game-main/__SHELL0.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "The high-level __SHELL0 class directly depends on the concrete Craps class instead of an abstraction, violating DIP. High-level modules should depend on abstractions rather than low-level implementations."}]}]}
{"project_id": 73, "chunk_id": 0, "prompt": {"main_file_path": "Casino-Craps-Game-main/Casino-Craps-Game-main/Die.java", "main_file_content": "import java.util.*; import java.lang.*; import java.io.*; public class Die { private int n; private int faceValue; private Random rand; public Die(int n) { this.n = n; this.rand = new Random(); } public int getFaceValue() { return faceValue; } public void setN(int n) { this.n = n; } public void roll() { faceValue = rand.nextInt(n)+1; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Casino-Craps-Game-main/Casino-Craps-Game-main/Die.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "Die directly instantiates Random, a low-level module. High-level modules depending on Die would indirectly depend on this concrete implementation instead of an abstraction."}, {"principle": "Open-Closed", "justification": "Die's random number generation cannot be modified without changing the class. It should allow extension through injected dependencies rather than hard-coded Random."}]}]}
{"project_id": 73, "chunk_id": 0, "prompt": {"main_file_path": "Casino-Craps-Game-main/Casino-Craps-Game-main/Craps.java", "main_file_content": "import java.util.*; import java.lang.*; import java.io.*; public class Craps { static Scanner scan = new Scanner ( System.in ); static boolean done, undecided, chance, ok; static String answer; static Die d1, d2; static int sum, point_value; static int played_games = 0, wins = 0, loses = 0; static int two = 0, three = 0, four = 0, five = 0, six = 0, seven = 0, eight = 0, nine = 0, ten = 0, eleven = 0, twelve = 0; public static void main (String[] args) { d1 = new Die(6); d2 = new Die(6); soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") done = false; while (!done) { sout(\"\") answer = scan.nextLine(); undecided = false; d1.roll(); d2.roll(); sum = d1.getFaceValue() + d2.getFaceValue(); played_games++; if (sum == 2 || sum == 3 || sum == 12) { soutl(\"\") soutl(\"\") loses++; if (sum == 2) { two++; } else if (sum == 3) { three++; } else if (sum == 12) { twelve++; } } else if (sum == 7 || sum == 11) { soutl(\"\") soutl(\"\") wins++; if (sum == 7) { seven++; } else if (sum == 11) { eleven++; } } else { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") point_value = sum; undecided = true; if (sum == 4) { four++; } else if (sum == 5) { five++; } else if (sum == 6) { six++; } else if (sum == 8) { eight++; } else if (sum == 9) { nine++; } else if (sum == 10) { ten++; } } if (undecided) { sout(\"\") answer = scan.nextLine(); soutl(\"\") chance = false; while (!chance) { d1.roll(); d2.roll(); sum = d1.getFaceValue() + d2.getFaceValue(); soutl(\"\") if (sum == 7) { soutl(\"\") soutl(\"\") chance = true; loses++; seven++; } else if (sum == point_value) { soutl(\"\") soutl(\"\") chance = true; wins++; if (sum == 2) { two++; } else if (sum == 3) { three++; } else if (sum == 4) { four++; } else if (sum == 5) { five++; } else if (sum == 6) { six++; } else if (sum == 8) { eight++; } else if (sum == 9) { nine++; } else if (sum == 10) { ten++; } else if (sum == 11) { eleven++; } else if (sum == 12) { twelve++; } } else { chance = false; if (sum == 2) { two++; } else if (sum == 3) { three++; } else if (sum == 4) { four++; } else if (sum == 5) { five++; } else if (sum == 6) { six++; } else if (sum == 8) { eight++; } else if (sum == 9) { nine++; } else if (sum == 10) { ten++; } else if (sum == 11) { eleven++; } else if (sum == 12) { twelve++; } } } } sout(\"\") ok = false; while (!ok){ answer = scan.nextLine(); if (answer.equals(\"Yes\") || answer.equals(\"yes\") || answer.equals(\"Y\") || answer.equals(\"y\")) { soutl(\"\") done = true; ok = true; } else if (answer.equals(\"No\") || answer.equals(\"no\") || answer.equals(\"N\") || answer.equals(\"n\")) { done = false; ok = true; } else { sout(\"\") } } } soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Casino-Craps-Game-main/Casino-Craps-Game-main/Craps.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Craps class handles game logic, user input/output, statistics tracking, and result reporting. This constitutes multiple responsibilities, violating SRP."}, {"principle": "Open-Closed", "justification": "Game outcome determination uses explicit conditionals for each sum value. Adding new outcomes requires modifying existing code, violating OCP."}, {"principle": "Dependency Inversion", "justification": "Craps directly instantiates concrete Die objects without depending on abstractions. High-level game logic depends on low-level Die implementation, violating DIP."}]}]}
{"project_id": 77, "chunk_id": 0, "prompt": {"main_file_path": "WorkerContracts-java-main/WorkerContracts-java-main/src/application/Program.java", "main_file_content": "package application; import java.util.Date; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Locale; import java.util.Scanner; import entities.Department; import entities.HourContract; import entities.Worker; import entities.WorkerLevel; public class Program { public static void main(String[] args) throws ParseException { Locale.setDefault(Locale.US); Scanner sc = new Scanner(System.in); SimpleDateFormat sdf = new SimpleDateFormat(\"dd/MM/yyyy\"); sout(\"\") String departmentName = sc.nextLine(); soutl(\"\") sout(\"\") String workerName = sc.nextLine(); sout(\"\") String workerlevel = sc.nextLine(); sout(\"\") double baseSalary = sc.nextDouble(); Worker worker = new Worker(workerName, WorkerLevel.valueOf(workerlevel), baseSalary, new Department(departmentName)); sout(\"\") int n = sc.nextInt(); for (int i = 1; i <= n; i++) { soutl(\"\") sout(\"\") Date contractDate = sdf.parse(sc.next()); sout(\"\") double valuePerHour = sc.nextDouble(); sout(\"\") int hours = sc.nextInt(); HourContract contract = new HourContract(contractDate, valuePerHour, hours); worker.addContract(contract); } sout(\"\") String monthAndYear = sc.next(); int month = Integer.parseInt(monthAndYear.substring(0, 2)); int year = Integer.parseInt(monthAndYear.substring(3)); soutl(\"\") soutl(\"\") soutl(\"\") sc.close(); } }", "dependencies": [{"file_path": "WorkerContracts-java-main/WorkerContracts-java-main/src/entities/Department.java", "file_content": "package entities; public class Department { private String name; public Department() { } public Department(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } }"}, {"file_path": "WorkerContracts-java-main/WorkerContracts-java-main/src/entities/HourContract.java", "file_content": "package entities; import java.util.Date; public class HourContract { private Date date; private Double valuePerHour; private Integer hours; public HourContract() { } public HourContract(Date date, Double valuePerHour, Integer hours) { this.date = date; this.valuePerHour = valuePerHour; this.hours = hours; } public Date getDate() { return date; } public void setDate(Date date) { this.date = date; } public Double getValuePerHour() { return valuePerHour; } public void setValuePerHour(Double valuePerHour) { this.valuePerHour = valuePerHour; } public Integer getHours() { return hours; } public void setHours(Integer hours) { this.hours = hours; } public double totalValue() { return valuePerHour * hours; } }"}, {"file_path": "WorkerContracts-java-main/WorkerContracts-java-main/src/entities/Worker.java", "file_content": "package entities; import java.util.ArrayList; import java.util.Calendar; import java.util.List; public class Worker { private String name; private WorkerLevel level; private Double baseSalary; private Department department; private List<HourContract> contracts = new ArrayList<>(); public Worker() { } public Worker(String name, WorkerLevel level, Double baseSalary, Department department) { this.name = name; this.level = level; this.baseSalary = baseSalary; this.department = department; } public String getName() { return name; } public void setName(String name) { this.name = name; } public WorkerLevel getLevel() { return level; } public void setLevel(WorkerLevel level) { this.level = level; } public Double getBaseSalary() { return baseSalary; } public void setBaseSalary(Double baseSalary) { this.baseSalary = baseSalary; } public Department getDepartment() { return department; } public void setDepartment(Department department) { this.department = department; } public List<HourContract> getContracts() { return contracts; } public void addContract(HourContract contract) { contracts.add(contract); } public void removeContract(HourContract contract) { contracts.remove(contract); } public double income(int year, int month) { double sum = baseSalary; Calendar cal = Calendar.getInstance(); for (HourContract c : contracts) { cal.setTime(c.getDate()); int c_year = cal.get(Calendar.YEAR); int c_month = 1 + cal.get(Calendar.MONTH); if (year == c_year && month == c_month) { sum += c.totalValue(); } } return sum; } }"}, {"file_path": "WorkerContracts-java-main/WorkerContracts-java-main/src/entities/WorkerLevel.java", "file_content": "package entities; public enum WorkerLevel { JUNIOR, MID_LEVEL, SENIOR, }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "WorkerContracts-java-main/WorkerContracts-java-main/src/entities/Worker.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Worker class manages contracts, calculates income, and holds worker data. These are multiple responsibilities, leading to multiple reasons to change."}, {"principle": "Open-Closed", "justification": "Adding new types of income calculations requires modifying the Worker class instead of extending it."}, {"principle": "Dependency Inversion", "justification": "Worker directly depends on concrete classes Department and HourContract instead of abstractions, violating high-level module dependency rules."}]}, {"file_path": "WorkerContracts-java-main/WorkerContracts-java-main/src/application/Program.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "Program directly instantiates concrete classes (Worker, Department, HourContract) instead of depending on abstractions for high-level policy."}]}]}
{"project_id": 77, "chunk_id": 0, "prompt": {"main_file_path": "WorkerContracts-java-main/WorkerContracts-java-main/src/entities/HourContract.java", "main_file_content": "package entities; import java.util.Date; public class HourContract { private Date date; private Double valuePerHour; private Integer hours; public HourContract() { } public HourContract(Date date, Double valuePerHour, Integer hours) { this.date = date; this.valuePerHour = valuePerHour; this.hours = hours; } public Date getDate() { return date; } public void setDate(Date date) { this.date = date; } public Double getValuePerHour() { return valuePerHour; } public void setValuePerHour(Double valuePerHour) { this.valuePerHour = valuePerHour; } public Integer getHours() { return hours; } public void setHours(Integer hours) { this.hours = hours; } public double totalValue() { return valuePerHour * hours; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 77, "chunk_id": 0, "prompt": {"main_file_path": "WorkerContracts-java-main/WorkerContracts-java-main/src/entities/Department.java", "main_file_content": "package entities; public class Department { private String name; public Department() { } public Department(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "WorkerContracts-java-main/WorkerContracts-java-main/src/entities/Department.java", "violatedPrinciples": []}]}
{"project_id": 77, "chunk_id": 0, "prompt": {"main_file_path": "WorkerContracts-java-main/WorkerContracts-java-main/src/entities/Worker.java", "main_file_content": "package entities; import java.util.ArrayList; import java.util.Calendar; import java.util.List; public class Worker { private String name; private WorkerLevel level; private Double baseSalary; private Department department; private List<HourContract> contracts = new ArrayList<>(); public Worker() { } public Worker(String name, WorkerLevel level, Double baseSalary, Department department) { this.name = name; this.level = level; this.baseSalary = baseSalary; this.department = department; } public String getName() { return name; } public void setName(String name) { this.name = name; } public WorkerLevel getLevel() { return level; } public void setLevel(WorkerLevel level) { this.level = level; } public Double getBaseSalary() { return baseSalary; } public void setBaseSalary(Double baseSalary) { this.baseSalary = baseSalary; } public Department getDepartment() { return department; } public void setDepartment(Department department) { this.department = department; } public List<HourContract> getContracts() { return contracts; } public void addContract(HourContract contract) { contracts.add(contract); } public void removeContract(HourContract contract) { contracts.remove(contract); } public double income(int year, int month) { double sum = baseSalary; Calendar cal = Calendar.getInstance(); for (HourContract c : contracts) { cal.setTime(c.getDate()); int c_year = cal.get(Calendar.YEAR); int c_month = 1 + cal.get(Calendar.MONTH); if (year == c_year && month == c_month) { sum += c.totalValue(); } } return sum; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "WorkerContracts-java-main/WorkerContracts-java-main/src/entities/Worker.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Worker class manages worker data, contract list operations, and income calculation. These multiple responsibilities mean it has more than one reason to change."}, {"principle": "Dependency Inversion", "justification": "Worker directly depends on concrete Department and HourContract classes instead of abstractions. High-level modules should not depend on low-level implementations."}]}]}
{"project_id": 77, "chunk_id": 0, "prompt": {"main_file_path": "WorkerContracts-java-main/WorkerContracts-java-main/src/entities/WorkerLevel.java", "main_file_content": "package entities; public enum WorkerLevel { JUNIOR, MID_LEVEL, SENIOR, }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "WorkerContracts-java-main/WorkerContracts-java-main/src/entities/WorkerLevel.java", "violatedPrinciples": []}]}
{"project_id": 79, "chunk_id": 0, "prompt": {"main_file_path": "EasyFonts-master/EasyFonts-master/src/main/java/com/vstechlab/easyfonts/EasyFonts.java", "main_file_content": "package com.vstechlab.easyfonts; import android.content.Context; import android.content.res.Resources; import android.graphics.Typeface; import android.util.Log; import com.vstechlab.testeasyfont.easyfonts.R; import java.io.BufferedOutputStream; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; public final class EasyFonts { static byte[] sBuffer; static BufferedOutputStream sBOutStream; static InputStream sInputStream; static String sOutPath; static Typeface sResTypeface; private static String TAG = \"EastFonts\"; private static Typeface sRobotoThin; private static Typeface sRobotoBlack; private static Typeface sRobotoBlackItalic; private static Typeface sRobotoBold; private static Typeface sRobotoBoldItalic; private static Typeface sRobotoItalic; private static Typeface sRobotoLight; private static Typeface sRobotoLightItalic; private static Typeface sRobotoMedium; private static Typeface sRobotoMediumItalic; private static Typeface sRobotoRegular; private static Typeface sRobotoThinItalic; private static Typeface sRecognition; private static Typeface sAndroidNation; private static Typeface sAndroidNationBold; private static Typeface sAndroidNationItalic; private static Typeface sDroidSerifRegular; private static Typeface sDroidSerifBold; private static Typeface sDroidSerifBoldItalic; private static Typeface sDroidSerifItalic; private static Typeface sFreedom; private static Typeface sDroidRobot; private static Typeface sFunRaiser; private static Typeface sGreenAvocado; private EasyFonts(){} public static Typeface robotoThin(Context context){ sRobotoThin = getFontFromRes(R.raw.roboto_thin, context); return sRobotoThin; } public static Typeface robotoBlack(Context context){ sRobotoBlack = getFontFromRes(R.raw.roboto_black, context); return sRobotoBlack; } public static Typeface robotoBlackItalic(Context context){ sRobotoBlackItalic = getFontFromRes(R.raw.roboto_blackitalic, context); return sRobotoBlackItalic; } public static Typeface robotoBold(Context context){ sRobotoBold = getFontFromRes(R.raw.roboto_bold, context); return sRobotoBold; } public static Typeface robotoBoldItalic(Context context){ sRobotoBoldItalic = getFontFromRes(R.raw.roboto_bolditalic, context); return sRobotoBoldItalic; } public static Typeface robotoItalic(Context context){ sRobotoItalic = getFontFromRes(R.raw.roboto_italic, context); return sRobotoItalic; } public static Typeface robotoLight(Context context){ sRobotoLight = getFontFromRes(R.raw.roboto_light, context); return sRobotoLight; } public static Typeface robotoLightItalic(Context context){ sRobotoLightItalic = getFontFromRes(R.raw.roboto_lightitalic, context); return sRobotoLightItalic; } public static Typeface robotoMedium(Context context){ sRobotoMedium = getFontFromRes(R.raw.roboto_medium, context); return sRobotoMedium; } public static Typeface robotoMediumItalic(Context context){ sRobotoMediumItalic = getFontFromRes(R.raw.roboto_mediumitalic, context); return sRobotoMediumItalic; } public static Typeface robotoRegular(Context context){ sRobotoRegular = getFontFromRes(R.raw.roboto_regular, context); return sRobotoRegular; } public static Typeface robotoThinItalic(Context context){ sRobotoThinItalic = getFontFromRes(R.raw.roboto_thinitalic, context); return sRobotoThinItalic; } public static Typeface recognition(Context context){ sRecognition = getFontFromRes(R.raw.recognition, context); return sRecognition; } public static Typeface androidNation(Context context){ sAndroidNation = getFontFromRes(R.raw.androidnation, context); return sAndroidNation; } public static Typeface androidNationBold(Context context){ sAndroidNationBold = getFontFromRes(R.raw.androidnation_b, context); return sAndroidNationBold; } public static Typeface androidNationItalic(Context context){ sAndroidNationItalic = getFontFromRes(R.raw.androidnation_i, context); return sAndroidNationItalic; } public static Typeface droidSerifRegular(Context context){ sDroidSerifRegular = getFontFromRes(R.raw.droidserif_regular, context); return sDroidSerifRegular; } public static Typeface droidSerifBold(Context context){ sDroidSerifBold = getFontFromRes(R.raw.droidserif_bold, context); return sDroidSerifBold; } public static Typeface droidSerifBoldItalic(Context context){ sDroidSerifBoldItalic = getFontFromRes(R.raw.droidserif_bolditalic, context); return sDroidSerifBoldItalic; } public static Typeface droidSerifItalic(Context context){ sDroidSerifItalic = getFontFromRes(R.raw.droidserif_italic, context); return sDroidSerifItalic; } public static Typeface freedom(Context context){ sFreedom = getFontFromRes(R.raw.freedom, context); return sFreedom; } public static Typeface droidRobot(Context context){ sDroidRobot = getFontFromRes(R.raw.droid_robot_jp2, context); return sDroidRobot; } public static Typeface funRaiser(Context context){ sFunRaiser = getFontFromRes(R.raw.fun_raiser, context); return sFunRaiser; } public static Typeface greenAvocado(Context context){ sGreenAvocado = getFontFromRes(R.raw.green_avocado, context); return sGreenAvocado; } private static Typeface getFontFromRes(int resource, Context context){ sResTypeface = null; sInputStream = null; sOutPath = context.getCacheDir() + \"/tmp\" + System.currentTimeMillis() +\".raw\"; try{ sInputStream = context.getResources().openRawResource(resource); }catch (Resources.NotFoundException e){ Log.e(TAG, \"Could not find font in Resources!\"); } try{ sBuffer = new byte[sInputStream.available()]; sBOutStream = new BufferedOutputStream(new FileOutputStream(sOutPath)); int l = 0; while ((l = sInputStream.read(sBuffer)) > 0){ sBOutStream.write(sBuffer, 0, l); } sBOutStream.close(); sResTypeface = Typeface.createFromFile(sOutPath); new File(sOutPath).delete(); }catch (IOException e){ Log.e(TAG, \"Error reading in fonts!\"); return null; } Log.d(TAG, \"Successfully loaded font.\"); return sResTypeface; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "EasyFonts-master/EasyFonts-master/src/main/java/com/vstechlab/easyfonts/EasyFonts.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The EasyFonts class handles multiple responsibilities: managing font instances, loading fonts from resources, and handling file operations. This consolidation violates SRP as it has more than one reason to change."}, {"principle": "Open-Closed", "justification": "Adding a new font requires modifying the EasyFonts class by adding a new method, violating OCP. The class is not open for extension but closed for modification."}]}]}
{"project_id": 79, "chunk_id": 0, "prompt": {"main_file_path": "EasyFonts-master/EasyFonts-master/src/main/java/com/vstechlab/testeasyfont/easyfonts/EasyFonts.java", "main_file_content": "package com.vstechlab.testeasyfont.easyfonts; import android.content.Context; import android.content.res.Resources; import android.graphics.Typeface; import android.util.Log; import java.io.BufferedOutputStream; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; public final class EasyFonts { static byte[] sBuffer; static BufferedOutputStream sBOutStream; static InputStream sInputStream; static String sOutPath; static Typeface sResTypeface; private static String TAG = \"EastFonts\"; private static Typeface sRobotoThin; private static Typeface sRobotoBlack; private static Typeface sRobotoBlackItalic; private static Typeface sRobotoBold; private static Typeface sRobotoBoldItalic; private static Typeface sRobotoItalic; private static Typeface sRobotoLight; private static Typeface sRobotoLightItalic; private static Typeface sRobotoMedium; private static Typeface sRobotoMediumItalic; private static Typeface sRobotoRegular; private static Typeface sRobotoThinItalic; private static Typeface sRecognition; private static Typeface sAndroidNation; private static Typeface sAndroidNationBold; private static Typeface sAndroidNationItalic; private static Typeface sDroidSerifRegular; private static Typeface sDroidSerifBold; private static Typeface sDroidSerifBoldItalic; private static Typeface sDroidSerifItalic; private static Typeface sFreedom; private static Typeface sDroidRobot; private static Typeface sFunRaiser; private static Typeface sGreenAvocado; private EasyFonts(){} public static Typeface robotoThin(Context context){ sRobotoThin = getFontFromRes(R.raw.roboto_thin, context); return sRobotoThin; } public static Typeface robotoBlack(Context context){ sRobotoBlack = getFontFromRes(R.raw.roboto_black, context); return sRobotoBlack; } public static Typeface robotoBlackItalic(Context context){ sRobotoBlackItalic = getFontFromRes(R.raw.roboto_blackitalic, context); return sRobotoBlackItalic; } public static Typeface robotoBold(Context context){ sRobotoBold = getFontFromRes(R.raw.roboto_bold, context); return sRobotoBold; } public static Typeface robotoBoldItalic(Context context){ sRobotoBoldItalic = getFontFromRes(R.raw.roboto_bolditalic, context); return sRobotoBoldItalic; } public static Typeface robotoItalic(Context context){ sRobotoItalic = getFontFromRes(R.raw.roboto_italic, context); return sRobotoItalic; } public static Typeface robotoLight(Context context){ sRobotoLight = getFontFromRes(R.raw.roboto_light, context); return sRobotoLight; } public static Typeface robotoLightItalic(Context context){ sRobotoLightItalic = getFontFromRes(R.raw.roboto_lightitalic, context); return sRobotoLightItalic; } public static Typeface robotoMedium(Context context){ sRobotoMedium = getFontFromRes(R.raw.roboto_medium, context); return sRobotoMedium; } public static Typeface robotoMediumItalic(Context context){ sRobotoMediumItalic = getFontFromRes(R.raw.roboto_mediumitalic, context); return sRobotoMediumItalic; } public static Typeface robotoRegular(Context context){ sRobotoRegular = getFontFromRes(R.raw.roboto_regular, context); return sRobotoRegular; } public static Typeface robotoThinItalic(Context context){ sRobotoThinItalic = getFontFromRes(R.raw.roboto_thinitalic, context); return sRobotoThinItalic; } public static Typeface recognition(Context context){ sRecognition = getFontFromRes(R.raw.recognition, context); return sRecognition; } public static Typeface androidNation(Context context){ sAndroidNation = getFontFromRes(R.raw.androidnation, context); return sAndroidNation; } public static Typeface androidNationBold(Context context){ sAndroidNationBold = getFontFromRes(R.raw.androidnation_b, context); return sAndroidNationBold; } public static Typeface androidNationItalic(Context context){ sAndroidNationItalic = getFontFromRes(R.raw.androidnation_i, context); return sAndroidNationItalic; } public static Typeface droidSerifRegular(Context context){ sDroidSerifRegular = getFontFromRes(R.raw.droidserif_regular, context); return sDroidSerifRegular; } public static Typeface droidSerifBold(Context context){ sDroidSerifBold = getFontFromRes(R.raw.droidserif_bold, context); return sDroidSerifBold; } public static Typeface droidSerifBoldItalic(Context context){ sDroidSerifBoldItalic = getFontFromRes(R.raw.droidserif_bolditalic, context); return sDroidSerifBoldItalic; } public static Typeface droidSerifItalic(Context context){ sDroidSerifItalic = getFontFromRes(R.raw.droidserif_italic, context); return sDroidSerifItalic; } public static Typeface freedom(Context context){ sFreedom = getFontFromRes(R.raw.freedom, context); return sFreedom; } public static Typeface droidRobot(Context context){ sDroidRobot = getFontFromRes(R.raw.droid_robot_jp2, context); return sDroidRobot; } public static Typeface funRaiser(Context context){ sFunRaiser = getFontFromRes(R.raw.fun_raiser, context); return sFunRaiser; } public static Typeface greenAvocado(Context context){ sGreenAvocado = getFontFromRes(R.raw.green_avocado, context); return sGreenAvocado; } private static Typeface getFontFromRes(int resource, Context context){ sResTypeface = null; sInputStream = null; sOutPath = context.getCacheDir() + \"/tmp\" + System.currentTimeMillis() +\".raw\"; try{ sInputStream = context.getResources().openRawResource(resource); }catch (Resources.NotFoundException e){ Log.e(TAG, \"Could not find font in Resources!\"); } try{ sBuffer = new byte[sInputStream.available()]; sBOutStream = new BufferedOutputStream(new FileOutputStream(sOutPath)); int l = 0; while ((l = sInputStream.read(sBuffer)) > 0){ sBOutStream.write(sBuffer, 0, l); } sBOutStream.close(); sResTypeface = Typeface.createFromFile(sOutPath); new File(sOutPath).delete(); }catch (IOException e){ Log.e(TAG, \"Error reading in fonts!\"); return null; } Log.d(TAG, \"Successfully loaded font.\"); return sResTypeface; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "EasyFonts-master/EasyFonts-master/src/main/java/com/vstechlab/testeasyfont/easyfonts/EasyFonts.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The EasyFonts class handles multiple responsibilities: font retrieval from resources, file I/O operations, caching Typeface instances, and providing static methods for various fonts. This consolidation of duties violates SRP as changes to font loading, caching, or addition of new fonts would all require modifying the same class."}, {"principle": "Open-Closed", "justification": "Adding a new font requires modifying the EasyFonts class by adding a new static method, violating OCP. The class is not closed for modification and does not support extension through abstractions or inheritance (it is final)."}, {"principle": "Interface Segregation", "justification": "Clients must depend on the entire EasyFonts class even if they only use one font method. There is no interface segregation; all methods are part of a single monolithic class, forcing unnecessary dependencies on unused methods."}]}]}
{"project_id": 79, "chunk_id": 0, "prompt": {"main_file_path": "EasyFonts-master/EasyFonts-master/src/androidTest/java/com/vstechlab/testeasyfont/easyfonts/ApplicationTest.java", "main_file_content": "package com.vstechlab.testeasyfont.easyfonts; import android.app.Application; import android.test.ApplicationTestCase; public class ApplicationTest extends ApplicationTestCase<Application> { public ApplicationTest() { super(Application.class); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "EasyFonts-master/EasyFonts-master/src/androidTest/java/com/vstechlab/testeasyfont/easyfonts/ApplicationTest.java", "violatedPrinciples": []}]}
{"project_id": 79, "chunk_id": 0, "prompt": {"main_file_path": "EasyFonts-master/EasyFonts-master/easyfonts/src/main/java/com/vstechlab/easyfonts/EasyFonts.java", "main_file_content": "package com.vstechlab.easyfonts; import android.content.Context; import android.graphics.Typeface; import com.vstechlab.testeasyfont.easyfonts.R; public final class EasyFonts { private EasyFonts(){} public static Typeface robotoThin(Context context){ return FontSourceProcessor.process(R.raw.roboto_thin, context); } public static Typeface robotoBlack(Context context){ return FontSourceProcessor.process(R.raw.roboto_black, context); } public static Typeface robotoBlackItalic(Context context){ return FontSourceProcessor.process(R.raw.roboto_blackitalic, context); } public static Typeface robotoBold(Context context){ return FontSourceProcessor.process(R.raw.roboto_bold, context); } public static Typeface robotoBoldItalic(Context context){ return FontSourceProcessor.process(R.raw.roboto_bolditalic, context); } public static Typeface robotoItalic(Context context){ return FontSourceProcessor.process(R.raw.roboto_italic, context); } public static Typeface robotoLight(Context context){ return FontSourceProcessor.process(R.raw.roboto_light, context); } public static Typeface robotoLightItalic(Context context){ return FontSourceProcessor.process(R.raw.roboto_lightitalic, context); } public static Typeface robotoMedium(Context context){ return FontSourceProcessor.process(R.raw.roboto_medium, context); } public static Typeface robotoMediumItalic(Context context){ return FontSourceProcessor.process(R.raw.roboto_mediumitalic, context); } public static Typeface robotoRegular(Context context){ return FontSourceProcessor.process(R.raw.roboto_regular, context); } public static Typeface robotoThinItalic(Context context){ return FontSourceProcessor.process(R.raw.roboto_thinitalic, context); } public static Typeface recognition(Context context){ return FontSourceProcessor.process(R.raw.recognition, context); } public static Typeface androidNation(Context context){ return FontSourceProcessor.process(R.raw.androidnation, context); } public static Typeface androidNationBold(Context context){ return FontSourceProcessor.process(R.raw.androidnation_b, context); } public static Typeface androidNationItalic(Context context){ return FontSourceProcessor.process(R.raw.androidnation_i, context); } public static Typeface droidSerifRegular(Context context){ return FontSourceProcessor.process(R.raw.droidserif_regular, context); } public static Typeface droidSerifBold(Context context){ return FontSourceProcessor.process(R.raw.droidserif_bold, context); } public static Typeface droidSerifBoldItalic(Context context){ return FontSourceProcessor.process(R.raw.droidserif_bolditalic, context); } public static Typeface droidSerifItalic(Context context){ return FontSourceProcessor.process(R.raw.droidserif_italic, context); } public static Typeface freedom(Context context){ return FontSourceProcessor.process(R.raw.freedom, context); } public static Typeface droidRobot(Context context){ return FontSourceProcessor.process(R.raw.droid_robot_jp2, context); } public static Typeface funRaiser(Context context){ return FontSourceProcessor.process(R.raw.fun_raiser, context); } public static Typeface greenAvocado(Context context){ return FontSourceProcessor.process(R.raw.green_avocado, context); } public static Typeface walkwayBlack(Context context){ return FontSourceProcessor.process(R.raw.walkway_black, context); } public static Typeface walkwayBold(Context context){ return FontSourceProcessor.process(R.raw.walkway_bold, context); } public static Typeface walkwayOblique(Context context){ return FontSourceProcessor.process(R.raw.walkway_oblique, context); } public static Typeface walkwayObliqueBlack(Context context){ return FontSourceProcessor.process(R.raw.walkway_oblique_black, context); } public static Typeface walkwayObliqueSemiBold(Context context){ return FontSourceProcessor.process(R.raw.walkway_oblique_semibold, context); } public static Typeface walkwayObliqueUltraBold(Context context){ return FontSourceProcessor.process(R.raw.walkway_oblique_ultrabold, context); } public static Typeface walkwaySemiBold(Context context){ return FontSourceProcessor.process(R.raw.walkway_semibold, context); } public static Typeface walkwayUltraBold(Context context){ return FontSourceProcessor.process(R.raw.walkway_ultrabold, context); } public static Typeface windSong(Context context){ return FontSourceProcessor.process(R.raw.windsong, context); } public static Typeface tangerineRegular(Context context){ return FontSourceProcessor.process(R.raw.tangerine_regular, context); } public static Typeface tangerineBold(Context context){ return FontSourceProcessor.process(R.raw.tangerine_bold, context); } public static Typeface ostrichBlack(Context context){ return FontSourceProcessor.process(R.raw.ostrich_black, context); } public static Typeface ostrichBold(Context context){ return FontSourceProcessor.process(R.raw.ostrich_bold, context); } public static Typeface ostrichDashed(Context context){ return FontSourceProcessor.process(R.raw.ostrich_dashed, context); } public static Typeface ostrichLight(Context context){ return FontSourceProcessor.process(R.raw.ostrich_light, context); } public static Typeface ostrichRegular(Context context){ return FontSourceProcessor.process(R.raw.ostrich_regular, context); } public static Typeface ostrichRounded(Context context){ return FontSourceProcessor.process(R.raw.ostrich_rounded, context); } public static Typeface caviarDreamsBold(Context context){ return FontSourceProcessor.process(R.raw.caviar_dreams_bold, context); } public static Typeface caviarDreams(Context context){ return FontSourceProcessor.process(R.raw.caviardreams, context); } public static Typeface caviarDreamsBoldItalic(Context context){ return FontSourceProcessor.process(R.raw.caviardreams_bolditalic, context); } public static Typeface caviarDreamsItalic(Context context){ return FontSourceProcessor.process(R.raw.caviardreams_italic, context); } public static Typeface captureIt(Context context){ return FontSourceProcessor.process(R.raw.capture_it, context); } public static Typeface captureIt2(Context context){ return FontSourceProcessor.process(R.raw.capture_it_2, context); } public static Typeface cac_champagne(Context context){ return FontSourceProcessor.process(R.raw.cac_champagne, context); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "EasyFonts-master/EasyFonts-master/easyfonts/src/main/java/com/vstechlab/easyfonts/EasyFonts.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The EasyFonts class handles multiple responsibilities: managing different font families (Roboto, AndroidNation, etc.) and their variants. Adding or modifying any font requires changing this single class, indicating multiple reasons to change."}, {"principle": "Open-Closed", "justification": "Adding a new font type (e.g., a new Roboto variant) requires modifying the EasyFonts class by adding a new method. The class is not closed for modification against font additions."}, {"principle": "Dependency Inversion", "justification": "The class directly depends on the concrete FontSourceProcessor class instead of an abstraction. High-level font retrieval logic should depend on an interface, not a low-level implementation like FontSourceProcessor."}]}]}
{"project_id": 79, "chunk_id": 0, "prompt": {"main_file_path": "EasyFonts-master/EasyFonts-master/easyfonts/src/main/java/com/vstechlab/easyfonts/FontSourceProcessor.java", "main_file_content": "package com.vstechlab.easyfonts; import android.content.Context; import android.content.res.Resources; import android.graphics.Typeface; import android.util.Log; import java.io.BufferedOutputStream; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; final class FontSourceProcessor { private static final String TAG = \"FontSourceProcessor\"; public static Typeface process(int resource, Context context){ Typeface sResTypeface; InputStream sInputStream = null; String sOutPath = context.getCacheDir() + \"/tmp\" + System.currentTimeMillis() + \".raw\"; try{ sInputStream = context.getResources().openRawResource(resource); }catch (Resources.NotFoundException e){ Log.e(TAG, \"Could not find font in Resources!\"); } try{ byte[] sBuffer = new byte[sInputStream.available()]; BufferedOutputStream sBOutStream = new BufferedOutputStream(new FileOutputStream(sOutPath)); int l; while ((l = sInputStream.read(sBuffer)) > 0){ sBOutStream.write(sBuffer, 0, l); } sBOutStream.close(); sResTypeface = Typeface.createFromFile(sOutPath); new File(sOutPath).delete(); }catch (IOException e){ Log.e(TAG, \"Error reading in fonts!\"); return null; } Log.d(TAG, \"Successfully loaded font.\"); return sResTypeface; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "EasyFonts-master/EasyFonts-master/easyfonts/src/main/java/com/vstechlab/easyfonts/FontSourceProcessor.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "FontSourceProcessor handles multiple responsibilities: reading resources, file I/O operations (writing/deleting), creating Typeface instances, and error logging. These should be separated into distinct classes."}]}]}
{"project_id": 79, "chunk_id": 0, "prompt": {"main_file_path": "EasyFonts-master/EasyFonts-master/easyfonts/src/androidTest/java/com/vstechlab/testeasyfont/easyfonts/ApplicationTest.java", "main_file_content": "package com.vstechlab.testeasyfont.easyfonts; import android.app.Application; import android.test.ApplicationTestCase; public class ApplicationTest extends ApplicationTestCase<Application> { public ApplicationTest() { super(Application.class); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "EasyFonts-master/EasyFonts-master/easyfonts/src/androidTest/java/com/vstechlab/testeasyfont/easyfonts/ApplicationTest.java", "violatedPrinciples": []}]}
{"project_id": 79, "chunk_id": 0, "prompt": {"main_file_path": "EasyFonts-master/EasyFonts-master/app/src/main/java/com/vstechlab/testeasyfont/testeasyfont/MainActivity.java", "main_file_content": "package com.vstechlab.testeasyfont.testeasyfont; import android.os.Bundle; import android.support.v7.app.AppCompatActivity; import android.view.Menu; import android.view.MenuItem; import android.widget.TextView; import com.vstechlab.easyfonts.EasyFonts; public class MainActivity extends AppCompatActivity { TextView tvRobotoBlack; TextView tvRobotoBlackItalic; TextView tvRobotoBold; TextView tvRobotoBoldItalic; TextView tvRobotoItalic; TextView tvRobotoLight; TextView tvRobotoLightItalic; TextView tvRobotoMedium; TextView tvRobotoMediumItalic; TextView tvRobotoRegular; TextView tvRobotoThin; TextView tvRobotoThinItalic; TextView tvAndroidNation; TextView tvAndroidNationBold; TextView tvAndroidNationItalic; TextView tvDroidRobot; TextView tvDroidSerifBold; TextView tvDroidSerifBoldItalic; TextView tvDroidSerifItalic; TextView tvDroidSerifRegular; TextView tvFreedom; TextView tvFunRaiser; TextView tvGreenAvocado; TextView tvRecognition; TextView tvWalkwayBlack; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } @Override public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.menu_main, menu); tvRobotoBlack = (TextView) findViewById(R.id.tv_roboto_black); tvRobotoBlackItalic = (TextView) findViewById(R.id.tv_roboto_black_italic); tvRobotoBold = (TextView) findViewById(R.id.tv_roboto_bold); tvRobotoBoldItalic = (TextView) findViewById(R.id.tv_roboto_bold_italic); tvRobotoItalic = (TextView) findViewById(R.id.tv_roboto_italic); tvRobotoLight = (TextView) findViewById(R.id.tv_roboto_light); tvRobotoLightItalic = (TextView) findViewById(R.id.tv_roboto_light_italic); tvRobotoMedium = (TextView) findViewById(R.id.tv_roboto_medium); tvRobotoMediumItalic = (TextView) findViewById(R.id.tv_roboto_medium_italic); tvRobotoRegular = (TextView) findViewById(R.id.tv_roboto_regular); tvRobotoThin = (TextView) findViewById(R.id.tv_roboto_thin); tvRobotoThinItalic = (TextView) findViewById(R.id.tv_roboto_thin_italic); tvAndroidNation = (TextView) findViewById(R.id.tv_android_nation); tvAndroidNationBold = (TextView) findViewById(R.id.tv_android_nation_bold); tvAndroidNationItalic = (TextView) findViewById(R.id.tv_android_nation_italic); tvDroidRobot = (TextView) findViewById(R.id.tv_droid_robot); tvDroidSerifBold = (TextView) findViewById(R.id.tv_droid_serif_bold); tvDroidSerifBoldItalic = (TextView) findViewById(R.id.tv_droid_serif_bold_italic); tvDroidSerifItalic = (TextView) findViewById(R.id.tv_droid_serif_italic); tvDroidSerifRegular = (TextView) findViewById(R.id.tv_droid_serif_regular); tvFreedom = (TextView) findViewById(R.id.tv_freedom); tvFunRaiser = (TextView) findViewById(R.id.tv_fun_raiser); tvGreenAvocado = (TextView) findViewById(R.id.tv_green_avocado); tvRecognition = (TextView) findViewById(R.id.tv_recognition); tvWalkwayBlack = (TextView) findViewById(R.id.tv_walkway_black); tvRobotoBlack.setTypeface(EasyFonts.robotoBlack(this)); tvRobotoBlackItalic.setTypeface(EasyFonts.robotoBlackItalic(this)); tvRobotoBold.setTypeface(EasyFonts.robotoBold(this)); tvRobotoBoldItalic.setTypeface(EasyFonts.robotoBoldItalic(this)); tvRobotoItalic.setTypeface(EasyFonts.robotoItalic(this)); tvRobotoLight.setTypeface(EasyFonts.robotoLight(this)); tvRobotoLightItalic.setTypeface(EasyFonts.robotoLightItalic(this)); tvRobotoMedium.setTypeface(EasyFonts.robotoMedium(this)); tvRobotoMediumItalic.setTypeface(EasyFonts.robotoMediumItalic(this)); tvRobotoRegular.setTypeface(EasyFonts.robotoRegular(this)); tvRobotoThin.setTypeface(EasyFonts.robotoThin(this)); tvRobotoThinItalic.setTypeface(EasyFonts.robotoThinItalic(this)); tvAndroidNation.setTypeface(EasyFonts.androidNation(this)); tvAndroidNationBold.setTypeface(EasyFonts.androidNationBold(this)); tvAndroidNationItalic.setTypeface(EasyFonts.androidNationItalic(this)); tvDroidRobot.setTypeface(EasyFonts.droidRobot(this)); tvDroidSerifBold.setTypeface(EasyFonts.droidSerifBold(this)); tvDroidSerifBoldItalic.setTypeface(EasyFonts.droidSerifBoldItalic(this)); tvDroidSerifItalic.setTypeface(EasyFonts.droidSerifItalic(this)); tvDroidSerifRegular.setTypeface(EasyFonts.droidSerifRegular(this)); tvFreedom.setTypeface(EasyFonts.freedom(this)); tvFunRaiser.setTypeface(EasyFonts.funRaiser(this)); tvGreenAvocado.setTypeface(EasyFonts.greenAvocado(this)); tvRecognition.setTypeface(EasyFonts.recognition(this)); tvWalkwayBlack.setTypeface(EasyFonts.walkwayBlack(this)); return true; } @Override public boolean onOptionsItemSelected(MenuItem item) { int id = item.getItemId(); if (id == R.id.action_settings) { return true; } return super.onOptionsItemSelected(item); } }", "dependencies": [{"file_path": "EasyFonts-master/EasyFonts-master/src/main/java/com/vstechlab/easyfonts/EasyFonts.java", "file_content": "package com.vstechlab.easyfonts; import android.content.Context; import android.content.res.Resources; import android.graphics.Typeface; import android.util.Log; import com.vstechlab.testeasyfont.easyfonts.R; import java.io.BufferedOutputStream; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; public final class EasyFonts { static byte[] sBuffer; static BufferedOutputStream sBOutStream; static InputStream sInputStream; static String sOutPath; static Typeface sResTypeface; private static String TAG = \"EastFonts\"; private static Typeface sRobotoThin; private static Typeface sRobotoBlack; private static Typeface sRobotoBlackItalic; private static Typeface sRobotoBold; private static Typeface sRobotoBoldItalic; private static Typeface sRobotoItalic; private static Typeface sRobotoLight; private static Typeface sRobotoLightItalic; private static Typeface sRobotoMedium; private static Typeface sRobotoMediumItalic; private static Typeface sRobotoRegular; private static Typeface sRobotoThinItalic; private static Typeface sRecognition; private static Typeface sAndroidNation; private static Typeface sAndroidNationBold; private static Typeface sAndroidNationItalic; private static Typeface sDroidSerifRegular; private static Typeface sDroidSerifBold; private static Typeface sDroidSerifBoldItalic; private static Typeface sDroidSerifItalic; private static Typeface sFreedom; private static Typeface sDroidRobot; private static Typeface sFunRaiser; private static Typeface sGreenAvocado; private EasyFonts(){} public static Typeface robotoThin(Context context){ sRobotoThin = getFontFromRes(R.raw.roboto_thin, context); return sRobotoThin; } public static Typeface robotoBlack(Context context){ sRobotoBlack = getFontFromRes(R.raw.roboto_black, context); return sRobotoBlack; } public static Typeface robotoBlackItalic(Context context){ sRobotoBlackItalic = getFontFromRes(R.raw.roboto_blackitalic, context); return sRobotoBlackItalic; } public static Typeface robotoBold(Context context){ sRobotoBold = getFontFromRes(R.raw.roboto_bold, context); return sRobotoBold; } public static Typeface robotoBoldItalic(Context context){ sRobotoBoldItalic = getFontFromRes(R.raw.roboto_bolditalic, context); return sRobotoBoldItalic; } public static Typeface robotoItalic(Context context){ sRobotoItalic = getFontFromRes(R.raw.roboto_italic, context); return sRobotoItalic; } public static Typeface robotoLight(Context context){ sRobotoLight = getFontFromRes(R.raw.roboto_light, context); return sRobotoLight; } public static Typeface robotoLightItalic(Context context){ sRobotoLightItalic = getFontFromRes(R.raw.roboto_lightitalic, context); return sRobotoLightItalic; } public static Typeface robotoMedium(Context context){ sRobotoMedium = getFontFromRes(R.raw.roboto_medium, context); return sRobotoMedium; } public static Typeface robotoMediumItalic(Context context){ sRobotoMediumItalic = getFontFromRes(R.raw.roboto_mediumitalic, context); return sRobotoMediumItalic; } public static Typeface robotoRegular(Context context){ sRobotoRegular = getFontFromRes(R.raw.roboto_regular, context); return sRobotoRegular; } public static Typeface robotoThinItalic(Context context){ sRobotoThinItalic = getFontFromRes(R.raw.roboto_thinitalic, context); return sRobotoThinItalic; } public static Typeface recognition(Context context){ sRecognition = getFontFromRes(R.raw.recognition, context); return sRecognition; } public static Typeface androidNation(Context context){ sAndroidNation = getFontFromRes(R.raw.androidnation, context); return sAndroidNation; } public static Typeface androidNationBold(Context context){ sAndroidNationBold = getFontFromRes(R.raw.androidnation_b, context); return sAndroidNationBold; } public static Typeface androidNationItalic(Context context){ sAndroidNationItalic = getFontFromRes(R.raw.androidnation_i, context); return sAndroidNationItalic; } public static Typeface droidSerifRegular(Context context){ sDroidSerifRegular = getFontFromRes(R.raw.droidserif_regular, context); return sDroidSerifRegular; } public static Typeface droidSerifBold(Context context){ sDroidSerifBold = getFontFromRes(R.raw.droidserif_bold, context); return sDroidSerifBold; } public static Typeface droidSerifBoldItalic(Context context){ sDroidSerifBoldItalic = getFontFromRes(R.raw.droidserif_bolditalic, context); return sDroidSerifBoldItalic; } public static Typeface droidSerifItalic(Context context){ sDroidSerifItalic = getFontFromRes(R.raw.droidserif_italic, context); return sDroidSerifItalic; } public static Typeface freedom(Context context){ sFreedom = getFontFromRes(R.raw.freedom, context); return sFreedom; } public static Typeface droidRobot(Context context){ sDroidRobot = getFontFromRes(R.raw.droid_robot_jp2, context); return sDroidRobot; } public static Typeface funRaiser(Context context){ sFunRaiser = getFontFromRes(R.raw.fun_raiser, context); return sFunRaiser; } public static Typeface greenAvocado(Context context){ sGreenAvocado = getFontFromRes(R.raw.green_avocado, context); return sGreenAvocado; } private static Typeface getFontFromRes(int resource, Context context){ sResTypeface = null; sInputStream = null; sOutPath = context.getCacheDir() + \"/tmp\" + System.currentTimeMillis() +\".raw\"; try{ sInputStream = context.getResources().openRawResource(resource); }catch (Resources.NotFoundException e){ Log.e(TAG, \"Could not find font in Resources!\"); } try{ sBuffer = new byte[sInputStream.available()]; sBOutStream = new BufferedOutputStream(new FileOutputStream(sOutPath)); int l = 0; while ((l = sInputStream.read(sBuffer)) > 0){ sBOutStream.write(sBuffer, 0, l); } sBOutStream.close(); sResTypeface = Typeface.createFromFile(sOutPath); new File(sOutPath).delete(); }catch (IOException e){ Log.e(TAG, \"Error reading in fonts!\"); return null; } Log.d(TAG, \"Successfully loaded font.\"); return sResTypeface; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "EasyFonts-master/EasyFonts-master/app/src/main/java/com/vstechlab/testeasyfont/testeasyfont/MainActivity.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "MainActivity handles UI setup, menu inflation, and font configuration. Changes in font logic or UI structure would require modifying this class, indicating multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Adding a new font requires modifying onCreate() to initialize new TextViews and apply fonts. The class is not closed for modification when extending functionality."}, {"principle": "Dependency Inversion", "justification": "MainActivity directly depends on the concrete EasyFonts class instead of an abstraction. High-level modules should not depend on low-level implementation details."}]}, {"file_path": "EasyFonts-master/EasyFonts-master/src/main/java/com/vstechlab/easyfonts/EasyFonts.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "Adding a new font requires adding a new method to EasyFonts. The class cannot be extended without modifying its existing code."}]}]}
{"project_id": 79, "chunk_id": 0, "prompt": {"main_file_path": "EasyFonts-master/EasyFonts-master/app/src/androidTest/java/com/vstechlab/testeasyfont/testeasyfont/ApplicationTest.java", "main_file_content": "package com.vstechlab.testeasyfont.testeasyfont; import android.app.Application; import android.test.ApplicationTestCase; public class ApplicationTest extends ApplicationTestCase<Application> { public ApplicationTest() { super(Application.class); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "EasyFonts-master/EasyFonts-master/app/src/androidTest/java/com/vstechlab/testeasyfont/testeasyfont/ApplicationTest.java", "violatedPrinciples": []}]}
{"project_id": 80, "chunk_id": 0, "prompt": {"main_file_path": "java-statsd-client-master/java-statsd-client-master/src/main/java/com/timgroup/statsd/NonBlockingStatsDClient.java", "main_file_content": "package com.timgroup.statsd; import java.nio.charset.Charset; import java.text.NumberFormat; import java.util.Locale; public final class NonBlockingStatsDClient extends ConvenienceMethodProvidingStatsDClient { private static final Charset STATS_D_ENCODING = Charset.forName(\"UTF-8\"); private static final StatsDClientErrorHandler NO_OP_HANDLER = new StatsDClientErrorHandler() { @Override public void handle(Exception e) { } }; private final String prefix; private final NonBlockingUdpSender sender; public NonBlockingStatsDClient(String prefix, String hostname, int port) throws StatsDClientException { this(prefix, hostname, port, NO_OP_HANDLER); } public NonBlockingStatsDClient(String prefix, String hostname, int port, StatsDClientErrorHandler errorHandler) throws StatsDClientException { this.prefix = (prefix == null || prefix.trim().isEmpty()) ? \"\" : (prefix.trim() + \".\"); try { this.sender = new NonBlockingUdpSender(hostname, port, STATS_D_ENCODING, errorHandler); } catch (Exception e) { throw new StatsDClientException(\"Failed to start StatsD client\", e); } } @Override public void stop() { sender.stop(); } @Override public void count(String aspect, long delta, double sampleRate) { send(messageFor(aspect, Long.toString(delta), \"c\", sampleRate)); } @Override public void recordGaugeValue(String aspect, long value) { recordGaugeCommon(aspect, Long.toString(value), value < 0, false); } @Override public void recordGaugeValue(String aspect, double value) { recordGaugeCommon(aspect, stringValueOf(value), value < 0, false); } @Override public void recordGaugeDelta(String aspect, long value) { recordGaugeCommon(aspect, Long.toString(value), value < 0, true); } @Override public void recordGaugeDelta(String aspect, double value) { recordGaugeCommon(aspect, stringValueOf(value), value < 0, true); } private void recordGaugeCommon(String aspect, String value, boolean negative, boolean delta) { final StringBuilder message = new StringBuilder(); if (!delta && negative) { message.append(messageFor(aspect, \"0\", \"g\")).append('\\n'); } message.append(messageFor(aspect, (delta && !negative) ? (\"+\" + value) : value, \"g\")); send(message.toString()); } @Override public void recordSetEvent(String aspect, String eventName) { send(messageFor(aspect, eventName, \"s\")); } @Override public void recordExecutionTime(String aspect, long timeInMs, double sampleRate) { send(messageFor(aspect, Long.toString(timeInMs), \"ms\", sampleRate)); } private String messageFor(String aspect, String value, String type) { return messageFor(aspect, value, type, 1.0); } private String messageFor(String aspect, String value, String type, double sampleRate) { final String message = prefix + aspect + ':' + value + '|' + type; return (sampleRate == 1.0) ? message : (message + \"|@\" + stringValueOf(sampleRate)); } private void send(final String message) { sender.send(message); } private String stringValueOf(double value) { NumberFormat formatter = NumberFormat.getInstance(Locale.US); formatter.setGroupingUsed(false); formatter.setMaximumFractionDigits(19); return formatter.format(value); } }", "dependencies": [{"file_path": "java-statsd-client-master/java-statsd-client-master/src/main/java/com/timgroup/statsd/StatsDClientErrorHandler.java", "file_content": "package com.timgroup.statsd; public interface StatsDClientErrorHandler { void handle(Exception exception); }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "java-statsd-client-master/java-statsd-client-master/src/main/java/com/timgroup/statsd/NonBlockingStatsDClient.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "Class is declared 'final', preventing extension through inheritance. Modifying behavior requires changing existing code rather than extending the class."}, {"principle": "Dependency Inversion", "justification": "High-level client directly instantiates concrete NonBlockingUdpSender. Should depend on an abstraction (e.g., UdpSender interface) instead."}]}]}
{"project_id": 80, "chunk_id": 0, "prompt": {"main_file_path": "java-statsd-client-master/java-statsd-client-master/src/main/java/com/timgroup/statsd/StatsDClientException.java", "main_file_content": "package com.timgroup.statsd; public final class StatsDClientException extends RuntimeException { private static final long serialVersionUID = 3186887620964773839L; public StatsDClientException() { super(); } public StatsDClientException(String message, Throwable cause) { super(message, cause); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "java-statsd-client-master/java-statsd-client-master/src/main/java/com/timgroup/statsd/StatsDClientException.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "The class is declared as final, preventing extension without modifying its code (removing the final modifier), which violates the Open/Closed Principle's requirement for extensibility without modification."}]}]}
{"project_id": 80, "chunk_id": 0, "prompt": {"main_file_path": "java-statsd-client-master/java-statsd-client-master/src/main/java/com/timgroup/statsd/NonBlockingUdpSender.java", "main_file_content": "package com.timgroup.statsd; import java.io.IOException; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.nio.channels.DatagramChannel; import java.nio.charset.Charset; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.ThreadFactory; import java.util.concurrent.TimeUnit; public final class NonBlockingUdpSender { private final Charset encoding; private final DatagramChannel clientSocket; private final ExecutorService executor; private StatsDClientErrorHandler handler; public NonBlockingUdpSender(String hostname, int port, Charset encoding, StatsDClientErrorHandler handler) throws IOException { this.encoding = encoding; this.handler = handler; this.clientSocket = DatagramChannel.open(); this.clientSocket.connect(new InetSocketAddress(hostname, port)); this.executor = Executors.newSingleThreadExecutor(new ThreadFactory() { final ThreadFactory delegate = Executors.defaultThreadFactory(); @Override public Thread newThread(Runnable r) { Thread result = delegate.newThread(r); result.setName(\"StatsD-\" + result.getName()); result.setDaemon(true); return result; } }); } public void stop() { try { executor.shutdown(); executor.awaitTermination(30, TimeUnit.SECONDS); } catch (Exception e) { handler.handle(e); } finally { if (clientSocket != null) { try { clientSocket.close(); } catch (Exception e) { handler.handle(e); } } } } public void send(final String message) { try { executor.execute(new Runnable() { @Override public void run() { blockingSend(message); } }); } catch (Exception e) { handler.handle(e); } } private void blockingSend(String message) { try { final byte[] sendData = message.getBytes(encoding); clientSocket.write(ByteBuffer.wrap(sendData)); } catch (Exception e) { handler.handle(e); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "java-statsd-client-master/java-statsd-client-master/src/main/java/com/timgroup/statsd/NonBlockingUdpSender.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The class handles network communication, thread pool management, and error handling. These are multiple responsibilities that could change independently."}, {"principle": "Open-Closed", "justification": "The class is marked final and lacks abstraction, preventing extension without modification (e.g., altering the sending mechanism or thread management)."}]}]}
{"project_id": 80, "chunk_id": 0, "prompt": {"main_file_path": "java-statsd-client-master/java-statsd-client-master/src/main/java/com/timgroup/statsd/NoOpStatsDClient.java", "main_file_content": "package com.timgroup.statsd; public final class NoOpStatsDClient extends ConvenienceMethodProvidingStatsDClient { @Override public void stop() { } @Override public void count(String aspect, long delta, double sampleRate) { } @Override public void recordGaugeValue(String aspect, long value) { } @Override public void recordGaugeValue(String aspect, double value) { } @Override public void recordGaugeDelta(String aspect, long delta) { } @Override public void recordGaugeDelta(String aspect, double delta) { } @Override public void recordSetEvent(String aspect, String value) { } @Override public void recordExecutionTime(String aspect, long timeInMs, double sampleRate) { } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "java-statsd-client-master/java-statsd-client-master/src/main/java/com/timgroup/statsd/NoOpStatsDClient.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "The class is declared as final, preventing extension without modifying its code, which violates the Open/Closed Principle requiring classes to be open for extension but closed for modification."}]}]}
{"project_id": 80, "chunk_id": 0, "prompt": {"main_file_path": "java-statsd-client-master/java-statsd-client-master/src/main/java/com/timgroup/statsd/StatsDClientErrorHandler.java", "main_file_content": "package com.timgroup.statsd; public interface StatsDClientErrorHandler { void handle(Exception exception); }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 80, "chunk_id": 0, "prompt": {"main_file_path": "java-statsd-client-master/java-statsd-client-master/src/main/java/com/timgroup/statsd/ConvenienceMethodProvidingStatsDClient.java", "main_file_content": "package com.timgroup.statsd; public abstract class ConvenienceMethodProvidingStatsDClient implements StatsDClient { public ConvenienceMethodProvidingStatsDClient() { super(); } @Override public final void count(String aspect, long delta) { count(aspect, delta, 1.0); } @Override public final void incrementCounter(String aspect) { count(aspect, 1); } @Override public final void increment(String aspect) { incrementCounter(aspect); } @Override public final void decrementCounter(String aspect) { count(aspect, -1); } @Override public final void decrement(String aspect) { decrementCounter(aspect); } @Override public final void gauge(String aspect, long value) { recordGaugeValue(aspect, value); } @Override public final void gauge(String aspect, double value) { recordGaugeValue(aspect, value); } @Override public final void set(String aspect, String eventName) { recordSetEvent(aspect, eventName); } @Override public final void time(String aspect, long timeInMs) { recordExecutionTime(aspect, timeInMs); } @Override public final void recordExecutionTime(String aspect, long timeInMs) { recordExecutionTime(aspect, timeInMs, 1.0); } @Override public void recordExecutionTimeToNow(String aspect, long systemTimeMillisAtStart) { time(aspect, Math.max(0, System.currentTimeMillis() - systemTimeMillisAtStart)); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "java-statsd-client-master/java-statsd-client-master/src/main/java/com/timgroup/statsd/ConvenienceMethodProvidingStatsDClient.java", "violatedPrinciples": []}]}
{"project_id": 80, "chunk_id": 0, "prompt": {"main_file_path": "java-statsd-client-master/java-statsd-client-master/src/main/java/com/timgroup/statsd/StatsDClient.java", "main_file_content": "package com.timgroup.statsd; public interface StatsDClient { void stop(); void count(String aspect, long delta); void count(String aspect, long delta, double sampleRate); void incrementCounter(String aspect); void increment(String aspect); void decrementCounter(String aspect); void decrement(String aspect); void recordGaugeValue(String aspect, long value); void recordGaugeValue(String aspect, double value); void recordGaugeDelta(String aspect, long delta); void recordGaugeDelta(String aspect, double delta); void gauge(String aspect, long value); void gauge(String aspect, double value); void recordSetEvent(String aspect, String eventName); void set(String aspect, String eventName); void recordExecutionTime(String aspect, long timeInMs); void recordExecutionTime(String aspect, long timeInMs, double sampleRate); void recordExecutionTimeToNow(String aspect, long systemTimeMillisAtStart); void time(String aspect, long value); }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "java-statsd-client-master/java-statsd-client-master/src/main/java/com/timgroup/statsd/StatsDClient.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "Adding new metric types requires modifying the StatsDClient interface, violating OCP as existing code should be closed for modification but open for extension."}, {"principle": "Interface Segregation", "justification": "The interface has many methods, forcing clients to depend on unused methods (e.g., a client needing only counters must implement gauge/set/timing methods)."}]}]}
{"project_id": 80, "chunk_id": 0, "prompt": {"main_file_path": "java-statsd-client-master/java-statsd-client-master/src/test/java/com/timgroup/statsd/NonBlockingStatsDClientTest.java", "main_file_content": "package com.timgroup.statsd; import static java.lang.Long.valueOf; import static junit.framework.Assert.assertTrue; import static org.hamcrest.MatcherAssert.assertThat; import static org.hamcrest.Matchers.contains; import static org.hamcrest.Matchers.startsWith; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketException; import java.nio.charset.Charset; import java.util.ArrayList; import java.util.List; import java.util.regex.Matcher; import java.util.regex.Pattern; import org.hamcrest.Matchers; import org.junit.After; import org.junit.Test; public final class NonBlockingStatsDClientTest { private static final int STATSD_SERVER_PORT = 17254; private final NonBlockingStatsDClient client = new NonBlockingStatsDClient(\"my.prefix\", \"localhost\", STATSD_SERVER_PORT); private final DummyStatsDServer server = new DummyStatsDServer(STATSD_SERVER_PORT); @After public void stop() throws Exception { client.stop(); server.stop(); } @Test(timeout=5000L) public void sends_counter_value_to_statsd() throws Exception { client.count(\"mycount\", Long.MAX_VALUE); server.waitForMessage(); assertThat(server.messagesReceived(), contains(\"my.prefix.mycount:9223372036854775807|c\")); } @Test(timeout=5000L) public void sends_counter_value_with_rate_to_statsd() throws Exception { client.count(\"mycount\", Long.MAX_VALUE, 0.00024); server.waitForMessage(); assertThat(server.messagesReceived(), contains(\"my.prefix.mycount:9223372036854775807|c|@0.00024\")); } @Test(timeout=5000L) public void sends_counter_increment_to_statsd() throws Exception { client.incrementCounter(\"myinc\"); server.waitForMessage(); assertThat(server.messagesReceived(), contains(\"my.prefix.myinc:1|c\")); } @Test(timeout=5000L) public void sends_counter_decrement_to_statsd() throws Exception { client.decrementCounter(\"mydec\"); server.waitForMessage(); assertThat(server.messagesReceived(), contains(\"my.prefix.mydec:-1|c\")); } @Test(timeout=5000L) public void sends_gauge_to_statsd() throws Exception { client.recordGaugeValue(\"mygauge\", Long.MAX_VALUE); server.waitForMessage(); assertThat(server.messagesReceived(), contains(\"my.prefix.mygauge:9223372036854775807|g\")); } @Test(timeout=5000L) public void sends_fractional_gauge_to_statsd() throws Exception { client.recordGaugeValue(\"mygauge\", 423.123456789d); server.waitForMessage(); assertThat(server.messagesReceived(), contains(\"my.prefix.mygauge:423.123456789|g\")); } @Test(timeout=5000L) public void sends_large_fractional_gauge_to_statsd() throws Exception { client.recordGaugeValue(\"mygauge\", 423423423.9d); server.waitForMessage(); assertThat(server.messagesReceived(), contains(\"my.prefix.mygauge:423423423.9|g\")); } @Test(timeout=5000L) public void sends_zero_gauge_to_statsd() throws Exception { client.recordGaugeValue(\"mygauge\", 0L); server.waitForMessage(); assertThat(server.messagesReceived(), contains(\"my.prefix.mygauge:0|g\")); } @Test(timeout=5000L) public void sends_negagive_gauge_to_statsd_by_resetting_to_zero_first() throws Exception { client.recordGaugeValue(\"mygauge\", -423L); server.waitForMessage(); assertThat(server.messagesReceived(), contains(\"my.prefix.mygauge:0|g\\nmy.prefix.mygauge:-423|g\")); } @Test(timeout=5000L) public void sends_gauge_positive_delta_to_statsd() throws Exception { client.recordGaugeDelta(\"mygauge\", 423L); server.waitForMessage(); assertThat(server.messagesReceived(), contains(\"my.prefix.mygauge:+423|g\")); } @Test(timeout=5000L) public void sends_gauge_negative_delta_to_statsd() throws Exception { client.recordGaugeDelta(\"mygauge\", -423L); server.waitForMessage(); assertThat(server.messagesReceived(), contains(\"my.prefix.mygauge:-423|g\")); } @Test(timeout=5000L) public void sends_gauge_zero_delta_to_statsd() throws Exception { client.recordGaugeDelta(\"mygauge\", 0L); server.waitForMessage(); assertThat(server.messagesReceived(), contains(\"my.prefix.mygauge:+0|g\")); } @Test(timeout=5000L) public void sends_set_to_statsd() throws Exception { client.recordSetEvent(\"myset\", \"test\"); server.waitForMessage(); assertThat(server.messagesReceived(), contains(\"my.prefix.myset:test|s\")); } @Test(timeout=5000L) public void sends_timer_to_statsd() throws Exception { client.recordExecutionTime(\"mytime\", 123L); server.waitForMessage(); assertThat(server.messagesReceived(), contains(\"my.prefix.mytime:123|ms\")); } @Test(timeout=5000L) public void sends_timer_with_rate_to_statsd() throws Exception { client.recordExecutionTime(\"mytime\", 123L, 0.000123); server.waitForMessage(); assertThat(server.messagesReceived(), contains(\"my.prefix.mytime:123|ms|@0.000123\")); } @Test(timeout=5000L) public void sends_timer_to_statsd_based_on_specified_start_time_to_now() throws Exception { final long startTime = System.currentTimeMillis() - 1000L; final long beforeCompletionTime = System.currentTimeMillis(); client.recordExecutionTimeToNow(\"mytime\", startTime); final long afterCompletionTime = System.currentTimeMillis(); server.waitForMessage(); long maxExpectedValue = afterCompletionTime - startTime; long minExpectedValue = beforeCompletionTime - startTime; final String messageReceived = server.messagesReceived().get(0); final Matcher resultMatcher = Pattern.compile(\".*:(\\\\d+)\\\\|ms\").matcher(messageReceived); assertTrue(messageReceived, resultMatcher.matches()); assertThat(valueOf(resultMatcher.group(1)), Matchers.greaterThanOrEqualTo(minExpectedValue)); assertThat(valueOf(resultMatcher.group(1)), Matchers.lessThanOrEqualTo(maxExpectedValue)); } @Test(timeout=5000L) public void sends_timer_of_zero_to_statsd_based_on_specified_start_time_in_the_future() throws Exception { client.recordExecutionTimeToNow(\"mytime\", System.currentTimeMillis() + 100000L); server.waitForMessage(); assertThat(server.messagesReceived(), contains(\"my.prefix.mytime:0|ms\")); } @Test(timeout=5000L) public void allows_empty_prefix() { final NonBlockingStatsDClient emptyPrefixClient = new NonBlockingStatsDClient(\" \", \"localhost\", STATSD_SERVER_PORT); try { emptyPrefixClient.count(\"mycount\", 24L); server.waitForMessage(); } finally { emptyPrefixClient.stop(); } assertThat(server.messagesReceived(), contains(startsWith(\"mycount:\"))); } @Test(timeout=5000L) public void allows_null_prefix() { final NonBlockingStatsDClient nullPrefixClient = new NonBlockingStatsDClient(null, \"localhost\", STATSD_SERVER_PORT); try { nullPrefixClient.count(\"mycount\", 24L); server.waitForMessage(); } finally { nullPrefixClient.stop(); } assertThat(server.messagesReceived(), contains(startsWith(\"mycount:\"))); } private static final class DummyStatsDServer { private final List<String> messagesReceived = new ArrayList<String>(); private final DatagramSocket server; public DummyStatsDServer(int port) { try { server = new DatagramSocket(port); } catch (SocketException e) { throw new IllegalStateException(e); } new Thread(new Runnable() { @Override public void run() { try { final DatagramPacket packet = new DatagramPacket(new byte[256], 256); server.receive(packet); messagesReceived.add(new String(packet.getData(), Charset.forName(\"UTF-8\")).trim()); } catch (Exception e) { } } }).start(); } public void stop() { server.close(); } public void waitForMessage() { while (messagesReceived.isEmpty()) { try { Thread.sleep(50L); } catch (InterruptedException e) {} } } public List<String> messagesReceived() { return new ArrayList<String>(messagesReceived); } } }", "dependencies": [{"file_path": "java-statsd-client-master/java-statsd-client-master/src/main/java/com/timgroup/statsd/NonBlockingStatsDClient.java", "file_content": "package com.timgroup.statsd; import java.nio.charset.Charset; import java.text.NumberFormat; import java.util.Locale; public final class NonBlockingStatsDClient extends ConvenienceMethodProvidingStatsDClient { private static final Charset STATS_D_ENCODING = Charset.forName(\"UTF-8\"); private static final StatsDClientErrorHandler NO_OP_HANDLER = new StatsDClientErrorHandler() { @Override public void handle(Exception e) { } }; private final String prefix; private final NonBlockingUdpSender sender; public NonBlockingStatsDClient(String prefix, String hostname, int port) throws StatsDClientException { this(prefix, hostname, port, NO_OP_HANDLER); } public NonBlockingStatsDClient(String prefix, String hostname, int port, StatsDClientErrorHandler errorHandler) throws StatsDClientException { this.prefix = (prefix == null || prefix.trim().isEmpty()) ? \"\" : (prefix.trim() + \".\"); try { this.sender = new NonBlockingUdpSender(hostname, port, STATS_D_ENCODING, errorHandler); } catch (Exception e) { throw new StatsDClientException(\"Failed to start StatsD client\", e); } } @Override public void stop() { sender.stop(); } @Override public void count(String aspect, long delta, double sampleRate) { send(messageFor(aspect, Long.toString(delta), \"c\", sampleRate)); } @Override public void recordGaugeValue(String aspect, long value) { recordGaugeCommon(aspect, Long.toString(value), value < 0, false); } @Override public void recordGaugeValue(String aspect, double value) { recordGaugeCommon(aspect, stringValueOf(value), value < 0, false); } @Override public void recordGaugeDelta(String aspect, long value) { recordGaugeCommon(aspect, Long.toString(value), value < 0, true); } @Override public void recordGaugeDelta(String aspect, double value) { recordGaugeCommon(aspect, stringValueOf(value), value < 0, true); } private void recordGaugeCommon(String aspect, String value, boolean negative, boolean delta) { final StringBuilder message = new StringBuilder(); if (!delta && negative) { message.append(messageFor(aspect, \"0\", \"g\")).append('\\n'); } message.append(messageFor(aspect, (delta && !negative) ? (\"+\" + value) : value, \"g\")); send(message.toString()); } @Override public void recordSetEvent(String aspect, String eventName) { send(messageFor(aspect, eventName, \"s\")); } @Override public void recordExecutionTime(String aspect, long timeInMs, double sampleRate) { send(messageFor(aspect, Long.toString(timeInMs), \"ms\", sampleRate)); } private String messageFor(String aspect, String value, String type) { return messageFor(aspect, value, type, 1.0); } private String messageFor(String aspect, String value, String type, double sampleRate) { final String message = prefix + aspect + ':' + value + '|' + type; return (sampleRate == 1.0) ? message : (message + \"|@\" + stringValueOf(sampleRate)); } private void send(final String message) { sender.send(message); } private String stringValueOf(double value) { NumberFormat formatter = NumberFormat.getInstance(Locale.US); formatter.setGroupingUsed(false); formatter.setMaximumFractionDigits(19); return formatter.format(value); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "java-statsd-client-master/java-statsd-client-master/src/main/java/com/timgroup/statsd/NonBlockingStatsDClient.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "The NonBlockingStatsDClient is declared as final, preventing extension without modification. This violates OCP as new functionality cannot be added through inheritance."}, {"principle": "Dependency Inversion", "justification": "NonBlockingStatsDClient directly instantiates NonBlockingUdpSender, a concrete class, instead of depending on an abstraction. High-level modules should not depend on low-level implementations."}]}, {"file_path": "java-statsd-client-master/java-statsd-client-master/src/test/java/com/timgroup/statsd/NonBlockingStatsDClientTest.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The DummyStatsDServer inner class handles both socket management and message storage/processing. These are two distinct responsibilities that should be separated."}]}]}
{"project_id": 81, "chunk_id": 0, "prompt": {"main_file_path": "Product-Ledger-main/src/productledger/Ledger.java", "main_file_content": "package productledger; import java.util.*; import java.util.ArrayList; import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.List; import java.io.IOException; public class Ledger { public List<Product> productList = new ArrayList<>(); private int balance = 0; public void Menu(){ while(true){ soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") sout(\"\") try{ BufferedReader br= new BufferedReader(new InputStreamReader(System.in)); String s= br.readLine(); if(s.equals(\"1\")){ addProduct(); } else if(s.equals(\"2\")){ deleteProduct(); } else if(s.equals(\"3\")){ buyProduct(); } else if(s.equals(\"4\")){ sellProduct(); } else if(s.equals(\"5\")){ showProducts(); } else if(s.equals(\"6\")){ soutl(\"\") } else if(s.equals(\"7\")){ break; } else{ soutl(\"\") } } catch (IOException e) { e.printStackTrace(); } } } private void addProduct(){ try{ BufferedReader br= new BufferedReader(new InputStreamReader(System.in)); sout(\"\") String name = br.readLine(); sout(\"\") int buyPrice = Integer.parseInt(br.readLine()); soutl(\"\") int sellPrice = Integer.parseInt(br.readLine()); soutl(\"\") int availableQuantity = Integer.parseInt(br.readLine()); soutl(\"\") int profit = Integer.parseInt(br.readLine()); Product product = new Product(name, buyPrice, sellPrice, availableQuantity, profit); productList.add(product); soutl(\"\") soutl(\"\") } catch (Exception e){ e.printStackTrace(); } } private void deleteProduct(){ sout(\"\") BufferedReader br= new BufferedReader(new InputStreamReader(System.in)); try{ int index=Integer.parseInt(br.readLine()); productList.remove(index); soutl(\"\") soutl(\"\") } catch (Exception e){ soutl(\"\") soutl(\"\") } } private void buyProduct(){ soutl(\"\") Product pd = null; int quantity, buyPrice, availableQuantity, index = 0; BufferedReader br= new BufferedReader(new InputStreamReader(System.in)); try{ index = Integer.parseInt(br.readLine()); pd = productList.get(index); } catch (Exception e){ soutl(\"\") } buyPrice = pd.getBuyPrice(); availableQuantity = pd.getAvailableQuantity(); soutl(\"\") try{ quantity = Integer.parseInt(br.readLine()); int totalPrice = quantity*buyPrice; if(totalPrice<balance){ balance = balance - totalPrice; availableQuantity = availableQuantity + quantity; pd.setAvailableQuantity(availableQuantity); productList.set(index, pd); } else{ soutl(\"\") soutl(\"\") return; } } catch (Exception e){ e.printStackTrace(); } } private void sellProduct(){ soutl(\"\") Product pd = null; int quantity, buyPrice, sellPrice, availableQuantity, profit, totalsellPrice,index = 0; BufferedReader br= new BufferedReader(new InputStreamReader(System.in)); try{ index = Integer.parseInt(br.readLine()); pd = productList.get(index); } catch (Exception e){ soutl(\"\") } sellPrice = pd.getSellPrice(); buyPrice = pd.getBuyPrice(); availableQuantity = pd.getAvailableQuantity(); profit = pd.getProfit(); soutl(\"\") try{ quantity = Integer.parseInt(br.readLine()); if(quantity<availableQuantity){ totalsellPrice = quantity*sellPrice; balance = balance + totalsellPrice; availableQuantity = availableQuantity - quantity; profit = profit + ((sellPrice-buyPrice)*quantity); pd.setAvailableQuantity(availableQuantity); pd.setProfit(profit); productList.set(index, pd); } else{ soutl(\"\") soutl(\"\") return; } } catch (Exception e){ e.printStackTrace(); } } private void showProducts(){ int index = 0; soutl(\"\") System.out.printf(\"%10s %30s %18s %20s\",\"Index\", \"Name\", \"Available Quantity\", \"Profit\"); soutl(\"\") soutl(\"\") for(Product product: productList){ System.out.format(\"%10d %30s %18d %20d\", index, product.getName(), product.getAvailableQuantity(), product.getProfit()); soutl(\"\") index++; } soutl(\"\") } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Product-Ledger-main/src/productledger/Ledger.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Ledger class handles multiple responsibilities: managing products, balance, user input/output, and menu navigation. This creates multiple reasons for the class to change, violating SRP."}, {"principle": "Open-Closed", "justification": "Adding new functionality (e.g., new menu options) requires modifying the existing Menu() method instead of extending the class. This violates OCP as the class is not open for extension but closed for modification."}]}]}
{"project_id": 81, "chunk_id": 0, "prompt": {"main_file_path": "Product-Ledger-main/src/productledger/Product.java", "main_file_content": "package productledger; public class Product { private String name; private int buyPrice; private int sellPrice; private int availableQuantity; private int profit; Product(String name, int buyPrice, int sellPrice, int availableQuantity, int profit){ this.name = name; this.buyPrice = buyPrice; this.sellPrice = sellPrice; this.availableQuantity = availableQuantity; this.profit = profit; } public String getName(){ return this.name; } public int getBuyPrice() { return this.buyPrice; } public int getSellPrice() { return this.sellPrice; } public int getAvailableQuantity() { return this.availableQuantity; } public int getProfit(){ return this.profit; } public void setAvailableQuantity(int availableQuantity) { this.availableQuantity = availableQuantity; } public void setProfit(int profit) { this.profit = profit; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Product-Ledger-main/src/productledger/Product.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Product class manages both product attributes (name, prices, quantity) and tracks profit, which are separate responsibilities. Profit tracking should be delegated to another class to ensure only one reason to change."}]}]}
{"project_id": 81, "chunk_id": 0, "prompt": {"main_file_path": "Product-Ledger-main/src/productledger/Main.java", "main_file_content": "package productledger; public class Main { public static void main(String[] args) { Ledger ledger = new Ledger(); ledger.Menu(); } }", "dependencies": [{"file_path": "Product-Ledger-main/src/productledger/Ledger.java", "file_content": "package productledger; import java.util.*; import java.util.ArrayList; import java.io.BufferedReader; import java.io.InputStreamReader; import java.util.List; import java.io.IOException; public class Ledger { public List<Product> productList = new ArrayList<>(); private int balance = 0; public void Menu(){ while(true){ soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") sout(\"\") try{ BufferedReader br= new BufferedReader(new InputStreamReader(System.in)); String s= br.readLine(); if(s.equals(\"1\")){ addProduct(); } else if(s.equals(\"2\")){ deleteProduct(); } else if(s.equals(\"3\")){ buyProduct(); } else if(s.equals(\"4\")){ sellProduct(); } else if(s.equals(\"5\")){ showProducts(); } else if(s.equals(\"6\")){ soutl(\"\") } else if(s.equals(\"7\")){ break; } else{ soutl(\"\") } } catch (IOException e) { e.printStackTrace(); } } } private void addProduct(){ try{ BufferedReader br= new BufferedReader(new InputStreamReader(System.in)); sout(\"\") String name = br.readLine(); sout(\"\") int buyPrice = Integer.parseInt(br.readLine()); soutl(\"\") int sellPrice = Integer.parseInt(br.readLine()); soutl(\"\") int availableQuantity = Integer.parseInt(br.readLine()); soutl(\"\") int profit = Integer.parseInt(br.readLine()); Product product = new Product(name, buyPrice, sellPrice, availableQuantity, profit); productList.add(product); soutl(\"\") soutl(\"\") } catch (Exception e){ e.printStackTrace(); } } private void deleteProduct(){ sout(\"\") BufferedReader br= new BufferedReader(new InputStreamReader(System.in)); try{ int index=Integer.parseInt(br.readLine()); productList.remove(index); soutl(\"\") soutl(\"\") } catch (Exception e){ soutl(\"\") soutl(\"\") } } private void buyProduct(){ soutl(\"\") Product pd = null; int quantity, buyPrice, availableQuantity, index = 0; BufferedReader br= new BufferedReader(new InputStreamReader(System.in)); try{ index = Integer.parseInt(br.readLine()); pd = productList.get(index); } catch (Exception e){ soutl(\"\") } buyPrice = pd.getBuyPrice(); availableQuantity = pd.getAvailableQuantity(); soutl(\"\") try{ quantity = Integer.parseInt(br.readLine()); int totalPrice = quantity*buyPrice; if(totalPrice<balance){ balance = balance - totalPrice; availableQuantity = availableQuantity + quantity; pd.setAvailableQuantity(availableQuantity); productList.set(index, pd); } else{ soutl(\"\") soutl(\"\") return; } } catch (Exception e){ e.printStackTrace(); } } private void sellProduct(){ soutl(\"\") Product pd = null; int quantity, buyPrice, sellPrice, availableQuantity, profit, totalsellPrice,index = 0; BufferedReader br= new BufferedReader(new InputStreamReader(System.in)); try{ index = Integer.parseInt(br.readLine()); pd = productList.get(index); } catch (Exception e){ soutl(\"\") } sellPrice = pd.getSellPrice(); buyPrice = pd.getBuyPrice(); availableQuantity = pd.getAvailableQuantity(); profit = pd.getProfit(); soutl(\"\") try{ quantity = Integer.parseInt(br.readLine()); if(quantity<availableQuantity){ totalsellPrice = quantity*sellPrice; balance = balance + totalsellPrice; availableQuantity = availableQuantity - quantity; profit = profit + ((sellPrice-buyPrice)*quantity); pd.setAvailableQuantity(availableQuantity); pd.setProfit(profit); productList.set(index, pd); } else{ soutl(\"\") soutl(\"\") return; } } catch (Exception e){ e.printStackTrace(); } } private void showProducts(){ int index = 0; soutl(\"\") System.out.printf(\"%10s %30s %18s %20s\",\"Index\", \"Name\", \"Available Quantity\", \"Profit\"); soutl(\"\") soutl(\"\") for(Product product: productList){ System.out.format(\"%10d %30s %18d %20d\", index, product.getName(), product.getAvailableQuantity(), product.getProfit()); soutl(\"\") index++; } soutl(\"\") } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Product-Ledger-main/src/productledger/Ledger.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Ledger class manages product data, handles user input/output, and implements business logic (buying/selling). These multiple responsibilities violate SRP, as changes to UI, data management, or transaction logic would all require modifying the class."}, {"principle": "Open-Closed", "justification": "Adding new menu options or product operations requires modifying the existing Menu() method and adding new conditional blocks, violating OCP by forcing changes to the class instead of extending it."}, {"principle": "Dependency Inversion", "justification": "Ledger directly depends on concrete Product class instances. High-level modules like Ledger should depend on abstractions (e.g., Product interface), not concrete implementations, to decouple policy from details."}]}]}
{"project_id": 82, "chunk_id": 0, "prompt": {"main_file_path": "Breakout-Ball-master/Breakout Ball/src/Bricks.java", "main_file_content": "import java.awt.Color; import java.awt.Graphics; public class Bricks { int bricks[][], brickWidth, brickHeight, i, j; static final int WIDTH = 540; static final int HEIGHT = 200; public Bricks (int row, int col) { bricks = new int[row][col]; for(i = 0; i < row; i++) { for(j = 0; j < col; j++) { bricks[i][j] = 1; } } brickWidth = WIDTH / col; brickHeight = HEIGHT / row; } public void draw(Graphics g) { for(i = 0; i < bricks.length; i++) { for(j = 0; j < bricks[0].length; j++) { if(bricks[i][j] > 0) { g.setColor(Color.red); g.fillRect(j * brickWidth + 80, i * brickHeight + 50, brickWidth, brickHeight); g.setColor(Color.black); g.fillRect(j * brickWidth + 80, i * brickHeight + 50, brickWidth, 1); g.fillRect(j * brickWidth + 80, i * brickHeight + 50, 1, brickHeight); } } } } public void setBrickValue(int row, int col) { bricks[row][col] = 0; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Breakout-Ball-master/Breakout Ball/src/Bricks.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Bricks class manages brick data and handles rendering logic, combining data management and UI rendering responsibilities into one class."}, {"principle": "Open-Closed", "justification": "The draw() method hardcodes rendering details (colors, borders). Extending rendering behavior requires modifying the class instead of extending it."}]}]}
{"project_id": 82, "chunk_id": 0, "prompt": {"main_file_path": "Breakout-Ball-master/Breakout Ball/src/Gameplay.java", "main_file_content": "import java.awt.event.*; import java.util.Random; import javax.swing.*; import java.awt.*; public class Gameplay extends JFrame implements KeyListener, ActionListener { private static final long serialVersionUID = 1L; boolean play = false; boolean gameOver = false; Timer timer = new Timer(40, this); int playerX = 300; int ballposX = 350 - 10; int ballposY = 350; int ballXdir; int ballYdir; boolean nothing = false; int score = 0; private Bricks bricks; Random row = new Random(); Random column = new Random(); int rows, columns, totalBricks; public Gameplay() { createBricks(); play = true; this.setSize(700, 600); this.setTitle(\"Breakout Ball\"); this.setResizable(false); this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); this.setLocationRelativeTo(null); this.addKeyListener(this); this.setVisible(true); } public void paint(Graphics g) { g.setColor(Color.BLACK); g.fillRect(0, 0, 700, 600); bricks.draw(g); g.setColor(Color.WHITE); g.setFont(new Font(\"Times New Roman\",Font.BOLD, 13)); g.drawString(\"Your score is: \" + score, 590, 45); g.setColor(Color.BLUE); g.fillOval(ballposX, ballposY, 20, 20); g.setColor(Color.GREEN); g.fillRect(playerX, 550, 100, 8); if(ballposY >= 600) { gameOver = true; end(g); g.setColor(Color.RED); g.drawString(\"Game Over!\", 265, 100); showMessage(g); } if(totalBricks <= 0) { end(g); g.setColor(Color.GREEN); g.drawString(\"You Won!\", 275, 100); showMessage(g); } g.dispose(); } public void end(Graphics g) { timer.stop(); g.setColor(Color.BLACK); g.fillRect(0, 0, 700, 600); play = false; ballXdir = 0; ballYdir = 0; g.setFont(new Font(\"ARIAL\",Font.PLAIN, 30)); } public void showMessage(Graphics g) { g.setFont(new Font(\"ARIAL\",Font.BOLD, 20)); g.drawString(\"Your score is: \" + score, 270, 300); g.setColor(Color.WHITE); g.setFont(new Font(\"ARIAL\",Font.BOLD, 20)); g.drawString(\"Press [SPACE] to Restart\", 230, 400); } public void keyPressed(KeyEvent e) { if (e.getKeyCode() == KeyEvent.VK_RIGHT) { if(nothing) { if(playerX >= 590) playerX = 590; else moveRight(); } } if (e.getKeyCode() == KeyEvent.VK_LEFT) { if(nothing) { if(playerX <= 10) playerX = 10; else moveLeft(); } } if (e.getKeyCode() == KeyEvent.VK_SPACE) { if(!play) { play = true; playerX = 300; ballposX = 350 - 10; ballposY = 400; ballDir(); if(gameOver) score = 0; createBricks(); timer.start(); } else if(!nothing) { nothing = true; ballDir(); timer.start(); } } } public void ballDir() { ballXdir = 0; ballYdir = 10; } public void createBricks() { rows = 3 + row.nextInt(2); columns = 4 + column.nextInt(3); bricks = new Bricks(rows, columns); totalBricks = rows * columns; } public void moveRight() { play = true; playerX += 20; } public void moveLeft() { play = true; playerX -= 20; } public void keyReleased(KeyEvent e) {} public void keyTyped(KeyEvent e) {} public void actionPerformed(ActionEvent e) { boolean flag = false; if(play) { int brickWidth = bricks.brickWidth; int brickHeight = bricks.brickHeight; int brickX; int brickY; Rectangle ball = new Rectangle(ballposX, ballposY, 20, 20); if(ball.intersects(new Rectangle(playerX, 550, 30, 8))) { ballYdir = -ballYdir; ballXdir -= 2; } else if(ball.intersects(new Rectangle(playerX + 70, 550, 30, 8))) { ballYdir = -ballYdir; ballXdir++; } else if(ball.intersects(new Rectangle(playerX + 30, 550, 40, 8))) ballYdir = -ballYdir; for(int i = 0; i < bricks.bricks.length; i++) { for(int j = 0; j < bricks.bricks[0].length; j++) { if(bricks.bricks[i][j] > 0) { brickX = j * brickWidth + 80; brickY = i * brickHeight + 50; Rectangle brickRect = new Rectangle(brickX, brickY, brickWidth, brickHeight); if(ball.intersects(brickRect)) { bricks.setBrickValue(i, j); score += 5; totalBricks--; if(ballposX + 19 <= brickRect.x || ballposX + 1 >= brickRect.x + brickRect.width) ballXdir = -ballXdir; else ballYdir = -ballYdir; flag = true; break; } } } if(flag) break; } ballPos(); if(ballposX < 0) ballXdir = -ballXdir; else if(ballposX > 680) ballXdir = -ballXdir; if(ballposY < 20) ballYdir = -ballYdir; repaint(); } } public void ballPos() { ballposX += ballXdir; ballposY += ballYdir; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Breakout-Ball-master/Breakout Ball/src/Gameplay.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Gameplay class manages game state, input handling, rendering, and UI setup, violating SRP by handling multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Gameplay class cannot be extended to modify game behavior (e.g., brick creation, ball movement) without altering its source code."}, {"principle": "Interface Segregation", "justification": "Implements KeyListener but provides empty keyReleased/keyTyped methods, forcing dependence on unused interfaces."}, {"principle": "Dependency Inversion", "justification": "Directly instantiates concrete Bricks class instead of depending on an abstraction, creating a high-level-to-low-level dependency."}]}]}
{"project_id": 82, "chunk_id": 0, "prompt": {"main_file_path": "Breakout-Ball-master/Breakout Ball/src/Main.java", "main_file_content": "public class Main { public static void main(String[] args) { new Gameplay(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Breakout-Ball-master/Breakout Ball/src/Main.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "The Main class directly instantiates the concrete Gameplay class. High-level modules (Main) should depend on abstractions, not concrete implementations."}]}]}
{"project_id": 85, "chunk_id": 0, "prompt": {"main_file_path": "Student_Database_Application_in_Java-main/Student_Database_Application/src/studentdatabaseapplication/StudentDatabaseApp.java", "main_file_content": "package studentdatabaseapplication; import java.util.Scanner; public class StudentDatabaseApp { public static void main(String[] args) { sout(\"\") Scanner sc = new Scanner(System.in); int numOfStudents = sc.nextInt(); Student[] students = new Student[numOfStudents]; for (int n = 0; n < numOfStudents; n++) { students[n] = new Student(); students[n].enroll(); students[n].payTuition(); } for (int n = 0; n < numOfStudents; n++) { soutl(\"\") } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Student_Database_Application_in_Java-main/Student_Database_Application/src/studentdatabaseapplication/StudentDatabaseApp.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The StudentDatabaseApp class handles user input, student creation, enrollment, and payment processing, which are multiple responsibilities. It should be split into separate classes for each responsibility."}, {"principle": "Dependency Inversion", "justification": "The StudentDatabaseApp directly instantiates the concrete Student class instead of depending on an abstraction (e.g., an interface), violating the dependency inversion principle for high-level modules."}]}]}
{"project_id": 85, "chunk_id": 0, "prompt": {"main_file_path": "Student_Database_Application_in_Java-main/Student_Database_Application/src/studentdatabaseapplication/Student.java", "main_file_content": "package studentdatabaseapplication; import java.util.Scanner; public class Student { private String firstName; private String lastName; private int gradeYear; private String studentID; private String courses = \"\"; private int tuitionBalance = 0; private static int costOfCourse = 600; private static int id = 1000; public Student() { Scanner sc = new Scanner(System.in); sout(\"\") this.firstName = sc.nextLine(); sout(\"\") this.lastName = sc.nextLine(); sout(\"\") this.gradeYear = sc.nextInt(); setStudentID(); } private void setStudentID() { id++; this.studentID = gradeYear + \"\" + id; } public void enroll() { do { sout(\"\") Scanner sc = new Scanner(System.in); String course = sc.nextLine(); if(!course.equals(\"Q\")) { courses = courses + \"\\n \" + course; tuitionBalance = tuitionBalance + costOfCourse; } else { break; } } while(1 != 0); } public void viewBalance() { soutl(\"\") } public void payTuition() { viewBalance(); sout(\"\") Scanner sc = new Scanner(System.in); int payment = sc.nextInt(); tuitionBalance = tuitionBalance - payment; soutl(\"\") viewBalance(); } public String toString() { return \"Name: \" + firstName + \" \" + lastName + \"\\nGrade Level: \" + gradeYear + \"\\nStudent ID: \" + studentID + \"\\nCourses Enrolled: \" + courses + \"\\nBalance: $\" + tuitionBalance; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Student_Database_Application_in_Java-main/Student_Database_Application/src/studentdatabaseapplication/Student.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Student class handles multiple responsibilities: student data management, user input handling, tuition balance calculation, and enrollment logic. This creates multiple reasons for the class to change."}, {"principle": "Open-Closed", "justification": "The Student class cannot be extended without modifying its code (e.g., to change enrollment behavior or student ID generation). It lacks abstractions for these behaviors."}, {"principle": "Interface Segregation", "justification": "Clients interacting with Student must depend on all methods (e.g., enroll(), payTuition()) even if they only use a subset. No interfaces exist to segregate these concerns."}]}]}
{"project_id": 86, "chunk_id": 0, "prompt": {"main_file_path": "java-pairmatching-precourse-main/java-pairmatching-precourse-main/src/main/java/pairmatching/Application.java", "main_file_content": "package pairmatching; public class Application { public static void main(String[] args) { } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "java-pairmatching-precourse-main/java-pairmatching-precourse-main/src/main/java/pairmatching/Application.java", "violatedPrinciples": []}]}
{"project_id": 86, "chunk_id": 0, "prompt": {"main_file_path": "java-pairmatching-precourse-main/java-pairmatching-precourse-main/src/test/java/pairmatching/ApplicationTest.java", "main_file_content": "package pairmatching; import static camp.nextstep.edu.missionutils.test.Assertions.assertShuffleTest; import static camp.nextstep.edu.missionutils.test.Assertions.assertSimpleTest; import static org.assertj.core.api.Assertions.assertThat; import camp.nextstep.edu.missionutils.test.NsTest; import java.util.Arrays; import org.junit.jupiter.api.Test; import pairmatching.Application; class ApplicationTest extends NsTest { private static final String ERROR_MESSAGE = \"[ERROR]\"; @Test void \uc9dd\uc218_\uc778\uc6d0_\ud398\uc5b4_\ub9e4\uce6d() { assertShuffleTest( () -> { run(\"1\", \"\ubc31\uc5d4\ub4dc, \ub808\ubca81, \uc790\ub3d9\ucc28\uacbd\uc8fc\", \"Q\"); assertThat(output()).contains(\"\ud0dc\uc6c5 : \ubc31\ud638\", \"\uce58\uc218 : \ud0dc\uc12d\"); }, Arrays.asList(\"\ud0dc\uc6c5\", \"\ubc31\ud638\", \"\uce58\uc218\", \"\ud0dc\uc12d\") ); } @Test void \uc5c6\ub294_\ubbf8\uc158\uc5d0_\ub300\ud55c_\uc608\uc678_\ucc98\ub9ac() { assertSimpleTest( () -> { runException(\"1\", \"\ubc31\uc5d4\ub4dc, \ub808\ubca81, \uc624\uc9d5\uc5b4\uac8c\uc784\"); assertThat(output()).contains(ERROR_MESSAGE); } ); } @Override public void runMain() { Application.main(new String[]{}); } }", "dependencies": [{"file_path": "java-pairmatching-precourse-main/java-pairmatching-precourse-main/src/main/java/pairmatching/Application.java", "file_content": "package pairmatching; public class Application { public static void main(String[] args) { } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 88, "chunk_id": 0, "prompt": {"main_file_path": "karts-with-sockets-main/karts-with-sockets-main/src/section1/Game.java", "main_file_content": "package section1; import javax.swing.*; import java.awt.*; public class Game extends JFrame { public static void main(String[] args) { new Game(); } Game() { setTitle(\"Racing Game: Part 1\"); setContentPane(new GamePanel()); setSize(new Dimension(850, 650)); setDefaultCloseOperation(EXIT_ON_CLOSE); setVisible(true); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "karts-with-sockets-main/karts-with-sockets-main/src/section1/Game.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Game class handles both JFrame window configuration (initialization, sizing) and application startup (main method), giving it multiple responsibilities. Changes to window setup or application bootstrapping would both require modifying this class."}, {"principle": "Dependency Inversion", "justification": "Game directly instantiates the concrete GamePanel class in its constructor. High-level modules like Game should depend on abstractions (interfaces) for components like panels, not concrete implementations."}]}]}
{"project_id": 88, "chunk_id": 0, "prompt": {"main_file_path": "karts-with-sockets-main/karts-with-sockets-main/src/section1/GamePanel.java", "main_file_content": "package section1; import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.KeyAdapter; import java.awt.event.KeyEvent; public class GamePanel extends JPanel implements ActionListener { private final Kart kart; private final Timer timer; public GamePanel() { setFocusable(true); Point kartPos = new Point(400, 250); String imgRoot = \"resources\\\\karts\\\\kart1\\\\\"; kart = new Kart(kartPos, new Dimension(50, 50), 0, imgRoot); addKeyListener(new KeyAdapter() { @Override public void keyPressed(KeyEvent e) { switch (e.getKeyCode()) { case KeyEvent.VK_LEFT -> kart.steerLeft(); case KeyEvent.VK_RIGHT -> kart.steerRight(); case KeyEvent.VK_UP -> kart.accelerate(); case KeyEvent.VK_DOWN -> kart.decelerate(); } } }); requestFocusInWindow(); timer = new Timer(30, this); timer.start(); } @Override public void paintComponent(Graphics g) { super.paintComponent(g); kart.render(g); } @Override public void actionPerformed(ActionEvent e) { kart.update(0.3); repaint(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "karts-with-sockets-main/karts-with-sockets-main/src/section1/GamePanel.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "GamePanel handles UI rendering, user input processing, and game loop management, which are multiple responsibilities. This violates SRP as the class has more than one reason to change."}, {"principle": "Open-Closed", "justification": "Adding new key bindings or modifying game loop behavior requires direct changes to GamePanel's code. This violates OCP since the class is not extendable without modification."}, {"principle": "Dependency Inversion", "justification": "GamePanel directly instantiates the concrete Kart class instead of depending on an abstraction. High-level modules should depend on abstractions, not concrete implementations."}]}]}
{"project_id": 88, "chunk_id": 0, "prompt": {"main_file_path": "karts-with-sockets-main/karts-with-sockets-main/src/section1/Kart.java", "main_file_content": "package section1; import javax.imageio.ImageIO; import java.awt.*; import java.io.IOException; public class Kart { private int centerX, centerY; private final int width; private final int height; private int v; private int direction; static int totalKarts; private final Color color1; private final Color color2; Image[] images; public Kart(Point center, Dimension size, int direction, String imgRoot) { images = new Image[16]; for(int i = 0; i < images.length; i++) { try { images[i] = ImageIO.read(getClass().getClassLoader().getResource(imgRoot + i + \".png\")); } catch (IOException e) { e.printStackTrace(); } } this.centerX = center.x; this.centerY = center.y; this.width = size.width; this.height = size.height; this.direction = direction; if (totalKarts++ == 0) { this.color1 = Color.RED; this.color2 = Color.BLUE; } else { this.color1 = Color.BLUE; this.color2 = Color.RED; } } public void render(Graphics g) { Rectangle bounds = getBounds(); if(images!= null && images[direction] != null) { g.drawImage(images[direction], bounds.x, bounds.y,null); return; } g.setColor(color1); g.fillRect(bounds.x, bounds.y, width, height); g.setColor(color2); int x2 = centerX + (int) (width/2 * Math.cos(direction * Math.PI / 8)); int y2 = centerY + (int) (width/2 * Math.sin(direction * Math.PI / 8)); g.fillRect(x2, y2, 10, 10); } public void steerLeft() { direction += 1; if(direction > 15) direction = 0; } public void steerRight() { direction -= 1; if(direction < 0) direction = 15; } public void accelerate() { v += 10; if (v > 100) v = 100; } public void decelerate() { v -= 10; if (v < 0) v = 0; } public void update(double dt) { centerX += v * Math.cos(direction * Math.PI / 8) * dt; centerY -= v * Math.sin(direction * Math.PI / 8) * dt; } public Rectangle getBounds() { return new Rectangle(centerX - width / 2, centerY - width / 2, width, height); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "karts-with-sockets-main/karts-with-sockets-main/src/section1/Kart.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Kart class handles image loading, rendering logic, and kart state management. These distinct responsibilities increase coupling and create multiple reasons to change."}, {"principle": "Open-Closed", "justification": "Adding new rendering behaviors or image-loading strategies requires modifying the Kart class directly. Existing code is not closed for modification nor open for extension."}]}]}
{"project_id": 88, "chunk_id": 0, "prompt": {"main_file_path": "karts-with-sockets-main/karts-with-sockets-main/src/section3/GameServer.java", "main_file_content": "package section3; import javax.swing.*; import java.awt.*; import java.awt.event.ActionListener; import java.io.BufferedReader; import java.io.InputStreamReader; import java.io.PrintWriter; import java.net.ServerSocket; import java.net.Socket; import java.util.ArrayList; import java.util.HashMap; import java.util.StringTokenizer; public class GameServer extends JFrame { private static final int DEFAULT_PORT = 12345; private int serverPort; public static void main(String[] args) { new GameServer(); } ArrayList<ClientThread> clientThreads; HashMap<String, String> karts; private ActionListener actionListener; JTextField portT; JButton exec; JButton showDataButton; JButton end; JCheckBox finalizeCheckBox; JTextArea transcript; private boolean finalize; ServerSocket serverSocket; int nClients; boolean running; public GameServer() { initActionListener(); clientThreads = new ArrayList<>(); karts = new HashMap<>(); JPanel mainPanel = new JPanel(); JLabel logoLabel; try { ImageIcon logoIcon = new ImageIcon(\"RacingLogoServer.png\"); logoLabel = new JLabel(logoIcon); } catch (Exception e) { logoLabel = new JLabel(\"<Racing logo image>\"); } mainPanel.add(logoLabel, BorderLayout.NORTH); JPanel btnP = new JPanel(new FlowLayout(FlowLayout.CENTER)); JLabel portL = new JLabel(\"Port :\"); btnP.add(portL); portT = new JTextField(DEFAULT_PORT + \"\"); btnP.add(portT); exec = new JButton(\"Execute\"); exec.addActionListener(actionListener); btnP.add(exec); showDataButton = new JButton(\"Show Karts Data\"); showDataButton.addActionListener(actionListener); showDataButton.setEnabled(false); btnP.add(showDataButton); finalizeCheckBox = new JCheckBox(\"Finalize\"); finalizeCheckBox.addActionListener(actionListener); btnP.add(finalizeCheckBox); end = new JButton(\"End\"); end.setEnabled(false); end.addActionListener(actionListener); btnP.add(end); mainPanel.add(btnP); transcript = new JTextArea(); transcript = new JTextArea(7, 40); transcript.setLineWrap(true); transcript.setWrapStyleWord(true); transcript.setEditable(false); mainPanel.add(new JScrollPane(transcript)); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setTitle(\"Server\"); setContentPane(mainPanel); setSize(new Dimension(560, 350)); setResizable(false); setVisible(true); } private void exec() { try { serverPort = Integer.parseInt(portT.getText().trim()); } catch (NumberFormatException e) { showError(\"Invalid port\" + portT.getText()); return; } try { serverSocket = new ServerSocket(serverPort); } catch (Exception e) { showError(\"Failed to initialize server socket\"); } running = true; new Thread(() -> { while (running) { try { Socket socket = serverSocket.accept(); ClientThread clientThread = new ClientThread(socket); clientThreads.add(clientThread); clientThread.start(); showDataButton.setEnabled(true); } catch (Exception e) { showError(e.getMessage()); } } }).start(); log(\"Listening on Port : \" + serverPort); exec.setEnabled(false); end.setEnabled(true); } private void showKartsData() { log(\"\\nsection3.Game All clients data : \"); log(\"\\n\"); for (String key : karts.keySet()) { log(karts.get(key) + \"\\n\"); } } private void end() { for (ClientThread client : clientThreads) { try { log(\"Disconnecting Player : \" + client.id); client.socket.close(); client.running = false; } catch (Exception e) { showError(\"Failed to disconnect client \" + client.id + \": \" + e.getMessage()); } } try { serverSocket.close(); } catch (Exception e) { showError(\"Failed to close the Server : \" + e.getMessage()); } log(\"Server closed.\"); running = false; exec.setEnabled(true); end.setEnabled(false); } private void initActionListener() { actionListener = e -> { if (e.getSource() == exec) { exec(); } else if (e.getSource() == showDataButton) { showKartsData(); } else if (e.getSource() == end) { end(); } else if (e.getSource() == finalizeCheckBox) { finalize = finalizeCheckBox.isSelected(); } }; } synchronized void log(String message) { transcript.append(message + \"\\n\"); } synchronized void showError(String errorMessage) { JOptionPane.showMessageDialog(this, errorMessage, \"Error !\", JOptionPane.ERROR_MESSAGE); } private class ClientThread extends Thread { boolean running; private final Socket socket; private BufferedReader in; private PrintWriter out; String id; private ClientThread(Socket socket) { this.socket = socket; try { in = new BufferedReader(new InputStreamReader(socket.getInputStream())); out = new PrintWriter(socket.getOutputStream()); id = nClients++ + \"\"; log(\"New Client Connected. Identification : \" + id); out.println(id); out.flush(); running = true; } catch (Exception e) { showError(\"I/O Error occurred : \" + e.getMessage()); } } public void run() { String line; while (running) { try { line = in.readLine(); handleClientRequest(line); } catch (Exception e) { showError(\"Failed to load client request\" + e.getMessage()); break; } } log(\"Client \" + id + \" left the game\"); if (--nClients == 0 && finalize) { log(\"Last client closed.\"); end(); } } private synchronized void handleClientRequest(String request) { if (request == null) { log(\"Client \" + id + \" closed\"); return; } log(request); StringTokenizer st = new StringTokenizer(request.trim(), \"#\"); String protocol = st.nextToken(); if (protocol.equals(\"P0\")) { try { socket.close(); log(\"Client closed : \" + id); log(\"Game Over !\"); for(var client: clientThreads) { if(client.id != id) { client.out.println(\"P0#\" + id); } } running = false; } catch (Exception e) { showError(\"Failed to close socket\"); } } else if (protocol.equals(\"P1\")) { String data = st.nextToken(); int numKarts = karts.size() - 1; karts.put(id, data.trim()); log(\"Kart Data received from : \" + id ); log(\"Number of karts '\" + (numKarts) + \"' sent to client \" + id); out.println(numKarts + \"\"); out.flush(); if (numKarts < 1) return; for (var client : clientThreads) { if (!client.id.equals(id)) { out.println(client.id + \"?\" + karts.get(client.id)); out.flush(); log(\"Kart \" + client.id + \" Data \" + karts.get(client.id) + \" sent to : \" + id + \"\\n\"); } } log(\"\"); } } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "karts-with-sockets-main/karts-with-sockets-main/src/section3/GameServer.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "GameServer handles GUI construction, server socket management, client connection handling, and business logic, violating SRP by managing multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Protocol handling in handleClientRequest uses explicit conditionals (P0/P1 checks). Adding new protocols requires modifying this method, violating OCP."}, {"principle": "Dependency Inversion", "justification": "GameServer directly instantiates low-level ClientThread and ServerSocket/Socket without abstractions, creating direct dependencies on concrete implementations."}]}]}
{"project_id": 88, "chunk_id": 0, "prompt": {"main_file_path": "karts-with-sockets-main/karts-with-sockets-main/src/section3/GamePanel.java", "main_file_content": "package section3; import javax.imageio.ImageIO; import javax.sound.sampled.AudioSystem; import javax.sound.sampled.Clip; import javax.swing.*; import java.awt.*; import java.awt.event.*; import java.io.*; import java.net.Socket; public class GamePanel extends JPanel implements ActionListener { private Timer timer; Kart[] karts; private boolean debugMode; private final int FPS = 30; private Rectangle innerBounds = new Rectangle(150, 200, 550, 300); private Rectangle midBounds = new Rectangle(100, 150, 650, 400); private Rectangle outerBounds = new Rectangle(50, 100, 750, 500); private int trackWidth = 100; private Point startPoint = new Point(425, 500); private final String KART1_PATH = \"karts/kart1/\"; private final String KART2_PATH = \"karts/kart2/\"; private final String mapImgPath = \"map.png\"; private Image mapImg; private int id; private Socket socket; private BufferedReader in; private PrintWriter out; private boolean connected; protected GamePanel() { setFocusable(true); try { mapImg = ImageIO.read(getClass().getClassLoader().getResource(mapImgPath)); } catch (IOException e) { e.printStackTrace(); } init(); addKeyListener(new KeyAdapter() { @Override public void keyPressed(KeyEvent e) { switch (e.getKeyCode()) { case KeyEvent.VK_LEFT -> karts[id].steerLeft(); case KeyEvent.VK_RIGHT -> karts[id].steerRight(); case KeyEvent.VK_UP -> karts[id].accelerate(); case KeyEvent.VK_DOWN -> karts[id].decelerate(); } } }); addMouseListener(new MouseAdapter() { @Override public void mouseEntered(MouseEvent e) { requestFocusInWindow(); } }); } protected void init() { Point kart1Pos = new Point(startPoint.x + trackWidth / 4, startPoint.y + trackWidth / 4); Point kart2Pos = new Point(startPoint.x + trackWidth / 4, startPoint.y + trackWidth / 4 + trackWidth / 2); Kart kart1 = new Kart(kart1Pos, new Dimension(35, 25), 0, KART1_PATH); Kart kart2 = new Kart(kart2Pos, new Dimension(35, 25), 0, KART2_PATH); karts = new Kart[]{kart1, kart2}; requestFocusInWindow(); if(timer != null) timer.stop(); timer = new Timer(1000 / FPS, this); timer.start(); } @Override public void paintComponent(Graphics g) { super.paintComponent(g); renderMap(g); for (var kart : karts) { kart.render(g); } if (debugMode) { drawColliders(g); } } private void renderMap(Graphics g) { if (mapImg != null) { g.drawImage(mapImg, 0, 0, null); return; } Color c1 = Color.GREEN; g.setColor(c1); g.fillRect(innerBounds.x, innerBounds.y, innerBounds.width, innerBounds.height); Color c2 = Color.BLACK; g.setColor(c2); g.drawRect(outerBounds.x, outerBounds.y, outerBounds.width, outerBounds.height); g.drawRect(innerBounds.x, innerBounds.y, innerBounds.width, innerBounds.height); Color c3 = Color.YELLOW; g.setColor(c3); g.drawRect(midBounds.x, midBounds.y, midBounds.width, midBounds.height); Color c4 = Color.WHITE; g.setColor(c4); g.drawLine(startPoint.x, startPoint.y, startPoint.x, startPoint.y + trackWidth); } private void drawColliders(Graphics g) { g.setColor(Color.RED); g.drawRect(outerBounds.x, outerBounds.y, outerBounds.width, outerBounds.height); g.drawRect(innerBounds.x, innerBounds.y, innerBounds.width, innerBounds.height); for (Kart kart : karts) kart.drawColliders(g); } @Override public void actionPerformed(ActionEvent e) { checkCollisions(); karts[id].update(0.3); if (connected) requestNextFrame(); repaint(); } private synchronized void requestNextFrame() { out.println(\"P1#\" + karts[id].encode()); out.flush(); try { String line = in.readLine().trim(); if (line.length() > 1 && line.substring(0, 2).equals(\"P0\")) { String message = \"The client \" + line.substring(2) + \" left.\" + \" You can continue playing alone or disconnect and restart the game.\"; JOptionPane.showMessageDialog(this, message); } int numKarts = Integer.parseInt(line); log(\"number of other karts = \" + numKarts + \"\\n\"); if (numKarts < 1) { log(\"No other player connected !\"); return; } for (int i = 1; i <= numKarts; i++) { String response = in.readLine(); soutl(\"\") int idx = Integer.parseInt(response.substring(0, response.indexOf('?'))); String kartData = response.substring(response.indexOf('?') + 1); karts[idx].decode(kartData); } } catch (IOException e) { e.printStackTrace(); } } protected boolean connect(String server, int port) { try { socket = new Socket(server, port); in = new BufferedReader(new InputStreamReader(socket.getInputStream())); out = new PrintWriter(socket.getOutputStream()); id = Integer.parseInt(in.readLine().trim()); log(\"Connected to Server.\\nIdentification received : \" + id + '\\n'); connected = true; requestFocusInWindow(); return true; } catch (Exception e) { showError(\"Failed to connect : \" + e.getMessage()); e.printStackTrace(); return false; } } void gameOver() { timer.stop(); log(\"section3.Game Over !!\"); disconnect(); JOptionPane.showMessageDialog(null, \"Game Over !\"); } protected void disconnect() { connected = false; try { if(out == null) return; out.println(\"P0#\" + karts[id].encode()); out.flush(); socket.close(); } catch (Exception e) { e.printStackTrace(); } } private void checkCollisions() { for (int i = 0; i < karts.length; i++) { if (i == id) continue; if (karts[id].getShape().intersects(karts[i].getShape().getBounds())) { collisionEffect(); gameOver(); return; } } checkKartCollision(karts[id], innerBounds, outerBounds); } private void checkKartCollision(Kart kart, Rectangle innerBounds, Rectangle outerBounds) { Shape kartBounds = kart.getShape(); if (kartBounds.intersects(innerBounds)) { kart.stop(); if (!kart.isStuck()) { collisionEffect(); soutl(\"\") kart.setStuck(true); } } else if (!outerBounds.contains(kartBounds.getBounds())) { kart.stop(); if (!kart.isStuck()) { collisionEffect(); soutl(\"\") kart.setStuck(true); } } else { kart.setStuck(false); } } private void collisionEffect() { try { String soundPath = \"collision.wav\"; Clip collisionClip = AudioSystem.getClip(); collisionClip.open(AudioSystem.getAudioInputStream(getClass().getClassLoader().getResource(soundPath))); collisionClip.start(); } catch (Exception e) { e.printStackTrace(); } } public boolean isConnected() { return connected; } protected void setDebugMode(boolean debugMode) { this.debugMode = debugMode; } private void showError(String s) { if (debugMode) JOptionPane.showMessageDialog(this, s, \"Error\", JOptionPane.ERROR_MESSAGE); } private void log(String message) { if (debugMode) sout(\"\") } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "karts-with-sockets-main/karts-with-sockets-main/src/section3/GamePanel.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "GamePanel handles UI rendering, game state management, collision detection, network communication, and sound effects. These multiple responsibilities violate SRP as the class has multiple reasons to change."}, {"principle": "Open-Closed", "justification": "GamePanel directly implements all behaviors (e.g., collision checks, network protocols) without abstraction. Extending functionality (e.g., adding new collision types) would require modifying existing code instead of extending via interfaces/implementations."}, {"principle": "Dependency Inversion", "justification": "High-level GamePanel directly depends on low-level concrete classes like Socket, Kart, and audio/IO utilities. It should depend on abstractions for network communication, kart behavior, and sound management instead."}]}]}
{"project_id": 88, "chunk_id": 0, "prompt": {"main_file_path": "karts-with-sockets-main/karts-with-sockets-main/src/section3/GameClient.java", "main_file_content": "package section3; import javax.swing.*; import java.awt.*; public class GameClient extends JFrame { private final JButton connectButton, disconnectButton; public static void main(String[] args) { new GameClient(); } private final JTextField serverField; private final JTextField portField; private GamePanel game; final int DEFAULT_PORT = 12345; final String DEFAULT_SERVER = \"localhost\"; public GameClient() { setTitle(\"Kart Racing: Client\"); game = new GamePanel(); add(game, BorderLayout.CENTER); JLabel serverLabel = new JLabel(\"Server: \"); serverField = new JTextField(10); serverField.setText(DEFAULT_SERVER); JLabel portLabel = new JLabel(\"Port: \"); portField = new JTextField(10); portField.setText(DEFAULT_PORT + \"\"); connectButton = new JButton(\"Connect\"); connectButton.addActionListener(e -> connect()); disconnectButton = new JButton(\"Disconnect\"); disconnectButton.addActionListener(e -> disconnect()); disconnectButton.setEnabled(false); JCheckBox debugCheckBox = new JCheckBox(\"Debug Mode\"); debugCheckBox.addActionListener(e -> game.setDebugMode(debugCheckBox.isSelected())); JPanel topPanel = new JPanel(new FlowLayout(FlowLayout.CENTER)); topPanel.add(serverLabel); topPanel.add(serverField); topPanel.add(portLabel); topPanel.add(portField); topPanel.add(connectButton); topPanel.add(disconnectButton); topPanel.add(debugCheckBox); topPanel.setBorder(BorderFactory.createLineBorder(Color.BLUE)); add(topPanel, BorderLayout.NORTH); setSize(new Dimension(850, 700)); setDefaultCloseOperation(EXIT_ON_CLOSE); setVisible(true); } private void disconnect() { game.disconnect(); disconnectButton.setEnabled(false); connectButton.setEnabled(true); } private void connect() { String server = serverField.getText().trim(); int port = -1; try { port = Integer.parseInt(portField.getText().trim()); } catch (NumberFormatException e) { soutl(\"\") } game.init(); if (game.connect(server, port)) { connectButton.setEnabled(false); disconnectButton.setEnabled(true); } else { JOptionPane.showMessageDialog(this, \"Failed to connect\", \"Error\", JOptionPane.ERROR_MESSAGE); } } }", "dependencies": [{"file_path": "karts-with-sockets-main/karts-with-sockets-main/src/section1/GamePanel.java", "file_content": "package section1; import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.KeyAdapter; import java.awt.event.KeyEvent; public class GamePanel extends JPanel implements ActionListener { private final Kart kart; private final Timer timer; public GamePanel() { setFocusable(true); Point kartPos = new Point(400, 250); String imgRoot = \"resources\\\\karts\\\\kart1\\\\\"; kart = new Kart(kartPos, new Dimension(50, 50), 0, imgRoot); addKeyListener(new KeyAdapter() { @Override public void keyPressed(KeyEvent e) { switch (e.getKeyCode()) { case KeyEvent.VK_LEFT -> kart.steerLeft(); case KeyEvent.VK_RIGHT -> kart.steerRight(); case KeyEvent.VK_UP -> kart.accelerate(); case KeyEvent.VK_DOWN -> kart.decelerate(); } } }); requestFocusInWindow(); timer = new Timer(30, this); timer.start(); } @Override public void paintComponent(Graphics g) { super.paintComponent(g); kart.render(g); } @Override public void actionPerformed(ActionEvent e) { kart.update(0.3); repaint(); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "karts-with-sockets-main/karts-with-sockets-main/src/section3/GameClient.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "GameClient manages UI components (JFrame), network connection logic, and user interactions. These multiple responsibilities violate SRP as they represent more than one reason to change."}, {"principle": "Dependency Inversion", "justification": "GameClient directly instantiates GamePanel (a concrete class). High-level modules like GameClient should depend on abstractions rather than concrete implementations."}]}, {"file_path": "karts-with-sockets-main/karts-with-sockets-main/src/section1/GamePanel.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "GamePanel handles rendering, keyboard input processing, game loop timing, and Kart updates. These distinct responsibilities violate SRP."}, {"principle": "Dependency Inversion", "justification": "GamePanel directly instantiates Kart (a concrete class). High-level game logic should depend on abstractions rather than concrete Kart implementations."}]}]}
{"project_id": 88, "chunk_id": 0, "prompt": {"main_file_path": "karts-with-sockets-main/karts-with-sockets-main/src/section3/Kart.java", "main_file_content": "package section3; import javax.imageio.ImageIO; import java.awt.*; import java.awt.geom.AffineTransform; import java.io.IOException; import java.util.StringTokenizer; public class Kart { private int centerX, centerY; private int sizeX, sizeY; private int speed; private int direction; private boolean stuck; public boolean isStuck() { return stuck; } public void setStuck(boolean stuck) { this.stuck = stuck; } private Image[] images; public Kart(Point center, Dimension dim, int direction, String imgRootPath) { images = new Image[16]; for (int i = 0; i < images.length; i++) { try { images[i] = ImageIO.read(getClass().getClassLoader().getResource(imgRootPath + i + \".png\")); } catch (IOException e) { e.printStackTrace(); } } this.centerX = center.x; this.centerY = center.y; this.sizeX = dim.width; this.sizeY = dim.height; this.direction = direction; } public void render(Graphics g) { if (images != null && images[direction] != null) { g.drawImage(images[direction], centerX - 25, centerY - 22, null); } else { soutl(\"\") } } public void steerLeft() { direction += 1; if (direction > 15) direction = 0; } public void steerRight() { direction -= 1; if (direction < 0) direction = 15; } public void accelerate() { speed += 10; if (speed > 100) speed = 100; } public void decelerate() { speed -= 10; if (speed < 0) speed = 0; } public void update(double dt) { centerX += speed * Math.cos(direction * Math.PI / 8) * dt; centerY -= speed * Math.sin(direction * Math.PI / 8) * dt; } public void stop() { speed = 0; } public Shape getShape() { Rectangle bounds = new Rectangle(centerX - sizeX / 2, centerY - sizeY / 2, sizeX, sizeY); AffineTransform tx = new AffineTransform(); tx.rotate(-Math.PI / 8 * direction, centerX, centerY); return tx.createTransformedShape(bounds); } public void drawColliders(Graphics g) { Shape bounds = getShape(); Graphics2D g2d = (Graphics2D) g; g2d.setColor(Color.GREEN); g2d.draw(bounds); } public String encode() { String s; s = centerX + \"-\" + centerY + \"-\" + sizeX + \"-\" + sizeY + \"-\" + speed + \"-\" + direction + \"-\" + stuck; return s; } public void decode(String kartData) { StringTokenizer st = new StringTokenizer(kartData, \"-\"); this.centerX = Integer.parseInt(st.nextToken()); this.centerY = Integer.parseInt(st.nextToken()); this.sizeX = Integer.parseInt(st.nextToken()); this.sizeY = Integer.parseInt(st.nextToken()); this.speed = Integer.parseInt(st.nextToken()); this.direction = Integer.parseInt(st.nextToken()); this.stuck = Boolean.parseBoolean(st.nextToken()); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "karts-with-sockets-main/karts-with-sockets-main/src/section3/Kart.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Kart class handles multiple responsibilities: rendering graphics, managing state (position, speed, direction), image loading, encoding/decoding data, and collision detection. This creates multiple reasons to change the class."}, {"principle": "Open-Closed", "justification": "The Kart class cannot be extended without modification. For example, changes to image loading or movement logic require altering existing methods instead of overriding or extending via abstractions."}, {"principle": "Interface Segregation", "justification": "Clients of Kart must depend on all methods (e.g., encode(), decode(), steerLeft(), drawColliders()) even if they only use a subset. No interfaces are provided to segregate functionality."}, {"principle": "Dependency Inversion", "justification": "Kart directly depends on concrete image loading (ImageIO) and low-level rendering logic. High-level business logic (movement, state) is not decoupled from these implementation details via abstractions."}]}]}
{"project_id": 88, "chunk_id": 0, "prompt": {"main_file_path": "karts-with-sockets-main/karts-with-sockets-main/src/section2/Game.java", "main_file_content": "package section2; import javax.swing.*; import java.awt.*; public class Game extends JFrame { public static void main(String[] args) { new Game(); } Game() { setTitle(\"Kart Racing Game\"); GamePanel game = new GamePanel(); game.debugMode = true; setContentPane(game); setSize(new Dimension(850, 700)); setDefaultCloseOperation(EXIT_ON_CLOSE); setVisible(true); } }", "dependencies": [{"file_path": "karts-with-sockets-main/karts-with-sockets-main/src/section1/GamePanel.java", "file_content": "package section1; import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.KeyAdapter; import java.awt.event.KeyEvent; public class GamePanel extends JPanel implements ActionListener { private final Kart kart; private final Timer timer; public GamePanel() { setFocusable(true); Point kartPos = new Point(400, 250); String imgRoot = \"resources\\\\karts\\\\kart1\\\\\"; kart = new Kart(kartPos, new Dimension(50, 50), 0, imgRoot); addKeyListener(new KeyAdapter() { @Override public void keyPressed(KeyEvent e) { switch (e.getKeyCode()) { case KeyEvent.VK_LEFT -> kart.steerLeft(); case KeyEvent.VK_RIGHT -> kart.steerRight(); case KeyEvent.VK_UP -> kart.accelerate(); case KeyEvent.VK_DOWN -> kart.decelerate(); } } }); requestFocusInWindow(); timer = new Timer(30, this); timer.start(); } @Override public void paintComponent(Graphics g) { super.paintComponent(g); kart.render(g); } @Override public void actionPerformed(ActionEvent e) { kart.update(0.3); repaint(); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "karts-with-sockets-main/karts-with-sockets-main/src/section1/GamePanel.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "GamePanel handles user input processing, game state updates via Timer, and rendering logic. These are three distinct responsibilities requiring separate reasons to change."}, {"principle": "Open-Closed", "justification": "GamePanel directly instantiates concrete Kart class. Adding new vehicle types would require modifying GamePanel's code rather than extending through abstractions."}, {"principle": "Dependency Inversion", "justification": "GamePanel depends on concrete Kart implementation instead of an abstraction. High-level game logic should depend on interfaces rather than low-level kart details."}]}]}
{"project_id": 88, "chunk_id": 0, "prompt": {"main_file_path": "karts-with-sockets-main/karts-with-sockets-main/src/section2/GamePanel.java", "main_file_content": "package section2; import javax.imageio.ImageIO; import javax.sound.sampled.AudioSystem; import javax.sound.sampled.Clip; import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.KeyAdapter; import java.awt.event.KeyEvent; public class GamePanel extends JPanel implements ActionListener { private final Kart kart1; private final Kart kart2; private final Timer timer; private final Point startPoint = new Point(425, 500); private final int trackWidth = 100; Rectangle innerBounds = new Rectangle(150, 200, 550, 300); Rectangle outerBounds = new Rectangle(50, 100, 750, 500); Rectangle midBounds = new Rectangle(100, 150, 650, 400); Dimension kartDim = new Dimension(35, 25); private final String mapImgPath = \"map.png\"; private final String imgRoot1 = \"karts/kart1/\"; private final String imgRoot2 = \"karts/kart2/\"; private Image mapImg; protected boolean debugMode; public GamePanel() { setFocusable(true); try { mapImg = ImageIO.read(getClass().getClassLoader().getResource(mapImgPath)); } catch (Exception e) { e.printStackTrace(); } Point kart1Pos = new Point(startPoint.x + 25, startPoint.y + 25); Point kart2Pos = new Point(startPoint.x + 25, startPoint.y + 25 + 50); kart1 = new Kart(kart1Pos, kartDim, 0, imgRoot1); kart2 = new Kart(kart2Pos, kartDim, 0, imgRoot2); addKeyListener(new KeyAdapter() { @Override public void keyPressed(KeyEvent e) { switch (e.getKeyCode()) { case KeyEvent.VK_LEFT -> kart1.steerLeft(); case KeyEvent.VK_RIGHT -> kart1.steerRight(); case KeyEvent.VK_UP -> kart1.accelerate(); case KeyEvent.VK_DOWN -> kart1.decelerate(); case KeyEvent.VK_A -> kart2.steerLeft(); case KeyEvent.VK_D -> kart2.steerRight(); case KeyEvent.VK_W -> kart2.accelerate(); case KeyEvent.VK_S -> kart2.decelerate(); } } }); requestFocusInWindow(); timer = new Timer(30, this); timer.start(); } @Override public void paintComponent(Graphics g) { super.paintComponent(g); renderMap(g); kart1.render(g); kart2.render(g); if (debugMode) { drawColliders(g); } } private void renderMap(Graphics g) { if (mapImg != null) { g.drawImage(mapImg, 0, 0, null); return; } Color c1 = Color.GREEN; g.setColor(c1); g.fillRect(innerBounds.x, innerBounds.y, innerBounds.width, innerBounds.height); Color c2 = Color.BLACK; g.setColor(c2); g.drawRect(outerBounds.x, outerBounds.y, outerBounds.width, outerBounds.height); g.drawRect(innerBounds.x, innerBounds.y, innerBounds.width, innerBounds.height); Color c3 = Color.YELLOW; g.setColor(c3); g.drawRect(midBounds.x, midBounds.y, midBounds.width, midBounds.height); Color c4 = Color.WHITE; g.setColor(c4); g.drawLine(startPoint.x, startPoint.y, startPoint.x, startPoint.y + trackWidth); } private void drawColliders(Graphics g) { g.setColor(Color.RED); g.drawRect(outerBounds.x, outerBounds.y, outerBounds.width, outerBounds.height); g.drawRect(innerBounds.x, innerBounds.y, innerBounds.width, innerBounds.height); kart1.drawColliders(g); kart2.drawColliders(g); } @Override public void actionPerformed(ActionEvent e) { checkCollisions(); kart1.update(0.3); kart2.update(0.3); repaint(); } private void checkCollisions() { if (kart1.getShape().intersects(kart2.getShape().getBounds())) { collisionEffect(); gameOver(); return; } checkKartCollision(kart1, innerBounds, outerBounds); checkKartCollision(kart2, innerBounds, outerBounds); } private void gameOver() { timer.stop(); JOptionPane.showMessageDialog(this, \"Game Over !\"); } private void checkKartCollision(Kart kart, Rectangle innerBounds, Rectangle outerBounds) { Shape kartBounds = kart.getShape(); if (kartBounds.intersects(innerBounds)) { kart.stop(); if (!kart.isStuck()) { collisionEffect(); soutl(\"\") kart.setStuck(true); } } else if (!outerBounds.contains(kartBounds.getBounds())) { kart.stop(); if (!kart.isStuck()) { collisionEffect(); soutl(\"\") kart.setStuck(true); } } else { kart.setStuck(false); } } private void collisionEffect() { try { String soundPath = \"collision.wav\"; Clip collisionClip = AudioSystem.getClip(); collisionClip.open(AudioSystem.getAudioInputStream(getClass().getClassLoader().getResource(soundPath))); collisionClip.start(); } catch (Exception e) { e.printStackTrace(); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "karts-with-sockets-main/karts-with-sockets-main/src/section2/GamePanel.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "GamePanel handles rendering, input handling, collision detection, sound effects, and game state management. These are multiple responsibilities requiring changes for UI, logic, or audio updates."}, {"principle": "Dependency Inversion", "justification": "GamePanel directly instantiates concrete Kart classes. High-level modules should depend on abstractions rather than concrete implementations."}]}]}
{"project_id": 88, "chunk_id": 0, "prompt": {"main_file_path": "karts-with-sockets-main/karts-with-sockets-main/src/section2/Kart.java", "main_file_content": "package section2; import javax.imageio.ImageIO; import java.awt.*; import java.awt.geom.AffineTransform; public class Kart { private int centerX, centerY; private int sizeX, sizeY; private int speed; private int direction; private boolean stuck; public boolean isStuck() { return stuck; } public void setStuck(boolean stuck) { this.stuck = stuck; } private Image[] images; public Kart(Point center, Dimension dim, int direction, String imgRootPath) { images = new Image[16]; for (int i = 0; i < images.length; i++) { try { images[i] = ImageIO.read(getClass().getClassLoader().getResource(imgRootPath + i + \".png\")); } catch (Exception e) { e.printStackTrace(); } } this.centerX = center.x; this.centerY = center.y; this.sizeX = dim.width; this.sizeY = dim.height; this.direction = direction; } public void render(Graphics g) { if (images != null && images[direction] != null) { g.drawImage(images[direction], centerX - 25, centerY - 22, null); } else { soutl(\"\") } } public void steerLeft() { direction += 1; if (direction > 15) direction = 0; } public void steerRight() { direction -= 1; if (direction < 0) direction = 15; } public void accelerate() { speed += 10; if (speed > 100) speed = 100; } public void decelerate() { speed -= 10; if (speed < 0) speed = 0; } public void update(double dt) { centerX += speed * Math.cos(direction * Math.PI / 8) * dt; centerY -= speed * Math.sin(direction * Math.PI / 8) * dt; } public void stop() { speed = 0; } public Shape getShape() { Rectangle bounds = new Rectangle(centerX - sizeX / 2, centerY - sizeY / 2, sizeX, sizeY); AffineTransform tx = new AffineTransform(); tx.rotate(-Math.PI / 8 * direction, centerX, centerY); return tx.createTransformedShape(bounds); } public void drawColliders(Graphics g) { Shape bounds = getShape(); Graphics2D g2d = (Graphics2D) g; g2d.setColor(Color.GREEN); g2d.draw(bounds); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "karts-with-sockets-main/karts-with-sockets-main/src/section2/Kart.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Kart class handles image loading, rendering, movement logic, collision detection, and state management. These multiple responsibilities indicate a violation of SRP."}, {"principle": "Open-Closed", "justification": "The Kart class cannot be extended to modify image-loading or movement behavior without directly altering its code, violating OCP."}, {"principle": "Dependency Inversion", "justification": "Kart directly depends on concrete ImageIO for image loading instead of abstractions. High-level modules would depend on Kart's concrete implementation."}]}]}
{"project_id": 92, "chunk_id": 0, "prompt": {"main_file_path": "LinkedList-Implementation-w-Java-main/src/FactoryImpl.java", "main_file_content": "import java.util.ArrayList; import java.util.NoSuchElementException; public class FactoryImpl implements Factory { private Holder first; private Holder last; private Integer size = 0; @Override public void addFirst(Product product) { Holder holder = new Holder(null, product, null); if (size == 0) { first = holder; last = first; } else { holder.setNextHolder(first); first.setPreviousHolder(holder); first = holder; } size++; } @Override public void addLast(Product product) { Holder holder = new Holder(null, product, null); if (size == 0) { last = holder; first = last; } else { last.setNextHolder(holder); holder.setPreviousHolder(last); last = holder; } size++; } @Override public void add(int index, Product product) throws IndexOutOfBoundsException { if ((index <= size) && (index >= 0)) { if (index == 0) { addFirst(product); } else if (index == size) { addLast(product); } else { Holder holder = new Holder(null, product, null); Holder currentHolder = first.getNextHolder(); for (int i = 1; i < size; i++) { if (i == index) { Holder currentPrev = currentHolder.getPreviousHolder(); currentPrev.setNextHolder(holder); holder.setPreviousHolder(currentPrev); holder.setNextHolder(currentHolder); currentHolder.setPreviousHolder(holder); size++; break; } currentHolder = currentHolder.getNextHolder(); } } } else { throw new IndexOutOfBoundsException(); } } @Override public Product removeFirst() throws NoSuchElementException { if (size != 0) { if (size == 1) { Product product = first.getProduct(); first.setProduct(null); last.setProduct(null); size--; printProduct(product.getId(), product.getValue()); return product; } else { Product firstProduct = first.getProduct(); Holder newFirst = first.getNextHolder(); first = newFirst; newFirst.setPreviousHolder(null); size--; printProduct(firstProduct.getId(), firstProduct.getValue()); return firstProduct; } } else { throw new NoSuchElementException(); } } @Override public Product removeLast() throws NoSuchElementException { if (size != 0) { if (size == 1) { Product product = first.getProduct(); first.setProduct(null); last.setProduct(null); size--; printProduct(product.getId(), product.getValue()); return product; } else { Product lastProduct = last.getProduct(); Holder newLast = last.getPreviousHolder(); last = newLast; newLast.setNextHolder(null); size--; printProduct(lastProduct.getId(), lastProduct.getValue()); return lastProduct; } } else { throw new NoSuchElementException(); } } @Override public Product removeIndex(int index) throws IndexOutOfBoundsException { if ((index < size) && (index >= 0)) { Holder currentHolder = first; for (int i = 0; i < size; i++) { if (i == index) { if (i == 0) { removeFirst(); } else if (i == size - 1) { removeLast(); } else { Product currentProduct = currentHolder.getProduct(); Holder currentPrev = currentHolder.getPreviousHolder(); Holder currentNext = currentHolder.getNextHolder(); currentPrev.setNextHolder(currentNext); currentNext.setPreviousHolder(currentPrev); size--; printProduct(currentProduct.getId(), currentProduct.getValue()); } return currentHolder.getProduct(); } currentHolder = currentHolder.getNextHolder(); } } throw new IndexOutOfBoundsException(); } @Override public Product removeProduct(int value) throws NoSuchElementException { if (size != 0) { Holder currentHolder = first; for (int i = 0; i < size; i++) { Product currentProduct = currentHolder.getProduct(); if (currentProduct.getValue() == value) { if (i == 0) { removeFirst(); } else if (i == size - 1) { removeLast(); } else { Holder currentPrev = currentHolder.getPreviousHolder(); Holder currentNext = currentHolder.getNextHolder(); currentPrev.setNextHolder(currentNext); currentNext.setPreviousHolder(currentPrev); printProduct(currentProduct.getId(), currentProduct.getValue()); size--; } return currentHolder.getProduct(); } currentHolder = currentHolder.getNextHolder(); } } throw new NoSuchElementException(); } @Override public Product find(int id) throws NoSuchElementException { if (size != 0) { Holder currentHolder = first; for (int i = 0; i < size; i++) { Product currentProduct = currentHolder.getProduct(); if (currentProduct.getId() == id) { printProduct(currentProduct.getId(), currentProduct.getValue()); return currentHolder.getProduct(); } currentHolder = currentHolder.getNextHolder(); } } throw new NoSuchElementException(); } @Override public Product get(int index) throws IndexOutOfBoundsException { if ((index < size) && (index >= 0)) { Holder currentHolder = first; for (int i = 0; i < size; i++) { if (i == index) { printProduct(currentHolder.getProduct().getId(), currentHolder.getProduct().getValue()); return currentHolder.getProduct(); } currentHolder = currentHolder.getNextHolder(); } } throw new IndexOutOfBoundsException(); } @Override public Product update(int id, Integer value) throws NoSuchElementException { if (size != 0) { Holder currentHolder = first; for (int i = 0; i < size; i++) { Product currentProduct = currentHolder.getProduct(); if (currentProduct.getId() == id) { printProduct(id, currentProduct.getValue()); currentProduct.setValue(value); return currentHolder.getProduct(); } currentHolder = currentHolder.getNextHolder(); } } throw new NoSuchElementException(); } @Override public int filterDuplicates() { int count = 0; if (size != 0) { ArrayList<Integer> values = new ArrayList<>(); Holder currentHolder = first; for (int i = 0; i < size; i++) { Product currentProduct = currentHolder.getProduct(); if (!values.contains(currentProduct.getValue())) { values.add(currentProduct.getValue()); } else { if (i == (size - 1)) { Holder newLast = last.getPreviousHolder(); last = newLast; newLast.setNextHolder(null); } else { Holder currentPrev = currentHolder.getPreviousHolder(); Holder currentNext = currentHolder.getNextHolder(); currentPrev.setNextHolder(currentNext); currentNext.setPreviousHolder(currentPrev); } count++; size--; i--; } currentHolder = currentHolder.getNextHolder(); } } soutl(\"\") return count; } @Override public void reverse() { if (size > 1) { Holder currentHolder = first; for (int i = 0; i < size; i++) { if (i == 0) { Holder currentNext = currentHolder.getNextHolder(); currentHolder.setPreviousHolder(currentNext); currentHolder.setNextHolder(null); last = currentHolder; } else if (i == size - 1) { Holder currentPrevious = currentHolder.getPreviousHolder(); currentHolder.setNextHolder(currentPrevious); currentHolder.setPreviousHolder(null); first = currentHolder; } else { Holder currentPrevious = currentHolder.getPreviousHolder(); Holder currentNext = currentHolder.getNextHolder(); currentHolder.setPreviousHolder(currentNext); currentHolder.setNextHolder(currentPrevious); } currentHolder = currentHolder.getPreviousHolder(); } } print(); } public void print() { if (size != 0) { Holder currentHolder = first; sout(\"\") for (int i = 0; i < size; i++) { Product currentProduct = currentHolder.getProduct(); sout(\"\") if (currentHolder.getNextHolder() != null) { sout(\"\") } currentHolder = currentHolder.getNextHolder(); } soutl(\"\") } else { soutl(\"\") } } public void printProduct(int id, int value) { soutl(\"\") } }", "dependencies": [{"file_path": "LinkedList-Implementation-w-Java-main/src/Holder.java", "file_content": "public class Holder { private Holder nextHolder; private Holder previousHolder; private Product product; public Holder(Holder previousHolder, Product product, Holder nextHolder) { this.nextHolder = nextHolder; this.previousHolder = previousHolder; this.product = product; } public Holder getNextHolder() { return nextHolder; } public void setNextHolder(Holder nextHolder) { this.nextHolder = nextHolder; } public Holder getPreviousHolder() { return previousHolder; } public void setPreviousHolder(Holder previousHolder) { this.previousHolder = previousHolder; } public Product getProduct() { return product; } public void setProduct(Product product) { this.product = product; } public String toString() { return (product == null) ? \"Holder empty.\" : product.toString() ; } @SuppressWarnings(\"EqualsReplaceableByObjectsCall\") @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Holder holder = (Holder) o; if (nextHolder != null ? !nextHolder.equals(holder.nextHolder) : holder.nextHolder != null) return false; if (previousHolder != null ? !previousHolder.equals(holder.previousHolder) : holder.previousHolder != null) return false; return product != null ? product.equals(holder.product) : holder.product == null; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "LinkedList-Implementation-w-Java-main/src/FactoryImpl.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "FactoryImpl manages linked list operations and handles printing logic. These are two distinct responsibilities, violating SRP."}, {"principle": "Open-Closed", "justification": "Adding new list operations (e.g., custom traversal) requires modifying FactoryImpl instead of extending via abstractions, violating OCP."}, {"principle": "Dependency Inversion", "justification": "FactoryImpl directly depends on concrete Holder and Product classes instead of abstractions, violating DIP for high-level modules."}]}]}
{"project_id": 92, "chunk_id": 0, "prompt": {"main_file_path": "LinkedList-Implementation-w-Java-main/src/Holder.java", "main_file_content": "public class Holder { private Holder nextHolder; private Holder previousHolder; private Product product; public Holder(Holder previousHolder, Product product, Holder nextHolder) { this.nextHolder = nextHolder; this.previousHolder = previousHolder; this.product = product; } public Holder getNextHolder() { return nextHolder; } public void setNextHolder(Holder nextHolder) { this.nextHolder = nextHolder; } public Holder getPreviousHolder() { return previousHolder; } public void setPreviousHolder(Holder previousHolder) { this.previousHolder = previousHolder; } public Product getProduct() { return product; } public void setProduct(Product product) { this.product = product; } public String toString() { return (product == null) ? \"Holder empty.\" : product.toString() ; } @SuppressWarnings(\"EqualsReplaceableByObjectsCall\") @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Holder holder = (Holder) o; if (nextHolder != null ? !nextHolder.equals(holder.nextHolder) : holder.nextHolder != null) return false; if (previousHolder != null ? !previousHolder.equals(holder.previousHolder) : holder.previousHolder != null) return false; return product != null ? product.equals(holder.product) : holder.product == null; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "LinkedList-Implementation-w-Java-main/src/Holder.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "Holder directly depends on the concrete Product class. High-level modules should depend on abstractions, not concrete implementations."}]}]}
{"project_id": 92, "chunk_id": 0, "prompt": {"main_file_path": "LinkedList-Implementation-w-Java-main/src/Product.java", "main_file_content": "public class Product { private final int id; private Integer value; public Product(int id, Integer value) { this.id = id; this.value = value; } public int getId() { return id; } public Integer getValue() { return value; } public void setValue(Integer value) { this.value = value; } public String toString() { return \"(\" + id + \", \" + value + \")\"; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Product product = (Product) o; return id == product.id; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "LinkedList-Implementation-w-Java-main/src/Product.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Product class manages both product data (id, value) and equality logic. Changes to data structure or equality rules would require modifying the same class, indicating multiple responsibilities."}]}]}
{"project_id": 92, "chunk_id": 0, "prompt": {"main_file_path": "LinkedList-Implementation-w-Java-main/src/Project1.java", "main_file_content": "import java.io.*; import java.util.NoSuchElementException; import java.util.Objects; public class Project1 { public static void main(String[] args) throws IOException { FactoryImpl factory = new FactoryImpl(); BufferedReader br = new BufferedReader( new FileReader(args[0])); PrintStream o = new PrintStream(args[1]); System.setOut(o); String line = br.readLine(); while (line != null) { String[] commands = line.split(\" \"); if (Objects.equals(commands[0], \"AF\")) { Product inputProduct = new Product(Integer.parseInt(commands[1]), Integer.parseInt(commands[2])); factory.addFirst(inputProduct); } if (Objects.equals(commands[0], \"AL\")) { Product inputProduct = new Product(Integer.parseInt(commands[1]), Integer.parseInt(commands[2])); factory.addLast(inputProduct); } if (Objects.equals(commands[0], \"A\")) { Product inputProduct = new Product(Integer.parseInt(commands[2]), Integer.valueOf(commands[3])); try{ factory.add(Integer.parseInt(commands[1]), inputProduct); } catch (IndexOutOfBoundsException e){ soutl(\"\") } } if (Objects.equals(commands[0], \"RF\")) { try { factory.removeFirst(); } catch (NoSuchElementException e) { soutl(\"\") } } if (Objects.equals(commands[0], \"RL\")) { try { factory.removeLast(); } catch (NoSuchElementException e) { soutl(\"\") } } if (Objects.equals(commands[0], \"RI\")) { try { factory.removeIndex(Integer.parseInt(commands[1])); } catch (IndexOutOfBoundsException e) { soutl(\"\") } } if (Objects.equals(commands[0], \"RP\")){ try{ factory.removeProduct(Integer.parseInt(commands[1])); } catch (NoSuchElementException e){ soutl(\"\") } } if (Objects.equals(commands[0], \"F\")){ try{ factory.find(Integer.parseInt(commands[1])); } catch (NoSuchElementException e){ soutl(\"\") } } if (Objects.equals(commands[0], \"G\")){ try{ factory.get(Integer.parseInt(commands[1])); } catch (IndexOutOfBoundsException e){ soutl(\"\") } } if (Objects.equals(commands[0], \"U\")){ try{ factory.update(Integer.parseInt(commands[1]),Integer.parseInt(commands[2])); } catch (NoSuchElementException e){ soutl(\"\") } } if (Objects.equals(commands[0], \"FD\")){ factory.filterDuplicates(); } if (Objects.equals(commands[0], \"R\")){ factory.reverse(); } if (Objects.equals(commands[0], \"P\")){ factory.print(); } line = br.readLine(); } br.close(); } }", "dependencies": [{"file_path": "LinkedList-Implementation-w-Java-main/src/FactoryImpl.java", "file_content": "import java.util.ArrayList; import java.util.NoSuchElementException; public class FactoryImpl implements Factory { private Holder first; private Holder last; private Integer size = 0; @Override public void addFirst(Product product) { Holder holder = new Holder(null, product, null); if (size == 0) { first = holder; last = first; } else { holder.setNextHolder(first); first.setPreviousHolder(holder); first = holder; } size++; } @Override public void addLast(Product product) { Holder holder = new Holder(null, product, null); if (size == 0) { last = holder; first = last; } else { last.setNextHolder(holder); holder.setPreviousHolder(last); last = holder; } size++; } @Override public void add(int index, Product product) throws IndexOutOfBoundsException { if ((index <= size) && (index >= 0)) { if (index == 0) { addFirst(product); } else if (index == size) { addLast(product); } else { Holder holder = new Holder(null, product, null); Holder currentHolder = first.getNextHolder(); for (int i = 1; i < size; i++) { if (i == index) { Holder currentPrev = currentHolder.getPreviousHolder(); currentPrev.setNextHolder(holder); holder.setPreviousHolder(currentPrev); holder.setNextHolder(currentHolder); currentHolder.setPreviousHolder(holder); size++; break; } currentHolder = currentHolder.getNextHolder(); } } } else { throw new IndexOutOfBoundsException(); } } @Override public Product removeFirst() throws NoSuchElementException { if (size != 0) { if (size == 1) { Product product = first.getProduct(); first.setProduct(null); last.setProduct(null); size--; printProduct(product.getId(), product.getValue()); return product; } else { Product firstProduct = first.getProduct(); Holder newFirst = first.getNextHolder(); first = newFirst; newFirst.setPreviousHolder(null); size--; printProduct(firstProduct.getId(), firstProduct.getValue()); return firstProduct; } } else { throw new NoSuchElementException(); } } @Override public Product removeLast() throws NoSuchElementException { if (size != 0) { if (size == 1) { Product product = first.getProduct(); first.setProduct(null); last.setProduct(null); size--; printProduct(product.getId(), product.getValue()); return product; } else { Product lastProduct = last.getProduct(); Holder newLast = last.getPreviousHolder(); last = newLast; newLast.setNextHolder(null); size--; printProduct(lastProduct.getId(), lastProduct.getValue()); return lastProduct; } } else { throw new NoSuchElementException(); } } @Override public Product removeIndex(int index) throws IndexOutOfBoundsException { if ((index < size) && (index >= 0)) { Holder currentHolder = first; for (int i = 0; i < size; i++) { if (i == index) { if (i == 0) { removeFirst(); } else if (i == size - 1) { removeLast(); } else { Product currentProduct = currentHolder.getProduct(); Holder currentPrev = currentHolder.getPreviousHolder(); Holder currentNext = currentHolder.getNextHolder(); currentPrev.setNextHolder(currentNext); currentNext.setPreviousHolder(currentPrev); size--; printProduct(currentProduct.getId(), currentProduct.getValue()); } return currentHolder.getProduct(); } currentHolder = currentHolder.getNextHolder(); } } throw new IndexOutOfBoundsException(); } @Override public Product removeProduct(int value) throws NoSuchElementException { if (size != 0) { Holder currentHolder = first; for (int i = 0; i < size; i++) { Product currentProduct = currentHolder.getProduct(); if (currentProduct.getValue() == value) { if (i == 0) { removeFirst(); } else if (i == size - 1) { removeLast(); } else { Holder currentPrev = currentHolder.getPreviousHolder(); Holder currentNext = currentHolder.getNextHolder(); currentPrev.setNextHolder(currentNext); currentNext.setPreviousHolder(currentPrev); printProduct(currentProduct.getId(), currentProduct.getValue()); size--; } return currentHolder.getProduct(); } currentHolder = currentHolder.getNextHolder(); } } throw new NoSuchElementException(); } @Override public Product find(int id) throws NoSuchElementException { if (size != 0) { Holder currentHolder = first; for (int i = 0; i < size; i++) { Product currentProduct = currentHolder.getProduct(); if (currentProduct.getId() == id) { printProduct(currentProduct.getId(), currentProduct.getValue()); return currentHolder.getProduct(); } currentHolder = currentHolder.getNextHolder(); } } throw new NoSuchElementException(); } @Override public Product get(int index) throws IndexOutOfBoundsException { if ((index < size) && (index >= 0)) { Holder currentHolder = first; for (int i = 0; i < size; i++) { if (i == index) { printProduct(currentHolder.getProduct().getId(), currentHolder.getProduct().getValue()); return currentHolder.getProduct(); } currentHolder = currentHolder.getNextHolder(); } } throw new IndexOutOfBoundsException(); } @Override public Product update(int id, Integer value) throws NoSuchElementException { if (size != 0) { Holder currentHolder = first; for (int i = 0; i < size; i++) { Product currentProduct = currentHolder.getProduct(); if (currentProduct.getId() == id) { printProduct(id, currentProduct.getValue()); currentProduct.setValue(value); return currentHolder.getProduct(); } currentHolder = currentHolder.getNextHolder(); } } throw new NoSuchElementException(); } @Override public int filterDuplicates() { int count = 0; if (size != 0) { ArrayList<Integer> values = new ArrayList<>(); Holder currentHolder = first; for (int i = 0; i < size; i++) { Product currentProduct = currentHolder.getProduct(); if (!values.contains(currentProduct.getValue())) { values.add(currentProduct.getValue()); } else { if (i == (size - 1)) { Holder newLast = last.getPreviousHolder(); last = newLast; newLast.setNextHolder(null); } else { Holder currentPrev = currentHolder.getPreviousHolder(); Holder currentNext = currentHolder.getNextHolder(); currentPrev.setNextHolder(currentNext); currentNext.setPreviousHolder(currentPrev); } count++; size--; i--; } currentHolder = currentHolder.getNextHolder(); } } soutl(\"\") return count; } @Override public void reverse() { if (size > 1) { Holder currentHolder = first; for (int i = 0; i < size; i++) { if (i == 0) { Holder currentNext = currentHolder.getNextHolder(); currentHolder.setPreviousHolder(currentNext); currentHolder.setNextHolder(null); last = currentHolder; } else if (i == size - 1) { Holder currentPrevious = currentHolder.getPreviousHolder(); currentHolder.setNextHolder(currentPrevious); currentHolder.setPreviousHolder(null); first = currentHolder; } else { Holder currentPrevious = currentHolder.getPreviousHolder(); Holder currentNext = currentHolder.getNextHolder(); currentHolder.setPreviousHolder(currentNext); currentHolder.setNextHolder(currentPrevious); } currentHolder = currentHolder.getPreviousHolder(); } } print(); } public void print() { if (size != 0) { Holder currentHolder = first; sout(\"\") for (int i = 0; i < size; i++) { Product currentProduct = currentHolder.getProduct(); sout(\"\") if (currentHolder.getNextHolder() != null) { sout(\"\") } currentHolder = currentHolder.getNextHolder(); } soutl(\"\") } else { soutl(\"\") } } public void printProduct(int id, int value) { soutl(\"\") } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "LinkedList-Implementation-w-Java-main/src/FactoryImpl.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "FactoryImpl manages linked list operations and handles printing logic. These are two distinct responsibilities, violating SRP."}, {"principle": "Open-Closed", "justification": "Adding new operations (e.g., alternative printing/output mechanisms) requires modifying FactoryImpl directly instead of extending it."}]}, {"file_path": "LinkedList-Implementation-w-Java-main/src/Project1.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "Project1 directly instantiates FactoryImpl (a concrete class) instead of depending on an abstraction (e.g., the Factory interface)."}]}]}
{"project_id": 92, "chunk_id": 0, "prompt": {"main_file_path": "LinkedList-Implementation-w-Java-main/src/Factory.java", "main_file_content": "import java.util.NoSuchElementException; public interface Factory { void addFirst(Product product); void addLast(Product product); Product removeFirst() throws NoSuchElementException; Product removeLast() throws NoSuchElementException; Product find(int id) throws NoSuchElementException; Product update(int id, Integer value) throws NoSuchElementException; Product get(int index) throws IndexOutOfBoundsException; void add(int index, Product product) throws IndexOutOfBoundsException; Product removeIndex(int index) throws IndexOutOfBoundsException; Product removeProduct(int value) throws NoSuchElementException; int filterDuplicates(); void reverse(); }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "LinkedList-Implementation-w-Java-main/src/Factory.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Factory interface declares multiple responsibilities (e.g., adding/removing products, filtering duplicates, reversing), forcing implementing classes to handle more than one reason to change."}, {"principle": "Interface Segregation", "justification": "The Factory interface is large and forces clients to depend on all methods (e.g., filterDuplicates, reverse) even if they only need a subset, violating ISP."}]}]}
{"project_id": 93, "chunk_id": 0, "prompt": {"main_file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/principal/Principal.java", "main_file_content": "package ar.edu.unju.escmi.poo.principal; import java.time.LocalDate; import java.time.format.DateTimeFormatter; import java.time.format.DateTimeParseException; import java.util.InputMismatchException; import java.util.Scanner; import javax.persistence.NoResultException; import ar.edu.unju.escmi.poo.dao.IDetalleDao; import ar.edu.unju.escmi.poo.dao.IFacturaDao; import ar.edu.unju.escmi.poo.dao.IProductoDao; import ar.edu.unju.escmi.poo.dao.IRolDao; import ar.edu.unju.escmi.poo.dao.IStockDao; import ar.edu.unju.escmi.poo.dao.IUsuarioDao; import ar.edu.unju.escmi.poo.dao.imp.DetalleDaoImp; import ar.edu.unju.escmi.poo.dao.imp.FacturaDaoImp; import ar.edu.unju.escmi.poo.dao.imp.ProductoDaoImp; import ar.edu.unju.escmi.poo.dao.imp.RolDaoImp; import ar.edu.unju.escmi.poo.dao.imp.StockDaoImp; import ar.edu.unju.escmi.poo.dao.imp.UsuarioDaoImp; import ar.edu.unju.escmi.poo.dominio.Detalle; import ar.edu.unju.escmi.poo.dominio.Factura; import ar.edu.unju.escmi.poo.dominio.Producto; import ar.edu.unju.escmi.poo.dominio.Rol; import ar.edu.unju.escmi.poo.dominio.Stock; import ar.edu.unju.escmi.poo.dominio.Usuario; public class Principal { public static void main(String[] args) { IUsuarioDao usuarioDao = new UsuarioDaoImp(); IRolDao rolDao = new RolDaoImp(); IProductoDao productoDao = new ProductoDaoImp(); IStockDao stockDao = new StockDaoImp(); IFacturaDao facturaDao = new FacturaDaoImp(); IDetalleDao detalleDao = new DetalleDaoImp(); Usuario usuario = new Usuario(); Scanner scanner = new Scanner(System.in); String email,contrasena,seguir; int opcion=0; boolean error,repetido; do { soutl(\"\") soutl(\"\") email = scanner.next(); soutl(\"\") contrasena = scanner.next(); try { usuario = usuarioDao.obtenerUsuarioPorCredenciales(email,contrasena); if(usuario.getRol().getDescripcion().equals(\"Vendedor\")) { do { error=false; try { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") opcion = scanner.nextInt(); switch (opcion) { case 1: Usuario nuevoUsuario = new Usuario(); do { error=false; try { soutl(\"\") nuevoUsuario.setDni(scanner.nextInt()); }catch(InputMismatchException ime) { soutl(\"\") error=true; scanner.next(); } }while(error==true); soutl(\"\") nuevoUsuario.setNombre(scanner.next()); soutl(\"\") nuevoUsuario.setApellido(scanner.next()); soutl(\"\") nuevoUsuario.setDomicilio(scanner.next()); do { error=false; try { soutl(\"\") String fechaNac = scanner.next(); DateTimeFormatter formato = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\"); nuevoUsuario.setFechaNacimiento(LocalDate.parse(fechaNac, formato)); }catch(DateTimeParseException dtpe) { soutl(\"\") error=true; } }while(error==true); do { repetido=false; soutl(\"\") nuevoUsuario.setEmail(scanner.next()); for(int i=0;i<usuarioDao.obtenerUsuarios().size();i++) { if(nuevoUsuario.getEmail().equals(usuarioDao.obtenerUsuarios().get(i).getEmail())) { repetido=true; } } if(repetido==true) { soutl(\"\") } }while(repetido==true); soutl(\"\") nuevoUsuario.setContrasena(scanner.next()); nuevoUsuario.setRol(rolDao.buscarRolPorId(2L)); usuarioDao.agregarUsuario(nuevoUsuario); break; case 2: Factura factura = new Factura(); factura.setNumeroFactura((int)(Math. random()*100+1)); factura.setFecha(LocalDate.now()); soutl(\"\") soutl(\"\") soutl(\"\") do { usuario = usuarioDao.obtenerUsuario(scanner.nextLong()); if(usuario==null) { soutl(\"\") } }while(usuario==null); factura.setUsuario(usuario); int cantidad; do { Detalle detalle = new Detalle(); detalle.setFactura(factura); soutl(\"\") productoDao.obtenerProductos().stream().forEach(System.out::println); soutl(\"\") Long idProducto = scanner.nextLong(); Producto prod = productoDao.obtenerProducto(idProducto); if(prod==null) { soutl(\"\") }else { do { soutl(\"\") cantidad=scanner.nextInt(); detalle.setCantidad(cantidad); }while(cantidad<0); Stock stock = stockDao.buscarStockPorIdProducto(idProducto); boolean band = stockDao.decrementarStock(stock, cantidad); if(!band) { soutl(\"\") soutl(\"\") }else { detalle.setProducto(prod); switch(prod.getDescuento()) { case 0: detalle.setImporte(detalle.calcularImporte()); break; case 25: detalle.setImporte(detalle.calcularImporte()*0.25); break; case 30: detalle.setImporte(detalle.calcularImporte()*0.3); break; } factura.agregarDetalle(detalle); soutl(\"\") factura.setTotal(factura.calcularTotal()); soutl(\"\") soutl(\"\") facturaDao.agregarFactura(factura); facturaDao.modificarFactura(factura); detalleDao.agregarDetalle(detalle); } } soutl(\"\") seguir = scanner.next(); }while(seguir.equals(\"SI\")||seguir.equals(\"si\")||seguir.equals(\"s\")); int pago=0; do { error=false; try { soutl(\"\") soutl(\"\") pago = scanner.nextInt(); if(pago==factura.getTotal()) { soutl(\"\") soutl(\"\") soutl(\"\") }else { soutl(\"\") } }catch(InputMismatchException ime) { soutl(\"\") error=true; scanner.next(); } }while(pago<factura.getTotal()||pago>factura.getTotal()||error==true); break; case 3: if(usuarioDao.obtenerUsuariosClientes()==null) { soutl(\"\") }else { soutl(\"\") } break; case 4: try { soutl(\"\") }catch(Exception e) { soutl(\"\") } break; case 5: try{ soutl(\"\") soutl(\"\") }catch(Exception e){ soutl(\"\") } break; case 6: soutl(\"\") break; default: soutl(\"\") break; } }catch(InputMismatchException ime) { soutl(\"\") error=true; scanner.next(); } }while(opcion!=6 || error==true); }else if(usuario.getRol().getDescripcion().equals(\"Cliente\")){ do { error=false; try { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") opcion = scanner.nextInt(); switch (opcion) { case 1: soutl(\"\") Factura factura = facturaDao.obtenerFacturaPorIdYNumeroFactura(usuario.getIdUsuario(), scanner.nextInt()); if(factura==null) { soutl(\"\") }else { soutl(\"\") } break; case 2: soutl(\"\") break; case 3: soutl(\"\") break; default: soutl(\"\") break; } }catch(InputMismatchException ime) { soutl(\"\") error=true; scanner.next(); } }while(opcion!=3 || error==true); } }catch(NoResultException nre) { soutl(\"\") } soutl(\"\") seguir = scanner.next(); } while (seguir.equals(\"SI\") || seguir.equals(\"si\") || seguir.equals(\"s\")); scanner.close(); } }", "dependencies": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/IDetalleDao.java", "file_content": "package ar.edu.unju.escmi.poo.dao; import ar.edu.unju.escmi.poo.dominio.Detalle; public interface IDetalleDao { public void agregarDetalle(Detalle nuevoDetalle); public void eliminarDetalle(Detalle detalle); }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/IFacturaDao.java", "file_content": "package ar.edu.unju.escmi.poo.dao; import java.util.List; import ar.edu.unju.escmi.poo.dominio.Factura; public interface IFacturaDao { public void agregarFactura(Factura nuevaFactura); public Factura buscarFacturaPorNumeroFactura(int nroFactura); public Factura obtenerFacturaPorIdYNumeroFactura(Long id, int nroFactura); public List<Factura> obtenerFacturas(); public List<Factura> obtenerFacturasPorId(Long id); public void eliminarFactura(Factura factura); public void modificarFactura(Factura factura); }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/IProductoDao.java", "file_content": "package ar.edu.unju.escmi.poo.dao; import java.util.List; import ar.edu.unju.escmi.poo.dominio.Producto; public interface IProductoDao { public void agregarProducto(Producto nuevoProducto); public void eliminarProducto(Producto producto); public List<Producto> obtenerProductos(); public Producto obtenerProducto(Long idProducto); }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/IRolDao.java", "file_content": "package ar.edu.unju.escmi.poo.dao; import java.util.List; import ar.edu.unju.escmi.poo.dominio.Rol; public interface IRolDao { public void agregarRol(Rol rol); public List<Rol> buscarRoles(); public Rol buscarRolPorId(Long id); }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/IStockDao.java", "file_content": "package ar.edu.unju.escmi.poo.dao; import ar.edu.unju.escmi.poo.dominio.Stock; public interface IStockDao { public void agregarStock(Stock Stock); public Stock buscarStockPorId(Long id); public Stock buscarStockPorIdProducto(Long idProducto); public boolean decrementarStock(Stock stock,int cantidad); }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/IUsuarioDao.java", "file_content": "package ar.edu.unju.escmi.poo.dao; import java.util.List; import ar.edu.unju.escmi.poo.dominio.Usuario; public interface IUsuarioDao { public void agregarUsuario(Usuario nuevoUsuario); public void eliminarUsuario(Usuario usuario); public List<Usuario> obtenerUsuarios(); public List<Usuario> obtenerUsuariosClientes(); public void modificarUsuario(Usuario usuario); public Usuario obtenerUsuario(Long idUsuario); public Usuario obtenerUsuarioPorCredenciales(String email,String contra); }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/imp/DetalleDaoImp.java", "file_content": "package ar.edu.unju.escmi.poo.dao.imp; import javax.persistence.EntityManager; import ar.edu.unju.escmi.poo.config.EmfSingleton; import ar.edu.unju.escmi.poo.dao.IDetalleDao; import ar.edu.unju.escmi.poo.dominio.Detalle; public class DetalleDaoImp implements IDetalleDao { private static EntityManager manager = EmfSingleton.getInstance().getEmf().createEntityManager(); @Override public void agregarDetalle(Detalle nuevoDetalle) { manager.getTransaction().begin(); manager.persist(nuevoDetalle); manager.getTransaction().commit(); } @Override public void eliminarDetalle(Detalle detalle) { manager.getTransaction().begin(); manager.remove(detalle); manager.getTransaction().commit(); } }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/imp/FacturaDaoImp.java", "file_content": "package ar.edu.unju.escmi.poo.dao.imp; import java.util.List; import javax.persistence.EntityManager; import javax.persistence.Query; import ar.edu.unju.escmi.poo.dao.IFacturaDao; import ar.edu.unju.escmi.poo.dominio.Factura; import ar.edu.unju.escmi.poo.config.EmfSingleton; public class FacturaDaoImp implements IFacturaDao{ private static EntityManager manager = EmfSingleton.getInstance().getEmf().createEntityManager(); @Override public void agregarFactura(Factura nuevaFactura) { try { manager.getTransaction().begin(); manager.persist(nuevaFactura); manager.getTransaction().commit(); }catch(Exception e) { soutl(\"\") } } @Override public Factura buscarFacturaPorNumeroFactura(int nroFactura) { Query query = manager.createQuery(\"SELECT f FROM Factura f\" + \" WHERE f.numeroFactura = :nroFactura\"); query.setParameter(\"nroFactura\", nroFactura); Factura factura = (Factura) query.getSingleResult(); return factura; } @Override public List<Factura> obtenerFacturas(){ @SuppressWarnings(\"unchecked\") List<Factura> facturas = (List<Factura>) manager.createQuery(\"SELECT f FROM Factura f\").getResultList(); return facturas; } @Override public List<Factura> obtenerFacturasPorId(Long id) { Query query = manager.createQuery(\"SELECT f FROM Factura f WHERE f.usuario.idUsuario = :id\"); query.setParameter(\"id\", id); @SuppressWarnings(\"unchecked\") List<Factura> facturas = (List<Factura>) query.getResultList(); return facturas; } @Override public Factura obtenerFacturaPorIdYNumeroFactura(Long id, int nroFactura) { Query query = manager.createQuery(\"SELECT f FROM Factura f WHERE f.usuario.idUsuario = :id AND f.numeroFactura = :nroFactura\"); query.setParameter(\"id\", id); query.setParameter(\"nroFactura\", nroFactura); Factura factura = (Factura) query.getSingleResult(); return factura; } @Override public void eliminarFactura(Factura factura) { manager.getTransaction().begin(); manager.remove(factura); manager.getTransaction().commit(); } @Override public void modificarFactura(Factura factura) { manager.getTransaction().begin(); manager.merge(factura); manager.getTransaction().commit(); } }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/imp/ProductoDaoImp.java", "file_content": "package ar.edu.unju.escmi.poo.dao.imp; import java.util.List; import javax.persistence.EntityManager; import ar.edu.unju.escmi.poo.config.EmfSingleton; import ar.edu.unju.escmi.poo.dao.IProductoDao; import ar.edu.unju.escmi.poo.dominio.Producto; import ar.edu.unju.escmi.poo.dominio.Usuario; public class ProductoDaoImp implements IProductoDao{ private static EntityManager manager = EmfSingleton.getInstance().getEmf().createEntityManager(); @Override public void agregarProducto(Producto nuevoProducto) { try{ manager.getTransaction().begin(); manager.persist(nuevoProducto); manager.getTransaction().commit(); }catch(Exception e) { soutl(\"\") } } @Override public void eliminarProducto(Producto producto) { manager.getTransaction().begin(); manager.remove(producto); } @Override public List<Producto> obtenerProductos() { @SuppressWarnings(\"unchecked\") List<Producto> productos = (List<Producto>) manager.createQuery(\"SELECT p FROM Producto p\").getResultList(); return productos; } @Override public Producto obtenerProducto(Long idProducto) { return manager.find(Producto.class, idProducto); } }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/imp/RolDaoImp.java", "file_content": "package ar.edu.unju.escmi.poo.dao.imp; import java.util.List; import javax.persistence.EntityManager; import ar.edu.unju.escmi.poo.config.EmfSingleton; import ar.edu.unju.escmi.poo.dao.IRolDao; import ar.edu.unju.escmi.poo.dominio.Rol; public class RolDaoImp implements IRolDao { private static EntityManager manager = EmfSingleton.getInstance().getEmf().createEntityManager(); @Override public List<Rol> buscarRoles() { return null; } @Override public Rol buscarRolPorId(Long id) { return manager.find(Rol.class,id); } @Override public void agregarRol(Rol rol) { try { manager.getTransaction().begin(); manager.persist(rol); manager.getTransaction().commit(); }catch(Exception e){ soutl(\"\") } } }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/imp/StockDaoImp.java", "file_content": "package ar.edu.unju.escmi.poo.dao.imp; import javax.persistence.EntityManager; import javax.persistence.Query; import ar.edu.unju.escmi.poo.config.EmfSingleton; import ar.edu.unju.escmi.poo.dao.IStockDao; import ar.edu.unju.escmi.poo.dominio.Stock; public class StockDaoImp implements IStockDao { private static EntityManager manager = EmfSingleton.getInstance().getEmf().createEntityManager(); @Override public void agregarStock(Stock Stock) { try { manager.getTransaction().begin(); manager.persist(Stock); manager.getTransaction().commit(); }catch(Exception e) { soutl(\"\") } } @Override public Stock buscarStockPorId(Long id) { return null; } @Override public Stock buscarStockPorIdProducto(Long idProducto) { Query query = manager.createQuery(\"SELECT s FROM Stock s WHERE s.producto.idProducto = :idProducto\"); query.setParameter(\"idProducto\", idProducto); Stock stock = (Stock)query.getSingleResult(); return stock; } @Override public boolean decrementarStock(Stock stock, int cantidad) { if(stock.getCantidad()-cantidad >= 0) { stock.setCantidad(stock.getCantidad()-cantidad); manager.getTransaction().begin(); manager.merge(stock); manager.getTransaction().commit(); return true; }else { return false; } } }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/imp/UsuarioDaoImp.java", "file_content": "package ar.edu.unju.escmi.poo.dao.imp; import java.util.List; import javax.persistence.EntityManager; import javax.persistence.Query; import ar.edu.unju.escmi.poo.config.EmfSingleton; import ar.edu.unju.escmi.poo.dao.IUsuarioDao; import ar.edu.unju.escmi.poo.dominio.Usuario; public class UsuarioDaoImp implements IUsuarioDao { private static EntityManager manager = EmfSingleton.getInstance().getEmf().createEntityManager(); @Override public void agregarUsuario(Usuario nuevoUsuario) { try { manager.getTransaction().begin(); manager.persist(nuevoUsuario); manager.getTransaction().commit(); }catch(Exception e) { soutl(\"\") } } @Override public void eliminarUsuario(Usuario usuario) { manager.getTransaction().begin(); manager.remove(usuario); manager.getTransaction().commit(); } @Override public List<Usuario> obtenerUsuarios() { @SuppressWarnings(\"unchecked\") List<Usuario> usuarios = (List<Usuario>) manager.createQuery(\"SELECT u FROM Usuario u\").getResultList(); return usuarios; } @Override public void modificarUsuario(Usuario usuario) { manager.getTransaction().begin(); manager.merge(usuario); manager.getTransaction().commit(); } @Override public Usuario obtenerUsuario(Long idUsuario) { return manager.find(Usuario.class, idUsuario); } @Override public Usuario obtenerUsuarioPorCredenciales(String email,String contra) { Query query = manager.createQuery(\"SELECT u FROM Usuario u WHERE u.email = :email AND u.contrasena = :contra\"); query.setParameter(\"email\", email); query.setParameter(\"contra\", contra); Usuario usuario = (Usuario) query.getSingleResult(); return usuario; } @Override public List<Usuario> obtenerUsuariosClientes() { @SuppressWarnings(\"unchecked\") List<Usuario> clientes = (List<Usuario>) manager.createQuery(\"SELECT u FROM Usuario u\" + \" WHERE u.rol.descripcion = 'Cliente'\").getResultList(); return clientes; } }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dominio/Detalle.java", "file_content": "package ar.edu.unju.escmi.poo.dominio; import java.io.Serializable; import javax.persistence.CascadeType; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.FetchType; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.JoinColumn; import javax.persistence.ManyToOne; import javax.persistence.OneToOne; import javax.persistence.Table; @Entity @Table(name=\"detalles\") public class Detalle implements Serializable{ private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long idDetalle; @Column(name=\"cantidad\") private int cantidad; @OneToOne(fetch = FetchType.LAZY) @JoinColumn(name=\"id_producto\") private Producto producto; @Column(name=\"importe\") private double importe; @ManyToOne @JoinColumn(name=\"factura_id\") private Factura factura; public Detalle() { } public Detalle(int cantidad, Producto producto,double importe) { super(); this.cantidad = cantidad; this.producto = producto; this.importe = importe; } public static long getSerialversionuid() { return serialVersionUID; } public Long getIdDetalle() { return idDetalle; } public void setIdDetalle(Long idDetalle) { this.idDetalle = idDetalle; } public int getCantidad() { return cantidad; } public void setCantidad(int cantidad) { this.cantidad = cantidad; } public Producto getProducto() { return producto; } public void setProducto(Producto producto) { this.producto = producto; } public double getImporte() { return importe; } public void setImporte(double importe) { this.importe = importe; } public Factura getFactura() { return factura; } public void setFactura(Factura factura) { this.factura = factura; } public double calcularImporte() { this.importe = (this.cantidad*(this.producto.getPrecioUnitario())); return (this.importe); } @Override public String toString() { return \"Detalle [Descripcion= \" + producto.getDescripcion()+ producto.getDescuento()+ \" cantidad=\" + cantidad + \", Precio Unitario=\" + producto.getPrecioUnitario() + \", IMPORTE=\" + importe + \"]\"; } }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dominio/Factura.java", "file_content": "package ar.edu.unju.escmi.poo.dominio; import java.io.Serializable; import java.time.LocalDate; import java.util.ArrayList; import java.util.List; import javax.persistence.CascadeType; import javax.persistence.Column; import javax.persistence.ElementCollection; import javax.persistence.Entity; import javax.persistence.FetchType; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.JoinColumn; import javax.persistence.ManyToOne; import javax.persistence.OneToMany; import javax.persistence.OneToOne; import javax.persistence.Table; @Entity @Table(name=\"facturas\") public class Factura implements Serializable{ private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy=GenerationType.AUTO) private Long idFactura; @Column(name = \"numero_factura\",unique=true) private int numeroFactura; @Column(name=\"fecha_generacion\") private LocalDate fecha; @Column(name=\"total\") private double total; @OneToMany(cascade = CascadeType.MERGE, mappedBy = \"factura\") private List<Detalle> detalles = new ArrayList<Detalle>(); @OneToOne(fetch = FetchType.LAZY) @JoinColumn(name=\"id_usuario\") private Usuario usuario; public Factura() { } public Factura(int numeroFactura, LocalDate fecha, double total, List<Detalle> detalles, Usuario usuario) { super(); this.numeroFactura = numeroFactura; this.fecha = fecha; this.total = total; this.detalles = detalles; this.usuario = usuario; } public Long getIdFactura() { return idFactura; } public void setIdFactura(Long idFactura) { this.idFactura = idFactura; } public static long getSerialversionuid() { return serialVersionUID; } public int getNumeroFactura() { return numeroFactura; } public void setNumeroFactura(int numeroFactura) { this.numeroFactura = numeroFactura; } public LocalDate getFecha() { return fecha; } public void setFecha(LocalDate fecha) { this.fecha = fecha; } public List<Detalle> getDetalles() { return detalles; } public void setDetalles(List<Detalle> detalles) { this.detalles = detalles; } public Usuario getUsuario() { return usuario; } public void setUsuario(Usuario usuario) { this.usuario = usuario; } public double getTotal() { return total; } public void setTotal(double total) { this.total = total; } public double calcularTotal() { double sumaImportes=0; for(int i=0;i<this.detalles.size();i++) { sumaImportes+=this.detalles.get(i).getImporte(); } this.total = sumaImportes; return this.total; } public void agregarDetalle(Detalle nuevoDetalle) { detalles.add(nuevoDetalle); } @Override public String toString() { return \"Factura [N\u00b0 FACTURA =\" + numeroFactura + \", FECHA =\" + fecha + \", Usuario=\" + usuario + \", detalles=\" + detalles + \", TOTAL A PAGAR= \" + total + \"]\"; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/principal/Principal.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Principal class handles user authentication, menu navigation, user creation, invoice processing, and UI interactions. This combines multiple responsibilities (UI, business logic, data handling) into a single class."}, {"principle": "Open-Closed", "justification": "The switch statement for discount calculations (25% and 30%) directly modifies behavior based on concrete values. Adding new discount types requires modifying this existing code instead of extending it."}, {"principle": "Dependency Inversion", "justification": "High-level Principal class directly instantiates low-level DAO implementations (e.g., new UsuarioDaoImp()). It should depend on abstractions (interfaces) and receive implementations via dependency injection."}]}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dominio/Factura.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Factura class manages invoice details, calculates totals, and handles business logic for adding details. This combines data storage, calculation, and collection management responsibilities."}]}]}
{"project_id": 93, "chunk_id": 1, "prompt": {"main_file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/principal/Principal.java", "main_file_content": "package ar.edu.unju.escmi.poo.principal; import java.time.LocalDate; import java.time.format.DateTimeFormatter; import java.time.format.DateTimeParseException; import java.util.InputMismatchException; import java.util.Scanner; import javax.persistence.NoResultException; import ar.edu.unju.escmi.poo.dao.IDetalleDao; import ar.edu.unju.escmi.poo.dao.IFacturaDao; import ar.edu.unju.escmi.poo.dao.IProductoDao; import ar.edu.unju.escmi.poo.dao.IRolDao; import ar.edu.unju.escmi.poo.dao.IStockDao; import ar.edu.unju.escmi.poo.dao.IUsuarioDao; import ar.edu.unju.escmi.poo.dao.imp.DetalleDaoImp; import ar.edu.unju.escmi.poo.dao.imp.FacturaDaoImp; import ar.edu.unju.escmi.poo.dao.imp.ProductoDaoImp; import ar.edu.unju.escmi.poo.dao.imp.RolDaoImp; import ar.edu.unju.escmi.poo.dao.imp.StockDaoImp; import ar.edu.unju.escmi.poo.dao.imp.UsuarioDaoImp; import ar.edu.unju.escmi.poo.dominio.Detalle; import ar.edu.unju.escmi.poo.dominio.Factura; import ar.edu.unju.escmi.poo.dominio.Producto; import ar.edu.unju.escmi.poo.dominio.Rol; import ar.edu.unju.escmi.poo.dominio.Stock; import ar.edu.unju.escmi.poo.dominio.Usuario; public class Principal { public static void main(String[] args) { IUsuarioDao usuarioDao = new UsuarioDaoImp(); IRolDao rolDao = new RolDaoImp(); IProductoDao productoDao = new ProductoDaoImp(); IStockDao stockDao = new StockDaoImp(); IFacturaDao facturaDao = new FacturaDaoImp(); IDetalleDao detalleDao = new DetalleDaoImp(); Usuario usuario = new Usuario(); Scanner scanner = new Scanner(System.in); String email,contrasena,seguir; int opcion=0; boolean error,repetido; do { soutl(\"\") soutl(\"\") email = scanner.next(); soutl(\"\") contrasena = scanner.next(); try { usuario = usuarioDao.obtenerUsuarioPorCredenciales(email,contrasena); if(usuario.getRol().getDescripcion().equals(\"Vendedor\")) { do { error=false; try { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") opcion = scanner.nextInt(); switch (opcion) { case 1: Usuario nuevoUsuario = new Usuario(); do { error=false; try { soutl(\"\") nuevoUsuario.setDni(scanner.nextInt()); }catch(InputMismatchException ime) { soutl(\"\") error=true; scanner.next(); } }while(error==true); soutl(\"\") nuevoUsuario.setNombre(scanner.next()); soutl(\"\") nuevoUsuario.setApellido(scanner.next()); soutl(\"\") nuevoUsuario.setDomicilio(scanner.next()); do { error=false; try { soutl(\"\") String fechaNac = scanner.next(); DateTimeFormatter formato = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\"); nuevoUsuario.setFechaNacimiento(LocalDate.parse(fechaNac, formato)); }catch(DateTimeParseException dtpe) { soutl(\"\") error=true; } }while(error==true); do { repetido=false; soutl(\"\") nuevoUsuario.setEmail(scanner.next()); for(int i=0;i<usuarioDao.obtenerUsuarios().size();i++) { if(nuevoUsuario.getEmail().equals(usuarioDao.obtenerUsuarios().get(i).getEmail())) { repetido=true; } } if(repetido==true) { soutl(\"\") } }while(repetido==true); soutl(\"\") nuevoUsuario.setContrasena(scanner.next()); nuevoUsuario.setRol(rolDao.buscarRolPorId(2L)); usuarioDao.agregarUsuario(nuevoUsuario); break; case 2: Factura factura = new Factura(); factura.setNumeroFactura((int)(Math. random()*100+1)); factura.setFecha(LocalDate.now()); soutl(\"\") soutl(\"\") soutl(\"\") do { usuario = usuarioDao.obtenerUsuario(scanner.nextLong()); if(usuario==null) { soutl(\"\") } }while(usuario==null); factura.setUsuario(usuario); int cantidad; do { Detalle detalle = new Detalle(); detalle.setFactura(factura); soutl(\"\") productoDao.obtenerProductos().stream().forEach(System.out::println); soutl(\"\") Long idProducto = scanner.nextLong(); Producto prod = productoDao.obtenerProducto(idProducto); if(prod==null) { soutl(\"\") }else { do { soutl(\"\") cantidad=scanner.nextInt(); detalle.setCantidad(cantidad); }while(cantidad<0); Stock stock = stockDao.buscarStockPorIdProducto(idProducto); boolean band = stockDao.decrementarStock(stock, cantidad); if(!band) { soutl(\"\") soutl(\"\") }else { detalle.setProducto(prod); switch(prod.getDescuento()) { case 0: detalle.setImporte(detalle.calcularImporte()); break; case 25: detalle.setImporte(detalle.calcularImporte()*0.25); break; case 30: detalle.setImporte(detalle.calcularImporte()*0.3); break; } factura.agregarDetalle(detalle); soutl(\"\") factura.setTotal(factura.calcularTotal()); soutl(\"\") soutl(\"\") facturaDao.agregarFactura(factura); facturaDao.modificarFactura(factura); detalleDao.agregarDetalle(detalle); } } soutl(\"\") seguir = scanner.next(); }while(seguir.equals(\"SI\")||seguir.equals(\"si\")||seguir.equals(\"s\")); int pago=0; do { error=false; try { soutl(\"\") soutl(\"\") pago = scanner.nextInt(); if(pago==factura.getTotal()) { soutl(\"\") soutl(\"\") soutl(\"\") }else { soutl(\"\") } }catch(InputMismatchException ime) { soutl(\"\") error=true; scanner.next(); } }while(pago<factura.getTotal()||pago>factura.getTotal()||error==true); break; case 3: if(usuarioDao.obtenerUsuariosClientes()==null) { soutl(\"\") }else { soutl(\"\") } break; case 4: try { soutl(\"\") }catch(Exception e) { soutl(\"\") } break; case 5: try{ soutl(\"\") soutl(\"\") }catch(Exception e){ soutl(\"\") } break; case 6: soutl(\"\") break; default: soutl(\"\") break; } }catch(InputMismatchException ime) { soutl(\"\") error=true; scanner.next(); } }while(opcion!=6 || error==true); }else if(usuario.getRol().getDescripcion().equals(\"Cliente\")){ do { error=false; try { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") opcion = scanner.nextInt(); switch (opcion) { case 1: soutl(\"\") Factura factura = facturaDao.obtenerFacturaPorIdYNumeroFactura(usuario.getIdUsuario(), scanner.nextInt()); if(factura==null) { soutl(\"\") }else { soutl(\"\") } break; case 2: soutl(\"\") break; case 3: soutl(\"\") break; default: soutl(\"\") break; } }catch(InputMismatchException ime) { soutl(\"\") error=true; scanner.next(); } }while(opcion!=3 || error==true); } }catch(NoResultException nre) { soutl(\"\") } soutl(\"\") seguir = scanner.next(); } while (seguir.equals(\"SI\") || seguir.equals(\"si\") || seguir.equals(\"s\")); scanner.close(); } }", "dependencies": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dominio/Producto.java", "file_content": "package ar.edu.unju.escmi.poo.dominio; import java.io.Serializable; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.Table; @Entity @Table(name=\"productos\") public class Producto implements Serializable{ private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long idProducto; @Column(name=\"descripcion\") private String descripcion; @Column(name=\"marca\") private String marca; @Column(name=\"origen\") private String origen; @Column(name=\"categoria\") private String categoria; @Column(name=\"descuento\") private int descuento; @Column(name=\"precio_unitario\") private double precioUnitario; public Producto() { } public Producto( String categoria, String descripcion, double precioUnitario, String origen, String marca,int descuento) { super(); this.categoria = categoria; this.descripcion = descripcion; this.precioUnitario = precioUnitario; this.origen = origen; this.marca = marca; this.descuento = descuento; } public Long getidProducto() { return idProducto; } public void setidProducto(Long idProducto) { this.idProducto = idProducto; } public String getDescripcion() { return descripcion; } public void setDescripcion(String descripcion) { this.descripcion = descripcion; } public String getMarca() { return marca; } public void setMarca(String marca) { this.marca = marca; } public String getOrigen() { return origen; } public void setOrigen(String origen) { this.origen = origen; } public String getCategoria() { return categoria; } public void setCategoria(String categoria) { this.categoria = categoria; } public int getDescuento() { return descuento; } public void setDescuento(int descuento) { this.descuento = descuento; } public double getPrecioUnitario() { return precioUnitario; } public void setPrecioUnitario(double precioUnitario) { this.precioUnitario = precioUnitario; } @Override public String toString() { return \"Producto [idProducto=\" + idProducto + \", descripcion=\" + descripcion + \", marca=\" + marca + \", origen=\" + origen + \", categoria=\" + categoria + \", descuento=\" + descuento + \", precioUnitario=\" + precioUnitario + \"]\"; } }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dominio/Rol.java", "file_content": "package ar.edu.unju.escmi.poo.dominio; import java.io.Serializable; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.Table; @Entity @Table(name=\"roles\") public class Rol implements Serializable { private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy=GenerationType.AUTO) @Column(name=\"id\") private Long idRol; @Column(name=\"descripcion\") private String descripcion; public Rol() { } public Rol(String descripcion) { super(); this.descripcion = descripcion; } public Long getIdRol() { return idRol; } public void setIdRol(Long idRol) { this.idRol = idRol; } public String getDescripcion() { return descripcion; } public void setDescripcion(String descripcion) { this.descripcion = descripcion; } public static long getSerialversionuid() { return serialVersionUID; } @Override public String toString() { return \"Rol [idRol=\" + idRol + \", descripcion=\" + descripcion + \"]\"; } }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dominio/Stock.java", "file_content": "package ar.edu.unju.escmi.poo.dominio; import java.io.Serializable; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.FetchType; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.JoinColumn; import javax.persistence.OneToOne; import javax.persistence.Table; @Entity @Table(name=\"stocks\") public class Stock implements Serializable{ private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy=GenerationType.AUTO) private Long idStock; @Column(name=\"cantidad\") private int cantidad; @OneToOne(fetch = FetchType.LAZY) @JoinColumn(name=\"id_producto\") private Producto producto; public Stock() { } public Stock(int cantidad, Producto producto) { super(); this.cantidad = cantidad; this.producto = producto; } public Long getIdStock() { return idStock; } public void setIdStock(Long idStock) { this.idStock = idStock; } public static long getSerialversionuid() { return serialVersionUID; } public int getCantidad() { return cantidad; } public void setCantidad(int cantidad) { this.cantidad = cantidad; } public Producto getProducto() { return producto; } public void setProducto(Producto producto) { this.producto = producto; } @Override public String toString() { return \"Stock [cantidad=\" + cantidad + \", producto=\" + producto + \"]\"; } }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dominio/Usuario.java", "file_content": "package ar.edu.unju.escmi.poo.dominio; import java.io.Serializable; import java.time.LocalDate; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.FetchType; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.JoinColumn; import javax.persistence.OneToOne; import javax.persistence.Table; @Entity @Table(name=\"usuarios\") public class Usuario implements Serializable{ private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long idUsuario; @Column(name = \"dni\",nullable=true,unique=true) private int dni; @Column(name = \"nombre\") private String nombre; @Column(name = \"apellido\") private String apellido; @Column(name = \"domicilio\") private String domicilio; @Column(name = \"fecha_nacimiento\") private LocalDate fechaNacimiento; @Column(name = \"email\",unique=true) private String email; @Column(name = \"contrasena\") private String contrasena; @OneToOne(fetch = FetchType.LAZY) @JoinColumn(name=\"id_rol\") private Rol rol; public Usuario() { } public Usuario(int dni, String nombre, String apellido, String domicilio, LocalDate fechaNacimiento, String email, String contrasena, Rol rol) { super(); this.dni = dni; this.nombre = nombre; this.apellido = apellido; this.domicilio = domicilio; this.fechaNacimiento = fechaNacimiento; this.email = email; this.contrasena = contrasena; this.rol = rol; } public Long getIdUsuario() { return idUsuario; } public void setIdUsuario(Long idUsuario) { this.idUsuario = idUsuario; } public static long getSerialversionuid() { return serialVersionUID; } public int getDni() { return dni; } public void setDni(int dni) { this.dni = dni; } public String getNombre() { return nombre; } public void setNombre(String nombre) { this.nombre = nombre; } public String getApellido() { return apellido; } public void setApellido(String apellido) { this.apellido = apellido; } public String getDomicilio() { return domicilio; } public void setDomicilio(String domicilio) { this.domicilio = domicilio; } public LocalDate getFechaNacimiento() { return fechaNacimiento; } public void setFechaNacimiento(LocalDate fechaNacimiento) { this.fechaNacimiento = fechaNacimiento; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getContrasena() { return contrasena; } public void setContrasena(String contrasena) { this.contrasena = contrasena; } public Rol getRol() { return rol; } public void setRol(Rol rol) { this.rol = rol; } @Override public String toString() { return \"Usuario [idUsuario=\" + idUsuario + \", dni=\" + dni + \", nombre=\" + nombre + \", apellido=\" + apellido + \", domicilio=\" + domicilio + \", fechaNacimiento=\" + fechaNacimiento + \", email=\" + email + \", contrasena=\" + contrasena + \", rol=\" + rol + \"]\"; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/principal/Principal.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Principal class handles user authentication, menu navigation, user input processing, business logic execution, and direct database interactions. This combines multiple responsibilities (UI, business logic, data access) into a single class."}, {"principle": "Open-Closed", "justification": "The switch-case structure for menu options requires modifying existing code to add new functionality. The class is not closed for modification when new features need to be added."}, {"principle": "Dependency Inversion", "justification": "While interfaces are used for DAOs, the high-level Principal class directly instantiates concrete DAO implementations (e.g., new UsuarioDaoImp()). This creates direct dependencies on low-level modules rather than relying solely on abstractions."}]}]}
{"project_id": 93, "chunk_id": 0, "prompt": {"main_file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/config/EmfSingleton.java", "main_file_content": "package ar.edu.unju.escmi.poo.config; import javax.persistence.EntityManagerFactory; import javax.persistence.Persistence; public class EmfSingleton { private static EmfSingleton miInstancia = new EmfSingleton(); static private final String PERSISTENCE_UNIT_NAME = \"TestPersistence\"; private EntityManagerFactory emf = null; public static EmfSingleton getInstance() { return miInstancia; } private EmfSingleton() { } public EntityManagerFactory getEmf() { if (this.emf == null) this.emf = Persistence.createEntityManagerFactory(PERSISTENCE_UNIT_NAME); return this.emf; } }", "dependencies": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/config/EmfSingleton.java", "file_content": "package ar.edu.unju.escmi.poo.config; import javax.persistence.EntityManagerFactory; import javax.persistence.Persistence; public class EmfSingleton { private static EmfSingleton miInstancia = new EmfSingleton(); static private final String PERSISTENCE_UNIT_NAME = \"TestPersistence\"; private EntityManagerFactory emf = null; public static EmfSingleton getInstance() { return miInstancia; } private EmfSingleton() { } public EntityManagerFactory getEmf() { if (this.emf == null) this.emf = Persistence.createEntityManagerFactory(PERSISTENCE_UNIT_NAME); return this.emf; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/config/EmfSingleton.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "EmfSingleton directly instantiates EntityManagerFactory via Persistence.createEntityManagerFactory(), violating DIP by depending on a concrete implementation instead of an abstraction. High-level modules should depend on abstractions rather than low-level details."}]}]}
{"project_id": 93, "chunk_id": 0, "prompt": {"main_file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/IDetalleDao.java", "main_file_content": "package ar.edu.unju.escmi.poo.dao; import ar.edu.unju.escmi.poo.dominio.Detalle; public interface IDetalleDao { public void agregarDetalle(Detalle nuevoDetalle); public void eliminarDetalle(Detalle detalle); }", "dependencies": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dominio/Detalle.java", "file_content": "package ar.edu.unju.escmi.poo.dominio; import java.io.Serializable; import javax.persistence.CascadeType; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.FetchType; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.JoinColumn; import javax.persistence.ManyToOne; import javax.persistence.OneToOne; import javax.persistence.Table; @Entity @Table(name=\"detalles\") public class Detalle implements Serializable{ private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long idDetalle; @Column(name=\"cantidad\") private int cantidad; @OneToOne(fetch = FetchType.LAZY) @JoinColumn(name=\"id_producto\") private Producto producto; @Column(name=\"importe\") private double importe; @ManyToOne @JoinColumn(name=\"factura_id\") private Factura factura; public Detalle() { } public Detalle(int cantidad, Producto producto,double importe) { super(); this.cantidad = cantidad; this.producto = producto; this.importe = importe; } public static long getSerialversionuid() { return serialVersionUID; } public Long getIdDetalle() { return idDetalle; } public void setIdDetalle(Long idDetalle) { this.idDetalle = idDetalle; } public int getCantidad() { return cantidad; } public void setCantidad(int cantidad) { this.cantidad = cantidad; } public Producto getProducto() { return producto; } public void setProducto(Producto producto) { this.producto = producto; } public double getImporte() { return importe; } public void setImporte(double importe) { this.importe = importe; } public Factura getFactura() { return factura; } public void setFactura(Factura factura) { this.factura = factura; } public double calcularImporte() { this.importe = (this.cantidad*(this.producto.getPrecioUnitario())); return (this.importe); } @Override public String toString() { return \"Detalle [Descripcion= \" + producto.getDescripcion()+ producto.getDescuento()+ \" cantidad=\" + cantidad + \", Precio Unitario=\" + producto.getPrecioUnitario() + \", IMPORTE=\" + importe + \"]\"; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dominio/Detalle.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "The Detalle class directly implements calcularImporte with fixed logic. Modifying the calculation requires changing the class, violating OCP as it's not closed for modification."}]}]}
{"project_id": 93, "chunk_id": 0, "prompt": {"main_file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/IStockDao.java", "main_file_content": "package ar.edu.unju.escmi.poo.dao; import ar.edu.unju.escmi.poo.dominio.Stock; public interface IStockDao { public void agregarStock(Stock Stock); public Stock buscarStockPorId(Long id); public Stock buscarStockPorIdProducto(Long idProducto); public boolean decrementarStock(Stock stock,int cantidad); }", "dependencies": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dominio/Stock.java", "file_content": "package ar.edu.unju.escmi.poo.dominio; import java.io.Serializable; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.FetchType; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.JoinColumn; import javax.persistence.OneToOne; import javax.persistence.Table; @Entity @Table(name=\"stocks\") public class Stock implements Serializable{ private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy=GenerationType.AUTO) private Long idStock; @Column(name=\"cantidad\") private int cantidad; @OneToOne(fetch = FetchType.LAZY) @JoinColumn(name=\"id_producto\") private Producto producto; public Stock() { } public Stock(int cantidad, Producto producto) { super(); this.cantidad = cantidad; this.producto = producto; } public Long getIdStock() { return idStock; } public void setIdStock(Long idStock) { this.idStock = idStock; } public static long getSerialversionuid() { return serialVersionUID; } public int getCantidad() { return cantidad; } public void setCantidad(int cantidad) { this.cantidad = cantidad; } public Producto getProducto() { return producto; } public void setProducto(Producto producto) { this.producto = producto; } @Override public String toString() { return \"Stock [cantidad=\" + cantidad + \", producto=\" + producto + \"]\"; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/IStockDao.java", "violatedPrinciples": [{"principle": "Interface Segregation", "justification": "The IStockDao interface combines stock management and product search methods. Clients depending on this interface must implement all methods even if they only need a subset of them."}]}]}
{"project_id": 93, "chunk_id": 0, "prompt": {"main_file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/IRolDao.java", "main_file_content": "package ar.edu.unju.escmi.poo.dao; import java.util.List; import ar.edu.unju.escmi.poo.dominio.Rol; public interface IRolDao { public void agregarRol(Rol rol); public List<Rol> buscarRoles(); public Rol buscarRolPorId(Long id); }", "dependencies": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dominio/Rol.java", "file_content": "package ar.edu.unju.escmi.poo.dominio; import java.io.Serializable; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.Table; @Entity @Table(name=\"roles\") public class Rol implements Serializable { private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy=GenerationType.AUTO) @Column(name=\"id\") private Long idRol; @Column(name=\"descripcion\") private String descripcion; public Rol() { } public Rol(String descripcion) { super(); this.descripcion = descripcion; } public Long getIdRol() { return idRol; } public void setIdRol(Long idRol) { this.idRol = idRol; } public String getDescripcion() { return descripcion; } public void setDescripcion(String descripcion) { this.descripcion = descripcion; } public static long getSerialversionuid() { return serialVersionUID; } @Override public String toString() { return \"Rol [idRol=\" + idRol + \", descripcion=\" + descripcion + \"]\"; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 93, "chunk_id": 0, "prompt": {"main_file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/IProductoDao.java", "main_file_content": "package ar.edu.unju.escmi.poo.dao; import java.util.List; import ar.edu.unju.escmi.poo.dominio.Producto; public interface IProductoDao { public void agregarProducto(Producto nuevoProducto); public void eliminarProducto(Producto producto); public List<Producto> obtenerProductos(); public Producto obtenerProducto(Long idProducto); }", "dependencies": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dominio/Producto.java", "file_content": "package ar.edu.unju.escmi.poo.dominio; import java.io.Serializable; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.Table; @Entity @Table(name=\"productos\") public class Producto implements Serializable{ private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long idProducto; @Column(name=\"descripcion\") private String descripcion; @Column(name=\"marca\") private String marca; @Column(name=\"origen\") private String origen; @Column(name=\"categoria\") private String categoria; @Column(name=\"descuento\") private int descuento; @Column(name=\"precio_unitario\") private double precioUnitario; public Producto() { } public Producto( String categoria, String descripcion, double precioUnitario, String origen, String marca,int descuento) { super(); this.categoria = categoria; this.descripcion = descripcion; this.precioUnitario = precioUnitario; this.origen = origen; this.marca = marca; this.descuento = descuento; } public Long getidProducto() { return idProducto; } public void setidProducto(Long idProducto) { this.idProducto = idProducto; } public String getDescripcion() { return descripcion; } public void setDescripcion(String descripcion) { this.descripcion = descripcion; } public String getMarca() { return marca; } public void setMarca(String marca) { this.marca = marca; } public String getOrigen() { return origen; } public void setOrigen(String origen) { this.origen = origen; } public String getCategoria() { return categoria; } public void setCategoria(String categoria) { this.categoria = categoria; } public int getDescuento() { return descuento; } public void setDescuento(int descuento) { this.descuento = descuento; } public double getPrecioUnitario() { return precioUnitario; } public void setPrecioUnitario(double precioUnitario) { this.precioUnitario = precioUnitario; } @Override public String toString() { return \"Producto [idProducto=\" + idProducto + \", descripcion=\" + descripcion + \", marca=\" + marca + \", origen=\" + origen + \", categoria=\" + categoria + \", descuento=\" + descuento + \", precioUnitario=\" + precioUnitario + \"]\"; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/IProductoDao.java", "violatedPrinciples": [{"principle": "Interface Segregation", "justification": "The IProductoDao interface forces clients to depend on all CRUD methods. Clients that only need to read products must still implement unused methods like agregarProducto and eliminarProducto."}]}]}
{"project_id": 93, "chunk_id": 0, "prompt": {"main_file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/IUsuarioDao.java", "main_file_content": "package ar.edu.unju.escmi.poo.dao; import java.util.List; import ar.edu.unju.escmi.poo.dominio.Usuario; public interface IUsuarioDao { public void agregarUsuario(Usuario nuevoUsuario); public void eliminarUsuario(Usuario usuario); public List<Usuario> obtenerUsuarios(); public List<Usuario> obtenerUsuariosClientes(); public void modificarUsuario(Usuario usuario); public Usuario obtenerUsuario(Long idUsuario); public Usuario obtenerUsuarioPorCredenciales(String email,String contra); }", "dependencies": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dominio/Usuario.java", "file_content": "package ar.edu.unju.escmi.poo.dominio; import java.io.Serializable; import java.time.LocalDate; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.FetchType; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.JoinColumn; import javax.persistence.OneToOne; import javax.persistence.Table; @Entity @Table(name=\"usuarios\") public class Usuario implements Serializable{ private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long idUsuario; @Column(name = \"dni\",nullable=true,unique=true) private int dni; @Column(name = \"nombre\") private String nombre; @Column(name = \"apellido\") private String apellido; @Column(name = \"domicilio\") private String domicilio; @Column(name = \"fecha_nacimiento\") private LocalDate fechaNacimiento; @Column(name = \"email\",unique=true) private String email; @Column(name = \"contrasena\") private String contrasena; @OneToOne(fetch = FetchType.LAZY) @JoinColumn(name=\"id_rol\") private Rol rol; public Usuario() { } public Usuario(int dni, String nombre, String apellido, String domicilio, LocalDate fechaNacimiento, String email, String contrasena, Rol rol) { super(); this.dni = dni; this.nombre = nombre; this.apellido = apellido; this.domicilio = domicilio; this.fechaNacimiento = fechaNacimiento; this.email = email; this.contrasena = contrasena; this.rol = rol; } public Long getIdUsuario() { return idUsuario; } public void setIdUsuario(Long idUsuario) { this.idUsuario = idUsuario; } public static long getSerialversionuid() { return serialVersionUID; } public int getDni() { return dni; } public void setDni(int dni) { this.dni = dni; } public String getNombre() { return nombre; } public void setNombre(String nombre) { this.nombre = nombre; } public String getApellido() { return apellido; } public void setApellido(String apellido) { this.apellido = apellido; } public String getDomicilio() { return domicilio; } public void setDomicilio(String domicilio) { this.domicilio = domicilio; } public LocalDate getFechaNacimiento() { return fechaNacimiento; } public void setFechaNacimiento(LocalDate fechaNacimiento) { this.fechaNacimiento = fechaNacimiento; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getContrasena() { return contrasena; } public void setContrasena(String contrasena) { this.contrasena = contrasena; } public Rol getRol() { return rol; } public void setRol(Rol rol) { this.rol = rol; } @Override public String toString() { return \"Usuario [idUsuario=\" + idUsuario + \", dni=\" + dni + \", nombre=\" + nombre + \", apellido=\" + apellido + \", domicilio=\" + domicilio + \", fechaNacimiento=\" + fechaNacimiento + \", email=\" + email + \", contrasena=\" + contrasena + \", rol=\" + rol + \"]\"; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/IUsuarioDao.java", "violatedPrinciples": [{"principle": "Interface Segregation", "justification": "The IUsuarioDao interface includes multiple methods (e.g., agregarUsuario, eliminarUsuario, modificarUsuario) that clients may not all need. Clients depending on this interface are forced to implement unused methods, violating ISP."}]}]}
{"project_id": 93, "chunk_id": 0, "prompt": {"main_file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/IFacturaDao.java", "main_file_content": "package ar.edu.unju.escmi.poo.dao; import java.util.List; import ar.edu.unju.escmi.poo.dominio.Factura; public interface IFacturaDao { public void agregarFactura(Factura nuevaFactura); public Factura buscarFacturaPorNumeroFactura(int nroFactura); public Factura obtenerFacturaPorIdYNumeroFactura(Long id, int nroFactura); public List<Factura> obtenerFacturas(); public List<Factura> obtenerFacturasPorId(Long id); public void eliminarFactura(Factura factura); public void modificarFactura(Factura factura); }", "dependencies": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dominio/Factura.java", "file_content": "package ar.edu.unju.escmi.poo.dominio; import java.io.Serializable; import java.time.LocalDate; import java.util.ArrayList; import java.util.List; import javax.persistence.CascadeType; import javax.persistence.Column; import javax.persistence.ElementCollection; import javax.persistence.Entity; import javax.persistence.FetchType; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.JoinColumn; import javax.persistence.ManyToOne; import javax.persistence.OneToMany; import javax.persistence.OneToOne; import javax.persistence.Table; @Entity @Table(name=\"facturas\") public class Factura implements Serializable{ private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy=GenerationType.AUTO) private Long idFactura; @Column(name = \"numero_factura\",unique=true) private int numeroFactura; @Column(name=\"fecha_generacion\") private LocalDate fecha; @Column(name=\"total\") private double total; @OneToMany(cascade = CascadeType.MERGE, mappedBy = \"factura\") private List<Detalle> detalles = new ArrayList<Detalle>(); @OneToOne(fetch = FetchType.LAZY) @JoinColumn(name=\"id_usuario\") private Usuario usuario; public Factura() { } public Factura(int numeroFactura, LocalDate fecha, double total, List<Detalle> detalles, Usuario usuario) { super(); this.numeroFactura = numeroFactura; this.fecha = fecha; this.total = total; this.detalles = detalles; this.usuario = usuario; } public Long getIdFactura() { return idFactura; } public void setIdFactura(Long idFactura) { this.idFactura = idFactura; } public static long getSerialversionuid() { return serialVersionUID; } public int getNumeroFactura() { return numeroFactura; } public void setNumeroFactura(int numeroFactura) { this.numeroFactura = numeroFactura; } public LocalDate getFecha() { return fecha; } public void setFecha(LocalDate fecha) { this.fecha = fecha; } public List<Detalle> getDetalles() { return detalles; } public void setDetalles(List<Detalle> detalles) { this.detalles = detalles; } public Usuario getUsuario() { return usuario; } public void setUsuario(Usuario usuario) { this.usuario = usuario; } public double getTotal() { return total; } public void setTotal(double total) { this.total = total; } public double calcularTotal() { double sumaImportes=0; for(int i=0;i<this.detalles.size();i++) { sumaImportes+=this.detalles.get(i).getImporte(); } this.total = sumaImportes; return this.total; } public void agregarDetalle(Detalle nuevoDetalle) { detalles.add(nuevoDetalle); } @Override public String toString() { return \"Factura [N\u00b0 FACTURA =\" + numeroFactura + \", FECHA =\" + fecha + \", Usuario=\" + usuario + \", detalles=\" + detalles + \", TOTAL A PAGAR= \" + total + \"]\"; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dominio/Factura.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Factura class handles both data storage (properties) and business logic (calcularTotal, agregarDetalle), introducing multiple reasons to change."}]}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/IFacturaDao.java", "violatedPrinciples": [{"principle": "Interface Segregation", "justification": "IFacturaDao forces clients to depend on all CRUD methods even if they only need a subset, violating ISP by imposing unnecessary method implementations."}]}]}
{"project_id": 93, "chunk_id": 0, "prompt": {"main_file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dominio/Detalle.java", "main_file_content": "package ar.edu.unju.escmi.poo.dominio; import java.io.Serializable; import javax.persistence.CascadeType; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.FetchType; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.JoinColumn; import javax.persistence.ManyToOne; import javax.persistence.OneToOne; import javax.persistence.Table; @Entity @Table(name=\"detalles\") public class Detalle implements Serializable{ private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long idDetalle; @Column(name=\"cantidad\") private int cantidad; @OneToOne(fetch = FetchType.LAZY) @JoinColumn(name=\"id_producto\") private Producto producto; @Column(name=\"importe\") private double importe; @ManyToOne @JoinColumn(name=\"factura_id\") private Factura factura; public Detalle() { } public Detalle(int cantidad, Producto producto,double importe) { super(); this.cantidad = cantidad; this.producto = producto; this.importe = importe; } public static long getSerialversionuid() { return serialVersionUID; } public Long getIdDetalle() { return idDetalle; } public void setIdDetalle(Long idDetalle) { this.idDetalle = idDetalle; } public int getCantidad() { return cantidad; } public void setCantidad(int cantidad) { this.cantidad = cantidad; } public Producto getProducto() { return producto; } public void setProducto(Producto producto) { this.producto = producto; } public double getImporte() { return importe; } public void setImporte(double importe) { this.importe = importe; } public Factura getFactura() { return factura; } public void setFactura(Factura factura) { this.factura = factura; } public double calcularImporte() { this.importe = (this.cantidad*(this.producto.getPrecioUnitario())); return (this.importe); } @Override public String toString() { return \"Detalle [Descripcion= \" + producto.getDescripcion()+ producto.getDescuento()+ \" cantidad=\" + cantidad + \", Precio Unitario=\" + producto.getPrecioUnitario() + \", IMPORTE=\" + importe + \"]\"; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dominio/Detalle.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Detalle class handles data storage, business logic (calcularImporte), and presentation (toString), indicating multiple responsibilities."}, {"principle": "Dependency Inversion", "justification": "Detalle directly depends on concrete Producto and Factura classes instead of abstractions, violating high-level module dependency rules."}]}]}
{"project_id": 93, "chunk_id": 0, "prompt": {"main_file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dominio/Factura.java", "main_file_content": "package ar.edu.unju.escmi.poo.dominio; import java.io.Serializable; import java.time.LocalDate; import java.util.ArrayList; import java.util.List; import javax.persistence.CascadeType; import javax.persistence.Column; import javax.persistence.ElementCollection; import javax.persistence.Entity; import javax.persistence.FetchType; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.JoinColumn; import javax.persistence.ManyToOne; import javax.persistence.OneToMany; import javax.persistence.OneToOne; import javax.persistence.Table; @Entity @Table(name=\"facturas\") public class Factura implements Serializable{ private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy=GenerationType.AUTO) private Long idFactura; @Column(name = \"numero_factura\",unique=true) private int numeroFactura; @Column(name=\"fecha_generacion\") private LocalDate fecha; @Column(name=\"total\") private double total; @OneToMany(cascade = CascadeType.MERGE, mappedBy = \"factura\") private List<Detalle> detalles = new ArrayList<Detalle>(); @OneToOne(fetch = FetchType.LAZY) @JoinColumn(name=\"id_usuario\") private Usuario usuario; public Factura() { } public Factura(int numeroFactura, LocalDate fecha, double total, List<Detalle> detalles, Usuario usuario) { super(); this.numeroFactura = numeroFactura; this.fecha = fecha; this.total = total; this.detalles = detalles; this.usuario = usuario; } public Long getIdFactura() { return idFactura; } public void setIdFactura(Long idFactura) { this.idFactura = idFactura; } public static long getSerialversionuid() { return serialVersionUID; } public int getNumeroFactura() { return numeroFactura; } public void setNumeroFactura(int numeroFactura) { this.numeroFactura = numeroFactura; } public LocalDate getFecha() { return fecha; } public void setFecha(LocalDate fecha) { this.fecha = fecha; } public List<Detalle> getDetalles() { return detalles; } public void setDetalles(List<Detalle> detalles) { this.detalles = detalles; } public Usuario getUsuario() { return usuario; } public void setUsuario(Usuario usuario) { this.usuario = usuario; } public double getTotal() { return total; } public void setTotal(double total) { this.total = total; } public double calcularTotal() { double sumaImportes=0; for(int i=0;i<this.detalles.size();i++) { sumaImportes+=this.detalles.get(i).getImporte(); } this.total = sumaImportes; return this.total; } public void agregarDetalle(Detalle nuevoDetalle) { detalles.add(nuevoDetalle); } @Override public String toString() { return \"Factura [N\u00b0 FACTURA =\" + numeroFactura + \", FECHA =\" + fecha + \", Usuario=\" + usuario + \", detalles=\" + detalles + \", TOTAL A PAGAR= \" + total + \"]\"; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dominio/Factura.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Factura manages invoice data and calculates totals, handling multiple responsibilities. Data management and business logic (total calculation) should be separated."}, {"principle": "Open-Closed", "justification": "calcularTotal method's logic is fixed. To modify calculation behavior (e.g., add discounts), Factura's code must be altered instead of extended."}, {"principle": "Dependency Inversion", "justification": "Factura directly depends on concrete Usuario and Detalle classes. High-level modules should depend on abstractions, not low-level implementations."}]}]}
{"project_id": 93, "chunk_id": 0, "prompt": {"main_file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dominio/Usuario.java", "main_file_content": "package ar.edu.unju.escmi.poo.dominio; import java.io.Serializable; import java.time.LocalDate; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.FetchType; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.JoinColumn; import javax.persistence.OneToOne; import javax.persistence.Table; @Entity @Table(name=\"usuarios\") public class Usuario implements Serializable{ private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long idUsuario; @Column(name = \"dni\",nullable=true,unique=true) private int dni; @Column(name = \"nombre\") private String nombre; @Column(name = \"apellido\") private String apellido; @Column(name = \"domicilio\") private String domicilio; @Column(name = \"fecha_nacimiento\") private LocalDate fechaNacimiento; @Column(name = \"email\",unique=true) private String email; @Column(name = \"contrasena\") private String contrasena; @OneToOne(fetch = FetchType.LAZY) @JoinColumn(name=\"id_rol\") private Rol rol; public Usuario() { } public Usuario(int dni, String nombre, String apellido, String domicilio, LocalDate fechaNacimiento, String email, String contrasena, Rol rol) { super(); this.dni = dni; this.nombre = nombre; this.apellido = apellido; this.domicilio = domicilio; this.fechaNacimiento = fechaNacimiento; this.email = email; this.contrasena = contrasena; this.rol = rol; } public Long getIdUsuario() { return idUsuario; } public void setIdUsuario(Long idUsuario) { this.idUsuario = idUsuario; } public static long getSerialversionuid() { return serialVersionUID; } public int getDni() { return dni; } public void setDni(int dni) { this.dni = dni; } public String getNombre() { return nombre; } public void setNombre(String nombre) { this.nombre = nombre; } public String getApellido() { return apellido; } public void setApellido(String apellido) { this.apellido = apellido; } public String getDomicilio() { return domicilio; } public void setDomicilio(String domicilio) { this.domicilio = domicilio; } public LocalDate getFechaNacimiento() { return fechaNacimiento; } public void setFechaNacimiento(LocalDate fechaNacimiento) { this.fechaNacimiento = fechaNacimiento; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getContrasena() { return contrasena; } public void setContrasena(String contrasena) { this.contrasena = contrasena; } public Rol getRol() { return rol; } public void setRol(Rol rol) { this.rol = rol; } @Override public String toString() { return \"Usuario [idUsuario=\" + idUsuario + \", dni=\" + dni + \", nombre=\" + nombre + \", apellido=\" + apellido + \", domicilio=\" + domicilio + \", fechaNacimiento=\" + fechaNacimiento + \", email=\" + email + \", contrasena=\" + contrasena + \", rol=\" + rol + \"]\"; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dominio/Usuario.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "Usuario directly depends on the concrete Rol class instead of an abstraction. High-level modules should depend on abstractions (interfaces/abstract classes) rather than concrete implementations."}]}]}
{"project_id": 93, "chunk_id": 0, "prompt": {"main_file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dominio/Rol.java", "main_file_content": "package ar.edu.unju.escmi.poo.dominio; import java.io.Serializable; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.Table; @Entity @Table(name=\"roles\") public class Rol implements Serializable { private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy=GenerationType.AUTO) @Column(name=\"id\") private Long idRol; @Column(name=\"descripcion\") private String descripcion; public Rol() { } public Rol(String descripcion) { super(); this.descripcion = descripcion; } public Long getIdRol() { return idRol; } public void setIdRol(Long idRol) { this.idRol = idRol; } public String getDescripcion() { return descripcion; } public void setDescripcion(String descripcion) { this.descripcion = descripcion; } public static long getSerialversionuid() { return serialVersionUID; } @Override public String toString() { return \"Rol [idRol=\" + idRol + \", descripcion=\" + descripcion + \"]\"; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dominio/Rol.java", "violatedPrinciples": []}]}
{"project_id": 93, "chunk_id": 0, "prompt": {"main_file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dominio/Stock.java", "main_file_content": "package ar.edu.unju.escmi.poo.dominio; import java.io.Serializable; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.FetchType; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.JoinColumn; import javax.persistence.OneToOne; import javax.persistence.Table; @Entity @Table(name=\"stocks\") public class Stock implements Serializable{ private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy=GenerationType.AUTO) private Long idStock; @Column(name=\"cantidad\") private int cantidad; @OneToOne(fetch = FetchType.LAZY) @JoinColumn(name=\"id_producto\") private Producto producto; public Stock() { } public Stock(int cantidad, Producto producto) { super(); this.cantidad = cantidad; this.producto = producto; } public Long getIdStock() { return idStock; } public void setIdStock(Long idStock) { this.idStock = idStock; } public static long getSerialversionuid() { return serialVersionUID; } public int getCantidad() { return cantidad; } public void setCantidad(int cantidad) { this.cantidad = cantidad; } public Producto getProducto() { return producto; } public void setProducto(Producto producto) { this.producto = producto; } @Override public String toString() { return \"Stock [cantidad=\" + cantidad + \", producto=\" + producto + \"]\"; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dominio/Stock.java", "violatedPrinciples": []}]}
{"project_id": 93, "chunk_id": 0, "prompt": {"main_file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dominio/Producto.java", "main_file_content": "package ar.edu.unju.escmi.poo.dominio; import java.io.Serializable; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.Table; @Entity @Table(name=\"productos\") public class Producto implements Serializable{ private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long idProducto; @Column(name=\"descripcion\") private String descripcion; @Column(name=\"marca\") private String marca; @Column(name=\"origen\") private String origen; @Column(name=\"categoria\") private String categoria; @Column(name=\"descuento\") private int descuento; @Column(name=\"precio_unitario\") private double precioUnitario; public Producto() { } public Producto( String categoria, String descripcion, double precioUnitario, String origen, String marca,int descuento) { super(); this.categoria = categoria; this.descripcion = descripcion; this.precioUnitario = precioUnitario; this.origen = origen; this.marca = marca; this.descuento = descuento; } public Long getidProducto() { return idProducto; } public void setidProducto(Long idProducto) { this.idProducto = idProducto; } public String getDescripcion() { return descripcion; } public void setDescripcion(String descripcion) { this.descripcion = descripcion; } public String getMarca() { return marca; } public void setMarca(String marca) { this.marca = marca; } public String getOrigen() { return origen; } public void setOrigen(String origen) { this.origen = origen; } public String getCategoria() { return categoria; } public void setCategoria(String categoria) { this.categoria = categoria; } public int getDescuento() { return descuento; } public void setDescuento(int descuento) { this.descuento = descuento; } public double getPrecioUnitario() { return precioUnitario; } public void setPrecioUnitario(double precioUnitario) { this.precioUnitario = precioUnitario; } @Override public String toString() { return \"Producto [idProducto=\" + idProducto + \", descripcion=\" + descripcion + \", marca=\" + marca + \", origen=\" + origen + \", categoria=\" + categoria + \", descuento=\" + descuento + \", precioUnitario=\" + precioUnitario + \"]\"; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dominio/Producto.java", "violatedPrinciples": []}]}
{"project_id": 93, "chunk_id": 0, "prompt": {"main_file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/imp/ProductoDaoImp.java", "main_file_content": "package ar.edu.unju.escmi.poo.dao.imp; import java.util.List; import javax.persistence.EntityManager; import ar.edu.unju.escmi.poo.config.EmfSingleton; import ar.edu.unju.escmi.poo.dao.IProductoDao; import ar.edu.unju.escmi.poo.dominio.Producto; import ar.edu.unju.escmi.poo.dominio.Usuario; public class ProductoDaoImp implements IProductoDao{ private static EntityManager manager = EmfSingleton.getInstance().getEmf().createEntityManager(); @Override public void agregarProducto(Producto nuevoProducto) { try{ manager.getTransaction().begin(); manager.persist(nuevoProducto); manager.getTransaction().commit(); }catch(Exception e) { soutl(\"\") } } @Override public void eliminarProducto(Producto producto) { manager.getTransaction().begin(); manager.remove(producto); } @Override public List<Producto> obtenerProductos() { @SuppressWarnings(\"unchecked\") List<Producto> productos = (List<Producto>) manager.createQuery(\"SELECT p FROM Producto p\").getResultList(); return productos; } @Override public Producto obtenerProducto(Long idProducto) { return manager.find(Producto.class, idProducto); } }", "dependencies": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/config/EmfSingleton.java", "file_content": "package ar.edu.unju.escmi.poo.config; import javax.persistence.EntityManagerFactory; import javax.persistence.Persistence; public class EmfSingleton { private static EmfSingleton miInstancia = new EmfSingleton(); static private final String PERSISTENCE_UNIT_NAME = \"TestPersistence\"; private EntityManagerFactory emf = null; public static EmfSingleton getInstance() { return miInstancia; } private EmfSingleton() { } public EntityManagerFactory getEmf() { if (this.emf == null) this.emf = Persistence.createEntityManagerFactory(PERSISTENCE_UNIT_NAME); return this.emf; } }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/IProductoDao.java", "file_content": "package ar.edu.unju.escmi.poo.dao; import java.util.List; import ar.edu.unju.escmi.poo.dominio.Producto; public interface IProductoDao { public void agregarProducto(Producto nuevoProducto); public void eliminarProducto(Producto producto); public List<Producto> obtenerProductos(); public Producto obtenerProducto(Long idProducto); }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dominio/Producto.java", "file_content": "package ar.edu.unju.escmi.poo.dominio; import java.io.Serializable; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.Table; @Entity @Table(name=\"productos\") public class Producto implements Serializable{ private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long idProducto; @Column(name=\"descripcion\") private String descripcion; @Column(name=\"marca\") private String marca; @Column(name=\"origen\") private String origen; @Column(name=\"categoria\") private String categoria; @Column(name=\"descuento\") private int descuento; @Column(name=\"precio_unitario\") private double precioUnitario; public Producto() { } public Producto( String categoria, String descripcion, double precioUnitario, String origen, String marca,int descuento) { super(); this.categoria = categoria; this.descripcion = descripcion; this.precioUnitario = precioUnitario; this.origen = origen; this.marca = marca; this.descuento = descuento; } public Long getidProducto() { return idProducto; } public void setidProducto(Long idProducto) { this.idProducto = idProducto; } public String getDescripcion() { return descripcion; } public void setDescripcion(String descripcion) { this.descripcion = descripcion; } public String getMarca() { return marca; } public void setMarca(String marca) { this.marca = marca; } public String getOrigen() { return origen; } public void setOrigen(String origen) { this.origen = origen; } public String getCategoria() { return categoria; } public void setCategoria(String categoria) { this.categoria = categoria; } public int getDescuento() { return descuento; } public void setDescuento(int descuento) { this.descuento = descuento; } public double getPrecioUnitario() { return precioUnitario; } public void setPrecioUnitario(double precioUnitario) { this.precioUnitario = precioUnitario; } @Override public String toString() { return \"Producto [idProducto=\" + idProducto + \", descripcion=\" + descripcion + \", marca=\" + marca + \", origen=\" + origen + \", categoria=\" + categoria + \", descuento=\" + descuento + \", precioUnitario=\" + precioUnitario + \"]\"; } }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dominio/Usuario.java", "file_content": "package ar.edu.unju.escmi.poo.dominio; import java.io.Serializable; import java.time.LocalDate; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.FetchType; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.JoinColumn; import javax.persistence.OneToOne; import javax.persistence.Table; @Entity @Table(name=\"usuarios\") public class Usuario implements Serializable{ private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long idUsuario; @Column(name = \"dni\",nullable=true,unique=true) private int dni; @Column(name = \"nombre\") private String nombre; @Column(name = \"apellido\") private String apellido; @Column(name = \"domicilio\") private String domicilio; @Column(name = \"fecha_nacimiento\") private LocalDate fechaNacimiento; @Column(name = \"email\",unique=true) private String email; @Column(name = \"contrasena\") private String contrasena; @OneToOne(fetch = FetchType.LAZY) @JoinColumn(name=\"id_rol\") private Rol rol; public Usuario() { } public Usuario(int dni, String nombre, String apellido, String domicilio, LocalDate fechaNacimiento, String email, String contrasena, Rol rol) { super(); this.dni = dni; this.nombre = nombre; this.apellido = apellido; this.domicilio = domicilio; this.fechaNacimiento = fechaNacimiento; this.email = email; this.contrasena = contrasena; this.rol = rol; } public Long getIdUsuario() { return idUsuario; } public void setIdUsuario(Long idUsuario) { this.idUsuario = idUsuario; } public static long getSerialversionuid() { return serialVersionUID; } public int getDni() { return dni; } public void setDni(int dni) { this.dni = dni; } public String getNombre() { return nombre; } public void setNombre(String nombre) { this.nombre = nombre; } public String getApellido() { return apellido; } public void setApellido(String apellido) { this.apellido = apellido; } public String getDomicilio() { return domicilio; } public void setDomicilio(String domicilio) { this.domicilio = domicilio; } public LocalDate getFechaNacimiento() { return fechaNacimiento; } public void setFechaNacimiento(LocalDate fechaNacimiento) { this.fechaNacimiento = fechaNacimiento; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getContrasena() { return contrasena; } public void setContrasena(String contrasena) { this.contrasena = contrasena; } public Rol getRol() { return rol; } public void setRol(Rol rol) { this.rol = rol; } @Override public String toString() { return \"Usuario [idUsuario=\" + idUsuario + \", dni=\" + dni + \", nombre=\" + nombre + \", apellido=\" + apellido + \", domicilio=\" + domicilio + \", fechaNacimiento=\" + fechaNacimiento + \", email=\" + email + \", contrasena=\" + contrasena + \", rol=\" + rol + \"]\"; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/imp/ProductoDaoImp.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "ProductoDaoImp directly depends on the concrete EmfSingleton class to obtain EntityManager. High-level modules should depend on abstractions (e.g., an interface for EntityManagerFactory) rather than concrete implementations."}]}]}
{"project_id": 93, "chunk_id": 0, "prompt": {"main_file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/imp/RolDaoImp.java", "main_file_content": "package ar.edu.unju.escmi.poo.dao.imp; import java.util.List; import javax.persistence.EntityManager; import ar.edu.unju.escmi.poo.config.EmfSingleton; import ar.edu.unju.escmi.poo.dao.IRolDao; import ar.edu.unju.escmi.poo.dominio.Rol; public class RolDaoImp implements IRolDao { private static EntityManager manager = EmfSingleton.getInstance().getEmf().createEntityManager(); @Override public List<Rol> buscarRoles() { return null; } @Override public Rol buscarRolPorId(Long id) { return manager.find(Rol.class,id); } @Override public void agregarRol(Rol rol) { try { manager.getTransaction().begin(); manager.persist(rol); manager.getTransaction().commit(); }catch(Exception e){ soutl(\"\") } } }", "dependencies": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/config/EmfSingleton.java", "file_content": "package ar.edu.unju.escmi.poo.config; import javax.persistence.EntityManagerFactory; import javax.persistence.Persistence; public class EmfSingleton { private static EmfSingleton miInstancia = new EmfSingleton(); static private final String PERSISTENCE_UNIT_NAME = \"TestPersistence\"; private EntityManagerFactory emf = null; public static EmfSingleton getInstance() { return miInstancia; } private EmfSingleton() { } public EntityManagerFactory getEmf() { if (this.emf == null) this.emf = Persistence.createEntityManagerFactory(PERSISTENCE_UNIT_NAME); return this.emf; } }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/IRolDao.java", "file_content": "package ar.edu.unju.escmi.poo.dao; import java.util.List; import ar.edu.unju.escmi.poo.dominio.Rol; public interface IRolDao { public void agregarRol(Rol rol); public List<Rol> buscarRoles(); public Rol buscarRolPorId(Long id); }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dominio/Rol.java", "file_content": "package ar.edu.unju.escmi.poo.dominio; import java.io.Serializable; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.Table; @Entity @Table(name=\"roles\") public class Rol implements Serializable { private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy=GenerationType.AUTO) @Column(name=\"id\") private Long idRol; @Column(name=\"descripcion\") private String descripcion; public Rol() { } public Rol(String descripcion) { super(); this.descripcion = descripcion; } public Long getIdRol() { return idRol; } public void setIdRol(Long idRol) { this.idRol = idRol; } public String getDescripcion() { return descripcion; } public void setDescripcion(String descripcion) { this.descripcion = descripcion; } public static long getSerialversionuid() { return serialVersionUID; } @Override public String toString() { return \"Rol [idRol=\" + idRol + \", descripcion=\" + descripcion + \"]\"; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/imp/RolDaoImp.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "RolDaoImp directly instantiates EntityManager via concrete EmfSingleton. High-level modules should depend on abstractions rather than concrete low-level implementations for entity management."}]}]}
{"project_id": 93, "chunk_id": 0, "prompt": {"main_file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/imp/DetalleDaoImp.java", "main_file_content": "package ar.edu.unju.escmi.poo.dao.imp; import javax.persistence.EntityManager; import ar.edu.unju.escmi.poo.config.EmfSingleton; import ar.edu.unju.escmi.poo.dao.IDetalleDao; import ar.edu.unju.escmi.poo.dominio.Detalle; public class DetalleDaoImp implements IDetalleDao { private static EntityManager manager = EmfSingleton.getInstance().getEmf().createEntityManager(); @Override public void agregarDetalle(Detalle nuevoDetalle) { manager.getTransaction().begin(); manager.persist(nuevoDetalle); manager.getTransaction().commit(); } @Override public void eliminarDetalle(Detalle detalle) { manager.getTransaction().begin(); manager.remove(detalle); manager.getTransaction().commit(); } }", "dependencies": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/config/EmfSingleton.java", "file_content": "package ar.edu.unju.escmi.poo.config; import javax.persistence.EntityManagerFactory; import javax.persistence.Persistence; public class EmfSingleton { private static EmfSingleton miInstancia = new EmfSingleton(); static private final String PERSISTENCE_UNIT_NAME = \"TestPersistence\"; private EntityManagerFactory emf = null; public static EmfSingleton getInstance() { return miInstancia; } private EmfSingleton() { } public EntityManagerFactory getEmf() { if (this.emf == null) this.emf = Persistence.createEntityManagerFactory(PERSISTENCE_UNIT_NAME); return this.emf; } }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/IDetalleDao.java", "file_content": "package ar.edu.unju.escmi.poo.dao; import ar.edu.unju.escmi.poo.dominio.Detalle; public interface IDetalleDao { public void agregarDetalle(Detalle nuevoDetalle); public void eliminarDetalle(Detalle detalle); }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dominio/Detalle.java", "file_content": "package ar.edu.unju.escmi.poo.dominio; import java.io.Serializable; import javax.persistence.CascadeType; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.FetchType; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.JoinColumn; import javax.persistence.ManyToOne; import javax.persistence.OneToOne; import javax.persistence.Table; @Entity @Table(name=\"detalles\") public class Detalle implements Serializable{ private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long idDetalle; @Column(name=\"cantidad\") private int cantidad; @OneToOne(fetch = FetchType.LAZY) @JoinColumn(name=\"id_producto\") private Producto producto; @Column(name=\"importe\") private double importe; @ManyToOne @JoinColumn(name=\"factura_id\") private Factura factura; public Detalle() { } public Detalle(int cantidad, Producto producto,double importe) { super(); this.cantidad = cantidad; this.producto = producto; this.importe = importe; } public static long getSerialversionuid() { return serialVersionUID; } public Long getIdDetalle() { return idDetalle; } public void setIdDetalle(Long idDetalle) { this.idDetalle = idDetalle; } public int getCantidad() { return cantidad; } public void setCantidad(int cantidad) { this.cantidad = cantidad; } public Producto getProducto() { return producto; } public void setProducto(Producto producto) { this.producto = producto; } public double getImporte() { return importe; } public void setImporte(double importe) { this.importe = importe; } public Factura getFactura() { return factura; } public void setFactura(Factura factura) { this.factura = factura; } public double calcularImporte() { this.importe = (this.cantidad*(this.producto.getPrecioUnitario())); return (this.importe); } @Override public String toString() { return \"Detalle [Descripcion= \" + producto.getDescripcion()+ producto.getDescuento()+ \" cantidad=\" + cantidad + \", Precio Unitario=\" + producto.getPrecioUnitario() + \", IMPORTE=\" + importe + \"]\"; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/imp/DetalleDaoImp.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "DetalleDaoImp directly references EmfSingleton, a concrete class, to obtain EntityManager. High-level modules should depend on abstractions rather than concrete implementations."}]}]}
{"project_id": 93, "chunk_id": 0, "prompt": {"main_file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/imp/StockDaoImp.java", "main_file_content": "package ar.edu.unju.escmi.poo.dao.imp; import javax.persistence.EntityManager; import javax.persistence.Query; import ar.edu.unju.escmi.poo.config.EmfSingleton; import ar.edu.unju.escmi.poo.dao.IStockDao; import ar.edu.unju.escmi.poo.dominio.Stock; public class StockDaoImp implements IStockDao { private static EntityManager manager = EmfSingleton.getInstance().getEmf().createEntityManager(); @Override public void agregarStock(Stock Stock) { try { manager.getTransaction().begin(); manager.persist(Stock); manager.getTransaction().commit(); }catch(Exception e) { soutl(\"\") } } @Override public Stock buscarStockPorId(Long id) { return null; } @Override public Stock buscarStockPorIdProducto(Long idProducto) { Query query = manager.createQuery(\"SELECT s FROM Stock s WHERE s.producto.idProducto = :idProducto\"); query.setParameter(\"idProducto\", idProducto); Stock stock = (Stock)query.getSingleResult(); return stock; } @Override public boolean decrementarStock(Stock stock, int cantidad) { if(stock.getCantidad()-cantidad >= 0) { stock.setCantidad(stock.getCantidad()-cantidad); manager.getTransaction().begin(); manager.merge(stock); manager.getTransaction().commit(); return true; }else { return false; } } }", "dependencies": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/config/EmfSingleton.java", "file_content": "package ar.edu.unju.escmi.poo.config; import javax.persistence.EntityManagerFactory; import javax.persistence.Persistence; public class EmfSingleton { private static EmfSingleton miInstancia = new EmfSingleton(); static private final String PERSISTENCE_UNIT_NAME = \"TestPersistence\"; private EntityManagerFactory emf = null; public static EmfSingleton getInstance() { return miInstancia; } private EmfSingleton() { } public EntityManagerFactory getEmf() { if (this.emf == null) this.emf = Persistence.createEntityManagerFactory(PERSISTENCE_UNIT_NAME); return this.emf; } }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/IStockDao.java", "file_content": "package ar.edu.unju.escmi.poo.dao; import ar.edu.unju.escmi.poo.dominio.Stock; public interface IStockDao { public void agregarStock(Stock Stock); public Stock buscarStockPorId(Long id); public Stock buscarStockPorIdProducto(Long idProducto); public boolean decrementarStock(Stock stock,int cantidad); }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dominio/Stock.java", "file_content": "package ar.edu.unju.escmi.poo.dominio; import java.io.Serializable; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.FetchType; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.JoinColumn; import javax.persistence.OneToOne; import javax.persistence.Table; @Entity @Table(name=\"stocks\") public class Stock implements Serializable{ private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy=GenerationType.AUTO) private Long idStock; @Column(name=\"cantidad\") private int cantidad; @OneToOne(fetch = FetchType.LAZY) @JoinColumn(name=\"id_producto\") private Producto producto; public Stock() { } public Stock(int cantidad, Producto producto) { super(); this.cantidad = cantidad; this.producto = producto; } public Long getIdStock() { return idStock; } public void setIdStock(Long idStock) { this.idStock = idStock; } public static long getSerialversionuid() { return serialVersionUID; } public int getCantidad() { return cantidad; } public void setCantidad(int cantidad) { this.cantidad = cantidad; } public Producto getProducto() { return producto; } public void setProducto(Producto producto) { this.producto = producto; } @Override public String toString() { return \"Stock [cantidad=\" + cantidad + \", producto=\" + producto + \"]\"; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/imp/StockDaoImp.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "StockDaoImp directly depends on EmfSingleton, a concrete class, to obtain EntityManager. High-level modules should depend on abstractions, and low-level modules (like DAO) should also depend on abstractions rather than concrete implementations."}]}]}
{"project_id": 93, "chunk_id": 0, "prompt": {"main_file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/imp/UsuarioDaoImp.java", "main_file_content": "package ar.edu.unju.escmi.poo.dao.imp; import java.util.List; import javax.persistence.EntityManager; import javax.persistence.Query; import ar.edu.unju.escmi.poo.config.EmfSingleton; import ar.edu.unju.escmi.poo.dao.IUsuarioDao; import ar.edu.unju.escmi.poo.dominio.Usuario; public class UsuarioDaoImp implements IUsuarioDao { private static EntityManager manager = EmfSingleton.getInstance().getEmf().createEntityManager(); @Override public void agregarUsuario(Usuario nuevoUsuario) { try { manager.getTransaction().begin(); manager.persist(nuevoUsuario); manager.getTransaction().commit(); }catch(Exception e) { soutl(\"\") } } @Override public void eliminarUsuario(Usuario usuario) { manager.getTransaction().begin(); manager.remove(usuario); manager.getTransaction().commit(); } @Override public List<Usuario> obtenerUsuarios() { @SuppressWarnings(\"unchecked\") List<Usuario> usuarios = (List<Usuario>) manager.createQuery(\"SELECT u FROM Usuario u\").getResultList(); return usuarios; } @Override public void modificarUsuario(Usuario usuario) { manager.getTransaction().begin(); manager.merge(usuario); manager.getTransaction().commit(); } @Override public Usuario obtenerUsuario(Long idUsuario) { return manager.find(Usuario.class, idUsuario); } @Override public Usuario obtenerUsuarioPorCredenciales(String email,String contra) { Query query = manager.createQuery(\"SELECT u FROM Usuario u WHERE u.email = :email AND u.contrasena = :contra\"); query.setParameter(\"email\", email); query.setParameter(\"contra\", contra); Usuario usuario = (Usuario) query.getSingleResult(); return usuario; } @Override public List<Usuario> obtenerUsuariosClientes() { @SuppressWarnings(\"unchecked\") List<Usuario> clientes = (List<Usuario>) manager.createQuery(\"SELECT u FROM Usuario u\" + \" WHERE u.rol.descripcion = 'Cliente'\").getResultList(); return clientes; } }", "dependencies": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/config/EmfSingleton.java", "file_content": "package ar.edu.unju.escmi.poo.config; import javax.persistence.EntityManagerFactory; import javax.persistence.Persistence; public class EmfSingleton { private static EmfSingleton miInstancia = new EmfSingleton(); static private final String PERSISTENCE_UNIT_NAME = \"TestPersistence\"; private EntityManagerFactory emf = null; public static EmfSingleton getInstance() { return miInstancia; } private EmfSingleton() { } public EntityManagerFactory getEmf() { if (this.emf == null) this.emf = Persistence.createEntityManagerFactory(PERSISTENCE_UNIT_NAME); return this.emf; } }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/IUsuarioDao.java", "file_content": "package ar.edu.unju.escmi.poo.dao; import java.util.List; import ar.edu.unju.escmi.poo.dominio.Usuario; public interface IUsuarioDao { public void agregarUsuario(Usuario nuevoUsuario); public void eliminarUsuario(Usuario usuario); public List<Usuario> obtenerUsuarios(); public List<Usuario> obtenerUsuariosClientes(); public void modificarUsuario(Usuario usuario); public Usuario obtenerUsuario(Long idUsuario); public Usuario obtenerUsuarioPorCredenciales(String email,String contra); }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dominio/Usuario.java", "file_content": "package ar.edu.unju.escmi.poo.dominio; import java.io.Serializable; import java.time.LocalDate; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.FetchType; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.JoinColumn; import javax.persistence.OneToOne; import javax.persistence.Table; @Entity @Table(name=\"usuarios\") public class Usuario implements Serializable{ private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long idUsuario; @Column(name = \"dni\",nullable=true,unique=true) private int dni; @Column(name = \"nombre\") private String nombre; @Column(name = \"apellido\") private String apellido; @Column(name = \"domicilio\") private String domicilio; @Column(name = \"fecha_nacimiento\") private LocalDate fechaNacimiento; @Column(name = \"email\",unique=true) private String email; @Column(name = \"contrasena\") private String contrasena; @OneToOne(fetch = FetchType.LAZY) @JoinColumn(name=\"id_rol\") private Rol rol; public Usuario() { } public Usuario(int dni, String nombre, String apellido, String domicilio, LocalDate fechaNacimiento, String email, String contrasena, Rol rol) { super(); this.dni = dni; this.nombre = nombre; this.apellido = apellido; this.domicilio = domicilio; this.fechaNacimiento = fechaNacimiento; this.email = email; this.contrasena = contrasena; this.rol = rol; } public Long getIdUsuario() { return idUsuario; } public void setIdUsuario(Long idUsuario) { this.idUsuario = idUsuario; } public static long getSerialversionuid() { return serialVersionUID; } public int getDni() { return dni; } public void setDni(int dni) { this.dni = dni; } public String getNombre() { return nombre; } public void setNombre(String nombre) { this.nombre = nombre; } public String getApellido() { return apellido; } public void setApellido(String apellido) { this.apellido = apellido; } public String getDomicilio() { return domicilio; } public void setDomicilio(String domicilio) { this.domicilio = domicilio; } public LocalDate getFechaNacimiento() { return fechaNacimiento; } public void setFechaNacimiento(LocalDate fechaNacimiento) { this.fechaNacimiento = fechaNacimiento; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getContrasena() { return contrasena; } public void setContrasena(String contrasena) { this.contrasena = contrasena; } public Rol getRol() { return rol; } public void setRol(Rol rol) { this.rol = rol; } @Override public String toString() { return \"Usuario [idUsuario=\" + idUsuario + \", dni=\" + dni + \", nombre=\" + nombre + \", apellido=\" + apellido + \", domicilio=\" + domicilio + \", fechaNacimiento=\" + fechaNacimiento + \", email=\" + email + \", contrasena=\" + contrasena + \", rol=\" + rol + \"]\"; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/imp/UsuarioDaoImp.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "UsuarioDaoImp directly depends on the concrete EmfSingleton class to obtain EntityManager. High-level modules should depend on abstractions, and dependencies should be injected rather than instantiated directly."}]}]}
{"project_id": 93, "chunk_id": 0, "prompt": {"main_file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/imp/FacturaDaoImp.java", "main_file_content": "package ar.edu.unju.escmi.poo.dao.imp; import java.util.List; import javax.persistence.EntityManager; import javax.persistence.Query; import ar.edu.unju.escmi.poo.dao.IFacturaDao; import ar.edu.unju.escmi.poo.dominio.Factura; import ar.edu.unju.escmi.poo.config.EmfSingleton; public class FacturaDaoImp implements IFacturaDao{ private static EntityManager manager = EmfSingleton.getInstance().getEmf().createEntityManager(); @Override public void agregarFactura(Factura nuevaFactura) { try { manager.getTransaction().begin(); manager.persist(nuevaFactura); manager.getTransaction().commit(); }catch(Exception e) { soutl(\"\") } } @Override public Factura buscarFacturaPorNumeroFactura(int nroFactura) { Query query = manager.createQuery(\"SELECT f FROM Factura f\" + \" WHERE f.numeroFactura = :nroFactura\"); query.setParameter(\"nroFactura\", nroFactura); Factura factura = (Factura) query.getSingleResult(); return factura; } @Override public List<Factura> obtenerFacturas(){ @SuppressWarnings(\"unchecked\") List<Factura> facturas = (List<Factura>) manager.createQuery(\"SELECT f FROM Factura f\").getResultList(); return facturas; } @Override public List<Factura> obtenerFacturasPorId(Long id) { Query query = manager.createQuery(\"SELECT f FROM Factura f WHERE f.usuario.idUsuario = :id\"); query.setParameter(\"id\", id); @SuppressWarnings(\"unchecked\") List<Factura> facturas = (List<Factura>) query.getResultList(); return facturas; } @Override public Factura obtenerFacturaPorIdYNumeroFactura(Long id, int nroFactura) { Query query = manager.createQuery(\"SELECT f FROM Factura f WHERE f.usuario.idUsuario = :id AND f.numeroFactura = :nroFactura\"); query.setParameter(\"id\", id); query.setParameter(\"nroFactura\", nroFactura); Factura factura = (Factura) query.getSingleResult(); return factura; } @Override public void eliminarFactura(Factura factura) { manager.getTransaction().begin(); manager.remove(factura); manager.getTransaction().commit(); } @Override public void modificarFactura(Factura factura) { manager.getTransaction().begin(); manager.merge(factura); manager.getTransaction().commit(); } }", "dependencies": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/IFacturaDao.java", "file_content": "package ar.edu.unju.escmi.poo.dao; import java.util.List; import ar.edu.unju.escmi.poo.dominio.Factura; public interface IFacturaDao { public void agregarFactura(Factura nuevaFactura); public Factura buscarFacturaPorNumeroFactura(int nroFactura); public Factura obtenerFacturaPorIdYNumeroFactura(Long id, int nroFactura); public List<Factura> obtenerFacturas(); public List<Factura> obtenerFacturasPorId(Long id); public void eliminarFactura(Factura factura); public void modificarFactura(Factura factura); }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dominio/Factura.java", "file_content": "package ar.edu.unju.escmi.poo.dominio; import java.io.Serializable; import java.time.LocalDate; import java.util.ArrayList; import java.util.List; import javax.persistence.CascadeType; import javax.persistence.Column; import javax.persistence.ElementCollection; import javax.persistence.Entity; import javax.persistence.FetchType; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.JoinColumn; import javax.persistence.ManyToOne; import javax.persistence.OneToMany; import javax.persistence.OneToOne; import javax.persistence.Table; @Entity @Table(name=\"facturas\") public class Factura implements Serializable{ private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy=GenerationType.AUTO) private Long idFactura; @Column(name = \"numero_factura\",unique=true) private int numeroFactura; @Column(name=\"fecha_generacion\") private LocalDate fecha; @Column(name=\"total\") private double total; @OneToMany(cascade = CascadeType.MERGE, mappedBy = \"factura\") private List<Detalle> detalles = new ArrayList<Detalle>(); @OneToOne(fetch = FetchType.LAZY) @JoinColumn(name=\"id_usuario\") private Usuario usuario; public Factura() { } public Factura(int numeroFactura, LocalDate fecha, double total, List<Detalle> detalles, Usuario usuario) { super(); this.numeroFactura = numeroFactura; this.fecha = fecha; this.total = total; this.detalles = detalles; this.usuario = usuario; } public Long getIdFactura() { return idFactura; } public void setIdFactura(Long idFactura) { this.idFactura = idFactura; } public static long getSerialversionuid() { return serialVersionUID; } public int getNumeroFactura() { return numeroFactura; } public void setNumeroFactura(int numeroFactura) { this.numeroFactura = numeroFactura; } public LocalDate getFecha() { return fecha; } public void setFecha(LocalDate fecha) { this.fecha = fecha; } public List<Detalle> getDetalles() { return detalles; } public void setDetalles(List<Detalle> detalles) { this.detalles = detalles; } public Usuario getUsuario() { return usuario; } public void setUsuario(Usuario usuario) { this.usuario = usuario; } public double getTotal() { return total; } public void setTotal(double total) { this.total = total; } public double calcularTotal() { double sumaImportes=0; for(int i=0;i<this.detalles.size();i++) { sumaImportes+=this.detalles.get(i).getImporte(); } this.total = sumaImportes; return this.total; } public void agregarDetalle(Detalle nuevoDetalle) { detalles.add(nuevoDetalle); } @Override public String toString() { return \"Factura [N\u00b0 FACTURA =\" + numeroFactura + \", FECHA =\" + fecha + \", Usuario=\" + usuario + \", detalles=\" + detalles + \", TOTAL A PAGAR= \" + total + \"]\"; } }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/config/EmfSingleton.java", "file_content": "package ar.edu.unju.escmi.poo.config; import javax.persistence.EntityManagerFactory; import javax.persistence.Persistence; public class EmfSingleton { private static EmfSingleton miInstancia = new EmfSingleton(); static private final String PERSISTENCE_UNIT_NAME = \"TestPersistence\"; private EntityManagerFactory emf = null; public static EmfSingleton getInstance() { return miInstancia; } private EmfSingleton() { } public EntityManagerFactory getEmf() { if (this.emf == null) this.emf = Persistence.createEntityManagerFactory(PERSISTENCE_UNIT_NAME); return this.emf; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/imp/FacturaDaoImp.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "FacturaDaoImp directly depends on the concrete EmfSingleton class to obtain EntityManager, violating DIP which requires dependencies on abstractions rather than concrete implementations."}]}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/IFacturaDao.java", "violatedPrinciples": [{"principle": "Interface Segregation", "justification": "IFacturaDao is a large interface with multiple methods, forcing clients to depend on all invoice operations even if they only need a subset, violating ISP."}]}]}
{"project_id": 93, "chunk_id": 0, "prompt": {"main_file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/test/java/ar/edu/unju/escmi/poo/dominio/UsuarioTest.java", "main_file_content": "package ar.edu.unju.escmi.poo.dominio; import static org.junit.jupiter.api.Assertions.*; import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import ar.edu.unju.escmi.poo.dao.IRolDao; import ar.edu.unju.escmi.poo.dao.IUsuarioDao; import ar.edu.unju.escmi.poo.dao.imp.RolDaoImp; import ar.edu.unju.escmi.poo.dao.imp.UsuarioDaoImp; class UsuarioTest { IUsuarioDao usuarioDao = new UsuarioDaoImp(); IRolDao rolDao = new RolDaoImp(); Usuario usuario; Rol rol; @BeforeEach void setUp() throws Exception { usuario = new Usuario(); rol = new Rol(); } @AfterEach void tearDown() throws Exception { } @Test void testVerificarRolAsignado() { rol = rolDao.buscarRolPorId(1L); usuario.setRol(rol); assertTrue(\"Vendedor\".equals(usuario.getRol().getDescripcion())); } }", "dependencies": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/IRolDao.java", "file_content": "package ar.edu.unju.escmi.poo.dao; import java.util.List; import ar.edu.unju.escmi.poo.dominio.Rol; public interface IRolDao { public void agregarRol(Rol rol); public List<Rol> buscarRoles(); public Rol buscarRolPorId(Long id); }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/IUsuarioDao.java", "file_content": "package ar.edu.unju.escmi.poo.dao; import java.util.List; import ar.edu.unju.escmi.poo.dominio.Usuario; public interface IUsuarioDao { public void agregarUsuario(Usuario nuevoUsuario); public void eliminarUsuario(Usuario usuario); public List<Usuario> obtenerUsuarios(); public List<Usuario> obtenerUsuariosClientes(); public void modificarUsuario(Usuario usuario); public Usuario obtenerUsuario(Long idUsuario); public Usuario obtenerUsuarioPorCredenciales(String email,String contra); }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/imp/RolDaoImp.java", "file_content": "package ar.edu.unju.escmi.poo.dao.imp; import java.util.List; import javax.persistence.EntityManager; import ar.edu.unju.escmi.poo.config.EmfSingleton; import ar.edu.unju.escmi.poo.dao.IRolDao; import ar.edu.unju.escmi.poo.dominio.Rol; public class RolDaoImp implements IRolDao { private static EntityManager manager = EmfSingleton.getInstance().getEmf().createEntityManager(); @Override public List<Rol> buscarRoles() { return null; } @Override public Rol buscarRolPorId(Long id) { return manager.find(Rol.class,id); } @Override public void agregarRol(Rol rol) { try { manager.getTransaction().begin(); manager.persist(rol); manager.getTransaction().commit(); }catch(Exception e){ soutl(\"\") } } }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/imp/UsuarioDaoImp.java", "file_content": "package ar.edu.unju.escmi.poo.dao.imp; import java.util.List; import javax.persistence.EntityManager; import javax.persistence.Query; import ar.edu.unju.escmi.poo.config.EmfSingleton; import ar.edu.unju.escmi.poo.dao.IUsuarioDao; import ar.edu.unju.escmi.poo.dominio.Usuario; public class UsuarioDaoImp implements IUsuarioDao { private static EntityManager manager = EmfSingleton.getInstance().getEmf().createEntityManager(); @Override public void agregarUsuario(Usuario nuevoUsuario) { try { manager.getTransaction().begin(); manager.persist(nuevoUsuario); manager.getTransaction().commit(); }catch(Exception e) { soutl(\"\") } } @Override public void eliminarUsuario(Usuario usuario) { manager.getTransaction().begin(); manager.remove(usuario); manager.getTransaction().commit(); } @Override public List<Usuario> obtenerUsuarios() { @SuppressWarnings(\"unchecked\") List<Usuario> usuarios = (List<Usuario>) manager.createQuery(\"SELECT u FROM Usuario u\").getResultList(); return usuarios; } @Override public void modificarUsuario(Usuario usuario) { manager.getTransaction().begin(); manager.merge(usuario); manager.getTransaction().commit(); } @Override public Usuario obtenerUsuario(Long idUsuario) { return manager.find(Usuario.class, idUsuario); } @Override public Usuario obtenerUsuarioPorCredenciales(String email,String contra) { Query query = manager.createQuery(\"SELECT u FROM Usuario u WHERE u.email = :email AND u.contrasena = :contra\"); query.setParameter(\"email\", email); query.setParameter(\"contra\", contra); Usuario usuario = (Usuario) query.getSingleResult(); return usuario; } @Override public List<Usuario> obtenerUsuariosClientes() { @SuppressWarnings(\"unchecked\") List<Usuario> clientes = (List<Usuario>) manager.createQuery(\"SELECT u FROM Usuario u\" + \" WHERE u.rol.descripcion = 'Cliente'\").getResultList(); return clientes; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/test/java/ar/edu/unju/escmi/poo/dominio/UsuarioTest.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "UsuarioTest directly instantiates UsuarioDaoImp and RolDaoImp (concrete classes) instead of depending solely on their abstractions (IUsuarioDao, IRolDao), violating DIP."}, {"principle": "Interface Segregation", "justification": "UsuarioTest depends on IRolDao but only uses buscarRolPorId, not agregarRol or buscarRoles, forcing dependency on unused methods."}, {"principle": "Interface Segregation", "justification": "UsuarioTest declares IUsuarioDao dependency but does not use any of its methods in the provided test, violating ISP."}]}]}
{"project_id": 93, "chunk_id": 0, "prompt": {"main_file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/test/java/ar/edu/unju/escmi/poo/dominio/DetalleTest.java", "main_file_content": "package ar.edu.unju.escmi.poo.dominio; import static org.junit.jupiter.api.Assertions.*; import java.util.ArrayList; import java.util.List; import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import ar.edu.unju.escmi.poo.dao.IProductoDao; import ar.edu.unju.escmi.poo.dao.imp.ProductoDaoImp; class DetalleTest { IProductoDao productoDao = new ProductoDaoImp(); List<Detalle> detalles; Producto producto; @BeforeEach void setUp() throws Exception { detalles = new ArrayList<Detalle>(); producto = new Producto(); } @AfterEach void tearDown() throws Exception { } @Test void testCalcularImporte() { producto = productoDao.obtenerProducto(12L); detalles.add(new Detalle(4,producto,producto.getPrecioUnitario()*4)); assertTrue(30000*4 == detalles.get(0).getImporte()); } }", "dependencies": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/IProductoDao.java", "file_content": "package ar.edu.unju.escmi.poo.dao; import java.util.List; import ar.edu.unju.escmi.poo.dominio.Producto; public interface IProductoDao { public void agregarProducto(Producto nuevoProducto); public void eliminarProducto(Producto producto); public List<Producto> obtenerProductos(); public Producto obtenerProducto(Long idProducto); }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/imp/ProductoDaoImp.java", "file_content": "package ar.edu.unju.escmi.poo.dao.imp; import java.util.List; import javax.persistence.EntityManager; import ar.edu.unju.escmi.poo.config.EmfSingleton; import ar.edu.unju.escmi.poo.dao.IProductoDao; import ar.edu.unju.escmi.poo.dominio.Producto; import ar.edu.unju.escmi.poo.dominio.Usuario; public class ProductoDaoImp implements IProductoDao{ private static EntityManager manager = EmfSingleton.getInstance().getEmf().createEntityManager(); @Override public void agregarProducto(Producto nuevoProducto) { try{ manager.getTransaction().begin(); manager.persist(nuevoProducto); manager.getTransaction().commit(); }catch(Exception e) { soutl(\"\") } } @Override public void eliminarProducto(Producto producto) { manager.getTransaction().begin(); manager.remove(producto); } @Override public List<Producto> obtenerProductos() { @SuppressWarnings(\"unchecked\") List<Producto> productos = (List<Producto>) manager.createQuery(\"SELECT p FROM Producto p\").getResultList(); return productos; } @Override public Producto obtenerProducto(Long idProducto) { return manager.find(Producto.class, idProducto); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/test/java/ar/edu/unju/escmi/poo/dominio/DetalleTest.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "DetalleTest directly instantiates ProductoDaoImp (concrete class) instead of depending solely on IProductoDao (abstraction). High-level test modules should not depend on low-level implementations."}, {"principle": "Interface Segregation", "justification": "IProductoDao contains methods (agregarProducto, eliminarProducto) unused by DetalleTest. Clients should not depend on interfaces with unused methods."}]}]}
{"project_id": 93, "chunk_id": 0, "prompt": {"main_file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/test/java/ar/edu/unju/escmi/poo/dominio/FacturaTest.java", "main_file_content": "package ar.edu.unju.escmi.poo.dominio; import static org.junit.jupiter.api.Assertions.*; import java.time.LocalDate; import java.util.ArrayList; import java.util.List; import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import ar.edu.unju.escmi.poo.dao.IFacturaDao; import ar.edu.unju.escmi.poo.dao.IProductoDao; import ar.edu.unju.escmi.poo.dao.IRolDao; import ar.edu.unju.escmi.poo.dao.IUsuarioDao; import ar.edu.unju.escmi.poo.dao.imp.FacturaDaoImp; import ar.edu.unju.escmi.poo.dao.imp.ProductoDaoImp; import ar.edu.unju.escmi.poo.dao.imp.RolDaoImp; import ar.edu.unju.escmi.poo.dao.imp.UsuarioDaoImp; class FacturaTest { IFacturaDao facturaDao = new FacturaDaoImp(); IUsuarioDao usuarioDao = new UsuarioDaoImp(); IRolDao rolDao = new RolDaoImp(); IProductoDao productoDao = new ProductoDaoImp(); Factura factura; List<Detalle> detalles; Usuario usuario; Producto producto; @BeforeEach void setUp() throws Exception { factura = new Factura(); usuario = new Usuario(); detalles = new ArrayList<Detalle>(); producto = new Producto(); } @AfterEach void tearDown() throws Exception { } @Test void testCalcularTotal() { usuario = usuarioDao.obtenerUsuario(2L); factura.setNumeroFactura(258); factura.setFecha(LocalDate.now()); Rol rol = new Rol(); rol.setDescripcion(rolDao.buscarRolPorId(2L).getDescripcion()); usuario.setRol(rol); factura.setUsuario(usuario); producto = productoDao.obtenerProducto(10L); detalles.add(new Detalle(3,producto,producto.getPrecioUnitario()*3)); factura.setDetalles(detalles); double obtenido = factura.calcularTotal(); assertTrue(obtenido != 0); } }", "dependencies": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/IFacturaDao.java", "file_content": "package ar.edu.unju.escmi.poo.dao; import java.util.List; import ar.edu.unju.escmi.poo.dominio.Factura; public interface IFacturaDao { public void agregarFactura(Factura nuevaFactura); public Factura buscarFacturaPorNumeroFactura(int nroFactura); public Factura obtenerFacturaPorIdYNumeroFactura(Long id, int nroFactura); public List<Factura> obtenerFacturas(); public List<Factura> obtenerFacturasPorId(Long id); public void eliminarFactura(Factura factura); public void modificarFactura(Factura factura); }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/IProductoDao.java", "file_content": "package ar.edu.unju.escmi.poo.dao; import java.util.List; import ar.edu.unju.escmi.poo.dominio.Producto; public interface IProductoDao { public void agregarProducto(Producto nuevoProducto); public void eliminarProducto(Producto producto); public List<Producto> obtenerProductos(); public Producto obtenerProducto(Long idProducto); }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/IRolDao.java", "file_content": "package ar.edu.unju.escmi.poo.dao; import java.util.List; import ar.edu.unju.escmi.poo.dominio.Rol; public interface IRolDao { public void agregarRol(Rol rol); public List<Rol> buscarRoles(); public Rol buscarRolPorId(Long id); }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/IUsuarioDao.java", "file_content": "package ar.edu.unju.escmi.poo.dao; import java.util.List; import ar.edu.unju.escmi.poo.dominio.Usuario; public interface IUsuarioDao { public void agregarUsuario(Usuario nuevoUsuario); public void eliminarUsuario(Usuario usuario); public List<Usuario> obtenerUsuarios(); public List<Usuario> obtenerUsuariosClientes(); public void modificarUsuario(Usuario usuario); public Usuario obtenerUsuario(Long idUsuario); public Usuario obtenerUsuarioPorCredenciales(String email,String contra); }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/imp/FacturaDaoImp.java", "file_content": "package ar.edu.unju.escmi.poo.dao.imp; import java.util.List; import javax.persistence.EntityManager; import javax.persistence.Query; import ar.edu.unju.escmi.poo.dao.IFacturaDao; import ar.edu.unju.escmi.poo.dominio.Factura; import ar.edu.unju.escmi.poo.config.EmfSingleton; public class FacturaDaoImp implements IFacturaDao{ private static EntityManager manager = EmfSingleton.getInstance().getEmf().createEntityManager(); @Override public void agregarFactura(Factura nuevaFactura) { try { manager.getTransaction().begin(); manager.persist(nuevaFactura); manager.getTransaction().commit(); }catch(Exception e) { soutl(\"\") } } @Override public Factura buscarFacturaPorNumeroFactura(int nroFactura) { Query query = manager.createQuery(\"SELECT f FROM Factura f\" + \" WHERE f.numeroFactura = :nroFactura\"); query.setParameter(\"nroFactura\", nroFactura); Factura factura = (Factura) query.getSingleResult(); return factura; } @Override public List<Factura> obtenerFacturas(){ @SuppressWarnings(\"unchecked\") List<Factura> facturas = (List<Factura>) manager.createQuery(\"SELECT f FROM Factura f\").getResultList(); return facturas; } @Override public List<Factura> obtenerFacturasPorId(Long id) { Query query = manager.createQuery(\"SELECT f FROM Factura f WHERE f.usuario.idUsuario = :id\"); query.setParameter(\"id\", id); @SuppressWarnings(\"unchecked\") List<Factura> facturas = (List<Factura>) query.getResultList(); return facturas; } @Override public Factura obtenerFacturaPorIdYNumeroFactura(Long id, int nroFactura) { Query query = manager.createQuery(\"SELECT f FROM Factura f WHERE f.usuario.idUsuario = :id AND f.numeroFactura = :nroFactura\"); query.setParameter(\"id\", id); query.setParameter(\"nroFactura\", nroFactura); Factura factura = (Factura) query.getSingleResult(); return factura; } @Override public void eliminarFactura(Factura factura) { manager.getTransaction().begin(); manager.remove(factura); manager.getTransaction().commit(); } @Override public void modificarFactura(Factura factura) { manager.getTransaction().begin(); manager.merge(factura); manager.getTransaction().commit(); } }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/imp/ProductoDaoImp.java", "file_content": "package ar.edu.unju.escmi.poo.dao.imp; import java.util.List; import javax.persistence.EntityManager; import ar.edu.unju.escmi.poo.config.EmfSingleton; import ar.edu.unju.escmi.poo.dao.IProductoDao; import ar.edu.unju.escmi.poo.dominio.Producto; import ar.edu.unju.escmi.poo.dominio.Usuario; public class ProductoDaoImp implements IProductoDao{ private static EntityManager manager = EmfSingleton.getInstance().getEmf().createEntityManager(); @Override public void agregarProducto(Producto nuevoProducto) { try{ manager.getTransaction().begin(); manager.persist(nuevoProducto); manager.getTransaction().commit(); }catch(Exception e) { soutl(\"\") } } @Override public void eliminarProducto(Producto producto) { manager.getTransaction().begin(); manager.remove(producto); } @Override public List<Producto> obtenerProductos() { @SuppressWarnings(\"unchecked\") List<Producto> productos = (List<Producto>) manager.createQuery(\"SELECT p FROM Producto p\").getResultList(); return productos; } @Override public Producto obtenerProducto(Long idProducto) { return manager.find(Producto.class, idProducto); } }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/imp/RolDaoImp.java", "file_content": "package ar.edu.unju.escmi.poo.dao.imp; import java.util.List; import javax.persistence.EntityManager; import ar.edu.unju.escmi.poo.config.EmfSingleton; import ar.edu.unju.escmi.poo.dao.IRolDao; import ar.edu.unju.escmi.poo.dominio.Rol; public class RolDaoImp implements IRolDao { private static EntityManager manager = EmfSingleton.getInstance().getEmf().createEntityManager(); @Override public List<Rol> buscarRoles() { return null; } @Override public Rol buscarRolPorId(Long id) { return manager.find(Rol.class,id); } @Override public void agregarRol(Rol rol) { try { manager.getTransaction().begin(); manager.persist(rol); manager.getTransaction().commit(); }catch(Exception e){ soutl(\"\") } } }"}, {"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/main/java/ar/edu/unju/escmi/poo/dao/imp/UsuarioDaoImp.java", "file_content": "package ar.edu.unju.escmi.poo.dao.imp; import java.util.List; import javax.persistence.EntityManager; import javax.persistence.Query; import ar.edu.unju.escmi.poo.config.EmfSingleton; import ar.edu.unju.escmi.poo.dao.IUsuarioDao; import ar.edu.unju.escmi.poo.dominio.Usuario; public class UsuarioDaoImp implements IUsuarioDao { private static EntityManager manager = EmfSingleton.getInstance().getEmf().createEntityManager(); @Override public void agregarUsuario(Usuario nuevoUsuario) { try { manager.getTransaction().begin(); manager.persist(nuevoUsuario); manager.getTransaction().commit(); }catch(Exception e) { soutl(\"\") } } @Override public void eliminarUsuario(Usuario usuario) { manager.getTransaction().begin(); manager.remove(usuario); manager.getTransaction().commit(); } @Override public List<Usuario> obtenerUsuarios() { @SuppressWarnings(\"unchecked\") List<Usuario> usuarios = (List<Usuario>) manager.createQuery(\"SELECT u FROM Usuario u\").getResultList(); return usuarios; } @Override public void modificarUsuario(Usuario usuario) { manager.getTransaction().begin(); manager.merge(usuario); manager.getTransaction().commit(); } @Override public Usuario obtenerUsuario(Long idUsuario) { return manager.find(Usuario.class, idUsuario); } @Override public Usuario obtenerUsuarioPorCredenciales(String email,String contra) { Query query = manager.createQuery(\"SELECT u FROM Usuario u WHERE u.email = :email AND u.contrasena = :contra\"); query.setParameter(\"email\", email); query.setParameter(\"contra\", contra); Usuario usuario = (Usuario) query.getSingleResult(); return usuario; } @Override public List<Usuario> obtenerUsuariosClientes() { @SuppressWarnings(\"unchecked\") List<Usuario> clientes = (List<Usuario>) manager.createQuery(\"SELECT u FROM Usuario u\" + \" WHERE u.rol.descripcion = 'Cliente'\").getResultList(); return clientes; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "TP_FINAL_GRUPO11_POO-master/TP_FINAL_GRUPO11_POO-master/tpfinalgrupo11/src/test/java/ar/edu/unju/escmi/poo/dominio/FacturaTest.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "FacturaTest directly instantiates concrete DAO implementations (FacturaDaoImp, UsuarioDaoImp, etc.) instead of depending on their abstractions (IFacturaDao, IUsuarioDao). High-level modules should depend on interfaces, not concrete classes."}]}]}
{"project_id": 94, "chunk_id": 0, "prompt": {"main_file_path": "Command_Line_Chess-master/Knight.java", "main_file_content": "package Chess; import java.text.DecimalFormat; public class Knight extends Piece{ public Knight(int color, Square location) { super(color,location); } @Override public boolean canMove(String to) { boolean validMove = false; Square targetLocation = location.getBoard().getSquareAt(to); int [] coordLoc = {location.row,location.col}; int [] coordTar = {targetLocation.row, targetLocation.col}; int locRow = coordLoc[0]; int locCol = coordLoc[1]; int tarRow = coordTar[0]; int tarCol = coordTar[1]; double distance = Math.sqrt(Math.pow((tarRow - locRow),2) + Math.pow((tarCol - locCol),2)); String dist = new DecimalFormat(\"##.##\").format(distance); String str224 = new DecimalFormat(\"##.##\").format(2.23607); if(dist.equals(str224)){ Square [] between = location.getBoard().getSquaresBetweenForKnight(location,targetLocation); for (Square square : between){ validMove = square.isEmpty(); } if(!validMove){ if(targetLocation.getPiece() != null && targetLocation.getPiece().isEnemy(this)) validMove = true; } return validMove; } return false; } @Override public String toString() { return color == 0 ? \"N\":\"n\"; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Command_Line_Chess-master/Knight.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "Knight directly depends on concrete classes Square and Board (via location.getBoard()). High-level modules (e.g., Piece subclasses) should depend on abstractions, not low-level implementations."}]}]}
{"project_id": 94, "chunk_id": 0, "prompt": {"main_file_path": "Command_Line_Chess-master/Rook.java", "main_file_content": "package Chess; import java.util.Arrays; public class Rook extends Piece{ public Rook(int color, Square location) { super(color,location); } @Override public String toString() { return color == 0 ? \"R\":\"r\"; } @Override public boolean canMove(String to) { boolean validMove = false; Square targetLocation = location.getBoard().getSquareAt(to); Square [] between = location.getBoard().getSquaresBetween(location,targetLocation); if(location.isAtSameRow(targetLocation) || location.isAtSameColumn(targetLocation)){ for (int i = 0; i<between.length-1; i++){ validMove = between[i].isEmpty(); if(!validMove) break; } if(validMove){ if(targetLocation.getPiece() != null && targetLocation.getPiece().isEnemy(this)) validMove = true; Square[] betweenWithoutTarget = Arrays.copyOfRange(between, 1, between.length); int index =0; int i; for (Square square : betweenWithoutTarget){ validMove = square.isEmpty(); int [] validArray = new int[betweenWithoutTarget.length]; if(validMove) i = 0; else i = 1; validArray[index] = i; index++; for (int value : validArray) if (value == 1) { validMove = false; break; } } } return validMove; } return false; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Command_Line_Chess-master/Rook.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "The Rook class directly depends on concrete classes Square and Board (via location.getBoard()) instead of abstractions. High-level modules like Rook should depend on interfaces/abstract classes rather than concrete implementations."}]}]}
{"project_id": 94, "chunk_id": 0, "prompt": {"main_file_path": "Command_Line_Chess-master/Bishop.java", "main_file_content": "package Chess; public class Bishop extends Piece{ public Bishop(int color, Square location) { super(color,location); } @Override public boolean canMove(String to) { boolean validMove = false; Square targetLocation = location.getBoard().getSquareAt(to); Square [] between = location.getBoard().getSquaresBetween(location,targetLocation); if(this.location.isAtSameDiagonal(targetLocation)){ for (Square square : between){ validMove = square.isEmpty(); } if(!validMove){ if(targetLocation.getPiece() != null && targetLocation.getPiece().isEnemy(this)) validMove = true; } return validMove; } return false; } @Override public String toString() { return color == 0 ? \"B\":\"b\"; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Command_Line_Chess-master/Bishop.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "Bishop directly depends on concrete Square class (via location.getBoard()) for movement logic. High-level piece logic should depend on abstractions for board/square interactions."}]}]}
{"project_id": 94, "chunk_id": 0, "prompt": {"main_file_path": "Command_Line_Chess-master/Queen.java", "main_file_content": "package Chess; public class Queen extends Piece{ public Queen(int color, Square location) { super(color,location); } @Override public boolean canMove(String to) { boolean validMove = false; Square targetLocation = location.getBoard().getSquareAt(to); Square [] between = location.getBoard().getSquaresBetween(location,targetLocation); if(this.location.isAtSameColumn(targetLocation) || this.location.isAtSameRow(targetLocation) || this.location.isAtSameDiagonal(targetLocation)){ for (Square square : between){ validMove = square.isEmpty(); } if(!validMove){ if(targetLocation.getPiece() != null && targetLocation.getPiece().isEnemy(this)) validMove = true; } return validMove; } return false; } @Override public String toString() { return color == 0 ? \"Q\":\"q\"; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Command_Line_Chess-master/Queen.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "Queen (high-level module) directly depends on concrete Square and Board classes instead of abstractions. Low-level modules like Square/Board should implement abstractions referenced by high-level modules."}]}]}
{"project_id": 94, "chunk_id": 0, "prompt": {"main_file_path": "Command_Line_Chess-master/King.java", "main_file_content": "package Chess; public class King extends Piece{ public King(int color, Square location) { super(color,location); } @Override public String toString() { return color == 0 ? \"K\":\"k\"; } @Override public boolean canMove(String to) { boolean validMove; Square targetLocation = location.getBoard().getSquareAt(to); Square[] between = location.getBoard().getSquaresBetween(location,targetLocation); validMove = targetLocation.isEmpty() && between.length == 1; if(!validMove && between.length == 1){ if(targetLocation.getPiece() != null && targetLocation.getPiece().isEnemy(this)) validMove = true; } return validMove; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Command_Line_Chess-master/King.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "King directly references concrete Board and Square classes instead of depending on abstractions. High-level modules (King) should not depend on low-level implementation details."}]}]}
{"project_id": 94, "chunk_id": 0, "prompt": {"main_file_path": "Command_Line_Chess-master/Main.java", "main_file_content": "package Chess; import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner reader = new Scanner(System.in); ChessBoard board = new ChessBoard(); soutl(\"\") while(!board.isGameEnded()){ soutl(\"\") Piece piece = null; do { sout(\"\") String from = reader.next(); piece = board.getPieceAt(from); soutl(\"\") }while(piece == null || piece.getColor()!=(board.isWhitePlaying() ? ChessBoard.WHITE : ChessBoard.BLACK)); String to = null; do { sout(\"\") to = reader.next(); }while(!piece.canMove(to)); piece.move(to); soutl(\"\") } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Command_Line_Chess-master/Main.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Main class handles user input, game loop control, piece movement validation, and board interactions, consolidating multiple responsibilities beyond coordinating program execution."}, {"principle": "Dependency Inversion", "justification": "Main directly instantiates and depends on concrete ChessBoard and Piece implementations without abstractions, making high-level game logic dependent on low-level modules."}]}]}
{"project_id": 94, "chunk_id": 0, "prompt": {"main_file_path": "Command_Line_Chess-master/ChessBoard.java", "main_file_content": "package Chess; import java.util.ArrayList; import java.util.Hashtable; public class ChessBoard { public static int BLACK = 1; public static int WHITE = 0; boolean isWhite; private int whitePieces = 16; private int blackPieces = 16; public Square[][] board2d = new Square[8][8]; public Hashtable<Character, Integer> abcHashtable = new Hashtable<Character, Integer>(); public ChessBoard(){ this.isWhite = true; for(int row = 0; row < 8; row++){ for (int col = 0 ; col <8; col++){ board2d[row][col] = new Square(row,col,this); } } for(int col = 0; col<8; col++) { new Pawn(WHITE, board2d[6][col]); new Pawn(BLACK, board2d[1][col]); } for(int col = 0; col<8; col+=7){ new Rook(WHITE,board2d[7][col]); new Rook(BLACK,board2d[0][col]); } new King(WHITE,board2d[7][4]); new King(BLACK,board2d[0][4]); new Queen(WHITE,board2d[7][3]); new Queen(BLACK,board2d[0][3]); for(int col = 2; col<6; col+=3){ new Bishop(WHITE,board2d[7][col]); new Bishop(BLACK,board2d[0][col]); } for(int col = 1; col<7; col+=5){ new Knight(WHITE,board2d[7][col]); new Knight(BLACK,board2d[0][col]); } createHashtable(); } public void decrementPiece(int color){ if(color == WHITE) this.whitePieces--; this.blackPieces--; } @Override public String toString() { String brdStr = \"\"; brdStr += \" A B C D E F G H \\n\"; brdStr += \" \\n\"; for (int row = 0; row < 8; ++row){ brdStr += 8-row + \" \"; for (int col = 0; col < 8; ++col){ brdStr += \"|\"; brdStr += \" \" + board2d[row][col] + \" \"; if (col == 7) brdStr += \"| \"; } brdStr += 8 - row + \" \\n\"; brdStr += \" \\n\"; } brdStr += \" A B C D E F G H \\n\"; return brdStr; } public boolean isGameEnded() { return (whitePieces == 0 || blackPieces == 0); } public boolean isWhitePlaying() { return isWhite; } public Piece getPieceAt(String from) { int [] coordinates = getCoordinates(from); return board2d[coordinates[0]][coordinates[1]].piece; } public int[] getCoordinates(String from) { from = from.toLowerCase(); char colChar = from.charAt(0); char rowChar = from.charAt(1); int row = 8 - Integer.parseInt(String.valueOf(rowChar)) ; int col = abcHashtable.get(colChar); return new int[]{row, col}; } private void createHashtable(){ abcHashtable.put('a',0); abcHashtable.put('b',1); abcHashtable.put('c',2); abcHashtable.put('d',3); abcHashtable.put('e',4); abcHashtable.put('f',5); abcHashtable.put('g',6); abcHashtable.put('h',7); } public Square getSquareAt(String to) { int [] coordinates = getCoordinates(to); return board2d[coordinates[0]][coordinates[1]]; } public Square[] getSquaresBetween(Square location, Square targetLocation) { Square [] btw; if(location.isAtSameDiagonal(targetLocation) || location.isAtSameColumn(targetLocation) || location.isAtSameRow(targetLocation)) { int [] coordLoc = {location.row,location.col}; int [] coordTar = {targetLocation.row, targetLocation.col}; int x1 = coordLoc[0]; int y1 = coordLoc[1]; int x2 = coordTar[0]; int y2 = coordTar[1]; btw = new Square[Math.max(Math.abs(x1-x2),Math.abs(y1-y2))]; Square [] squaresReversed = new Square[btw.length]; if(location.isAtSameRow(targetLocation)){ if(y2>y1){ btw = new Square[y2-y1]; int index = 0; for(int i=y1+1; i<=y2; i++){ btw[index]=board2d[x1][i]; index++; } }else{ btw = new Square[y1-y2]; int index = 0; for(int i=y1-1; i>=y2; i--){ btw[index]=board2d[x1][i]; index++; } } } else if(location.isAtSameColumn(targetLocation)){ if(x2>x1){ btw = new Square[x2-x1]; int index = 0; for(int i = x1+1; i<=x2;i++){ btw[index]=board2d[i][y1]; index++; } }else{ btw = new Square[x1-x2]; int index = 0; for(int i=x1-1; i>=x2; i--){ btw[index]=board2d[i][y1]; index++; } } } else{ if(x1>x2){ btw = new Square[x1-x2]; if(y2>y1){ x1 = x1-1; y1 = y1+1; for(int i = 0; i<btw.length;i++){ btw[i] = board2d[x1][y1]; x1--; y1++; } }else{ x1 = x1-1; y1 = y1-1; for(int i = 0; i<btw.length;i++){ btw[i] = board2d[x1][y1]; x1--; y1--; } } }else{ btw = new Square[x2-x1]; if (y1 > y2) { x1=x1+1; y1=y1-1; for(int i = 0; i<btw.length ; i++){ btw[i] = board2d[x1][y1]; x1++; y1--; } }else{ x1=x1+1; y1=y1+1; for(int i = 0; i<btw.length; i++){ btw[i] = board2d[x1][y1]; x1++; y1++; } } } } squaresReversed = new Square[btw.length]; int j = btw.length; for(int t = 0; t<btw.length; t++){ squaresReversed[j-1] = btw[t]; j = j -1; } return squaresReversed; } return new Square[0]; } public void nextPlayer() { isWhite = !isWhite; } public Square[] getSquaresBetweenForKnight(Square location, Square targetLocation) { Square [] squares = new Square[2]; int [] coordLoc = {location.row,location.col}; int [] coordTar = {targetLocation.row, targetLocation.col}; int locRow = coordLoc[0]; int locCol = coordLoc[1]; int tarRow = coordTar[0]; int tarCol = coordTar[1]; squares[1]=targetLocation; if(tarCol<locCol){ if(tarRow<locRow) squares[0] = board2d[tarRow][tarCol+1]; if(tarRow>locRow) squares[0] = board2d[tarRow-1][tarCol]; } else{ if(tarRow<locRow) squares[0] = board2d[tarRow][tarCol-1]; if(tarRow>locRow) squares[0] = board2d[tarRow-1][tarCol]; } return squares; } }", "dependencies": [{"file_path": "Command_Line_Chess-master/Square.java", "file_content": "package Chess; public class Square { public Piece piece; int row; int col; ChessBoard boardClass; public Square(int row, int col, ChessBoard boardClass) { this.row = row; this.col = col; this.boardClass = boardClass; } @Override public String toString() { return this.piece == null ? \" \": this.piece.toString(); } public void setPiece(Piece piece) { if(this.piece != null){ boardClass.decrementPiece(this.piece.getColor()); } this.piece = piece; } public ChessBoard getBoard() { return this.boardClass; } public int getRowDistance(Square location, int color) { return color == ChessBoard.WHITE ? Math.abs(this.row - location.row) : location.row - this.row; } public boolean isAtSameColumn(Square targetLocation) { return this.col == targetLocation.col; } public boolean isAtSameDiagonal(Square targetLocation) { return (Math.abs(this.row - targetLocation.row ) == Math.abs(this.col - targetLocation.col)); } public boolean isAtSameRow(Square targetLocation) { return this.row == targetLocation.row; } public boolean isEmpty() { return this.piece == null; } public boolean isNeighbourColumn(Square targetLocation) { return Math.abs(this.col - targetLocation.col) == 1; } public Piece getPiece() { return this.piece; } public boolean isAtLastRow(int color) { return ((color == ChessBoard.WHITE) ? (this.row == 0) : (this.row == 7)); } public void putNewQueen(int color) { this.piece = new Queen(color,this); } public void clear() { this.piece = null; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Command_Line_Chess-master/ChessBoard.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "ChessBoard manages board initialization, piece creation, game state (turn, piece counts), coordinate conversion, and string representation. These multiple responsibilities violate SRP, as it has multiple reasons to change."}, {"principle": "Open-Closed", "justification": "Adding a new piece type requires modifying ChessBoard's constructor to instantiate the new class. This violates OCP, as the class is not open for extension without modification."}, {"principle": "Dependency Inversion", "justification": "ChessBoard directly instantiates concrete Piece subclasses (e.g., Pawn, Rook) instead of depending on abstractions. High-level modules should not depend on low-level concrete implementations."}]}, {"file_path": "Command_Line_Chess-master/Square.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "Square directly references the concrete ChessBoard class in its field and methods. Low-level modules (Square) should not depend on high-level concrete modules (ChessBoard)."}]}]}
{"project_id": 94, "chunk_id": 0, "prompt": {"main_file_path": "Command_Line_Chess-master/Piece.java", "main_file_content": "package Chess; public abstract class Piece { public int color; public Square location; public Piece(int color, Square location){ this.color = color; this.location = location; this.location.setPiece(this); } public int getColor(){ return this.color; } public abstract boolean canMove(String to); public void move(String to){ Square targetLocation = location.getBoard().getSquareAt(to); targetLocation.setPiece(this); location.clear(); location = targetLocation; location.getBoard().nextPlayer(); } protected boolean isEnemy(Piece p) { return !(this.color == p.color); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Command_Line_Chess-master/Piece.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Piece class manages its state, movement logic, and directly triggers game flow (nextPlayer()), handling multiple responsibilities that could change independently."}, {"principle": "Dependency Inversion", "justification": "Piece directly depends on concrete classes Square and Board (via location.getBoard()) instead of abstractions, violating the requirement for high-level modules to depend on abstractions."}]}]}
{"project_id": 94, "chunk_id": 0, "prompt": {"main_file_path": "Command_Line_Chess-master/Pawn.java", "main_file_content": "package Chess; public class Pawn extends Piece{ public static boolean initialLocation = true; public static int count = 0; public Pawn(int color, Square location) { super(color,location); } @Override public boolean canMove(String to) { boolean validMove = false; Square targetLocation = location.getBoard().getSquareAt(to); int rowDistance = targetLocation.getRowDistance(location,this.color); if (this.location.isAtSameColumn(targetLocation)){ if(color == ChessBoard.WHITE && rowDistance > 0 && rowDistance <= 2){ if(rowDistance == 2){ if(initialLocation){ Square[] between = location.getBoard().getSquaresBetween(location,targetLocation); validMove = targetLocation.isEmpty() && between[0].isEmpty(); } } else{ validMove =targetLocation.isEmpty(); } return validMove; }else if( color == ChessBoard.BLACK && rowDistance < 0 && rowDistance >= -2){ if(rowDistance == -2){ if(initialLocation){ Square[] between = location.getBoard().getSquaresBetween(location,targetLocation); validMove = targetLocation.isEmpty() && between[0].isEmpty(); } }else{ validMove = targetLocation.isEmpty(); } } }else if(this.location.isNeighbourColumn(targetLocation)){ if(color == ChessBoard.WHITE && rowDistance == 1){ validMove = !targetLocation.isEmpty() && targetLocation.getPiece().getColor() == ChessBoard.BLACK; }else if (color == ChessBoard.BLACK && rowDistance == -1){ validMove = !targetLocation.isEmpty() && targetLocation.getPiece().getColor() == ChessBoard.WHITE; } } return validMove; } @Override public void move(String to) { Square targetLocation = location.getBoard().getSquareAt(to); if (targetLocation.isAtLastRow(color)) { targetLocation.putNewQueen(color); }else{ targetLocation.setPiece(this); } location.clear(); location = targetLocation; location.getBoard().nextPlayer(); count++; if (count > 1) initialLocation = false; } @Override public String toString() { return color == 0 ? \"P\":\"p\"; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Command_Line_Chess-master/Pawn.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Pawn class handles both movement validation (canMove) and promotion logic (move), violating SRP by managing multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Adding new pawn behaviors (e.g., movement rules) requires modifying the existing Pawn class instead of extending it, violating OCP."}, {"principle": "Dependency Inversion", "justification": "Pawn directly depends on concrete classes like ChessBoard and Square, and creates a Queen directly in move(), violating DIP by not depending on abstractions."}]}]}
{"project_id": 94, "chunk_id": 0, "prompt": {"main_file_path": "Command_Line_Chess-master/Square.java", "main_file_content": "package Chess; public class Square { public Piece piece; int row; int col; ChessBoard boardClass; public Square(int row, int col, ChessBoard boardClass) { this.row = row; this.col = col; this.boardClass = boardClass; } @Override public String toString() { return this.piece == null ? \" \": this.piece.toString(); } public void setPiece(Piece piece) { if(this.piece != null){ boardClass.decrementPiece(this.piece.getColor()); } this.piece = piece; } public ChessBoard getBoard() { return this.boardClass; } public int getRowDistance(Square location, int color) { return color == ChessBoard.WHITE ? Math.abs(this.row - location.row) : location.row - this.row; } public boolean isAtSameColumn(Square targetLocation) { return this.col == targetLocation.col; } public boolean isAtSameDiagonal(Square targetLocation) { return (Math.abs(this.row - targetLocation.row ) == Math.abs(this.col - targetLocation.col)); } public boolean isAtSameRow(Square targetLocation) { return this.row == targetLocation.row; } public boolean isEmpty() { return this.piece == null; } public boolean isNeighbourColumn(Square targetLocation) { return Math.abs(this.col - targetLocation.col) == 1; } public Piece getPiece() { return this.piece; } public boolean isAtLastRow(int color) { return ((color == ChessBoard.WHITE) ? (this.row == 0) : (this.row == 7)); } public void putNewQueen(int color) { this.piece = new Queen(color,this); } public void clear() { this.piece = null; } }", "dependencies": [{"file_path": "Command_Line_Chess-master/Queen.java", "file_content": "package Chess; public class Queen extends Piece{ public Queen(int color, Square location) { super(color,location); } @Override public boolean canMove(String to) { boolean validMove = false; Square targetLocation = location.getBoard().getSquareAt(to); Square [] between = location.getBoard().getSquaresBetween(location,targetLocation); if(this.location.isAtSameColumn(targetLocation) || this.location.isAtSameRow(targetLocation) || this.location.isAtSameDiagonal(targetLocation)){ for (Square square : between){ validMove = square.isEmpty(); } if(!validMove){ if(targetLocation.getPiece() != null && targetLocation.getPiece().isEnemy(this)) validMove = true; } return validMove; } return false; } @Override public String toString() { return color == 0 ? \"Q\":\"q\"; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Command_Line_Chess-master/Square.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Square manages state, movement checks, and piece creation (putNewQueen), violating single responsibility."}, {"principle": "Open-Closed", "justification": "Adding new piece types requires modifying Square (e.g., new putNewX methods), not closed for extension."}, {"principle": "Dependency Inversion", "justification": "Square depends on concrete ChessBoard and instantiates Queen directly, instead of abstractions."}]}]}
{"project_id": 98, "chunk_id": 0, "prompt": {"main_file_path": "Random_Password_Generator-master/src/RandomPasswordGenerator.java", "main_file_content": "import javax.swing.*; import java.awt.*; import java.awt.datatransfer.Clipboard; import java.awt.datatransfer.StringSelection; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.util.Random; public class RandomPasswordGenerator { private JPanel RandomPasswordGenerator; private JButton generateButton; private JButton copyButton; private JTextField passwordField; private JTextField lengthField; public RandomPasswordGenerator() { generateButton.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { try { int len = Integer.parseInt(lengthField.getText()); if (len < 8 || len > 12) { JOptionPane.showMessageDialog(null, \"Please enter a length between 8 and 12\"); return; } Random random = new Random(); String chars = \"1234567890QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm./?!@#$%&*\"; char[] pass = new char[len]; int len1 = chars.length(); for (int i = 0; i < len; i++) { pass[i] = chars.charAt(random.nextInt(len1)); } passwordField.setText(new String(pass)); } catch (NumberFormatException ex) { JOptionPane.showMessageDialog(null, \"Please enter a valid number\"); } } }); copyButton.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String password = passwordField.getText(); StringSelection stringSelection = new StringSelection(password); Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard(); clipboard.setContents(stringSelection, null); JOptionPane.showMessageDialog(null, \"Password copied to clipboard\"); } }); } public static void main(String[] args) { JFrame frame = new JFrame(\"Random Password Generator\"); ImageIcon icon = new ImageIcon(\"src/icon.png\"); Image originalImage = icon.getImage(); Image resizedImage = originalImage.getScaledInstance(30, 30, Image.SCALE_SMOOTH); frame.setIconImage(resizedImage); frame.setContentPane(new RandomPasswordGenerator().RandomPasswordGenerator); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.pack(); frame.setVisible(true); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Random_Password_Generator-master/src/RandomPasswordGenerator.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The RandomPasswordGenerator class handles UI setup, password generation logic, and clipboard operations, violating SRP by managing multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Password generation logic is hardcoded in the class; extending it (e.g., adding new character sets) requires modifying existing code instead of overriding or extending abstractions."}, {"principle": "Dependency Inversion", "justification": "The class directly depends on concrete UI components (e.g., JButton, JTextField) and password generation logic without abstractions, violating DIP for high-level modules."}]}]}
{"project_id": 101, "chunk_id": 0, "prompt": {"main_file_path": "MultiThreading-master/src/Application.java", "main_file_content": "public class Application { public static void main(String[] args) { long x = 100000000 ; x = x*(x+1)/2 ; soutl(\"\") sout(\"\") soutl(\"\") Sum object1 = new Sum () ; Sum object2 = new Sum () ; Sum object3 = new Sum () ; Sum object4 = new Sum () ; Task t = new Task(object1 , 25000000 , 0) ; t.start(); Task t2 = new Task(object2 , 50000000 , 25000001) ; t2.start(); Task t3 = new Task(object3 , 75000000 , 50000001 ) ; t3.start(); Task t4 = new Task(object4 , 100000000 , 75000001) ; t4.start(); sout(\"\") soutl(\"\") try { t.join(); t2.join(); t3.join(); t4.join(); long total = object1.getSum() + object2.getSum() + object3.getSum() + object4.getSum() ; soutl(\"\") sout(\"\") soutl(\"\") } catch (Exception e) { e.printStackTrace(); } } }", "dependencies": [{"file_path": "MultiThreading-master/src/Sum.java", "file_content": "public class Sum { private long sum; public long getSum() { return sum ; } public void setSum(long sum) { this.sum = sum ; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "MultiThreading-master/src/Application.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Application class's main method handles thread management, task configuration, result aggregation, and I/O operations, indicating multiple responsibilities."}, {"principle": "Dependency Inversion", "justification": "Application directly instantiates concrete Task and Sum classes instead of depending on abstractions, coupling high-level modules to low-level implementations."}]}]}
{"project_id": 101, "chunk_id": 0, "prompt": {"main_file_path": "MultiThreading-master/src/FileClass.java", "main_file_content": "import java.io.*; public class FileClass { synchronized public void fileWriting(String n) throws IOException { String str = \"Thread \" + n + \" started writing \\n\"; String str2 = \"Thread \" + n + \" currently writing\\n\"; String str3 = \"Thread \" + n + \" finished writing\\n\"; File file = new File(\"Sharable.txt\"); FileOutputStream outputStream = new FileOutputStream(file , true); byte[] strToBytes = str.getBytes(); byte[] strToBytes2 = str2.getBytes(); byte[] strToBytes3 = str3.getBytes(); outputStream.write(strToBytes); outputStream.write(strToBytes2); outputStream.write(strToBytes3); outputStream.close(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "MultiThreading-master/src/FileClass.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "FileClass handles message construction, file operations, and byte conversion. These are multiple responsibilities that could change independently."}, {"principle": "Open-Closed", "justification": "FileClass cannot be extended to modify file writing behavior without altering its existing code. No abstractions allow new implementations."}]}]}
{"project_id": 101, "chunk_id": 0, "prompt": {"main_file_path": "MultiThreading-master/src/Sum.java", "main_file_content": "public class Sum { private long sum; public long getSum() { return sum ; } public void setSum(long sum) { this.sum = sum ; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "MultiThreading-master/src/Sum.java", "violatedPrinciples": []}]}
{"project_id": 101, "chunk_id": 0, "prompt": {"main_file_path": "MultiThreading-master/src/Task.java", "main_file_content": "public class Task extends Thread { private int upper ; private int lower ; private Sum sumValue ; public Task(Sum sumValue , int upper , int lower ) { this.upper= upper ; this.lower = lower ; this.sumValue = sumValue ; } public void run() { long sum = 0 ; for(int i=lower ; i<=upper ; i++) { sum += i ; } sumValue.setSum(sum); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "MultiThreading-master/src/Task.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Task class handles both thread execution (inheriting Thread) and sum calculation logic, introducing multiple reasons to change."}, {"principle": "Dependency Inversion", "justification": "Task directly depends on concrete Sum class instead of an abstraction, making high-level logic dependent on low-level implementation."}]}]}
{"project_id": 101, "chunk_id": 0, "prompt": {"main_file_path": "MultiThreading-master/src/Task2.java", "main_file_content": "public class Task2 extends Thread { public void run(){ Thread.currentThread().setName(\"Thread 1 \"); try{ Thread.sleep(1500); } catch(InterruptedException e){ soutl(\"\") } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "MultiThreading-master/src/Task2.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Task2 class handles both thread configuration (setting name) and task execution (sleeping). These are separate responsibilities that could change independently, violating SRP."}]}]}
{"project_id": 101, "chunk_id": 0, "prompt": {"main_file_path": "MultiThreading-master/src/Application2.java", "main_file_content": "public class Application2 { public static void main(String[] args) { FileClass f = new FileClass () ; FileTask t = new FileTask(f , \"x\" ); t.start(); FileTask t2 = new FileTask(f , \"y\" ); t2.start(); FileTask t3 = new FileTask(f , \"z\" ); t3.start(); } }", "dependencies": [{"file_path": "MultiThreading-master/src/FileClass.java", "file_content": "import java.io.*; public class FileClass { synchronized public void fileWriting(String n) throws IOException { String str = \"Thread \" + n + \" started writing \\n\"; String str2 = \"Thread \" + n + \" currently writing\\n\"; String str3 = \"Thread \" + n + \" finished writing\\n\"; File file = new File(\"Sharable.txt\"); FileOutputStream outputStream = new FileOutputStream(file , true); byte[] strToBytes = str.getBytes(); byte[] strToBytes2 = str2.getBytes(); byte[] strToBytes3 = str3.getBytes(); outputStream.write(strToBytes); outputStream.write(strToBytes2); outputStream.write(strToBytes3); outputStream.close(); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "MultiThreading-master/src/FileClass.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "FileClass handles both message construction and file I/O operations, which are two distinct responsibilities. Changes to message formatting or file handling logic would require modifications to the same class."}]}, {"file_path": "MultiThreading-master/src/Application2.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "Application2 directly instantiates and depends on the concrete FileClass. High-level modules should depend on abstractions, not concrete implementations."}]}]}
{"project_id": 101, "chunk_id": 0, "prompt": {"main_file_path": "MultiThreading-master/src/Application3.java", "main_file_content": "public class Application3 { public static void main(String [] args) { Task2 t = new Task2() ; Task3 t2 = new Task3() ; t.start(); t2.start(); soutl(\"\") soutl(\"\") t.interrupt(); t2.interrupt(); soutl(\"\") soutl(\"\") try { t.join(); t2.join(); } catch (InterruptedException e) { soutl(\"\") } soutl(\"\") soutl(\"\") } }", "dependencies": [{"file_path": "MultiThreading-master/src/Task2.java", "file_content": "public class Task2 extends Thread { public void run(){ Thread.currentThread().setName(\"Thread 1 \"); try{ Thread.sleep(1500); } catch(InterruptedException e){ soutl(\"\") } } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "MultiThreading-master/src/Application3.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "Application3 directly instantiates concrete Task2 and Task3 classes. High-level modules should depend on abstractions rather than concrete implementations."}]}]}
{"project_id": 101, "chunk_id": 0, "prompt": {"main_file_path": "MultiThreading-master/src/Task3.java", "main_file_content": "public class Task3 extends Thread { public void run(){ Thread.currentThread().setName(\"Thread 2 \"); for(int i=0; i<5; i++){ soutl(\"\") if (Thread.interrupted()) { soutl(\"\") } } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "MultiThreading-master/src/Task3.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Task3 handles both thread configuration (setting name) and task execution logic (printing loop). Changes to thread setup or business logic would require modifying the same class, violating SRP."}]}]}
{"project_id": 101, "chunk_id": 0, "prompt": {"main_file_path": "MultiThreading-master/src/FileTask.java", "main_file_content": "public class FileTask extends Thread { FileClass fileC ; String name ; FileTask(FileClass fileC , String name){ this.fileC = fileC ; this.name = name ; } public void run() { try { fileC.fileWriting(name); } catch (Exception e) { e.printStackTrace(); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "MultiThreading-master/src/FileTask.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "FileTask handles both thread execution (inheriting Thread) and file operation delegation, introducing multiple responsibilities. Changes to threading logic or file handling would require modifying the class."}, {"principle": "Dependency Inversion", "justification": "FileTask directly depends on concrete FileClass. High-level threading policy should depend on abstractions (e.g., an interface) for file operations, not a concrete implementation."}]}]}
{"project_id": 102, "chunk_id": 0, "prompt": {"main_file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkContext.java", "main_file_content": "package org.jeasy.flows.work; import java.util.Map; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; public class WorkContext { private final Map<String, Object> context = new ConcurrentHashMap<>(); public void put(String key, Object value) { context.put(key, value); } public Object get(String key) { return context.get(key); } public Set<Map.Entry<String, Object>> getEntrySet() { return context.entrySet(); } @Override public String toString() { return \"context=\" + context + '}'; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkContext.java", "violatedPrinciples": []}]}
{"project_id": 102, "chunk_id": 0, "prompt": {"main_file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/NoOpWork.java", "main_file_content": "package org.jeasy.flows.work; import java.util.UUID; public class NoOpWork implements Work { @Override public String getName() { return UUID.randomUUID().toString(); } @Override public WorkReport execute(WorkContext workContext) { return new DefaultWorkReport(WorkStatus.COMPLETED, workContext); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/NoOpWork.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "NoOpWork directly instantiates DefaultWorkReport, a concrete class, instead of depending on an abstraction (WorkReport interface). High-level modules should not depend on low-level implementations."}]}]}
{"project_id": 102, "chunk_id": 0, "prompt": {"main_file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkReportPredicate.java", "main_file_content": "package org.jeasy.flows.work; import java.util.concurrent.atomic.AtomicInteger; @FunctionalInterface public interface WorkReportPredicate { boolean apply(WorkReport workReport); WorkReportPredicate ALWAYS_TRUE = workReport -> true; WorkReportPredicate ALWAYS_FALSE = workReport -> false; WorkReportPredicate COMPLETED = workReport -> workReport.getStatus().equals(WorkStatus.COMPLETED); WorkReportPredicate FAILED = workReport -> workReport.getStatus().equals(WorkStatus.FAILED); class TimesPredicate implements WorkReportPredicate { private final int times; private final AtomicInteger counter = new AtomicInteger(); public TimesPredicate(int times) { this.times = times; } @Override public boolean apply(WorkReport workReport) { return counter.incrementAndGet() != times; } public static TimesPredicate times(int times) { return new TimesPredicate(times); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 102, "chunk_id": 0, "prompt": {"main_file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkStatus.java", "main_file_content": "package org.jeasy.flows.work; public enum WorkStatus { FAILED, COMPLETED }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 102, "chunk_id": 0, "prompt": {"main_file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/Work.java", "main_file_content": "package org.jeasy.flows.work; import java.util.UUID; public interface Work { default String getName() { return UUID.randomUUID().toString(); } WorkReport execute(WorkContext workContext); }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/Work.java", "violatedPrinciples": [{"principle": "Interface Segregation", "justification": "The Work interface includes the getName() method, which may not be needed by all clients. Clients depending on this interface are forced to depend on this method even if they only use execute(), violating ISP."}, {"principle": "Dependency Inversion", "justification": "The execute() method depends on the concrete WorkContext class. High-level modules should depend on abstractions, not concrete implementations, violating DIP."}]}]}
{"project_id": 102, "chunk_id": 0, "prompt": {"main_file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/DefaultWorkReport.java", "main_file_content": "package org.jeasy.flows.work; public class DefaultWorkReport implements WorkReport { private final WorkStatus status; private final WorkContext workContext; private Throwable error; public DefaultWorkReport(WorkStatus status, WorkContext workContext) { this.status = status; this.workContext = workContext; } public DefaultWorkReport(WorkStatus status, WorkContext workContext, Throwable error) { this(status, workContext); this.error = error; } public WorkStatus getStatus() { return status; } public Throwable getError() { return error; } @Override public WorkContext getWorkContext() { return workContext; } @Override public String toString() { return \"DefaultWorkReport {\" + \"status=\" + status + \", context=\" + workContext + \", error=\" + (error == null ? \"''\" : error) + '}'; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/DefaultWorkReport.java", "violatedPrinciples": []}]}
{"project_id": 102, "chunk_id": 0, "prompt": {"main_file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkReport.java", "main_file_content": "package org.jeasy.flows.work; public interface WorkReport { WorkStatus getStatus(); Throwable getError(); WorkContext getWorkContext(); }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkReport.java", "violatedPrinciples": []}]}
{"project_id": 102, "chunk_id": 0, "prompt": {"main_file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/workflow/ConditionalFlow.java", "main_file_content": "package org.jeasy.flows.workflow; import org.jeasy.flows.work.NoOpWork; import org.jeasy.flows.work.Work; import org.jeasy.flows.work.WorkContext; import org.jeasy.flows.work.WorkReport; import org.jeasy.flows.work.WorkReportPredicate; import java.util.UUID; public class ConditionalFlow extends AbstractWorkFlow { private final Work initialWorkUnit, nextOnPredicateSuccess, nextOnPredicateFailure; private final WorkReportPredicate predicate; ConditionalFlow(String name, Work initialWorkUnit, Work nextOnPredicateSuccess, Work nextOnPredicateFailure, WorkReportPredicate predicate) { super(name); this.initialWorkUnit = initialWorkUnit; this.nextOnPredicateSuccess = nextOnPredicateSuccess; this.nextOnPredicateFailure = nextOnPredicateFailure; this.predicate = predicate; } public WorkReport execute(WorkContext workContext) { WorkReport jobReport = initialWorkUnit.execute(workContext); if (predicate.apply(jobReport)) { jobReport = nextOnPredicateSuccess.execute(workContext); } else { if (nextOnPredicateFailure != null && !(nextOnPredicateFailure instanceof NoOpWork)) { jobReport = nextOnPredicateFailure.execute(workContext); } } return jobReport; } public static class Builder { private Builder() { } public static NameStep aNewConditionalFlow() { return new BuildSteps(); } public interface NameStep extends ExecuteStep { ExecuteStep named(String name); } public interface ExecuteStep { WhenStep execute(Work initialWorkUnit); } public interface WhenStep { ThenStep when(WorkReportPredicate predicate); } public interface ThenStep { OtherwiseStep then(Work work); } public interface OtherwiseStep extends BuildStep { BuildStep otherwise(Work work); } public interface BuildStep { ConditionalFlow build(); } private static class BuildSteps implements NameStep, ExecuteStep, WhenStep, ThenStep, OtherwiseStep, BuildStep { private String name; private Work initialWorkUnit, nextOnPredicateSuccess, nextOnPredicateFailure; private WorkReportPredicate predicate; BuildSteps() { this.name = UUID.randomUUID().toString(); this.initialWorkUnit = new NoOpWork(); this.nextOnPredicateSuccess = new NoOpWork(); this.nextOnPredicateFailure = new NoOpWork(); this.predicate = WorkReportPredicate.ALWAYS_FALSE; } @Override public ExecuteStep named(String name) { this.name = name; return this; } @Override public WhenStep execute(Work initialWorkUnit) { this.initialWorkUnit = initialWorkUnit; return this; } @Override public ThenStep when(WorkReportPredicate predicate) { this.predicate = predicate; return this; } @Override public OtherwiseStep then(Work work) { this.nextOnPredicateSuccess = work; return this; } @Override public BuildStep otherwise(Work work) { this.nextOnPredicateFailure = work; return this; } @Override public ConditionalFlow build() { return new ConditionalFlow(this.name, this.initialWorkUnit, this.nextOnPredicateSuccess, this.nextOnPredicateFailure, this.predicate); } } } }", "dependencies": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/NoOpWork.java", "file_content": "package org.jeasy.flows.work; import java.util.UUID; public class NoOpWork implements Work { @Override public String getName() { return UUID.randomUUID().toString(); } @Override public WorkReport execute(WorkContext workContext) { return new DefaultWorkReport(WorkStatus.COMPLETED, workContext); } }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/Work.java", "file_content": "package org.jeasy.flows.work; import java.util.UUID; public interface Work { default String getName() { return UUID.randomUUID().toString(); } WorkReport execute(WorkContext workContext); }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkContext.java", "file_content": "package org.jeasy.flows.work; import java.util.Map; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; public class WorkContext { private final Map<String, Object> context = new ConcurrentHashMap<>(); public void put(String key, Object value) { context.put(key, value); } public Object get(String key) { return context.get(key); } public Set<Map.Entry<String, Object>> getEntrySet() { return context.entrySet(); } @Override public String toString() { return \"context=\" + context + '}'; } }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkReport.java", "file_content": "package org.jeasy.flows.work; public interface WorkReport { WorkStatus getStatus(); Throwable getError(); WorkContext getWorkContext(); }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkReportPredicate.java", "file_content": "package org.jeasy.flows.work; import java.util.concurrent.atomic.AtomicInteger; @FunctionalInterface public interface WorkReportPredicate { boolean apply(WorkReport workReport); WorkReportPredicate ALWAYS_TRUE = workReport -> true; WorkReportPredicate ALWAYS_FALSE = workReport -> false; WorkReportPredicate COMPLETED = workReport -> workReport.getStatus().equals(WorkStatus.COMPLETED); WorkReportPredicate FAILED = workReport -> workReport.getStatus().equals(WorkStatus.FAILED); class TimesPredicate implements WorkReportPredicate { private final int times; private final AtomicInteger counter = new AtomicInteger(); public TimesPredicate(int times) { this.times = times; } @Override public boolean apply(WorkReport workReport) { return counter.incrementAndGet() != times; } public static TimesPredicate times(int times) { return new TimesPredicate(times); } } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/workflow/ConditionalFlow.java", "violatedPrinciples": []}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/NoOpWork.java", "violatedPrinciples": []}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/Work.java", "violatedPrinciples": []}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkContext.java", "violatedPrinciples": []}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkReport.java", "violatedPrinciples": []}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkReportPredicate.java", "violatedPrinciples": []}]}
{"project_id": 102, "chunk_id": 0, "prompt": {"main_file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/workflow/ParallelFlowReport.java", "main_file_content": "package org.jeasy.flows.workflow; import org.jeasy.flows.work.WorkContext; import org.jeasy.flows.work.WorkReport; import org.jeasy.flows.work.WorkStatus; import java.util.ArrayList; import java.util.List; import java.util.Map; public class ParallelFlowReport implements WorkReport { private final List<WorkReport> reports; public ParallelFlowReport() { this(new ArrayList<>()); } public ParallelFlowReport(List<WorkReport> reports) { this.reports = reports; } public List<WorkReport> getReports() { return reports; } void add(WorkReport workReport) { reports.add(workReport); } void addAll(List<WorkReport> workReports) { reports.addAll(workReports); } @Override public WorkStatus getStatus() { for (WorkReport report : reports) { if (report.getStatus().equals(WorkStatus.FAILED)) { return WorkStatus.FAILED; } } return WorkStatus.COMPLETED; } @Override public Throwable getError() { for (WorkReport report : reports) { Throwable error = report.getError(); if (error != null) { return error; } } return null; } @Override public WorkContext getWorkContext() { WorkContext workContext = new WorkContext(); for (WorkReport report : reports) { WorkContext partialContext = report.getWorkContext(); for (Map.Entry<String, Object> entry : partialContext.getEntrySet()) { workContext.put(entry.getKey(), entry.getValue()); } } return workContext; } }", "dependencies": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkContext.java", "file_content": "package org.jeasy.flows.work; import java.util.Map; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; public class WorkContext { private final Map<String, Object> context = new ConcurrentHashMap<>(); public void put(String key, Object value) { context.put(key, value); } public Object get(String key) { return context.get(key); } public Set<Map.Entry<String, Object>> getEntrySet() { return context.entrySet(); } @Override public String toString() { return \"context=\" + context + '}'; } }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkReport.java", "file_content": "package org.jeasy.flows.work; public interface WorkReport { WorkStatus getStatus(); Throwable getError(); WorkContext getWorkContext(); }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkStatus.java", "file_content": "package org.jeasy.flows.work; public enum WorkStatus { FAILED, COMPLETED }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/workflow/ParallelFlowReport.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "ParallelFlowReport directly instantiates WorkContext (a concrete class) in getWorkContext(). High-level modules should depend on abstractions, not concrete implementations."}]}]}
{"project_id": 102, "chunk_id": 0, "prompt": {"main_file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/workflow/AbstractWorkFlow.java", "main_file_content": "package org.jeasy.flows.workflow; abstract class AbstractWorkFlow implements WorkFlow { private final String name; AbstractWorkFlow(String name) { this.name = name; } public String getName() { return name; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/workflow/AbstractWorkFlow.java", "violatedPrinciples": []}]}
{"project_id": 102, "chunk_id": 0, "prompt": {"main_file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/workflow/ParallelFlow.java", "main_file_content": "package org.jeasy.flows.workflow; import org.jeasy.flows.work.Work; import org.jeasy.flows.work.WorkContext; import org.jeasy.flows.work.WorkReport; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.UUID; import java.util.concurrent.ExecutorService; public class ParallelFlow extends AbstractWorkFlow { private final List<Work> workUnits = new ArrayList<>(); private final ParallelFlowExecutor workExecutor; ParallelFlow(String name, List<Work> workUnits, ParallelFlowExecutor parallelFlowExecutor) { super(name); this.workUnits.addAll(workUnits); this.workExecutor = parallelFlowExecutor; } public ParallelFlowReport execute(WorkContext workContext) { ParallelFlowReport workFlowReport = new ParallelFlowReport(); List<WorkReport> workReports = workExecutor.executeInParallel(workUnits, workContext); workFlowReport.addAll(workReports); return workFlowReport; } public static class Builder { private Builder() { } public static NameStep aNewParallelFlow() { return new BuildSteps(); } public interface NameStep extends ExecuteStep { ExecuteStep named(String name); } public interface ExecuteStep { WithStep execute(Work... workUnits); } public interface WithStep { BuildStep with(ExecutorService executorService); } public interface BuildStep { ParallelFlow build(); } private static class BuildSteps implements NameStep, ExecuteStep, WithStep, BuildStep { private String name; private final List<Work> works; private ExecutorService executorService; public BuildSteps() { this.name = UUID.randomUUID().toString(); this.works = new ArrayList<>(); } @Override public ExecuteStep named(String name) { this.name = name; return this; } @Override public WithStep execute(Work... workUnits) { this.works.addAll(Arrays.asList(workUnits)); return this; } @Override public BuildStep with(ExecutorService executorService) { this.executorService = executorService; return this; } @Override public ParallelFlow build() { return new ParallelFlow( this.name, this.works, new ParallelFlowExecutor(this.executorService)); } } } }", "dependencies": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/Work.java", "file_content": "package org.jeasy.flows.work; import java.util.UUID; public interface Work { default String getName() { return UUID.randomUUID().toString(); } WorkReport execute(WorkContext workContext); }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkContext.java", "file_content": "package org.jeasy.flows.work; import java.util.Map; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; public class WorkContext { private final Map<String, Object> context = new ConcurrentHashMap<>(); public void put(String key, Object value) { context.put(key, value); } public Object get(String key) { return context.get(key); } public Set<Map.Entry<String, Object>> getEntrySet() { return context.entrySet(); } @Override public String toString() { return \"context=\" + context + '}'; } }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkReport.java", "file_content": "package org.jeasy.flows.work; public interface WorkReport { WorkStatus getStatus(); Throwable getError(); WorkContext getWorkContext(); }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/workflow/ParallelFlow.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "ParallelFlow directly depends on the concrete ParallelFlowExecutor class instead of an abstraction, violating DIP. High-level modules should depend on abstractions, not low-level implementations."}]}]}
{"project_id": 102, "chunk_id": 0, "prompt": {"main_file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/workflow/ParallelFlowExecutor.java", "main_file_content": "package org.jeasy.flows.workflow; import org.jeasy.flows.work.Work; import org.jeasy.flows.work.WorkContext; import org.jeasy.flows.work.WorkReport; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.ExecutorService; import java.util.concurrent.Future; class ParallelFlowExecutor { private final ExecutorService workExecutor; ParallelFlowExecutor(ExecutorService workExecutor) { this.workExecutor = workExecutor; } List<WorkReport> executeInParallel(List<Work> workUnits, WorkContext workContext) { List<Callable<WorkReport>> tasks = new ArrayList<>(workUnits.size()); workUnits.forEach(work -> tasks.add(() -> work.execute(workContext))); List<Future<WorkReport>> futures; try { futures = this.workExecutor.invokeAll(tasks); } catch (InterruptedException e) { throw new RuntimeException(\"The parallel flow was interrupted while executing work units\", e); } Map<Work, Future<WorkReport>> workToReportFuturesMap = new HashMap<>(); for (int index = 0; index < workUnits.size(); index++) { workToReportFuturesMap.put(workUnits.get(index), futures.get(index)); } List<WorkReport> workReports = new ArrayList<>(); for (Map.Entry<Work, Future<WorkReport>> entry : workToReportFuturesMap.entrySet()) { try { workReports.add(entry.getValue().get()); } catch (InterruptedException e) { String message = String.format(\"The parallel flow was interrupted while waiting for the result of work unit '%s'\", entry.getKey().getName()); throw new RuntimeException(message, e); } catch (ExecutionException e) { String message = String.format(\"Unable to execute work unit '%s'\", entry.getKey().getName()); throw new RuntimeException(message, e); } } return workReports; } }", "dependencies": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/Work.java", "file_content": "package org.jeasy.flows.work; import java.util.UUID; public interface Work { default String getName() { return UUID.randomUUID().toString(); } WorkReport execute(WorkContext workContext); }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkContext.java", "file_content": "package org.jeasy.flows.work; import java.util.Map; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; public class WorkContext { private final Map<String, Object> context = new ConcurrentHashMap<>(); public void put(String key, Object value) { context.put(key, value); } public Object get(String key) { return context.get(key); } public Set<Map.Entry<String, Object>> getEntrySet() { return context.entrySet(); } @Override public String toString() { return \"context=\" + context + '}'; } }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkReport.java", "file_content": "package org.jeasy.flows.work; public interface WorkReport { WorkStatus getStatus(); Throwable getError(); WorkContext getWorkContext(); }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/workflow/ParallelFlowExecutor.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The class handles task creation, execution coordination, result aggregation, and exception handling, which are multiple responsibilities."}, {"principle": "Open-Closed", "justification": "The class is not extensible; modifying task execution behavior (e.g., adding logging) requires changing existing code."}, {"principle": "Dependency Inversion", "justification": "The method depends on the concrete WorkContext class instead of an abstraction, violating dependency inversion."}]}]}
{"project_id": 102, "chunk_id": 0, "prompt": {"main_file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/workflow/RepeatFlow.java", "main_file_content": "package org.jeasy.flows.workflow; import org.jeasy.flows.work.NoOpWork; import org.jeasy.flows.work.Work; import org.jeasy.flows.work.WorkContext; import org.jeasy.flows.work.WorkReportPredicate; import org.jeasy.flows.work.WorkReport; import java.util.UUID; public class RepeatFlow extends AbstractWorkFlow { private final Work work; private final WorkReportPredicate predicate; RepeatFlow(String name, Work work, WorkReportPredicate predicate) { super(name); this.work = work; this.predicate = predicate; } public WorkReport execute(WorkContext workContext) { WorkReport workReport; do { workReport = work.execute(workContext); } while (predicate.apply(workReport)); return workReport; } public static class Builder { private Builder() { } public static NameStep aNewRepeatFlow() { return new BuildSteps(); } public interface NameStep extends RepeatStep { RepeatStep named(String name); } public interface RepeatStep { UntilStep repeat(Work work); } public interface UntilStep { BuildStep until(WorkReportPredicate predicate); BuildStep times(int times); } public interface BuildStep { RepeatFlow build(); } private static class BuildSteps implements NameStep, RepeatStep, UntilStep, BuildStep { private String name; private Work work; private WorkReportPredicate predicate; BuildSteps() { this.name = UUID.randomUUID().toString(); this.work = new NoOpWork(); this.predicate = WorkReportPredicate.ALWAYS_FALSE; } @Override public RepeatStep named(String name) { this.name = name; return this; } @Override public UntilStep repeat(Work work) { this.work = work; return this; } @Override public BuildStep until(WorkReportPredicate predicate) { this.predicate = predicate; return this; } @Override public BuildStep times(int times) { until(WorkReportPredicate.TimesPredicate.times(times)); return this; } @Override public RepeatFlow build() { return new RepeatFlow(name, work, predicate); } } } }", "dependencies": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/NoOpWork.java", "file_content": "package org.jeasy.flows.work; import java.util.UUID; public class NoOpWork implements Work { @Override public String getName() { return UUID.randomUUID().toString(); } @Override public WorkReport execute(WorkContext workContext) { return new DefaultWorkReport(WorkStatus.COMPLETED, workContext); } }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/Work.java", "file_content": "package org.jeasy.flows.work; import java.util.UUID; public interface Work { default String getName() { return UUID.randomUUID().toString(); } WorkReport execute(WorkContext workContext); }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkContext.java", "file_content": "package org.jeasy.flows.work; import java.util.Map; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; public class WorkContext { private final Map<String, Object> context = new ConcurrentHashMap<>(); public void put(String key, Object value) { context.put(key, value); } public Object get(String key) { return context.get(key); } public Set<Map.Entry<String, Object>> getEntrySet() { return context.entrySet(); } @Override public String toString() { return \"context=\" + context + '}'; } }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkReportPredicate.java", "file_content": "package org.jeasy.flows.work; import java.util.concurrent.atomic.AtomicInteger; @FunctionalInterface public interface WorkReportPredicate { boolean apply(WorkReport workReport); WorkReportPredicate ALWAYS_TRUE = workReport -> true; WorkReportPredicate ALWAYS_FALSE = workReport -> false; WorkReportPredicate COMPLETED = workReport -> workReport.getStatus().equals(WorkStatus.COMPLETED); WorkReportPredicate FAILED = workReport -> workReport.getStatus().equals(WorkStatus.FAILED); class TimesPredicate implements WorkReportPredicate { private final int times; private final AtomicInteger counter = new AtomicInteger(); public TimesPredicate(int times) { this.times = times; } @Override public boolean apply(WorkReport workReport) { return counter.incrementAndGet() != times; } public static TimesPredicate times(int times) { return new TimesPredicate(times); } } }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkReport.java", "file_content": "package org.jeasy.flows.work; public interface WorkReport { WorkStatus getStatus(); Throwable getError(); WorkContext getWorkContext(); }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/Work.java", "violatedPrinciples": [{"principle": "Interface Segregation", "justification": "The Work interface includes the getName method, which is not used by clients like RepeatFlow. Clients depending on Work are forced to implement or inherit this method even when unused, violating ISP."}]}]}
{"project_id": 102, "chunk_id": 0, "prompt": {"main_file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/workflow/SequentialFlow.java", "main_file_content": "package org.jeasy.flows.workflow; import org.jeasy.flows.work.Work; import org.jeasy.flows.work.WorkContext; import org.jeasy.flows.work.WorkReport; import java.util.ArrayList; import java.util.List; import java.util.UUID; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import static org.jeasy.flows.work.WorkStatus.FAILED; public class SequentialFlow extends AbstractWorkFlow { private static final Logger LOGGER = LoggerFactory.getLogger(SequentialFlow.class.getName()); private final List<Work> workUnits = new ArrayList<>(); SequentialFlow(String name, List<Work> workUnits) { super(name); this.workUnits.addAll(workUnits); } public WorkReport execute(WorkContext workContext) { WorkReport workReport = null; for (Work work : workUnits) { workReport = work.execute(workContext); if (workReport != null && FAILED.equals(workReport.getStatus())) { LOGGER.info(\"Work unit ''{}'' has failed, skipping subsequent work units\", work.getName()); break; } } return workReport; } public static class Builder { private Builder() { } public static NameStep aNewSequentialFlow() { return new BuildSteps(); } public interface NameStep extends ExecuteStep { ExecuteStep named(String name); } public interface ExecuteStep { ThenStep execute(Work initialWork); ThenStep execute(List<Work> initialWorkUnits); } public interface ThenStep { ThenStep then(Work nextWork); ThenStep then(List<Work> nextWorkUnits); SequentialFlow build(); } private static class BuildSteps implements NameStep, ExecuteStep, ThenStep { private String name; private final List<Work> works; BuildSteps() { this.name = UUID.randomUUID().toString(); this.works = new ArrayList<>(); } public ExecuteStep named(String name) { this.name = name; return this; } @Override public ThenStep execute(Work initialWork) { this.works.add(initialWork); return this; } @Override public ThenStep execute(List<Work> initialWorkUnits) { this.works.addAll(initialWorkUnits); return this; } @Override public ThenStep then(Work nextWork) { this.works.add(nextWork); return this; } @Override public ThenStep then(List<Work> nextWorkUnits) { this.works.addAll(nextWorkUnits); return this; } @Override public SequentialFlow build() { return new SequentialFlow(this.name, this.works); } } } }", "dependencies": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/Work.java", "file_content": "package org.jeasy.flows.work; import java.util.UUID; public interface Work { default String getName() { return UUID.randomUUID().toString(); } WorkReport execute(WorkContext workContext); }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkContext.java", "file_content": "package org.jeasy.flows.work; import java.util.Map; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; public class WorkContext { private final Map<String, Object> context = new ConcurrentHashMap<>(); public void put(String key, Object value) { context.put(key, value); } public Object get(String key) { return context.get(key); } public Set<Map.Entry<String, Object>> getEntrySet() { return context.entrySet(); } @Override public String toString() { return \"context=\" + context + '}'; } }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkReport.java", "file_content": "package org.jeasy.flows.work; public interface WorkReport { WorkStatus getStatus(); Throwable getError(); WorkContext getWorkContext(); }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/workflow/SequentialFlow.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "SequentialFlow manages both workflow execution and object construction via its inner Builder class, introducing multiple reasons to change if construction logic or execution logic evolves."}]}]}
{"project_id": 102, "chunk_id": 0, "prompt": {"main_file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/workflow/WorkFlow.java", "main_file_content": "package org.jeasy.flows.workflow; import org.jeasy.flows.work.Work; public interface WorkFlow extends Work { }", "dependencies": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/Work.java", "file_content": "package org.jeasy.flows.work; import java.util.UUID; public interface Work { default String getName() { return UUID.randomUUID().toString(); } WorkReport execute(WorkContext workContext); }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/Work.java", "violatedPrinciples": [{"principle": "Interface Segregation", "justification": "The Work interface includes both getName and execute methods. Clients depending on Work must implement or depend on both, even if they only need one method, violating ISP."}]}]}
{"project_id": 102, "chunk_id": 0, "prompt": {"main_file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/engine/WorkFlowEngine.java", "main_file_content": "package org.jeasy.flows.engine; import org.jeasy.flows.work.WorkContext; import org.jeasy.flows.work.WorkReport; import org.jeasy.flows.workflow.WorkFlow; public interface WorkFlowEngine { WorkReport run(WorkFlow workFlow, WorkContext workContext); }", "dependencies": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkContext.java", "file_content": "package org.jeasy.flows.work; import java.util.Map; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; public class WorkContext { private final Map<String, Object> context = new ConcurrentHashMap<>(); public void put(String key, Object value) { context.put(key, value); } public Object get(String key) { return context.get(key); } public Set<Map.Entry<String, Object>> getEntrySet() { return context.entrySet(); } @Override public String toString() { return \"context=\" + context + '}'; } }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkReport.java", "file_content": "package org.jeasy.flows.work; public interface WorkReport { WorkStatus getStatus(); Throwable getError(); WorkContext getWorkContext(); }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/workflow/WorkFlow.java", "file_content": "package org.jeasy.flows.workflow; import org.jeasy.flows.work.Work; public interface WorkFlow extends Work { }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/engine/WorkFlowEngine.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "WorkFlowEngine's run method depends on concrete WorkContext class. High-level engine should depend on abstractions instead of low-level implementation details."}]}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/workflow/WorkFlow.java", "violatedPrinciples": [{"principle": "Interface Segregation", "justification": "WorkFlow interface extends Work without justification. Clients depending on WorkFlow are forced to implement all Work methods even if unused, violating ISP."}]}]}
{"project_id": 102, "chunk_id": 0, "prompt": {"main_file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/engine/WorkFlowEngineImpl.java", "main_file_content": "package org.jeasy.flows.engine; import org.jeasy.flows.work.WorkContext; import org.jeasy.flows.work.WorkReport; import org.jeasy.flows.workflow.WorkFlow; import org.slf4j.Logger; import org.slf4j.LoggerFactory; class WorkFlowEngineImpl implements WorkFlowEngine { private static final Logger LOGGER = LoggerFactory.getLogger(WorkFlowEngineImpl.class); public WorkReport run(WorkFlow workFlow, WorkContext workContext) { LOGGER.info(\"Running workflow ''{}''\", workFlow.getName()); return workFlow.execute(workContext); } }", "dependencies": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkContext.java", "file_content": "package org.jeasy.flows.work; import java.util.Map; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; public class WorkContext { private final Map<String, Object> context = new ConcurrentHashMap<>(); public void put(String key, Object value) { context.put(key, value); } public Object get(String key) { return context.get(key); } public Set<Map.Entry<String, Object>> getEntrySet() { return context.entrySet(); } @Override public String toString() { return \"context=\" + context + '}'; } }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkReport.java", "file_content": "package org.jeasy.flows.work; public interface WorkReport { WorkStatus getStatus(); Throwable getError(); WorkContext getWorkContext(); }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/workflow/WorkFlow.java", "file_content": "package org.jeasy.flows.workflow; import org.jeasy.flows.work.Work; public interface WorkFlow extends Work { }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/engine/WorkFlowEngineImpl.java", "violatedPrinciples": []}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkContext.java", "violatedPrinciples": []}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkReport.java", "violatedPrinciples": []}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/workflow/WorkFlow.java", "violatedPrinciples": []}]}
{"project_id": 102, "chunk_id": 0, "prompt": {"main_file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/engine/WorkFlowEngineBuilder.java", "main_file_content": "package org.jeasy.flows.engine; public class WorkFlowEngineBuilder { public static WorkFlowEngineBuilder aNewWorkFlowEngine() { return new WorkFlowEngineBuilder(); } private WorkFlowEngineBuilder() { } public WorkFlowEngine build() { return new WorkFlowEngineImpl(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/engine/WorkFlowEngineBuilder.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "WorkFlowEngineBuilder's build method directly instantiates WorkFlowEngineImpl. To change the engine implementation, the class must be modified, violating OCP by not allowing extension without modification."}, {"principle": "Dependency Inversion", "justification": "WorkFlowEngineBuilder (high-level) directly depends on WorkFlowEngineImpl (low-level concrete class) instead of an abstraction, violating DIP by creating a direct dependency between layers."}]}]}
{"project_id": 102, "chunk_id": 0, "prompt": {"main_file_path": "easy-flows-master/easy-flows-master/src/test/java/org/jeasy/flows/work/NoOpWorkTest.java", "main_file_content": "package org.jeasy.flows.work; import org.assertj.core.api.Assertions; import org.junit.Assert; import org.junit.Test; public class NoOpWorkTest { private final NoOpWork work = new NoOpWork(); @Test public void getName() { Assertions.assertThat(work.getName()).isNotNull(); } @Test public void testExecute() { WorkReport workReport = work.execute(new WorkContext()); Assert.assertNotNull(workReport); Assertions.assertThat(workReport.getStatus()).isEqualTo(WorkStatus.COMPLETED); } }", "dependencies": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/NoOpWork.java", "file_content": "package org.jeasy.flows.work; import java.util.UUID; public class NoOpWork implements Work { @Override public String getName() { return UUID.randomUUID().toString(); } @Override public WorkReport execute(WorkContext workContext) { return new DefaultWorkReport(WorkStatus.COMPLETED, workContext); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/NoOpWork.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "The Work interface's execute method depends on the concrete WorkContext class. High-level modules (like Work) should depend on abstractions, not concrete implementations."}]}]}
{"project_id": 102, "chunk_id": 0, "prompt": {"main_file_path": "easy-flows-master/easy-flows-master/src/test/java/org/jeasy/flows/workflow/SequentialFlowTest.java", "main_file_content": "package org.jeasy.flows.workflow; import java.util.Arrays; import java.util.List; import org.jeasy.flows.work.Work; import org.jeasy.flows.work.WorkContext; import org.junit.Test; import org.mockito.InOrder; import org.mockito.Mockito; public class SequentialFlowTest { @Test public void testExecute() { Work work1 = Mockito.mock(Work.class); Work work2 = Mockito.mock(Work.class); Work work3 = Mockito.mock(Work.class); WorkContext workContext = Mockito.mock(WorkContext.class); SequentialFlow sequentialFlow = SequentialFlow.Builder.aNewSequentialFlow() .named(\"testFlow\") .execute(work1) .then(work2) .then(work3) .build(); sequentialFlow.execute(workContext); InOrder inOrder = Mockito.inOrder(work1, work2, work3); inOrder.verify(work1, Mockito.times(1)).execute(workContext); inOrder.verify(work2, Mockito.times(1)).execute(workContext); inOrder.verify(work3, Mockito.times(1)).execute(workContext); } @Test public void testPassingMultipleWorkUnitsAtOnce() { Work work1 = Mockito.mock(Work.class); Work work2 = Mockito.mock(Work.class); Work work3 = Mockito.mock(Work.class); Work work4 = Mockito.mock(Work.class); WorkContext workContext = Mockito.mock(WorkContext.class); List<Work> initialWorkUnits = Arrays.asList(work1, work2); List<Work> nextWorkUnits = Arrays.asList(work3, work4); SequentialFlow sequentialFlow = SequentialFlow.Builder.aNewSequentialFlow() .named(\"testFlow\") .execute(initialWorkUnits) .then(nextWorkUnits) .build(); sequentialFlow.execute(workContext); InOrder inOrder = Mockito.inOrder(work1, work2, work3, work4); inOrder.verify(work1, Mockito.times(1)).execute(workContext); inOrder.verify(work2, Mockito.times(1)).execute(workContext); inOrder.verify(work3, Mockito.times(1)).execute(workContext); inOrder.verify(work4, Mockito.times(1)).execute(workContext); } }", "dependencies": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/Work.java", "file_content": "package org.jeasy.flows.work; import java.util.UUID; public interface Work { default String getName() { return UUID.randomUUID().toString(); } WorkReport execute(WorkContext workContext); }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkContext.java", "file_content": "package org.jeasy.flows.work; import java.util.Map; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; public class WorkContext { private final Map<String, Object> context = new ConcurrentHashMap<>(); public void put(String key, Object value) { context.put(key, value); } public Object get(String key) { return context.get(key); } public Set<Map.Entry<String, Object>> getEntrySet() { return context.entrySet(); } @Override public String toString() { return \"context=\" + context + '}'; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 102, "chunk_id": 0, "prompt": {"main_file_path": "easy-flows-master/easy-flows-master/src/test/java/org/jeasy/flows/workflow/ParallelFlowTest.java", "main_file_content": "package org.jeasy.flows.workflow; import org.assertj.core.api.Assertions; import org.jeasy.flows.work.Work; import org.jeasy.flows.work.WorkContext; import org.junit.Test; import org.mockito.Mockito; import java.util.Arrays; import java.util.List; public class ParallelFlowTest { @Test public void testExecute() { Work work1 = Mockito.mock(Work.class); Work work2 = Mockito.mock(Work.class); WorkContext workContext = Mockito.mock(WorkContext.class); ParallelFlowExecutor parallelFlowExecutor = Mockito.mock(ParallelFlowExecutor.class); List<Work> works = Arrays.asList(work1, work2); ParallelFlow parallelFlow = new ParallelFlow(\"pf\", works, parallelFlowExecutor); ParallelFlowReport parallelFlowReport = parallelFlow.execute(workContext); Assertions.assertThat(parallelFlowReport).isNotNull(); Mockito.verify(parallelFlowExecutor).executeInParallel(works, workContext); } }", "dependencies": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/Work.java", "file_content": "package org.jeasy.flows.work; import java.util.UUID; public interface Work { default String getName() { return UUID.randomUUID().toString(); } WorkReport execute(WorkContext workContext); }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkContext.java", "file_content": "package org.jeasy.flows.work; import java.util.Map; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; public class WorkContext { private final Map<String, Object> context = new ConcurrentHashMap<>(); public void put(String key, Object value) { context.put(key, value); } public Object get(String key) { return context.get(key); } public Set<Map.Entry<String, Object>> getEntrySet() { return context.entrySet(); } @Override public String toString() { return \"context=\" + context + '}'; } }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/workflow/ParallelFlow.java", "file_content": "package org.jeasy.flows.workflow; import org.jeasy.flows.work.Work; import org.jeasy.flows.work.WorkContext; import org.jeasy.flows.work.WorkReport; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.UUID; import java.util.concurrent.ExecutorService; public class ParallelFlow extends AbstractWorkFlow { private final List<Work> workUnits = new ArrayList<>(); private final ParallelFlowExecutor workExecutor; ParallelFlow(String name, List<Work> workUnits, ParallelFlowExecutor parallelFlowExecutor) { super(name); this.workUnits.addAll(workUnits); this.workExecutor = parallelFlowExecutor; } public ParallelFlowReport execute(WorkContext workContext) { ParallelFlowReport workFlowReport = new ParallelFlowReport(); List<WorkReport> workReports = workExecutor.executeInParallel(workUnits, workContext); workFlowReport.addAll(workReports); return workFlowReport; } public static class Builder { private Builder() { } public static NameStep aNewParallelFlow() { return new BuildSteps(); } public interface NameStep extends ExecuteStep { ExecuteStep named(String name); } public interface ExecuteStep { WithStep execute(Work... workUnits); } public interface WithStep { BuildStep with(ExecutorService executorService); } public interface BuildStep { ParallelFlow build(); } private static class BuildSteps implements NameStep, ExecuteStep, WithStep, BuildStep { private String name; private final List<Work> works; private ExecutorService executorService; public BuildSteps() { this.name = UUID.randomUUID().toString(); this.works = new ArrayList<>(); } @Override public ExecuteStep named(String name) { this.name = name; return this; } @Override public WithStep execute(Work... workUnits) { this.works.addAll(Arrays.asList(workUnits)); return this; } @Override public BuildStep with(ExecutorService executorService) { this.executorService = executorService; return this; } @Override public ParallelFlow build() { return new ParallelFlow( this.name, this.works, new ParallelFlowExecutor(this.executorService)); } } } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/workflow/ParallelFlow.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "ParallelFlow's Builder directly instantiates ParallelFlowExecutor (a concrete class), violating DIP by depending on a low-level implementation instead of an abstraction."}]}]}
{"project_id": 102, "chunk_id": 0, "prompt": {"main_file_path": "easy-flows-master/easy-flows-master/src/test/java/org/jeasy/flows/workflow/ConditionalFlowTest.java", "main_file_content": "package org.jeasy.flows.workflow; import org.jeasy.flows.work.Work; import org.jeasy.flows.work.WorkContext; import org.jeasy.flows.work.WorkReportPredicate; import org.junit.Test; import org.mockito.Mockito; public class ConditionalFlowTest { @Test public void callOnPredicateSuccess() { Work toExecute = Mockito.mock(Work.class); Work nextOnPredicateSuccess = Mockito.mock(Work.class); Work nextOnPredicateFailure = Mockito.mock(Work.class); WorkContext workContext = Mockito.mock(WorkContext.class); WorkReportPredicate predicate = WorkReportPredicate.ALWAYS_TRUE; ConditionalFlow conditionalFlow = ConditionalFlow.Builder.aNewConditionalFlow() .named(\"testFlow\") .execute(toExecute) .when(predicate) .then(nextOnPredicateSuccess) .otherwise(nextOnPredicateFailure) .build(); conditionalFlow.execute(workContext); Mockito.verify(toExecute, Mockito.times(1)).execute(workContext); Mockito.verify(nextOnPredicateSuccess, Mockito.times(1)).execute(workContext); Mockito.verify(nextOnPredicateFailure, Mockito.never()).execute(workContext); } @Test public void callOnPredicateFailure() { Work toExecute = Mockito.mock(Work.class); Work nextOnPredicateSuccess = Mockito.mock(Work.class); Work nextOnPredicateFailure = Mockito.mock(Work.class); WorkContext workContext = Mockito.mock(WorkContext.class); WorkReportPredicate predicate = WorkReportPredicate.ALWAYS_FALSE; ConditionalFlow conditionalFlow = ConditionalFlow.Builder.aNewConditionalFlow() .named(\"anotherTestFlow\") .execute(toExecute) .when(predicate) .then(nextOnPredicateSuccess) .otherwise(nextOnPredicateFailure) .build(); conditionalFlow.execute(workContext); Mockito.verify(toExecute, Mockito.times(1)).execute(workContext); Mockito.verify(nextOnPredicateFailure, Mockito.times(1)).execute(workContext); Mockito.verify(nextOnPredicateSuccess, Mockito.never()).execute(workContext); } }", "dependencies": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/Work.java", "file_content": "package org.jeasy.flows.work; import java.util.UUID; public interface Work { default String getName() { return UUID.randomUUID().toString(); } WorkReport execute(WorkContext workContext); }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkContext.java", "file_content": "package org.jeasy.flows.work; import java.util.Map; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; public class WorkContext { private final Map<String, Object> context = new ConcurrentHashMap<>(); public void put(String key, Object value) { context.put(key, value); } public Object get(String key) { return context.get(key); } public Set<Map.Entry<String, Object>> getEntrySet() { return context.entrySet(); } @Override public String toString() { return \"context=\" + context + '}'; } }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkReportPredicate.java", "file_content": "package org.jeasy.flows.work; import java.util.concurrent.atomic.AtomicInteger; @FunctionalInterface public interface WorkReportPredicate { boolean apply(WorkReport workReport); WorkReportPredicate ALWAYS_TRUE = workReport -> true; WorkReportPredicate ALWAYS_FALSE = workReport -> false; WorkReportPredicate COMPLETED = workReport -> workReport.getStatus().equals(WorkStatus.COMPLETED); WorkReportPredicate FAILED = workReport -> workReport.getStatus().equals(WorkStatus.FAILED); class TimesPredicate implements WorkReportPredicate { private final int times; private final AtomicInteger counter = new AtomicInteger(); public TimesPredicate(int times) { this.times = times; } @Override public boolean apply(WorkReport workReport) { return counter.incrementAndGet() != times; } public static TimesPredicate times(int times) { return new TimesPredicate(times); } } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 102, "chunk_id": 0, "prompt": {"main_file_path": "easy-flows-master/easy-flows-master/src/test/java/org/jeasy/flows/workflow/RepeatFlowTest.java", "main_file_content": "package org.jeasy.flows.workflow; import org.jeasy.flows.work.Work; import org.jeasy.flows.work.WorkContext; import org.jeasy.flows.work.WorkReportPredicate; import org.junit.Test; import org.mockito.Mockito; public class RepeatFlowTest { @Test public void testRepeatUntil() { Work work = Mockito.mock(Work.class); WorkContext workContext = Mockito.mock(WorkContext.class); WorkReportPredicate predicate = WorkReportPredicate.ALWAYS_FALSE; RepeatFlow repeatFlow = RepeatFlow.Builder.aNewRepeatFlow() .repeat(work) .until(predicate) .build(); repeatFlow.execute(workContext); Mockito.verify(work, Mockito.times(1)).execute(workContext); } @Test public void testRepeatTimes() { Work work = Mockito.mock(Work.class); WorkContext workContext = Mockito.mock(WorkContext.class); RepeatFlow repeatFlow = RepeatFlow.Builder.aNewRepeatFlow() .repeat(work) .times(3) .build(); repeatFlow.execute(workContext); Mockito.verify(work, Mockito.times(3)).execute(workContext); } }", "dependencies": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/Work.java", "file_content": "package org.jeasy.flows.work; import java.util.UUID; public interface Work { default String getName() { return UUID.randomUUID().toString(); } WorkReport execute(WorkContext workContext); }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkContext.java", "file_content": "package org.jeasy.flows.work; import java.util.Map; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; public class WorkContext { private final Map<String, Object> context = new ConcurrentHashMap<>(); public void put(String key, Object value) { context.put(key, value); } public Object get(String key) { return context.get(key); } public Set<Map.Entry<String, Object>> getEntrySet() { return context.entrySet(); } @Override public String toString() { return \"context=\" + context + '}'; } }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkReportPredicate.java", "file_content": "package org.jeasy.flows.work; import java.util.concurrent.atomic.AtomicInteger; @FunctionalInterface public interface WorkReportPredicate { boolean apply(WorkReport workReport); WorkReportPredicate ALWAYS_TRUE = workReport -> true; WorkReportPredicate ALWAYS_FALSE = workReport -> false; WorkReportPredicate COMPLETED = workReport -> workReport.getStatus().equals(WorkStatus.COMPLETED); WorkReportPredicate FAILED = workReport -> workReport.getStatus().equals(WorkStatus.FAILED); class TimesPredicate implements WorkReportPredicate { private final int times; private final AtomicInteger counter = new AtomicInteger(); public TimesPredicate(int times) { this.times = times; } @Override public boolean apply(WorkReport workReport) { return counter.incrementAndGet() != times; } public static TimesPredicate times(int times) { return new TimesPredicate(times); } } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 102, "chunk_id": 0, "prompt": {"main_file_path": "easy-flows-master/easy-flows-master/src/test/java/org/jeasy/flows/workflow/ParallelFlowExecutorTest.java", "main_file_content": "package org.jeasy.flows.workflow; import org.assertj.core.api.Assertions; import org.jeasy.flows.work.DefaultWorkReport; import org.jeasy.flows.work.Work; import org.jeasy.flows.work.WorkContext; import org.jeasy.flows.work.WorkReport; import org.jeasy.flows.work.WorkStatus; import org.junit.Test; import org.mockito.Mockito; import java.util.Arrays; import java.util.List; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class ParallelFlowExecutorTest { @Test public void testExecute() { ExecutorService executorService = Executors.newFixedThreadPool(2); HelloWorldWork work1 = new HelloWorldWork(\"work1\", WorkStatus.COMPLETED); HelloWorldWork work2 = new HelloWorldWork(\"work2\", WorkStatus.FAILED); WorkContext workContext = Mockito.mock(WorkContext.class); ParallelFlowExecutor parallelFlowExecutor = new ParallelFlowExecutor(executorService); List<WorkReport> workReports = parallelFlowExecutor.executeInParallel(Arrays.asList(work1, work2), workContext); executorService.shutdown(); Assertions.assertThat(workReports).hasSize(2); Assertions.assertThat(work1.isExecuted()).isTrue(); Assertions.assertThat(work2.isExecuted()).isTrue(); } static class HelloWorldWork implements Work { private final String name; private final WorkStatus status; private boolean executed; HelloWorldWork(String name, WorkStatus status) { this.name = name; this.status = status; } @Override public String getName() { return name; } @Override public WorkReport execute(WorkContext workContext) { executed = true; return new DefaultWorkReport(status, workContext); } public boolean isExecuted() { return executed; } } }", "dependencies": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/DefaultWorkReport.java", "file_content": "package org.jeasy.flows.work; public class DefaultWorkReport implements WorkReport { private final WorkStatus status; private final WorkContext workContext; private Throwable error; public DefaultWorkReport(WorkStatus status, WorkContext workContext) { this.status = status; this.workContext = workContext; } public DefaultWorkReport(WorkStatus status, WorkContext workContext, Throwable error) { this(status, workContext); this.error = error; } public WorkStatus getStatus() { return status; } public Throwable getError() { return error; } @Override public WorkContext getWorkContext() { return workContext; } @Override public String toString() { return \"DefaultWorkReport {\" + \"status=\" + status + \", context=\" + workContext + \", error=\" + (error == null ? \"''\" : error) + '}'; } }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/Work.java", "file_content": "package org.jeasy.flows.work; import java.util.UUID; public interface Work { default String getName() { return UUID.randomUUID().toString(); } WorkReport execute(WorkContext workContext); }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkContext.java", "file_content": "package org.jeasy.flows.work; import java.util.Map; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; public class WorkContext { private final Map<String, Object> context = new ConcurrentHashMap<>(); public void put(String key, Object value) { context.put(key, value); } public Object get(String key) { return context.get(key); } public Set<Map.Entry<String, Object>> getEntrySet() { return context.entrySet(); } @Override public String toString() { return \"context=\" + context + '}'; } }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkReport.java", "file_content": "package org.jeasy.flows.work; public interface WorkReport { WorkStatus getStatus(); Throwable getError(); WorkContext getWorkContext(); }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkStatus.java", "file_content": "package org.jeasy.flows.work; public enum WorkStatus { FAILED, COMPLETED }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 102, "chunk_id": 0, "prompt": {"main_file_path": "easy-flows-master/easy-flows-master/src/test/java/org/jeasy/flows/workflow/ParallelFlowReportTest.java", "main_file_content": "package org.jeasy.flows.workflow; import org.assertj.core.api.Assertions; import org.jeasy.flows.work.DefaultWorkReport; import org.jeasy.flows.work.WorkContext; import org.jeasy.flows.work.WorkStatus; import org.junit.Before; import org.junit.Test; public class ParallelFlowReportTest { private Exception exception; private ParallelFlowReport parallelFlowReport; @Before public void setUp() { exception = new Exception(\"test exception\"); WorkContext workContext = new WorkContext(); parallelFlowReport = new ParallelFlowReport(); parallelFlowReport.add(new DefaultWorkReport(WorkStatus.FAILED, workContext, exception)); parallelFlowReport.add(new DefaultWorkReport(WorkStatus.COMPLETED, workContext)); } @Test public void testGetStatus() { Assertions.assertThat(parallelFlowReport.getStatus()).isEqualTo(WorkStatus.FAILED); } @Test public void testGetError() { Assertions.assertThat(parallelFlowReport.getError()).isEqualTo(exception); } @Test public void testGetReports() { Assertions.assertThat(parallelFlowReport.getReports()).hasSize(2); } }", "dependencies": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/DefaultWorkReport.java", "file_content": "package org.jeasy.flows.work; public class DefaultWorkReport implements WorkReport { private final WorkStatus status; private final WorkContext workContext; private Throwable error; public DefaultWorkReport(WorkStatus status, WorkContext workContext) { this.status = status; this.workContext = workContext; } public DefaultWorkReport(WorkStatus status, WorkContext workContext, Throwable error) { this(status, workContext); this.error = error; } public WorkStatus getStatus() { return status; } public Throwable getError() { return error; } @Override public WorkContext getWorkContext() { return workContext; } @Override public String toString() { return \"DefaultWorkReport {\" + \"status=\" + status + \", context=\" + workContext + \", error=\" + (error == null ? \"''\" : error) + '}'; } }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkContext.java", "file_content": "package org.jeasy.flows.work; import java.util.Map; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; public class WorkContext { private final Map<String, Object> context = new ConcurrentHashMap<>(); public void put(String key, Object value) { context.put(key, value); } public Object get(String key) { return context.get(key); } public Set<Map.Entry<String, Object>> getEntrySet() { return context.entrySet(); } @Override public String toString() { return \"context=\" + context + '}'; } }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkStatus.java", "file_content": "package org.jeasy.flows.work; public enum WorkStatus { FAILED, COMPLETED }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 102, "chunk_id": 0, "prompt": {"main_file_path": "easy-flows-master/easy-flows-master/src/test/java/org/jeasy/flows/engine/WorkFlowEngineImplTest.java", "main_file_content": "package org.jeasy.flows.engine; import java.util.Map; import java.util.Set; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import org.jeasy.flows.work.DefaultWorkReport; import org.jeasy.flows.work.Work; import org.jeasy.flows.work.WorkContext; import org.jeasy.flows.work.WorkReport; import org.jeasy.flows.work.WorkStatus; import org.jeasy.flows.workflow.*; import org.junit.Test; import org.mockito.Mockito; import static org.assertj.core.api.Assertions.assertThat; import static org.jeasy.flows.engine.WorkFlowEngineBuilder.aNewWorkFlowEngine; import static org.jeasy.flows.work.WorkReportPredicate.COMPLETED; import static org.jeasy.flows.workflow.ConditionalFlow.Builder.aNewConditionalFlow; import static org.jeasy.flows.workflow.ParallelFlow.Builder.aNewParallelFlow; import static org.jeasy.flows.workflow.RepeatFlow.Builder.aNewRepeatFlow; import static org.jeasy.flows.workflow.SequentialFlow.Builder.aNewSequentialFlow; public class WorkFlowEngineImplTest { private final WorkFlowEngine workFlowEngine = new WorkFlowEngineImpl(); @Test public void run() { WorkFlow workFlow = Mockito.mock(WorkFlow.class); WorkContext workContext = Mockito.mock(WorkContext.class); workFlowEngine.run(workFlow,workContext); Mockito.verify(workFlow).execute(workContext); } @Test public void composeWorkFlowFromSeparateFlowsAndExecuteIt() { PrintMessageWork work1 = new PrintMessageWork(\"foo\"); PrintMessageWork work2 = new PrintMessageWork(\"hello\"); PrintMessageWork work3 = new PrintMessageWork(\"world\"); PrintMessageWork work4 = new PrintMessageWork(\"done\"); RepeatFlow repeatFlow = aNewRepeatFlow() .named(\"print foo 3 times\") .repeat(work1) .times(3) .build(); ExecutorService executorService = Executors.newFixedThreadPool(2); ParallelFlow parallelFlow = aNewParallelFlow() .named(\"print 'hello' and 'world' in parallel\") .execute(work2, work3) .with(executorService) .build(); ConditionalFlow conditionalFlow = aNewConditionalFlow() .execute(parallelFlow) .when(COMPLETED) .then(work4) .build(); SequentialFlow sequentialFlow = aNewSequentialFlow() .execute(repeatFlow) .then(conditionalFlow) .build(); WorkFlowEngine workFlowEngine = aNewWorkFlowEngine().build(); WorkContext workContext = new WorkContext(); WorkReport workReport = workFlowEngine.run(sequentialFlow, workContext); executorService.shutdown(); assertThat(workReport.getStatus()).isEqualTo(WorkStatus.COMPLETED); soutl(\"\") } @Test public void defineWorkFlowInlineAndExecuteIt() { PrintMessageWork work1 = new PrintMessageWork(\"foo\"); PrintMessageWork work2 = new PrintMessageWork(\"hello\"); PrintMessageWork work3 = new PrintMessageWork(\"world\"); PrintMessageWork work4 = new PrintMessageWork(\"done\"); ExecutorService executorService = Executors.newFixedThreadPool(2); WorkFlow workflow = aNewSequentialFlow() .execute(aNewRepeatFlow() .named(\"print foo 3 times\") .repeat(work1) .times(3) .build()) .then(aNewConditionalFlow() .execute(aNewParallelFlow() .named(\"print 'hello' and 'world' in parallel\") .execute(work2, work3) .with(executorService) .build()) .when(COMPLETED) .then(work4) .build()) .build(); WorkFlowEngine workFlowEngine = aNewWorkFlowEngine().build(); WorkContext workContext = new WorkContext(); WorkReport workReport = workFlowEngine.run(workflow, workContext); executorService.shutdown(); assertThat(workReport.getStatus()).isEqualTo(WorkStatus.COMPLETED); soutl(\"\") } @Test public void useWorkContextToPassInitialParametersAndShareDataBetweenWorkUnits() { WordCountWork work1 = new WordCountWork(1); WordCountWork work2 = new WordCountWork(2); AggregateWordCountsWork work3 = new AggregateWordCountsWork(); PrintWordCount work4 = new PrintWordCount(); ExecutorService executorService = Executors.newFixedThreadPool(2); WorkFlow workflow = aNewSequentialFlow() .execute(aNewParallelFlow() .execute(work1, work2) .with(executorService) .build()) .then(work3) .then(work4) .build(); WorkFlowEngine workFlowEngine = aNewWorkFlowEngine().build(); WorkContext workContext = new WorkContext(); workContext.put(\"partition1\", \"hello foo\"); workContext.put(\"partition2\", \"hello bar\"); WorkReport workReport = workFlowEngine.run(workflow, workContext); executorService.shutdown(); assertThat(workReport.getStatus()).isEqualTo(WorkStatus.COMPLETED); } static class PrintMessageWork implements Work { private final String message; public PrintMessageWork(String message) { this.message = message; } public String getName() { return \"print message work\"; } public WorkReport execute(WorkContext workContext) { soutl(\"\") return new DefaultWorkReport(WorkStatus.COMPLETED, workContext); } } static class WordCountWork implements Work { private final int partition; public WordCountWork(int partition) { this.partition = partition; } @Override public String getName() { return \"count words in a given string\"; } @Override public WorkReport execute(WorkContext workContext) { String input = (String) workContext.get(\"partition\" + partition); workContext.put(\"wordCountInPartition\" + partition, input.split(\" \").length); return new DefaultWorkReport(WorkStatus.COMPLETED, workContext); } } static class AggregateWordCountsWork implements Work { @Override public String getName() { return \"aggregate word counts from partitions\"; } @Override public WorkReport execute(WorkContext workContext) { Set<Map.Entry<String, Object>> entrySet = workContext.getEntrySet(); int sum = 0; for (Map.Entry<String, Object> entry : entrySet) { if (entry.getKey().contains(\"InPartition\")) { sum += (int) entry.getValue(); } } workContext.put(\"totalCount\", sum); return new DefaultWorkReport(WorkStatus.COMPLETED, workContext); } } static class PrintWordCount implements Work { @Override public String getName() { return \"print total word count\"; } @Override public WorkReport execute(WorkContext workContext) { int totalCount = (int) workContext.get(\"totalCount\"); soutl(\"\") return new DefaultWorkReport(WorkStatus.COMPLETED, workContext); } } }", "dependencies": [{"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/DefaultWorkReport.java", "file_content": "package org.jeasy.flows.work; public class DefaultWorkReport implements WorkReport { private final WorkStatus status; private final WorkContext workContext; private Throwable error; public DefaultWorkReport(WorkStatus status, WorkContext workContext) { this.status = status; this.workContext = workContext; } public DefaultWorkReport(WorkStatus status, WorkContext workContext, Throwable error) { this(status, workContext); this.error = error; } public WorkStatus getStatus() { return status; } public Throwable getError() { return error; } @Override public WorkContext getWorkContext() { return workContext; } @Override public String toString() { return \"DefaultWorkReport {\" + \"status=\" + status + \", context=\" + workContext + \", error=\" + (error == null ? \"''\" : error) + '}'; } }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/Work.java", "file_content": "package org.jeasy.flows.work; import java.util.UUID; public interface Work { default String getName() { return UUID.randomUUID().toString(); } WorkReport execute(WorkContext workContext); }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkContext.java", "file_content": "package org.jeasy.flows.work; import java.util.Map; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; public class WorkContext { private final Map<String, Object> context = new ConcurrentHashMap<>(); public void put(String key, Object value) { context.put(key, value); } public Object get(String key) { return context.get(key); } public Set<Map.Entry<String, Object>> getEntrySet() { return context.entrySet(); } @Override public String toString() { return \"context=\" + context + '}'; } }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkReport.java", "file_content": "package org.jeasy.flows.work; public interface WorkReport { WorkStatus getStatus(); Throwable getError(); WorkContext getWorkContext(); }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/work/WorkStatus.java", "file_content": "package org.jeasy.flows.work; public enum WorkStatus { FAILED, COMPLETED }"}, {"file_path": "easy-flows-master/easy-flows-master/src/main/java/org/jeasy/flows/engine/WorkFlowEngineImpl.java", "file_content": "package org.jeasy.flows.engine; import org.jeasy.flows.work.WorkContext; import org.jeasy.flows.work.WorkReport; import org.jeasy.flows.workflow.WorkFlow; import org.slf4j.Logger; import org.slf4j.LoggerFactory; class WorkFlowEngineImpl implements WorkFlowEngine { private static final Logger LOGGER = LoggerFactory.getLogger(WorkFlowEngineImpl.class); public WorkReport run(WorkFlow workFlow, WorkContext workContext) { LOGGER.info(\"Running workflow ''{}''\", workFlow.getName()); return workFlow.execute(workContext); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 103, "chunk_id": 0, "prompt": {"main_file_path": "DijkstraShortestPath-main/DijkstraShortestPath-main/DijkstraShortestPath.java", "main_file_content": "import java.util.*; import java.math.*; public class DijkstraShortestPath { public static void main(String[] args) { Map<String, Map<String, Integer>> graph = new HashMap<>(); Scanner scanner = new Scanner(System.in); soutl(\"\") while (true) { String input = scanner.nextLine(); if (input.equalsIgnoreCase(\"stop\")) { break; } String[] parts = input.split(\", \"); if (parts.length != 3) { soutl(\"\") continue; } String source = parts[0]; String destination = parts[2]; int distance; try { distance = Integer.parseInt(parts[1]); } catch (NumberFormatException e) { soutl(\"\") continue; } graph.putIfAbsent(source, new HashMap<>()); graph.putIfAbsent(destination, new HashMap<>()); graph.get(source).put(destination, distance); } String sourceNode = \"s\"; String targetNode = \"f\"; Map<String, Integer> distances = new HashMap<>(); Map<String, String> previousNodes = new HashMap<>(); for (String node : graph.keySet()) { distances.put(node, Integer.MAX_VALUE); } distances.put(sourceNode, 0); Set<String> visited = new HashSet<>(); while (!visited.contains(targetNode)) { String currentNode = null; int minDistance = Integer.MAX_VALUE; for (String node : graph.keySet()) { if (!visited.contains(node) && distances.get(node) < minDistance) { currentNode = node; minDistance = distances.get(node); } } if (currentNode == null) { break; } visited.add(currentNode); for (Map.Entry<String, Integer> neighbor : graph.get(currentNode).entrySet()) { int newDistance = distances.get(currentNode) + neighbor.getValue(); if (newDistance < distances.get(neighbor.getKey())) { distances.put(neighbor.getKey(), newDistance); previousNodes.put(neighbor.getKey(), currentNode); } } } if (distances.get(targetNode) != Integer.MAX_VALUE) { soutl(\"\") soutl(\"\") Double timeTaken = distances.get(targetNode)/17.0; Integer minutesTaken = (int) Math.round(timeTaken * 60); BigDecimal roundedTimeTaken = new BigDecimal(timeTaken).setScale(2, RoundingMode.HALF_UP); soutl(\"\") } else { soutl(\"\") } } private static String getPath(Map<String, String> previousNodes, String targetNode) { List<String> path = new ArrayList<>(); path.add(targetNode); String currentNode = targetNode; while (previousNodes.containsKey(currentNode)) { currentNode = previousNodes.get(currentNode); path.add(currentNode); } Collections.reverse(path); return String.join(\" -> \", path); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "DijkstraShortestPath-main/DijkstraShortestPath-main/DijkstraShortestPath.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The DijkstraShortestPath class handles multiple responsibilities including input processing, graph construction, algorithm execution, and output formatting. This violates SRP as there's more than one reason for the class to change."}, {"principle": "Open-Closed", "justification": "The algorithm and input/output logic are directly implemented in the class without abstraction. Extending functionality (e.g., supporting different graph formats or algorithms) would require modifying existing code, violating OCP."}]}]}
{"project_id": 104, "chunk_id": 0, "prompt": {"main_file_path": "Sorting-Visualizer-main/Sorting-Visualizer-main/Visualizer/SortingVisualizer.java", "main_file_content": "package Visualizer; import java.util.ArrayList; import java.util.Collections; import Visualizer.Sorts.*; public class SortingVisualizer { private static Thread sortingThread; public static VisualizerFrame frame; public static Integer[] toBeSorted; public static boolean isSorting = false; public static int sortDataCount = 20; public static int sleep = 20; public static int blockWidth; public static boolean stepped = false; public static void main(String[] args) { frame = new VisualizerFrame(); resetArray(); frame.setLocationRelativeTo(null); } public static void resetArray(){ if (isSorting) return; toBeSorted = new Integer[sortDataCount]; blockWidth = (int) Math.max(Math.floor(500/sortDataCount), 1); for(int i = 0; i<toBeSorted.length; i++){ if (stepped) { toBeSorted[i] = i; } else { toBeSorted[i] = (int) (sortDataCount*Math.random()); } } if (stepped) { ArrayList<Integer> shuffleThis = new ArrayList<>(); for (int i = 0; i < toBeSorted.length; i++) { shuffleThis.add(toBeSorted[i]); } Collections.shuffle(shuffleThis); toBeSorted = shuffleThis.toArray(toBeSorted); } frame.preDrawArray(toBeSorted); } public static void startSort(String type){ if (sortingThread == null || !isSorting){ resetArray(); isSorting = true; switch(type){ case \"Bubble\": sortingThread = new Thread(new BubbleSort(toBeSorted, frame, false)); break; case \"Selection\": sortingThread = new Thread(new SelectionSort(toBeSorted, frame, false)); break; case \"Insertion\": sortingThread = new Thread(new InsertionSort(toBeSorted, frame, false)); break; case \"Gnome\": sortingThread = new Thread(new GnomeSort(toBeSorted, frame, false)); break; case \"Merge\": sortingThread = new Thread(new MergeSort()); break; case \"Radix LSD\": sortingThread = new Thread(new RadixSort(toBeSorted, frame, true)); break; case \"Radix MSD\": sortingThread = new Thread(new RadixSort(toBeSorted, frame, false)); break; case \"Shell\": sortingThread = new Thread(new ShellSort()); break; case \"Quandrix\": sortingThread = new Thread(new QuandrixSort()); break; case \"Bubble(fast)\": sortingThread = new Thread(new BubbleSort(toBeSorted, frame, true)); break; case \"Selection(fast)\": sortingThread = new Thread(new SelectionSort(toBeSorted, frame, true)); break; case \"Insertion(fast)\": sortingThread = new Thread(new InsertionSort(toBeSorted, frame, true)); break; case \"Gnome(fast)\": sortingThread = new Thread(new GnomeSort(toBeSorted, frame, true)); break; default: isSorting = false; return; } sortingThread.start(); } } }", "dependencies": [{"file_path": "Sorting-Visualizer-main/Sorting-Visualizer-main/Visualizer/VisualizerFrame.java", "file_content": "package Visualizer; import java.awt.BorderLayout; import java.awt.Color; import java.awt.Dimension; import java.awt.GridBagConstraints; import java.awt.GridBagLayout; import java.awt.Insets; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.ComponentEvent; import java.awt.event.ComponentListener; import javax.swing.JButton; import javax.swing.JCheckBox; import javax.swing.JComboBox; import javax.swing.JFrame; import javax.swing.JLabel; import javax.swing.JPanel; import javax.swing.JSlider; import javax.swing.event.ChangeEvent; import javax.swing.event.ChangeListener; @SuppressWarnings(\"serial\") public class VisualizerFrame extends JFrame { private final int MAX_SPEED = 1000; private final int MIN_SPEED = 1; private final int MAX_SIZE = 500; private final int MIN_SIZE = 5; private final int DEFAULT_SPEED = 20; private final int DEFAULT_SIZE = 20; private final String[] Sorts = {\"Bubble\", \"Selection\", \"Insertion\", \"Gnome\", \"Merge\", \"Radix LSD\", \"Radix MSD\", \"Shell\", \"Quandrix\", \"Bubble(fast)\", \"Selection(fast)\", \"Insertion(fast)\", \"Gnome(fast)\"}; private int sizeModifier; private JPanel wrapper; private JPanel arrayWrapper; private JPanel buttonWrapper; private JPanel[] squarePanels; private JButton start; private JComboBox<String> selection; private JSlider speed; private JSlider size; private JLabel speedVal; private JLabel sizeVal; private GridBagConstraints c; private JCheckBox stepped; public VisualizerFrame(){ super(\"Sorting Visualizer\"); start = new JButton(\"Start\"); buttonWrapper = new JPanel(); arrayWrapper = new JPanel(); wrapper = new JPanel(); selection = new JComboBox<String>(); speed = new JSlider(MIN_SPEED, MAX_SPEED, DEFAULT_SPEED); size = new JSlider(MIN_SIZE, MAX_SIZE, DEFAULT_SIZE); speedVal = new JLabel(\"Speed: 20 ms\"); sizeVal = new JLabel(\"Size: 20 values\"); stepped = new JCheckBox(\"Stepped Values\"); c = new GridBagConstraints(); for(String s : Sorts) selection.addItem(s); arrayWrapper.setLayout(new GridBagLayout()); wrapper.setLayout(new BorderLayout()); c.insets = new Insets(0,1,0,1); c.anchor = GridBagConstraints.SOUTH; start.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { SortingVisualizer.startSort((String) selection.getSelectedItem()); } }); stepped.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { SortingVisualizer.stepped = stepped.isSelected(); } }); speed.setMinorTickSpacing(10); speed.setMajorTickSpacing(100); speed.setPaintTicks(true); speed.addChangeListener(new ChangeListener() { public void stateChanged(ChangeEvent arg0) { speedVal.setText((\"Speed: \" + Integer.toString(speed.getValue()) + \"ms\")); validate(); SortingVisualizer.sleep = speed.getValue(); } }); size.setMinorTickSpacing(10); size.setMajorTickSpacing(100); size.setPaintTicks(true); size.addChangeListener(new ChangeListener() { public void stateChanged(ChangeEvent arg0) { sizeVal.setText((\"Size: \" + Integer.toString(size.getValue()) + \" values\")); validate(); SortingVisualizer.sortDataCount = size.getValue(); } }); buttonWrapper.add(stepped); buttonWrapper.add(speedVal); buttonWrapper.add(speed); buttonWrapper.add(sizeVal); buttonWrapper.add(size); buttonWrapper.add(start); buttonWrapper.add(selection); wrapper.add(buttonWrapper, BorderLayout.SOUTH); wrapper.add(arrayWrapper); add(wrapper); setExtendedState(JFrame.MAXIMIZED_BOTH ); addComponentListener(new ComponentListener() { @Override public void componentResized(ComponentEvent e) { sizeModifier = (int) ((getHeight()*0.9)/(squarePanels.length)); } @Override public void componentMoved(ComponentEvent e) { } @Override public void componentShown(ComponentEvent e) { } @Override public void componentHidden(ComponentEvent e) { } }); setVisible(true); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setLocationRelativeTo(null); } public void preDrawArray(Integer[] squares){ squarePanels = new JPanel[SortingVisualizer.sortDataCount]; arrayWrapper.removeAll(); sizeModifier = (int) ((getHeight()*0.9)/(squarePanels.length)); for(int i = 0; i<SortingVisualizer.sortDataCount; i++){ squarePanels[i] = new JPanel(); squarePanels[i].setPreferredSize(new Dimension(SortingVisualizer.blockWidth, squares[i]*sizeModifier)); squarePanels[i].setBackground(Color.blue); arrayWrapper.add(squarePanels[i], c); } repaint(); validate(); } public void reDrawArray(Integer[] x){ reDrawArray(x, -1); } public void reDrawArray(Integer[] x, int y){ reDrawArray(x, y, -1); } public void reDrawArray(Integer[] x, int y, int z){ reDrawArray(x, y, z, -1); } public void reDrawArray(Integer[] squares, int working, int comparing, int reading){ arrayWrapper.removeAll(); for(int i = 0; i<squarePanels.length; i++){ squarePanels[i] = new JPanel(); squarePanels[i].setPreferredSize(new Dimension(SortingVisualizer.blockWidth, squares[i]*sizeModifier)); if (i == working){ squarePanels[i].setBackground(Color.green); }else if(i == comparing){ squarePanels[i].setBackground(Color.red); }else if(i == reading){ squarePanels[i].setBackground(Color.yellow); }else{ squarePanels[i].setBackground(Color.blue); } arrayWrapper.add(squarePanels[i], c); } repaint(); validate(); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Sorting-Visualizer-main/Sorting-Visualizer-main/Visualizer/SortingVisualizer.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "SortingVisualizer handles array management, thread creation, and UI coordination. Multiple responsibilities like resetting arrays, starting threads, and controlling sorting flow violate SRP."}, {"principle": "Open-Closed", "justification": "startSort uses a switch-case to select sorting algorithms. Adding a new algorithm requires modifying this method, violating OCP by not allowing extension without code changes."}, {"principle": "Dependency Inversion", "justification": "High-level SortingVisualizer directly instantiates concrete sorting implementations (e.g., BubbleSort, MergeSort) instead of depending on abstractions, violating DIP."}]}]}
{"project_id": 104, "chunk_id": 0, "prompt": {"main_file_path": "Sorting-Visualizer-main/Sorting-Visualizer-main/Visualizer/VisualizerFrame.java", "main_file_content": "package Visualizer; import java.awt.BorderLayout; import java.awt.Color; import java.awt.Dimension; import java.awt.GridBagConstraints; import java.awt.GridBagLayout; import java.awt.Insets; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.ComponentEvent; import java.awt.event.ComponentListener; import javax.swing.JButton; import javax.swing.JCheckBox; import javax.swing.JComboBox; import javax.swing.JFrame; import javax.swing.JLabel; import javax.swing.JPanel; import javax.swing.JSlider; import javax.swing.event.ChangeEvent; import javax.swing.event.ChangeListener; @SuppressWarnings(\"serial\") public class VisualizerFrame extends JFrame { private final int MAX_SPEED = 1000; private final int MIN_SPEED = 1; private final int MAX_SIZE = 500; private final int MIN_SIZE = 5; private final int DEFAULT_SPEED = 20; private final int DEFAULT_SIZE = 20; private final String[] Sorts = {\"Bubble\", \"Selection\", \"Insertion\", \"Gnome\", \"Merge\", \"Radix LSD\", \"Radix MSD\", \"Shell\", \"Quandrix\", \"Bubble(fast)\", \"Selection(fast)\", \"Insertion(fast)\", \"Gnome(fast)\"}; private int sizeModifier; private JPanel wrapper; private JPanel arrayWrapper; private JPanel buttonWrapper; private JPanel[] squarePanels; private JButton start; private JComboBox<String> selection; private JSlider speed; private JSlider size; private JLabel speedVal; private JLabel sizeVal; private GridBagConstraints c; private JCheckBox stepped; public VisualizerFrame(){ super(\"Sorting Visualizer\"); start = new JButton(\"Start\"); buttonWrapper = new JPanel(); arrayWrapper = new JPanel(); wrapper = new JPanel(); selection = new JComboBox<String>(); speed = new JSlider(MIN_SPEED, MAX_SPEED, DEFAULT_SPEED); size = new JSlider(MIN_SIZE, MAX_SIZE, DEFAULT_SIZE); speedVal = new JLabel(\"Speed: 20 ms\"); sizeVal = new JLabel(\"Size: 20 values\"); stepped = new JCheckBox(\"Stepped Values\"); c = new GridBagConstraints(); for(String s : Sorts) selection.addItem(s); arrayWrapper.setLayout(new GridBagLayout()); wrapper.setLayout(new BorderLayout()); c.insets = new Insets(0,1,0,1); c.anchor = GridBagConstraints.SOUTH; start.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { SortingVisualizer.startSort((String) selection.getSelectedItem()); } }); stepped.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { SortingVisualizer.stepped = stepped.isSelected(); } }); speed.setMinorTickSpacing(10); speed.setMajorTickSpacing(100); speed.setPaintTicks(true); speed.addChangeListener(new ChangeListener() { public void stateChanged(ChangeEvent arg0) { speedVal.setText((\"Speed: \" + Integer.toString(speed.getValue()) + \"ms\")); validate(); SortingVisualizer.sleep = speed.getValue(); } }); size.setMinorTickSpacing(10); size.setMajorTickSpacing(100); size.setPaintTicks(true); size.addChangeListener(new ChangeListener() { public void stateChanged(ChangeEvent arg0) { sizeVal.setText((\"Size: \" + Integer.toString(size.getValue()) + \" values\")); validate(); SortingVisualizer.sortDataCount = size.getValue(); } }); buttonWrapper.add(stepped); buttonWrapper.add(speedVal); buttonWrapper.add(speed); buttonWrapper.add(sizeVal); buttonWrapper.add(size); buttonWrapper.add(start); buttonWrapper.add(selection); wrapper.add(buttonWrapper, BorderLayout.SOUTH); wrapper.add(arrayWrapper); add(wrapper); setExtendedState(JFrame.MAXIMIZED_BOTH ); addComponentListener(new ComponentListener() { @Override public void componentResized(ComponentEvent e) { sizeModifier = (int) ((getHeight()*0.9)/(squarePanels.length)); } @Override public void componentMoved(ComponentEvent e) { } @Override public void componentShown(ComponentEvent e) { } @Override public void componentHidden(ComponentEvent e) { } }); setVisible(true); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setLocationRelativeTo(null); } public void preDrawArray(Integer[] squares){ squarePanels = new JPanel[SortingVisualizer.sortDataCount]; arrayWrapper.removeAll(); sizeModifier = (int) ((getHeight()*0.9)/(squarePanels.length)); for(int i = 0; i<SortingVisualizer.sortDataCount; i++){ squarePanels[i] = new JPanel(); squarePanels[i].setPreferredSize(new Dimension(SortingVisualizer.blockWidth, squares[i]*sizeModifier)); squarePanels[i].setBackground(Color.blue); arrayWrapper.add(squarePanels[i], c); } repaint(); validate(); } public void reDrawArray(Integer[] x){ reDrawArray(x, -1); } public void reDrawArray(Integer[] x, int y){ reDrawArray(x, y, -1); } public void reDrawArray(Integer[] x, int y, int z){ reDrawArray(x, y, z, -1); } public void reDrawArray(Integer[] squares, int working, int comparing, int reading){ arrayWrapper.removeAll(); for(int i = 0; i<squarePanels.length; i++){ squarePanels[i] = new JPanel(); squarePanels[i].setPreferredSize(new Dimension(SortingVisualizer.blockWidth, squares[i]*sizeModifier)); if (i == working){ squarePanels[i].setBackground(Color.green); }else if(i == comparing){ squarePanels[i].setBackground(Color.red); }else if(i == reading){ squarePanels[i].setBackground(Color.yellow); }else{ squarePanels[i].setBackground(Color.blue); } arrayWrapper.add(squarePanels[i], c); } repaint(); validate(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Sorting-Visualizer-main/Sorting-Visualizer-main/Visualizer/VisualizerFrame.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "VisualizerFrame handles UI setup, event handling, array visualization, and directly modifies static variables in SortingVisualizer, indicating multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Adding a new sorting algorithm requires modifying the Sorts array and selection logic in VisualizerFrame instead of extending via abstractions."}, {"principle": "Interface Segregation", "justification": "Implements ComponentListener but only uses componentResized, forcing empty implementations for unused methods (componentMoved, componentShown, componentHidden)."}, {"principle": "Dependency Inversion", "justification": "Directly depends on concrete SortingVisualizer class (static methods/variables) instead of abstractions for sorting control and configuration."}]}]}
{"project_id": 104, "chunk_id": 0, "prompt": {"main_file_path": "Sorting-Visualizer-main/Sorting-Visualizer-main/Visualizer/Sorts/InsertionSort.java", "main_file_content": "package Visualizer.Sorts; import Visualizer.*; public class InsertionSort implements Runnable{ private Integer[] toBeSorted; private VisualizerFrame frame; private boolean fast; public InsertionSort(Integer[] toBeSorted, VisualizerFrame frame, boolean fast) { this.toBeSorted = toBeSorted; this.frame = frame; this.fast = fast; } public void run() { if (fast) { sortFast(); } else { sortSlow(); } SortingVisualizer.isSorting=false; } public void sortFast() { int temp = 0; int insert = 0; for(int i = 1; i<toBeSorted.length; i++){ insert = i; for(int j = i-1; j>=0; j--){ if (toBeSorted[i] < toBeSorted[j]){ insert = j; if (j == 0){ break; } }else{ break; } } temp = toBeSorted[i]; for (int j = i; j>insert; j--){ toBeSorted[j] = toBeSorted[j-1]; } toBeSorted[insert] = temp; frame.reDrawArray(toBeSorted, i); try { Thread.sleep(SortingVisualizer.sleep); } catch (InterruptedException e) { e.printStackTrace(); } } } public void sortSlow() { int temp = 0; int insert = 0; for(int i = 1; i<toBeSorted.length; i++){ insert = i; for(int j = i-1; j>=0; j--){ if (toBeSorted[i] < toBeSorted[j]){ insert = j; if (j == 0){ break; } }else{ break; } frame.reDrawArray(toBeSorted, i, insert); try { Thread.sleep(SortingVisualizer.sleep); } catch (InterruptedException e) { e.printStackTrace(); } } temp = toBeSorted[i]; for (int j = i; j>insert; j--){ toBeSorted[j] = toBeSorted[j-1]; } toBeSorted[insert] = temp; } frame.reDrawArray(toBeSorted); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Sorting-Visualizer-main/Sorting-Visualizer-main/Visualizer/Sorts/InsertionSort.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The InsertionSort class handles both sorting logic and visualization updates (via frame.reDrawArray), and also manages thread sleeping, indicating multiple responsibilities."}, {"principle": "Interface Segregation", "justification": "The class directly depends on the concrete VisualizerFrame, which may have methods beyond those required for reDrawArray, forcing unnecessary dependencies."}, {"principle": "Dependency Inversion", "justification": "The high-level sorting logic depends directly on the low-level VisualizerFrame implementation instead of an abstraction (e.g., an interface for visualization)."}]}]}
{"project_id": 104, "chunk_id": 0, "prompt": {"main_file_path": "Sorting-Visualizer-main/Sorting-Visualizer-main/Visualizer/Sorts/ShellSort.java", "main_file_content": "package Visualizer.Sorts; import Visualizer.SortingVisualizer; public class ShellSort implements Runnable{ public void run() { int temp = 0; Integer[] toBeSorted = SortingVisualizer.toBeSorted; int j = 0; for(int gap = toBeSorted.length/2; gap > 0; gap/=2){ for(int i = gap; i<toBeSorted.length; i++){ temp = toBeSorted[i]; for (j = i; j>=gap && temp<toBeSorted[j-gap]; j -= gap){ toBeSorted[j] = toBeSorted[j-gap]; SortingVisualizer.frame.reDrawArray(toBeSorted, i, j); try { Thread.sleep(SortingVisualizer.sleep); } catch (InterruptedException e) { e.printStackTrace(); } } toBeSorted[j] = temp; } } SortingVisualizer.isSorting=false; } }", "dependencies": [{"file_path": "Sorting-Visualizer-main/Sorting-Visualizer-main/Visualizer/SortingVisualizer.java", "file_content": "package Visualizer; import java.util.ArrayList; import java.util.Collections; import Visualizer.Sorts.*; public class SortingVisualizer { private static Thread sortingThread; public static VisualizerFrame frame; public static Integer[] toBeSorted; public static boolean isSorting = false; public static int sortDataCount = 20; public static int sleep = 20; public static int blockWidth; public static boolean stepped = false; public static void main(String[] args) { frame = new VisualizerFrame(); resetArray(); frame.setLocationRelativeTo(null); } public static void resetArray(){ if (isSorting) return; toBeSorted = new Integer[sortDataCount]; blockWidth = (int) Math.max(Math.floor(500/sortDataCount), 1); for(int i = 0; i<toBeSorted.length; i++){ if (stepped) { toBeSorted[i] = i; } else { toBeSorted[i] = (int) (sortDataCount*Math.random()); } } if (stepped) { ArrayList<Integer> shuffleThis = new ArrayList<>(); for (int i = 0; i < toBeSorted.length; i++) { shuffleThis.add(toBeSorted[i]); } Collections.shuffle(shuffleThis); toBeSorted = shuffleThis.toArray(toBeSorted); } frame.preDrawArray(toBeSorted); } public static void startSort(String type){ if (sortingThread == null || !isSorting){ resetArray(); isSorting = true; switch(type){ case \"Bubble\": sortingThread = new Thread(new BubbleSort(toBeSorted, frame, false)); break; case \"Selection\": sortingThread = new Thread(new SelectionSort(toBeSorted, frame, false)); break; case \"Insertion\": sortingThread = new Thread(new InsertionSort(toBeSorted, frame, false)); break; case \"Gnome\": sortingThread = new Thread(new GnomeSort(toBeSorted, frame, false)); break; case \"Merge\": sortingThread = new Thread(new MergeSort()); break; case \"Radix LSD\": sortingThread = new Thread(new RadixSort(toBeSorted, frame, true)); break; case \"Radix MSD\": sortingThread = new Thread(new RadixSort(toBeSorted, frame, false)); break; case \"Shell\": sortingThread = new Thread(new ShellSort()); break; case \"Quandrix\": sortingThread = new Thread(new QuandrixSort()); break; case \"Bubble(fast)\": sortingThread = new Thread(new BubbleSort(toBeSorted, frame, true)); break; case \"Selection(fast)\": sortingThread = new Thread(new SelectionSort(toBeSorted, frame, true)); break; case \"Insertion(fast)\": sortingThread = new Thread(new InsertionSort(toBeSorted, frame, true)); break; case \"Gnome(fast)\": sortingThread = new Thread(new GnomeSort(toBeSorted, frame, true)); break; default: isSorting = false; return; } sortingThread.start(); } } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Sorting-Visualizer-main/Sorting-Visualizer-main/Visualizer/Sorts/ShellSort.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "ShellSort handles both sorting logic and directly updates the visualization by interacting with SortingVisualizer.frame, combining two responsibilities."}, {"principle": "Dependency Inversion", "justification": "ShellSort directly depends on concrete static fields of SortingVisualizer (e.g., toBeSorted, sleep) instead of abstractions."}]}, {"file_path": "Sorting-Visualizer-main/Sorting-Visualizer-main/Visualizer/SortingVisualizer.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "SortingVisualizer manages array initialization, thread coordination, UI frame updates, and algorithm selection, violating single responsibility."}, {"principle": "Open-Closed", "justification": "The switch statement in startSort() requires modification to add new sorting algorithms, violating the Open/Closed Principle."}, {"principle": "Dependency Inversion", "justification": "SortingVisualizer directly instantiates concrete sorting algorithm classes (e.g., BubbleSort, ShellSort) instead of depending on abstractions."}]}]}
{"project_id": 104, "chunk_id": 0, "prompt": {"main_file_path": "Sorting-Visualizer-main/Sorting-Visualizer-main/Visualizer/Sorts/RadixSort.java", "main_file_content": "package Visualizer.Sorts; import java.util.ArrayList; import Visualizer.SortingVisualizer; import Visualizer.VisualizerFrame; public class RadixSort implements Runnable{ private Integer[] toBeSorted; private VisualizerFrame frame; private boolean lsd; public RadixSort(Integer[] toBeSorted, VisualizerFrame frame, boolean lsd) { this.toBeSorted = toBeSorted; this.frame = frame; this.lsd = lsd; } public void run() { if (lsd) radixlsd(toBeSorted, 1); else radixmsd(toBeSorted, findDigit(toBeSorted)); SortingVisualizer.isSorting=false; } private void radixlsd(Integer[] x, int digit){ ArrayList<Integer>[] buckets = new ArrayList[10]; for(int i = 0; i<10; i++){ buckets[i] = new ArrayList<Integer>(); } int theDig = 0; int maxI = 0; for(int i = 0; i<x.length; i++){ theDig = (int) (x[i]%Math.pow(10, digit)); for(int t = 0; t<digit-1; t++){ theDig/=10; } if (x[i] > maxI) maxI = x[i]; frame.reDrawArray(x, -1, -1, i); try { Thread.sleep(SortingVisualizer.sleep); } catch (InterruptedException e) { e.printStackTrace(); } buckets[theDig].add(x[i]); } ArrayList<Integer> finalList = new ArrayList<>(); for(int i = 0; i<10; i++){ finalList.addAll(buckets[i]); } Integer[] y = finalList.toArray(new Integer[0]); frame.reDrawArray(y); try { Thread.sleep(SortingVisualizer.sleep); } catch (InterruptedException e) { e.printStackTrace(); } if (maxI < Math.pow(10, digit)) return; radixlsd(y, digit+1); } private void radixmsd(Integer[] x, int digit){ ArrayList<Integer>[] buckets = new ArrayList[10]; for(int i = 0; i<10; i++){ buckets[i] = new ArrayList<Integer>(); } int theDig = 0; for(int i = 0; i<x.length; i++){ theDig = (int) (x[i]%Math.pow(10, digit)); for(int t = 0; t<digit-1; t++){ theDig/=10; } frame.reDrawArray(x, -1, -1, i); try { Thread.sleep(SortingVisualizer.sleep); } catch (InterruptedException e) { e.printStackTrace(); } buckets[theDig].add(x[i]); } ArrayList<Integer> finalList = new ArrayList<>(); for(int i = 0; i<10; i++){ finalList.addAll(buckets[i]); } Integer[] y = finalList.toArray(new Integer[0]); frame.reDrawArray(y); try { Thread.sleep(SortingVisualizer.sleep); } catch (InterruptedException e) { e.printStackTrace(); } if (digit == 1) return; int beginning = 0; for (int i = 0; i < 10; i++) { y = radixmsd(y, digit-1, beginning, beginning + buckets[i].size()); beginning += buckets[i].size(); } } private Integer[] radixmsd(Integer[] x, int digit, int begin, int end){ ArrayList<Integer>[] buckets = new ArrayList[10]; for(int i = 0; i<10; i++){ buckets[i] = new ArrayList<Integer>(); } int theDig = 0; for(int i = begin; i<end; i++){ theDig = (int) (x[i]%Math.pow(10, digit)); for(int t = 0; t<digit-1; t++){ theDig/=10; } frame.reDrawArray(x, -1, -1, i); try { Thread.sleep(SortingVisualizer.sleep); } catch (InterruptedException e) { e.printStackTrace(); } buckets[theDig].add(x[i]); } ArrayList<Integer> finalList = new ArrayList<>(); for (int i = 0; i < begin; i++) { finalList.add(x[i]); } for(int i = 0; i<10; i++){ finalList.addAll(buckets[i]); } for (int i = end; i < x.length; i++) { finalList.add(x[i]); } Integer[] y = finalList.toArray(new Integer[0]); frame.reDrawArray(y); try { Thread.sleep(SortingVisualizer.sleep); } catch (InterruptedException e) { e.printStackTrace(); } if (digit == 1) return y; int beginning = begin; for (int i = 0; i < 10; i++) { y = radixmsd(y, digit-1, beginning, beginning + buckets[i].size()); beginning += buckets[i].size(); } return y; } private int findDigit(Integer[] x) { int max = Integer.MIN_VALUE; int digit = 1; for (int i : x) { if (i > max) max = i; } while (max > 10) { max = max/10; digit++; } return digit; } }", "dependencies": [{"file_path": "Sorting-Visualizer-main/Sorting-Visualizer-main/Visualizer/SortingVisualizer.java", "file_content": "package Visualizer; import java.util.ArrayList; import java.util.Collections; import Visualizer.Sorts.*; public class SortingVisualizer { private static Thread sortingThread; public static VisualizerFrame frame; public static Integer[] toBeSorted; public static boolean isSorting = false; public static int sortDataCount = 20; public static int sleep = 20; public static int blockWidth; public static boolean stepped = false; public static void main(String[] args) { frame = new VisualizerFrame(); resetArray(); frame.setLocationRelativeTo(null); } public static void resetArray(){ if (isSorting) return; toBeSorted = new Integer[sortDataCount]; blockWidth = (int) Math.max(Math.floor(500/sortDataCount), 1); for(int i = 0; i<toBeSorted.length; i++){ if (stepped) { toBeSorted[i] = i; } else { toBeSorted[i] = (int) (sortDataCount*Math.random()); } } if (stepped) { ArrayList<Integer> shuffleThis = new ArrayList<>(); for (int i = 0; i < toBeSorted.length; i++) { shuffleThis.add(toBeSorted[i]); } Collections.shuffle(shuffleThis); toBeSorted = shuffleThis.toArray(toBeSorted); } frame.preDrawArray(toBeSorted); } public static void startSort(String type){ if (sortingThread == null || !isSorting){ resetArray(); isSorting = true; switch(type){ case \"Bubble\": sortingThread = new Thread(new BubbleSort(toBeSorted, frame, false)); break; case \"Selection\": sortingThread = new Thread(new SelectionSort(toBeSorted, frame, false)); break; case \"Insertion\": sortingThread = new Thread(new InsertionSort(toBeSorted, frame, false)); break; case \"Gnome\": sortingThread = new Thread(new GnomeSort(toBeSorted, frame, false)); break; case \"Merge\": sortingThread = new Thread(new MergeSort()); break; case \"Radix LSD\": sortingThread = new Thread(new RadixSort(toBeSorted, frame, true)); break; case \"Radix MSD\": sortingThread = new Thread(new RadixSort(toBeSorted, frame, false)); break; case \"Shell\": sortingThread = new Thread(new ShellSort()); break; case \"Quandrix\": sortingThread = new Thread(new QuandrixSort()); break; case \"Bubble(fast)\": sortingThread = new Thread(new BubbleSort(toBeSorted, frame, true)); break; case \"Selection(fast)\": sortingThread = new Thread(new SelectionSort(toBeSorted, frame, true)); break; case \"Insertion(fast)\": sortingThread = new Thread(new InsertionSort(toBeSorted, frame, true)); break; case \"Gnome(fast)\": sortingThread = new Thread(new GnomeSort(toBeSorted, frame, true)); break; default: isSorting = false; return; } sortingThread.start(); } } }"}, {"file_path": "Sorting-Visualizer-main/Sorting-Visualizer-main/Visualizer/VisualizerFrame.java", "file_content": "package Visualizer; import java.awt.BorderLayout; import java.awt.Color; import java.awt.Dimension; import java.awt.GridBagConstraints; import java.awt.GridBagLayout; import java.awt.Insets; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.ComponentEvent; import java.awt.event.ComponentListener; import javax.swing.JButton; import javax.swing.JCheckBox; import javax.swing.JComboBox; import javax.swing.JFrame; import javax.swing.JLabel; import javax.swing.JPanel; import javax.swing.JSlider; import javax.swing.event.ChangeEvent; import javax.swing.event.ChangeListener; @SuppressWarnings(\"serial\") public class VisualizerFrame extends JFrame { private final int MAX_SPEED = 1000; private final int MIN_SPEED = 1; private final int MAX_SIZE = 500; private final int MIN_SIZE = 5; private final int DEFAULT_SPEED = 20; private final int DEFAULT_SIZE = 20; private final String[] Sorts = {\"Bubble\", \"Selection\", \"Insertion\", \"Gnome\", \"Merge\", \"Radix LSD\", \"Radix MSD\", \"Shell\", \"Quandrix\", \"Bubble(fast)\", \"Selection(fast)\", \"Insertion(fast)\", \"Gnome(fast)\"}; private int sizeModifier; private JPanel wrapper; private JPanel arrayWrapper; private JPanel buttonWrapper; private JPanel[] squarePanels; private JButton start; private JComboBox<String> selection; private JSlider speed; private JSlider size; private JLabel speedVal; private JLabel sizeVal; private GridBagConstraints c; private JCheckBox stepped; public VisualizerFrame(){ super(\"Sorting Visualizer\"); start = new JButton(\"Start\"); buttonWrapper = new JPanel(); arrayWrapper = new JPanel(); wrapper = new JPanel(); selection = new JComboBox<String>(); speed = new JSlider(MIN_SPEED, MAX_SPEED, DEFAULT_SPEED); size = new JSlider(MIN_SIZE, MAX_SIZE, DEFAULT_SIZE); speedVal = new JLabel(\"Speed: 20 ms\"); sizeVal = new JLabel(\"Size: 20 values\"); stepped = new JCheckBox(\"Stepped Values\"); c = new GridBagConstraints(); for(String s : Sorts) selection.addItem(s); arrayWrapper.setLayout(new GridBagLayout()); wrapper.setLayout(new BorderLayout()); c.insets = new Insets(0,1,0,1); c.anchor = GridBagConstraints.SOUTH; start.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { SortingVisualizer.startSort((String) selection.getSelectedItem()); } }); stepped.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { SortingVisualizer.stepped = stepped.isSelected(); } }); speed.setMinorTickSpacing(10); speed.setMajorTickSpacing(100); speed.setPaintTicks(true); speed.addChangeListener(new ChangeListener() { public void stateChanged(ChangeEvent arg0) { speedVal.setText((\"Speed: \" + Integer.toString(speed.getValue()) + \"ms\")); validate(); SortingVisualizer.sleep = speed.getValue(); } }); size.setMinorTickSpacing(10); size.setMajorTickSpacing(100); size.setPaintTicks(true); size.addChangeListener(new ChangeListener() { public void stateChanged(ChangeEvent arg0) { sizeVal.setText((\"Size: \" + Integer.toString(size.getValue()) + \" values\")); validate(); SortingVisualizer.sortDataCount = size.getValue(); } }); buttonWrapper.add(stepped); buttonWrapper.add(speedVal); buttonWrapper.add(speed); buttonWrapper.add(sizeVal); buttonWrapper.add(size); buttonWrapper.add(start); buttonWrapper.add(selection); wrapper.add(buttonWrapper, BorderLayout.SOUTH); wrapper.add(arrayWrapper); add(wrapper); setExtendedState(JFrame.MAXIMIZED_BOTH ); addComponentListener(new ComponentListener() { @Override public void componentResized(ComponentEvent e) { sizeModifier = (int) ((getHeight()*0.9)/(squarePanels.length)); } @Override public void componentMoved(ComponentEvent e) { } @Override public void componentShown(ComponentEvent e) { } @Override public void componentHidden(ComponentEvent e) { } }); setVisible(true); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setLocationRelativeTo(null); } public void preDrawArray(Integer[] squares){ squarePanels = new JPanel[SortingVisualizer.sortDataCount]; arrayWrapper.removeAll(); sizeModifier = (int) ((getHeight()*0.9)/(squarePanels.length)); for(int i = 0; i<SortingVisualizer.sortDataCount; i++){ squarePanels[i] = new JPanel(); squarePanels[i].setPreferredSize(new Dimension(SortingVisualizer.blockWidth, squares[i]*sizeModifier)); squarePanels[i].setBackground(Color.blue); arrayWrapper.add(squarePanels[i], c); } repaint(); validate(); } public void reDrawArray(Integer[] x){ reDrawArray(x, -1); } public void reDrawArray(Integer[] x, int y){ reDrawArray(x, y, -1); } public void reDrawArray(Integer[] x, int y, int z){ reDrawArray(x, y, z, -1); } public void reDrawArray(Integer[] squares, int working, int comparing, int reading){ arrayWrapper.removeAll(); for(int i = 0; i<squarePanels.length; i++){ squarePanels[i] = new JPanel(); squarePanels[i].setPreferredSize(new Dimension(SortingVisualizer.blockWidth, squares[i]*sizeModifier)); if (i == working){ squarePanels[i].setBackground(Color.green); }else if(i == comparing){ squarePanels[i].setBackground(Color.red); }else if(i == reading){ squarePanels[i].setBackground(Color.yellow); }else{ squarePanels[i].setBackground(Color.blue); } arrayWrapper.add(squarePanels[i], c); } repaint(); validate(); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Sorting-Visualizer-main/Sorting-Visualizer-main/Visualizer/Sorts/RadixSort.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "RadixSort handles both sorting logic and direct UI updates via VisualizerFrame, mixing two responsibilities."}, {"principle": "Open-Closed", "justification": "Adding new radix sort variations requires modifying the existing class (e.g., boolean flag for LSD/MSD)."}, {"principle": "Dependency Inversion", "justification": "Depends directly on concrete VisualizerFrame and SortingVisualizer classes instead of abstractions."}]}, {"file_path": "Sorting-Visualizer-main/Sorting-Visualizer-main/Visualizer/SortingVisualizer.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "Switch statement in startSort requires modification to add new sorting algorithms."}, {"principle": "Dependency Inversion", "justification": "High-level module directly instantiates concrete sort classes instead of depending on abstractions."}]}]}
{"project_id": 104, "chunk_id": 0, "prompt": {"main_file_path": "Sorting-Visualizer-main/Sorting-Visualizer-main/Visualizer/Sorts/MergeSort.java", "main_file_content": "package Visualizer.Sorts; import Visualizer.SortingVisualizer; public class MergeSort implements Runnable{ public void run() { Integer[] toBeSorted = SortingVisualizer.toBeSorted; inPlaceSort(toBeSorted); SortingVisualizer.isSorting=false; } public void inPlaceSort ( Integer[] x ) { inPlaceSort (x, 0, x.length-1); } private void inPlaceSort ( Integer[] x, int first, int last ) { int mid, lt, rt; int tmp; if ( first >= last ) return; mid = (first + last) / 2; inPlaceSort (x, first, mid); inPlaceSort (x, mid+1, last); lt = first; rt = mid+1; if ( x[mid] <= x[rt]) return; while (lt <= mid && rt <= last) { if ( x[lt] <= x[rt]) lt++; else { tmp = x[rt]; for (int i = rt-lt;i>0; i--){ x[lt+i] = x[lt+i-1]; } x[lt] = tmp; lt++; mid++; rt++; } SortingVisualizer.frame.reDrawArray(x, mid, rt, lt); try { Thread.sleep(SortingVisualizer.sleep); } catch (InterruptedException e) { e.printStackTrace(); } } } }", "dependencies": [{"file_path": "Sorting-Visualizer-main/Sorting-Visualizer-main/Visualizer/SortingVisualizer.java", "file_content": "package Visualizer; import java.util.ArrayList; import java.util.Collections; import Visualizer.Sorts.*; public class SortingVisualizer { private static Thread sortingThread; public static VisualizerFrame frame; public static Integer[] toBeSorted; public static boolean isSorting = false; public static int sortDataCount = 20; public static int sleep = 20; public static int blockWidth; public static boolean stepped = false; public static void main(String[] args) { frame = new VisualizerFrame(); resetArray(); frame.setLocationRelativeTo(null); } public static void resetArray(){ if (isSorting) return; toBeSorted = new Integer[sortDataCount]; blockWidth = (int) Math.max(Math.floor(500/sortDataCount), 1); for(int i = 0; i<toBeSorted.length; i++){ if (stepped) { toBeSorted[i] = i; } else { toBeSorted[i] = (int) (sortDataCount*Math.random()); } } if (stepped) { ArrayList<Integer> shuffleThis = new ArrayList<>(); for (int i = 0; i < toBeSorted.length; i++) { shuffleThis.add(toBeSorted[i]); } Collections.shuffle(shuffleThis); toBeSorted = shuffleThis.toArray(toBeSorted); } frame.preDrawArray(toBeSorted); } public static void startSort(String type){ if (sortingThread == null || !isSorting){ resetArray(); isSorting = true; switch(type){ case \"Bubble\": sortingThread = new Thread(new BubbleSort(toBeSorted, frame, false)); break; case \"Selection\": sortingThread = new Thread(new SelectionSort(toBeSorted, frame, false)); break; case \"Insertion\": sortingThread = new Thread(new InsertionSort(toBeSorted, frame, false)); break; case \"Gnome\": sortingThread = new Thread(new GnomeSort(toBeSorted, frame, false)); break; case \"Merge\": sortingThread = new Thread(new MergeSort()); break; case \"Radix LSD\": sortingThread = new Thread(new RadixSort(toBeSorted, frame, true)); break; case \"Radix MSD\": sortingThread = new Thread(new RadixSort(toBeSorted, frame, false)); break; case \"Shell\": sortingThread = new Thread(new ShellSort()); break; case \"Quandrix\": sortingThread = new Thread(new QuandrixSort()); break; case \"Bubble(fast)\": sortingThread = new Thread(new BubbleSort(toBeSorted, frame, true)); break; case \"Selection(fast)\": sortingThread = new Thread(new SelectionSort(toBeSorted, frame, true)); break; case \"Insertion(fast)\": sortingThread = new Thread(new InsertionSort(toBeSorted, frame, true)); break; case \"Gnome(fast)\": sortingThread = new Thread(new GnomeSort(toBeSorted, frame, true)); break; default: isSorting = false; return; } sortingThread.start(); } } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Sorting-Visualizer-main/Sorting-Visualizer-main/Visualizer/Sorts/MergeSort.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "MergeSort handles sorting logic and directly triggers UI updates (reDrawArray) and thread sleeping, combining multiple responsibilities."}, {"principle": "Liskov", "justification": "MergeSort relies on static state (SortingVisualizer.toBeSorted), unlike other sorts that use instance-specific data, breaking substitutability."}]}, {"file_path": "Sorting-Visualizer-main/Sorting-Visualizer-main/Visualizer/SortingVisualizer.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "Adding a new sort requires modifying the switch-case in startSort, violating 'open for extension, closed for modification'."}, {"principle": "Dependency Inversion", "justification": "High-level module SortingVisualizer directly instantiates concrete sorting classes instead of depending on abstractions."}]}]}
{"project_id": 104, "chunk_id": 0, "prompt": {"main_file_path": "Sorting-Visualizer-main/Sorting-Visualizer-main/Visualizer/Sorts/GnomeSort.java", "main_file_content": "package Visualizer.Sorts; import Visualizer.*; public class GnomeSort implements Runnable{ private Integer[] toBeSorted; private VisualizerFrame frame; private boolean fast; public GnomeSort(Integer[] toBeSorted, VisualizerFrame frame, boolean fast) { this.toBeSorted = toBeSorted; this.frame = frame; this.fast = fast; } public void run() { if (fast) { sortFast(); } else { sortSlow(); } SortingVisualizer.isSorting=false; } public void sortFast() { int temp = 0; for(int i = 0; i<toBeSorted.length-1; i++){ for(int j = i+1; j>0; j--){ if (toBeSorted[j] < toBeSorted[j-1]){ temp = toBeSorted[j]; toBeSorted[j] = toBeSorted[j-1]; toBeSorted[j-1] = temp; }else{ break; } } frame.reDrawArray(toBeSorted); try { Thread.sleep(SortingVisualizer.sleep); } catch (InterruptedException e) { e.printStackTrace(); } } } public void sortSlow() { int temp = 0; for(int i = 0; i<toBeSorted.length-1; i++){ for(int j = i+1; j>0; j--){ if (toBeSorted[j] < toBeSorted[j-1]){ temp = toBeSorted[j]; toBeSorted[j] = toBeSorted[j-1]; toBeSorted[j-1] = temp; frame.reDrawArray(toBeSorted, j, j-1); try { Thread.sleep(SortingVisualizer.sleep); } catch (InterruptedException e) { e.printStackTrace(); } }else{ break; } } } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Sorting-Visualizer-main/Sorting-Visualizer-main/Visualizer/Sorts/GnomeSort.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "GnomeSort handles both sorting logic and visualization updates (via frame.reDrawArray), violating SRP by having multiple responsibilities."}, {"principle": "Dependency Inversion", "justification": "GnomeSort directly depends on concrete classes VisualizerFrame and SortingVisualizer instead of abstractions, violating DIP by coupling high-level and low-level modules."}]}]}
{"project_id": 104, "chunk_id": 0, "prompt": {"main_file_path": "Sorting-Visualizer-main/Sorting-Visualizer-main/Visualizer/Sorts/QuandrixSort.java", "main_file_content": "package Visualizer.Sorts; import Visualizer.SortingVisualizer; public class QuandrixSort implements Runnable{ public void run() { int temp = 0; Integer[] toBeSorted = SortingVisualizer.toBeSorted; int i = 0; if (toBeSorted.length % 3 == 0) { SortingVisualizer.isSorting=false; return; } boolean swapped = false; int doubleCheck = 0; boolean end = false; while(doubleCheck < 3){ if (end) { swapped = false; end = false; } int j = i + 1; int k = j + 1; if (k < toBeSorted.length) { if (toBeSorted[k] < toBeSorted[j]) { temp = toBeSorted[j]; toBeSorted[j] = toBeSorted[k]; toBeSorted[k] = temp; swapped = true; } SortingVisualizer.frame.reDrawArray(toBeSorted, k, j); try { Thread.sleep(SortingVisualizer.sleep); } catch (InterruptedException e) { e.printStackTrace(); } } if (j < toBeSorted.length) { if (toBeSorted[j] < toBeSorted[i]) { temp = toBeSorted[i]; toBeSorted[i] = toBeSorted[j]; toBeSorted[j] = temp; swapped = true; } SortingVisualizer.frame.reDrawArray(toBeSorted, j, i); try { Thread.sleep(SortingVisualizer.sleep); } catch (InterruptedException e) { e.printStackTrace(); } if (k < toBeSorted.length) { if (toBeSorted[k] < toBeSorted[j]) { temp = toBeSorted[j]; toBeSorted[j] = toBeSorted[k]; toBeSorted[k] = temp; swapped = true; } SortingVisualizer.frame.reDrawArray(toBeSorted, k, j); try { Thread.sleep(SortingVisualizer.sleep); } catch (InterruptedException e) { e.printStackTrace(); } } } i += 3; if (i >= toBeSorted.length) { i = i % toBeSorted.length; end = true; if (!swapped) { doubleCheck++; } else { doubleCheck = 0; } } } SortingVisualizer.isSorting=false; } }", "dependencies": [{"file_path": "Sorting-Visualizer-main/Sorting-Visualizer-main/Visualizer/SortingVisualizer.java", "file_content": "package Visualizer; import java.util.ArrayList; import java.util.Collections; import Visualizer.Sorts.*; public class SortingVisualizer { private static Thread sortingThread; public static VisualizerFrame frame; public static Integer[] toBeSorted; public static boolean isSorting = false; public static int sortDataCount = 20; public static int sleep = 20; public static int blockWidth; public static boolean stepped = false; public static void main(String[] args) { frame = new VisualizerFrame(); resetArray(); frame.setLocationRelativeTo(null); } public static void resetArray(){ if (isSorting) return; toBeSorted = new Integer[sortDataCount]; blockWidth = (int) Math.max(Math.floor(500/sortDataCount), 1); for(int i = 0; i<toBeSorted.length; i++){ if (stepped) { toBeSorted[i] = i; } else { toBeSorted[i] = (int) (sortDataCount*Math.random()); } } if (stepped) { ArrayList<Integer> shuffleThis = new ArrayList<>(); for (int i = 0; i < toBeSorted.length; i++) { shuffleThis.add(toBeSorted[i]); } Collections.shuffle(shuffleThis); toBeSorted = shuffleThis.toArray(toBeSorted); } frame.preDrawArray(toBeSorted); } public static void startSort(String type){ if (sortingThread == null || !isSorting){ resetArray(); isSorting = true; switch(type){ case \"Bubble\": sortingThread = new Thread(new BubbleSort(toBeSorted, frame, false)); break; case \"Selection\": sortingThread = new Thread(new SelectionSort(toBeSorted, frame, false)); break; case \"Insertion\": sortingThread = new Thread(new InsertionSort(toBeSorted, frame, false)); break; case \"Gnome\": sortingThread = new Thread(new GnomeSort(toBeSorted, frame, false)); break; case \"Merge\": sortingThread = new Thread(new MergeSort()); break; case \"Radix LSD\": sortingThread = new Thread(new RadixSort(toBeSorted, frame, true)); break; case \"Radix MSD\": sortingThread = new Thread(new RadixSort(toBeSorted, frame, false)); break; case \"Shell\": sortingThread = new Thread(new ShellSort()); break; case \"Quandrix\": sortingThread = new Thread(new QuandrixSort()); break; case \"Bubble(fast)\": sortingThread = new Thread(new BubbleSort(toBeSorted, frame, true)); break; case \"Selection(fast)\": sortingThread = new Thread(new SelectionSort(toBeSorted, frame, true)); break; case \"Insertion(fast)\": sortingThread = new Thread(new InsertionSort(toBeSorted, frame, true)); break; case \"Gnome(fast)\": sortingThread = new Thread(new GnomeSort(toBeSorted, frame, true)); break; default: isSorting = false; return; } sortingThread.start(); } } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Sorting-Visualizer-main/Sorting-Visualizer-main/Visualizer/Sorts/QuandrixSort.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "QuandrixSort handles both sorting logic and direct UI updates (via SortingVisualizer.frame.reDrawArray), combining two responsibilities in one class."}, {"principle": "Dependency Inversion", "justification": "QuandrixSort directly depends on concrete static fields in SortingVisualizer (toBeSorted, isSorting, sleep, frame) instead of abstractions."}]}, {"file_path": "Sorting-Visualizer-main/Sorting-Visualizer-main/Visualizer/SortingVisualizer.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "The startSort method's switch statement requires modification to add new sorting algorithms, violating the Open/Closed Principle."}, {"principle": "Dependency Inversion", "justification": "SortingVisualizer directly instantiates concrete sorting algorithm classes instead of depending on abstractions (e.g., a SortingAlgorithm interface)."}, {"principle": "Single Responsibility", "justification": "SortingVisualizer manages array data, UI components, thread creation, and algorithm selection, exceeding a single responsibility."}]}]}
{"project_id": 104, "chunk_id": 0, "prompt": {"main_file_path": "Sorting-Visualizer-main/Sorting-Visualizer-main/Visualizer/Sorts/BubbleSort.java", "main_file_content": "package Visualizer.Sorts; import Visualizer.*; public class BubbleSort implements Runnable{ private Integer[] toBeSorted; private VisualizerFrame frame; private boolean fast; public BubbleSort(Integer[] toBeSorted, VisualizerFrame frame, boolean fast) { this.toBeSorted = toBeSorted; this.frame = frame; this.fast = fast; } public void run() { if (fast) { sortFast(); } else { sortSlow(); } SortingVisualizer.isSorting=false; } public void sortFast() { int temp = 0; boolean swapped = false; for(int i = 0; i<toBeSorted.length-1; i++){ swapped = false; for(int j = 1; j<toBeSorted.length-i; j++){ if (toBeSorted[j-1]> toBeSorted[j]){ temp = toBeSorted[j-1]; toBeSorted[j-1] = toBeSorted[j]; toBeSorted[j]= temp; swapped = true; } } frame.reDrawArray(toBeSorted); try { Thread.sleep(SortingVisualizer.sleep); } catch (InterruptedException e) { e.printStackTrace(); } if (!swapped) break; } } public void sortSlow() { int temp = 0; boolean swapped = false; for(int i = 0; i<toBeSorted.length-1; i++){ swapped = false; for(int j = 1; j<toBeSorted.length-i; j++){ if (toBeSorted[j-1]> toBeSorted[j]){ temp = toBeSorted[j-1]; toBeSorted[j-1] = toBeSorted[j]; toBeSorted[j]= temp; swapped = true; } frame.reDrawArray(toBeSorted, j, j+1); try { Thread.sleep(SortingVisualizer.sleep); } catch (InterruptedException e) { e.printStackTrace(); } } if (!swapped) break; } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Sorting-Visualizer-main/Sorting-Visualizer-main/Visualizer/Sorts/BubbleSort.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "BubbleSort class manages sorting logic and directly interacts with visualization (frame.reDrawArray), handling two responsibilities: algorithm execution and UI updates."}, {"principle": "Dependency Inversion", "justification": "BubbleSort directly depends on the concrete VisualizerFrame class instead of an abstraction, violating the rule that high-level modules should depend on abstractions."}]}]}
{"project_id": 104, "chunk_id": 0, "prompt": {"main_file_path": "Sorting-Visualizer-main/Sorting-Visualizer-main/Visualizer/Sorts/SelectionSort.java", "main_file_content": "package Visualizer.Sorts; import Visualizer.*; public class SelectionSort implements Runnable{ private Integer[] toBeSorted; private VisualizerFrame frame; private boolean fast; public SelectionSort(Integer[] toBeSorted, VisualizerFrame frame, boolean fast) { this.toBeSorted = toBeSorted; this.frame = frame; this.fast = fast; } public void run() { if (fast) { sortFast(); } else { sortSlow(); } SortingVisualizer.isSorting=false; } public void sortFast(){ int temp = 0; int selected = 0; for(int i = 0; i<toBeSorted.length; i++){ selected = i; for(int j = toBeSorted.length-1; j>i; j--){ if (toBeSorted[j] <= toBeSorted[selected]){ selected = j; } } frame.reDrawArray(toBeSorted); try { Thread.sleep(SortingVisualizer.sleep); } catch (InterruptedException e) { e.printStackTrace(); } temp = toBeSorted[i]; toBeSorted[i] = toBeSorted[selected]; toBeSorted[selected]= temp; } } public void sortSlow() { int temp = 0; int selected = 0; for(int i = 0; i<toBeSorted.length; i++){ selected = i; for(int j = toBeSorted.length-1; j>i; j--){ if (toBeSorted[j] <= toBeSorted[selected]){ selected = j; } frame.reDrawArray(toBeSorted, selected, j-1); try { Thread.sleep(SortingVisualizer.sleep); } catch (InterruptedException e) { e.printStackTrace(); } } temp = toBeSorted[i]; toBeSorted[i] = toBeSorted[selected]; toBeSorted[selected]= temp; } frame.reDrawArray(toBeSorted); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Sorting-Visualizer-main/Sorting-Visualizer-main/Visualizer/Sorts/SelectionSort.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The SelectionSort class handles both sorting logic and visualization updates (via frame.reDrawArray), indicating multiple responsibilities."}, {"principle": "Interface Segregation", "justification": "Depends directly on the concrete VisualizerFrame class, which may expose unnecessary methods beyond the required reDrawArray."}, {"principle": "Dependency Inversion", "justification": "High-level sorting logic depends on concrete VisualizerFrame and SortingVisualizer classes instead of abstractions."}]}]}
{"project_id": 106, "chunk_id": 0, "prompt": {"main_file_path": "Digi-Wallet-Project-main/src/main/java/Main.java", "main_file_content": "import DAO.WalletDAO; import DAO.WalletDAOImpl; import DAO.TransactionDAO; import DAO.TransactionDAOImpl; import DAO.UserDAOImpl; import Service.ReportService; import beans.*; import org.hibernate.Hibernate; import org.hibernate.Session; import org.hibernate.SessionFactory; import org.hibernate.Transaction; import org.hibernate.cfg.Configuration; import java.util.List; import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); SessionFactory sf = new Configuration().configure().buildSessionFactory(); Session s = sf.openSession(); try { UserDAOImpl userDAO = new UserDAOImpl(); boolean running = true; User user = null; while (running) { soutl(\"\") soutl(\"\") soutl(\"\") sout(\"\") int choice = sc.nextInt(); sc.nextLine(); switch (choice) { case 1: boolean loggedIn = false; while (!loggedIn) { sout(\"\") String username = sc.nextLine(); sout(\"\") String password = sc.nextLine(); user = userDAO.findUserByUsername(username); if (user != null && user.getPassword().equals(password)) { loggedIn = true; soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") sout(\"\") int action = sc.nextInt(); sc.nextLine(); switch (action) { case 1: WalletDAO walletInfo = new WalletDAOImpl(); Wallet userWallet=walletInfo.findWalletByUserId(user.getId()); if (userWallet != null) { soutl(\"\") soutl(\"\") } else { soutl(\"\") } break; case 2: Transaction tx = s.beginTransaction(); Category category = new Category(); sout(\"\") String c = sc.nextLine(); category.setName(c); s.save(category); Transactions transaction = new Transactions(); sout(\"\") double a = sc.nextDouble(); sc.nextLine(); transaction.setAmount(a); transaction.setDate(new java.util.Date()); transaction.setDescription(c); sout(\"\") String madeTo = sc.nextLine(); transaction.setMadeTo(madeTo); sout(\"\") String t = sc.nextLine(); transaction.setType(t); Wallet walletFromDB = s.get(Wallet.class, user.getWallet().getId()); Hibernate.initialize(walletFromDB.getTransactions()); if (t.equalsIgnoreCase(\"credit\")) { walletFromDB.setBalance(walletFromDB.getBalance() + a); } else if (t.equalsIgnoreCase(\"debit\")) { if (walletFromDB.getBalance() >= a) { walletFromDB.setBalance(walletFromDB.getBalance() - a); } else { soutl(\"\") return; } } transaction.setCategory(category); transaction.setWallet(walletFromDB); s.save(transaction); s.update(walletFromDB); tx.commit(); soutl(\"\") soutl(\"\") soutl(\"\") ReportService rs = new ReportService(); rs.generateReport(user.getId()); break; case 3: TransactionDAO transactionDAO = new TransactionDAOImpl(); List<Transactions> lastTransactions = transactionDAO.getTransactionByWallet(user.getWallet().getId()); if (lastTransactions == null || lastTransactions.isEmpty()) { soutl(\"\") } else { soutl(\"\") for (Transactions tx1 : lastTransactions) { soutl(\"\") } } break; case 4: sout(\"\") String newEmail = sc.nextLine(); userDAO.updateUserEmail(user.getId(), newEmail); break; case 5: sout(\"\") String confirm = sc.nextLine(); if (confirm.equalsIgnoreCase(\"yes\")) { userDAO.deleteUser(user.getId()); soutl(\"\") running = false; loggedIn = false; } break; case 6: soutl(\"\") running = false; break; default: soutl(\"\") } } else { soutl(\"\") sout(\"\") String choiceAgain = sc.nextLine(); if (choiceAgain.equalsIgnoreCase(\"back\")) { break; } } } break; case 2: Transaction tx = s.beginTransaction(); sout(\"\") String newUsername = sc.nextLine(); sout(\"\") String newPassword = sc.nextLine(); sout(\"\") String newEmail = sc.nextLine(); int userId = userDAO.register(newUsername, newPassword, newEmail); soutl(\"\") soutl(\"\") Wallet wallet = new Wallet(); soutl(\"\") sout(\"\") double initialBalance = sc.nextDouble(); sc.nextLine(); wallet.setBalance(initialBalance); wallet.setUser(userDAO.findUserById(userId)); s.save(wallet); SpendingLimit spendingLimit = new SpendingLimit(); soutl(\"\") sout(\"\") double limitAmount = sc.nextDouble(); sc.nextLine(); spendingLimit.setLimitAmount(limitAmount); spendingLimit.setWallet(wallet); s.save(spendingLimit); soutl(\"\") soutl(\"\") User registeredUser = userDAO.findUserById(userId); registeredUser.setWallet(wallet); s.update(registeredUser); tx.commit(); soutl(\"\") soutl(\"\") break; case 3: soutl(\"\") running = false; break; default: soutl(\"\") } } } catch (Exception e) { e.printStackTrace(); } finally { s.close(); sf.close(); } } }", "dependencies": [{"file_path": "Digi-Wallet-Project-main/src/main/java/DAO/WalletDAO.java", "file_content": "package DAO; import beans.Wallet; import org.hibernate.Session; public interface WalletDAO { void saveWallet(Wallet wallet); Wallet findWalletByUserId(int userId); void updateWalletBalance(int walletID, double amount); }"}, {"file_path": "Digi-Wallet-Project-main/src/main/java/DAO/WalletDAOImpl.java", "file_content": "package DAO; import beans.Wallet; import org.hibernate.Session; import org.hibernate.Transaction; import util.HibernateUtil; public class WalletDAOImpl implements WalletDAO { @Override public void saveWallet(Wallet wallet) { Session s = HibernateUtil.getSessionFactory().openSession(); Transaction tx = null; try { tx = s.beginTransaction(); s.save(wallet); tx.commit(); } catch (Exception e) { if (tx != null) tx.rollback(); e.printStackTrace(); } finally { s.close(); } } @Override public Wallet findWalletByUserId(int userId) { Session s = HibernateUtil.getSessionFactory().openSession(); Wallet wallet = null; try { wallet = (Wallet) s.createQuery(\"FROM Wallet WHERE user.id = :userId\", Wallet.class) .setParameter(\"userId\", userId) .uniqueResult(); } catch (Exception e) { e.printStackTrace(); } finally { s.close(); } return wallet; } @Override public void updateWalletBalance(int walletID, double amount) { Session s = HibernateUtil.getSessionFactory().openSession(); Transaction tx = null; try { tx = s.beginTransaction(); Wallet wallet = s.get(Wallet.class, walletID); wallet.updateBalance(amount); s.update(wallet); tx.commit(); } catch (Exception e) { if (tx != null) tx.rollback(); e.printStackTrace(); } finally { s.close(); } } public void displayWalletInfo(int userId) { Wallet wallet = findWalletByUserId(userId); if (wallet != null) { soutl(\"\") soutl(\"\") } else { soutl(\"\") } } }"}, {"file_path": "Digi-Wallet-Project-main/src/main/java/DAO/TransactionDAO.java", "file_content": "package DAO; import beans.Transactions; import java.util.List; public interface TransactionDAO { void saveTransaction(Transactions transactions); List<Transactions> getTransactionByWallet(int walletId); }"}, {"file_path": "Digi-Wallet-Project-main/src/main/java/DAO/TransactionDAOImpl.java", "file_content": "package DAO; import beans.Transactions; import org.hibernate.Session; import org.hibernate.Transaction; import util.HibernateUtil; import java.util.List; public class TransactionDAOImpl implements TransactionDAO { @Override public void saveTransaction(Transactions transactions) { Session s = HibernateUtil.getSessionFactory().openSession(); Transaction tx = s.beginTransaction(); s.save(transactions); tx.commit(); s.close(); } @Override public List<Transactions> getTransactionByWallet(int walletId) { Session session = HibernateUtil.getSessionFactory().openSession(); Transaction tx = null; List<Transactions> transactions = null; try { tx = session.beginTransaction(); transactions = session.createQuery(\"FROM Transactions WHERE wallet.id = :walletId ORDER BY date DESC\", Transactions.class) .setParameter(\"walletId\", walletId) .list(); tx.commit(); } catch (Exception e) { if (tx != null) tx.rollback(); e.printStackTrace(); } finally { session.close(); } return transactions; } }"}, {"file_path": "Digi-Wallet-Project-main/src/main/java/DAO/UserDAOImpl.java", "file_content": "package DAO; import beans.User; import beans.Wallet; import org.hibernate.Session; import org.hibernate.Transaction; import util.HibernateUtil; import org.hibernate.query.Query; public class UserDAOImpl implements UserDAO{ @Override public User findUserById(int id) { Session s = HibernateUtil.getSessionFactory().openSession(); User user = s.get(User.class, id); s.close(); return user; } @Override public User findUserByUsername(String username) { Session s = HibernateUtil.getSessionFactory().openSession(); User user = (User) s.createQuery(\"FROM User WHERE username = :username\") .setParameter(\"username\", username) .uniqueResult(); s.close(); return user; } @Override public boolean authenticate(String username, String password) { Session s = HibernateUtil.getSessionFactory().openSession(); User user = findUserByUsername(username); boolean isAuthenticated = user != null && user.getPassword().equals(password); s.close(); return isAuthenticated; } @Override public int register(String username, String password, String email) { Session s = HibernateUtil.getSessionFactory().openSession(); Transaction tx = s.beginTransaction(); User newUser = new User(); newUser.setUsername(username); newUser.setPassword(password); newUser.setEmail(email); Wallet wallet = new Wallet(); newUser.setWallet(wallet); s.save(newUser); tx.commit(); s.close(); return newUser.getId(); } @Override public void deleteUser(int userId) { Session session = HibernateUtil.getSessionFactory().openSession(); Transaction tx = session.beginTransaction(); Query<Wallet> walletQuery = session.createQuery(\"FROM Wallet WHERE user.id = :userId\", Wallet.class); walletQuery.setParameter(\"userId\", userId); Wallet wallet = walletQuery.uniqueResult(); if (wallet != null) { Query query1 = session.createQuery(\"DELETE FROM Transactions WHERE wallet.id = :id\"); query1.setParameter(\"walletId\", wallet.getId()); query1.executeUpdate(); Query query2 = session.createQuery(\"DELETE FROM SpendingLimit WHERE wallet.id = :walletId\"); query2.setParameter(\"walletId\", wallet.getId()); query2.executeUpdate(); Query query3 = session.createQuery(\"DELETE FROM Wallet WHERE id = :walletId\"); query3.setParameter(\"walletId\", wallet.getId()); query3.executeUpdate(); } User user = session.get(User.class, userId); if (user != null) { session.delete(user); } tx.commit(); session.close(); } @Override public void updateUserEmail(int userId, String newEmail) { Session s = HibernateUtil.getSessionFactory().openSession(); Transaction tx = s.beginTransaction(); User user = s.get(User.class, userId); if (user != null) { user.setEmail(newEmail); s.update(user); soutl(\"\") } else { soutl(\"\") } tx.commit(); s.close(); } }"}, {"file_path": "Digi-Wallet-Project-main/src/main/java/Service/ReportService.java", "file_content": "package Service; import DAO.TransactionDAO; import DAO.TransactionDAOImpl; import DAO.WalletDAO; import DAO.WalletDAOImpl; import beans.Transactions; import beans.Wallet; import java.util.List; public class ReportService { private WalletDAO walletDAO; private TransactionDAO transactionsDAO; public ReportService() { walletDAO = new WalletDAOImpl(); transactionsDAO = new TransactionDAOImpl(); } public void generateReport(int userId) { try { Wallet wallet = walletDAO.findWalletByUserId(userId); if (wallet != null) { List<Transactions> transactions = transactionsDAO.getTransactionByWallet(wallet.getId()); if (!transactions.isEmpty()) { soutl(\"\") soutl(\"\") for (Transactions transaction : transactions) { soutl(\"\") } } else { soutl(\"\") } } else { soutl(\"\") } } catch (Exception e) { e.printStackTrace(); soutl(\"\") } } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Digi-Wallet-Project-main/src/main/java/Main.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Main class handles user input, authentication, transaction processing, UI interactions, and session management, violating SRP by managing multiple responsibilities."}, {"principle": "Dependency Inversion", "justification": "Main directly instantiates concrete DAO implementations (e.g., UserDAOImpl, WalletDAOImpl) instead of depending on abstractions, creating tight coupling."}]}, {"file_path": "Digi-Wallet-Project-main/src/main/java/DAO/WalletDAOImpl.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "WalletDAOImpl's displayWalletInfo() mixes data access with UI output (e.g., printing to console), violating SRP by combining data retrieval and presentation."}]}, {"file_path": "Digi-Wallet-Project-main/src/main/java/Service/ReportService.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "ReportService directly depends on concrete WalletDAOImpl and TransactionDAOImpl in its constructor, instead of accepting abstractions, violating DIP."}]}]}
{"project_id": 106, "chunk_id": 0, "prompt": {"main_file_path": "Digi-Wallet-Project-main/src/main/java/util/HibernateUtil.java", "main_file_content": "package util; import org.hibernate.SessionFactory; import org.hibernate.cfg.Configuration; public class HibernateUtil { private static final SessionFactory sf; static { try { sf = new Configuration().configure().buildSessionFactory(); } catch (Throwable ex) { throw new ExceptionInInitializerError(ex); } } public static SessionFactory getSessionFactory() { return sf; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Digi-Wallet-Project-main/src/main/java/util/HibernateUtil.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "High-level modules directly depend on the concrete HibernateUtil class to obtain SessionFactory, instead of depending on an abstraction. The utility class itself directly instantiates low-level Hibernate components without abstraction."}]}]}
{"project_id": 106, "chunk_id": 0, "prompt": {"main_file_path": "Digi-Wallet-Project-main/src/main/java/DAO/UserDAO.java", "main_file_content": "package DAO; import beans.User; public interface UserDAO { void updateUserEmail(int id, String newEmail); void deleteUser(int id); User findUserById(int id); User findUserByUsername(String username); boolean authenticate(String username, String password); int register(String username, String password, String email); }", "dependencies": [{"file_path": "Digi-Wallet-Project-main/src/main/java/beans/User.java", "file_content": "package beans; import javax.persistence.*; @Entity @Table(name = \"User\") public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private int id; private String username; private String password; private String email; @OneToOne(mappedBy = \"user\", cascade = CascadeType.ALL) private Wallet wallet; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public Wallet getWallet() { return wallet; } public void setWallet(Wallet wallet) { this.wallet = wallet; } @Override public String toString() { return \"User [id=\" + id + \", username=\" + username + \" email=\" + email + \"]\"; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Digi-Wallet-Project-main/src/main/java/DAO/UserDAO.java", "violatedPrinciples": [{"principle": "Interface Segregation", "justification": "UserDAO combines authentication, registration, and CRUD operations. Clients depending on this interface must implement all methods even if they don't use them."}, {"principle": "Dependency Inversion", "justification": "UserDAO directly depends on the concrete User class. High-level modules should depend on abstractions (e.g., a User interface) instead."}]}]}
{"project_id": 106, "chunk_id": 0, "prompt": {"main_file_path": "Digi-Wallet-Project-main/src/main/java/DAO/TransactionDAO.java", "main_file_content": "package DAO; import beans.Transactions; import java.util.List; public interface TransactionDAO { void saveTransaction(Transactions transactions); List<Transactions> getTransactionByWallet(int walletId); }", "dependencies": [{"file_path": "Digi-Wallet-Project-main/src/main/java/beans/Transactions.java", "file_content": "package beans; import javax.persistence.*; import java.text.SimpleDateFormat; import java.util.Date; @Entity @Table(name = \"Transactions\") public class Transactions { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private int id; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \"wallet_id\") private Wallet wallet; @ManyToOne @JoinColumn(name = \"category_id\") private Category category; private Double amount; private String type; private String description; private Date date; private String madeTo; public String getMadeTo() { return madeTo; } public void setMadeTo(String madeTo) { this.madeTo = madeTo; } public int getId() { return id; } public void setId(int id) { this.id = id; } public Double getAmount() { return amount; } public void setAmount(Double amount) { this.amount = amount; } public String getType() { return type; } public void setType(String type) { this.type = type; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public Wallet getWallet() { return wallet; } public void setWallet(Wallet wallet) { this.wallet = wallet; } public Date getDate() { return date; } public void setDate(Date date) { this.date = date; } public Category getCategory() { return category; } public void setCategory(Category category) { this.category = category; } @Override public String toString() { SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); return String.format(\"Transaction ID: %d\\n\" + \"Amount: %.2f\\n\" + \"Type: %s\\n\" + \"Description: %s\\n\" + \"Date: %s\\n\" + \"Made To: %s\\n\" + \"Category: %s\\n\" + \"Wallet ID: %d\\n\", id, amount, type, description, sdf.format(date), madeTo, category != null ? category.getName() : \"N/A\", wallet != null ? wallet.getId() : \"N/A\"); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Digi-Wallet-Project-main/src/main/java/beans/Transactions.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Transactions class handles both data storage and formatting in the toString method, introducing multiple responsibilities."}]}, {"file_path": "Digi-Wallet-Project-main/src/main/java/DAO/TransactionDAO.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "The TransactionDAO interface depends on the concrete Transactions class instead of an abstraction, violating dependency inversion."}, {"principle": "Interface Segregation", "justification": "Clients of TransactionDAO must implement both save and retrieval methods even if they only need one, violating interface segregation."}]}]}
{"project_id": 106, "chunk_id": 0, "prompt": {"main_file_path": "Digi-Wallet-Project-main/src/main/java/DAO/WalletDAOImpl.java", "main_file_content": "package DAO; import beans.Wallet; import org.hibernate.Session; import org.hibernate.Transaction; import util.HibernateUtil; public class WalletDAOImpl implements WalletDAO { @Override public void saveWallet(Wallet wallet) { Session s = HibernateUtil.getSessionFactory().openSession(); Transaction tx = null; try { tx = s.beginTransaction(); s.save(wallet); tx.commit(); } catch (Exception e) { if (tx != null) tx.rollback(); e.printStackTrace(); } finally { s.close(); } } @Override public Wallet findWalletByUserId(int userId) { Session s = HibernateUtil.getSessionFactory().openSession(); Wallet wallet = null; try { wallet = (Wallet) s.createQuery(\"FROM Wallet WHERE user.id = :userId\", Wallet.class) .setParameter(\"userId\", userId) .uniqueResult(); } catch (Exception e) { e.printStackTrace(); } finally { s.close(); } return wallet; } @Override public void updateWalletBalance(int walletID, double amount) { Session s = HibernateUtil.getSessionFactory().openSession(); Transaction tx = null; try { tx = s.beginTransaction(); Wallet wallet = s.get(Wallet.class, walletID); wallet.updateBalance(amount); s.update(wallet); tx.commit(); } catch (Exception e) { if (tx != null) tx.rollback(); e.printStackTrace(); } finally { s.close(); } } public void displayWalletInfo(int userId) { Wallet wallet = findWalletByUserId(userId); if (wallet != null) { soutl(\"\") soutl(\"\") } else { soutl(\"\") } } }", "dependencies": [{"file_path": "Digi-Wallet-Project-main/src/main/java/beans/Wallet.java", "file_content": "package beans; import javax.persistence.*; import java.util.List; @Entity @Table(name = \"Wallet\") public class Wallet { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private int id; private Double balance; @OneToOne @JoinColumn(name = \"user_id\") private User user; @OneToMany(mappedBy = \"wallet\", cascade = CascadeType.ALL, fetch = FetchType.LAZY) private List<Transactions> transactions; public void updateBalance(double amount) { this.balance += amount; } public int getId() { return id; } public void setId(int id) { this.id = id; } public Double getBalance() { return balance; } public void setBalance(Double balance) { this.balance = balance; } public User getUser() { return user; } public void setUser(User user) { this.user = user; } public List<Transactions> getTransactions() { return transactions; } public void setTransactions(List<Transactions> transactions) { this.transactions = transactions; } @Override public String toString() { return \"Wallet{id=\" + id + \", balance=\" + balance + \", transactionsCount=\" + (transactions != null ? transactions.size() : 0) + \"}\"; } }"}, {"file_path": "Digi-Wallet-Project-main/src/main/java/util/HibernateUtil.java", "file_content": "package util; import org.hibernate.SessionFactory; import org.hibernate.cfg.Configuration; public class HibernateUtil { private static final SessionFactory sf; static { try { sf = new Configuration().configure().buildSessionFactory(); } catch (Throwable ex) { throw new ExceptionInInitializerError(ex); } } public static SessionFactory getSessionFactory() { return sf; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Digi-Wallet-Project-main/src/main/java/DAO/WalletDAOImpl.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "WalletDAOImpl handles both data access (save, find, update) and presentation logic (displayWalletInfo), introducing multiple reasons to change."}, {"principle": "Dependency Inversion", "justification": "Directly depends on concrete HibernateUtil instead of abstractions for session management, coupling high-level DAO to low-level implementation."}]}]}
{"project_id": 106, "chunk_id": 0, "prompt": {"main_file_path": "Digi-Wallet-Project-main/src/main/java/DAO/TransactionDAOImpl.java", "main_file_content": "package DAO; import beans.Transactions; import org.hibernate.Session; import org.hibernate.Transaction; import util.HibernateUtil; import java.util.List; public class TransactionDAOImpl implements TransactionDAO { @Override public void saveTransaction(Transactions transactions) { Session s = HibernateUtil.getSessionFactory().openSession(); Transaction tx = s.beginTransaction(); s.save(transactions); tx.commit(); s.close(); } @Override public List<Transactions> getTransactionByWallet(int walletId) { Session session = HibernateUtil.getSessionFactory().openSession(); Transaction tx = null; List<Transactions> transactions = null; try { tx = session.beginTransaction(); transactions = session.createQuery(\"FROM Transactions WHERE wallet.id = :walletId ORDER BY date DESC\", Transactions.class) .setParameter(\"walletId\", walletId) .list(); tx.commit(); } catch (Exception e) { if (tx != null) tx.rollback(); e.printStackTrace(); } finally { session.close(); } return transactions; } }", "dependencies": [{"file_path": "Digi-Wallet-Project-main/src/main/java/beans/Transactions.java", "file_content": "package beans; import javax.persistence.*; import java.text.SimpleDateFormat; import java.util.Date; @Entity @Table(name = \"Transactions\") public class Transactions { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private int id; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \"wallet_id\") private Wallet wallet; @ManyToOne @JoinColumn(name = \"category_id\") private Category category; private Double amount; private String type; private String description; private Date date; private String madeTo; public String getMadeTo() { return madeTo; } public void setMadeTo(String madeTo) { this.madeTo = madeTo; } public int getId() { return id; } public void setId(int id) { this.id = id; } public Double getAmount() { return amount; } public void setAmount(Double amount) { this.amount = amount; } public String getType() { return type; } public void setType(String type) { this.type = type; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public Wallet getWallet() { return wallet; } public void setWallet(Wallet wallet) { this.wallet = wallet; } public Date getDate() { return date; } public void setDate(Date date) { this.date = date; } public Category getCategory() { return category; } public void setCategory(Category category) { this.category = category; } @Override public String toString() { SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); return String.format(\"Transaction ID: %d\\n\" + \"Amount: %.2f\\n\" + \"Type: %s\\n\" + \"Description: %s\\n\" + \"Date: %s\\n\" + \"Made To: %s\\n\" + \"Category: %s\\n\" + \"Wallet ID: %d\\n\", id, amount, type, description, sdf.format(date), madeTo, category != null ? category.getName() : \"N/A\", wallet != null ? wallet.getId() : \"N/A\"); } }"}, {"file_path": "Digi-Wallet-Project-main/src/main/java/util/HibernateUtil.java", "file_content": "package util; import org.hibernate.SessionFactory; import org.hibernate.cfg.Configuration; public class HibernateUtil { private static final SessionFactory sf; static { try { sf = new Configuration().configure().buildSessionFactory(); } catch (Throwable ex) { throw new ExceptionInInitializerError(ex); } } public static SessionFactory getSessionFactory() { return sf; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Digi-Wallet-Project-main/src/main/java/DAO/TransactionDAOImpl.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "TransactionDAOImpl directly depends on the concrete HibernateUtil class to obtain sessions. High-level modules should depend on abstractions (e.g., a SessionFactory interface) instead of low-level implementations."}]}, {"file_path": "Digi-Wallet-Project-main/src/main/java/beans/Transactions.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Transactions class handles both data storage and formatting logic in toString(). Changes to data structure or display format would require modifying the class, indicating multiple responsibilities."}]}]}
{"project_id": 106, "chunk_id": 0, "prompt": {"main_file_path": "Digi-Wallet-Project-main/src/main/java/DAO/WalletDAO.java", "main_file_content": "package DAO; import beans.Wallet; import org.hibernate.Session; public interface WalletDAO { void saveWallet(Wallet wallet); Wallet findWalletByUserId(int userId); void updateWalletBalance(int walletID, double amount); }", "dependencies": [{"file_path": "Digi-Wallet-Project-main/src/main/java/beans/Wallet.java", "file_content": "package beans; import javax.persistence.*; import java.util.List; @Entity @Table(name = \"Wallet\") public class Wallet { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private int id; private Double balance; @OneToOne @JoinColumn(name = \"user_id\") private User user; @OneToMany(mappedBy = \"wallet\", cascade = CascadeType.ALL, fetch = FetchType.LAZY) private List<Transactions> transactions; public void updateBalance(double amount) { this.balance += amount; } public int getId() { return id; } public void setId(int id) { this.id = id; } public Double getBalance() { return balance; } public void setBalance(Double balance) { this.balance = balance; } public User getUser() { return user; } public void setUser(User user) { this.user = user; } public List<Transactions> getTransactions() { return transactions; } public void setTransactions(List<Transactions> transactions) { this.transactions = transactions; } @Override public String toString() { return \"Wallet{id=\" + id + \", balance=\" + balance + \", transactionsCount=\" + (transactions != null ? transactions.size() : 0) + \"}\"; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Digi-Wallet-Project-main/src/main/java/DAO/WalletDAO.java", "violatedPrinciples": [{"principle": "Interface Segregation", "justification": "WalletDAO interface forces implementers to depend on save, find, and update methods even if a client only needs a subset. Clients cannot use only the methods they require without implementing all."}]}, {"file_path": "Digi-Wallet-Project-main/src/main/java/beans/Wallet.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Wallet class manages entity mapping and balance update logic. Changes to persistence or business rules would require modifying the same class, indicating multiple responsibilities."}]}]}
{"project_id": 106, "chunk_id": 0, "prompt": {"main_file_path": "Digi-Wallet-Project-main/src/main/java/DAO/UserDAOImpl.java", "main_file_content": "package DAO; import beans.User; import beans.Wallet; import org.hibernate.Session; import org.hibernate.Transaction; import util.HibernateUtil; import org.hibernate.query.Query; public class UserDAOImpl implements UserDAO{ @Override public User findUserById(int id) { Session s = HibernateUtil.getSessionFactory().openSession(); User user = s.get(User.class, id); s.close(); return user; } @Override public User findUserByUsername(String username) { Session s = HibernateUtil.getSessionFactory().openSession(); User user = (User) s.createQuery(\"FROM User WHERE username = :username\") .setParameter(\"username\", username) .uniqueResult(); s.close(); return user; } @Override public boolean authenticate(String username, String password) { Session s = HibernateUtil.getSessionFactory().openSession(); User user = findUserByUsername(username); boolean isAuthenticated = user != null && user.getPassword().equals(password); s.close(); return isAuthenticated; } @Override public int register(String username, String password, String email) { Session s = HibernateUtil.getSessionFactory().openSession(); Transaction tx = s.beginTransaction(); User newUser = new User(); newUser.setUsername(username); newUser.setPassword(password); newUser.setEmail(email); Wallet wallet = new Wallet(); newUser.setWallet(wallet); s.save(newUser); tx.commit(); s.close(); return newUser.getId(); } @Override public void deleteUser(int userId) { Session session = HibernateUtil.getSessionFactory().openSession(); Transaction tx = session.beginTransaction(); Query<Wallet> walletQuery = session.createQuery(\"FROM Wallet WHERE user.id = :userId\", Wallet.class); walletQuery.setParameter(\"userId\", userId); Wallet wallet = walletQuery.uniqueResult(); if (wallet != null) { Query query1 = session.createQuery(\"DELETE FROM Transactions WHERE wallet.id = :id\"); query1.setParameter(\"walletId\", wallet.getId()); query1.executeUpdate(); Query query2 = session.createQuery(\"DELETE FROM SpendingLimit WHERE wallet.id = :walletId\"); query2.setParameter(\"walletId\", wallet.getId()); query2.executeUpdate(); Query query3 = session.createQuery(\"DELETE FROM Wallet WHERE id = :walletId\"); query3.setParameter(\"walletId\", wallet.getId()); query3.executeUpdate(); } User user = session.get(User.class, userId); if (user != null) { session.delete(user); } tx.commit(); session.close(); } @Override public void updateUserEmail(int userId, String newEmail) { Session s = HibernateUtil.getSessionFactory().openSession(); Transaction tx = s.beginTransaction(); User user = s.get(User.class, userId); if (user != null) { user.setEmail(newEmail); s.update(user); soutl(\"\") } else { soutl(\"\") } tx.commit(); s.close(); } }", "dependencies": [{"file_path": "Digi-Wallet-Project-main/src/main/java/beans/User.java", "file_content": "package beans; import javax.persistence.*; @Entity @Table(name = \"User\") public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private int id; private String username; private String password; private String email; @OneToOne(mappedBy = \"user\", cascade = CascadeType.ALL) private Wallet wallet; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public Wallet getWallet() { return wallet; } public void setWallet(Wallet wallet) { this.wallet = wallet; } @Override public String toString() { return \"User [id=\" + id + \", username=\" + username + \" email=\" + email + \"]\"; } }"}, {"file_path": "Digi-Wallet-Project-main/src/main/java/beans/Wallet.java", "file_content": "package beans; import javax.persistence.*; import java.util.List; @Entity @Table(name = \"Wallet\") public class Wallet { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private int id; private Double balance; @OneToOne @JoinColumn(name = \"user_id\") private User user; @OneToMany(mappedBy = \"wallet\", cascade = CascadeType.ALL, fetch = FetchType.LAZY) private List<Transactions> transactions; public void updateBalance(double amount) { this.balance += amount; } public int getId() { return id; } public void setId(int id) { this.id = id; } public Double getBalance() { return balance; } public void setBalance(Double balance) { this.balance = balance; } public User getUser() { return user; } public void setUser(User user) { this.user = user; } public List<Transactions> getTransactions() { return transactions; } public void setTransactions(List<Transactions> transactions) { this.transactions = transactions; } @Override public String toString() { return \"Wallet{id=\" + id + \", balance=\" + balance + \", transactionsCount=\" + (transactions != null ? transactions.size() : 0) + \"}\"; } }"}, {"file_path": "Digi-Wallet-Project-main/src/main/java/util/HibernateUtil.java", "file_content": "package util; import org.hibernate.SessionFactory; import org.hibernate.cfg.Configuration; public class HibernateUtil { private static final SessionFactory sf; static { try { sf = new Configuration().configure().buildSessionFactory(); } catch (Throwable ex) { throw new ExceptionInInitializerError(ex); } } public static SessionFactory getSessionFactory() { return sf; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Digi-Wallet-Project-main/src/main/java/DAO/UserDAOImpl.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "UserDAOImpl handles multiple responsibilities such as user management, wallet operations, and transaction deletions. The deleteUser method directly manages Transactions and SpendingLimit deletions, exceeding a single responsibility."}, {"principle": "Dependency Inversion", "justification": "UserDAOImpl directly depends on the concrete HibernateUtil class to obtain sessions. High-level modules (DAO) should depend on abstractions (e.g., interfaces) rather than low-level implementations."}]}]}
{"project_id": 106, "chunk_id": 0, "prompt": {"main_file_path": "Digi-Wallet-Project-main/src/main/java/beans/SpendingLimit.java", "main_file_content": "package beans; import javax.persistence.*; @Entity @Table(name = \"spending_limits\") public class SpendingLimit { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private int id; @ManyToOne @JoinColumn(name = \"wallet_id\") private Wallet wallet; @ManyToOne @JoinColumn(name = \"category_id\") private Category category; private double limitAmount; public int getId() { return id; } public void setId(int id) { this.id = id; } public Wallet getWallet() { return wallet; } public void setWallet(Wallet wallet) { this.wallet = wallet; } public Category getCategory() { return category; } public void setCategory(Category category) { this.category = category; } public double getLimitAmount() { return limitAmount; } public void setLimitAmount(double limitAmount) { this.limitAmount = limitAmount; } @Override public String toString() { return \"SpendingLimit{\" + \"id=\" + id + \", wallet=\" + wallet + \", category=\" + category + \", limitAmount=\" + limitAmount + '}'; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Digi-Wallet-Project-main/src/main/java/beans/SpendingLimit.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The class handles both data representation (fields, getters/setters) and persistence configuration (JPA annotations), introducing multiple reasons to change if data structure or ORM mappings evolve."}]}]}
{"project_id": 106, "chunk_id": 0, "prompt": {"main_file_path": "Digi-Wallet-Project-main/src/main/java/beans/Transactions.java", "main_file_content": "package beans; import javax.persistence.*; import java.text.SimpleDateFormat; import java.util.Date; @Entity @Table(name = \"Transactions\") public class Transactions { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private int id; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \"wallet_id\") private Wallet wallet; @ManyToOne @JoinColumn(name = \"category_id\") private Category category; private Double amount; private String type; private String description; private Date date; private String madeTo; public String getMadeTo() { return madeTo; } public void setMadeTo(String madeTo) { this.madeTo = madeTo; } public int getId() { return id; } public void setId(int id) { this.id = id; } public Double getAmount() { return amount; } public void setAmount(Double amount) { this.amount = amount; } public String getType() { return type; } public void setType(String type) { this.type = type; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public Wallet getWallet() { return wallet; } public void setWallet(Wallet wallet) { this.wallet = wallet; } public Date getDate() { return date; } public void setDate(Date date) { this.date = date; } public Category getCategory() { return category; } public void setCategory(Category category) { this.category = category; } @Override public String toString() { SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); return String.format(\"Transaction ID: %d\\n\" + \"Amount: %.2f\\n\" + \"Type: %s\\n\" + \"Description: %s\\n\" + \"Date: %s\\n\" + \"Made To: %s\\n\" + \"Category: %s\\n\" + \"Wallet ID: %d\\n\", id, amount, type, description, sdf.format(date), madeTo, category != null ? category.getName() : \"N/A\", wallet != null ? wallet.getId() : \"N/A\"); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Digi-Wallet-Project-main/src/main/java/beans/Transactions.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Transactions class handles both data storage (entity properties) and presentation logic (toString formatting), giving it multiple reasons to change."}, {"principle": "Dependency Inversion", "justification": "Transactions directly depends on concrete Wallet and Category classes instead of abstractions, violating the rule that high-level modules should depend on interfaces."}]}]}
{"project_id": 106, "chunk_id": 0, "prompt": {"main_file_path": "Digi-Wallet-Project-main/src/main/java/beans/Category.java", "main_file_content": "package beans; import javax.persistence.*; import java.util.Set; @Entity @Table(name = \"categories\") public class Category { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private int id; private String name; @OneToMany(mappedBy = \"category\") private Set<Transactions> transactions; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Set<Transactions> getTransactions() { return transactions; } public void setTransactions(Set<Transactions> transactions) { this.transactions = transactions; } @Override public String toString() { return \"Category{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", transactions=\" + transactions + '}'; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Digi-Wallet-Project-main/src/main/java/beans/Category.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Category class manages its own properties and directly handles relationships with Transactions, combining data management and relationship coordination responsibilities."}, {"principle": "Dependency Inversion", "justification": "Category directly depends on the concrete Transactions class for its relationship management, violating the principle that high-level modules should depend on abstractions."}]}]}
{"project_id": 106, "chunk_id": 0, "prompt": {"main_file_path": "Digi-Wallet-Project-main/src/main/java/beans/User.java", "main_file_content": "package beans; import javax.persistence.*; @Entity @Table(name = \"User\") public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private int id; private String username; private String password; private String email; @OneToOne(mappedBy = \"user\", cascade = CascadeType.ALL) private Wallet wallet; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public Wallet getWallet() { return wallet; } public void setWallet(Wallet wallet) { this.wallet = wallet; } @Override public String toString() { return \"User [id=\" + id + \", username=\" + username + \" email=\" + email + \"]\"; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Digi-Wallet-Project-main/src/main/java/beans/User.java", "violatedPrinciples": []}]}
{"project_id": 106, "chunk_id": 0, "prompt": {"main_file_path": "Digi-Wallet-Project-main/src/main/java/beans/Wallet.java", "main_file_content": "package beans; import javax.persistence.*; import java.util.List; @Entity @Table(name = \"Wallet\") public class Wallet { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private int id; private Double balance; @OneToOne @JoinColumn(name = \"user_id\") private User user; @OneToMany(mappedBy = \"wallet\", cascade = CascadeType.ALL, fetch = FetchType.LAZY) private List<Transactions> transactions; public void updateBalance(double amount) { this.balance += amount; } public int getId() { return id; } public void setId(int id) { this.id = id; } public Double getBalance() { return balance; } public void setBalance(Double balance) { this.balance = balance; } public User getUser() { return user; } public void setUser(User user) { this.user = user; } public List<Transactions> getTransactions() { return transactions; } public void setTransactions(List<Transactions> transactions) { this.transactions = transactions; } @Override public String toString() { return \"Wallet{id=\" + id + \", balance=\" + balance + \", transactionsCount=\" + (transactions != null ? transactions.size() : 0) + \"}\"; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Digi-Wallet-Project-main/src/main/java/beans/Wallet.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "Wallet directly depends on concrete classes User and Transactions. High-level modules should depend on abstractions, not concrete implementations."}]}]}
{"project_id": 106, "chunk_id": 0, "prompt": {"main_file_path": "Digi-Wallet-Project-main/src/main/java/Service/ReportService.java", "main_file_content": "package Service; import DAO.TransactionDAO; import DAO.TransactionDAOImpl; import DAO.WalletDAO; import DAO.WalletDAOImpl; import beans.Transactions; import beans.Wallet; import java.util.List; public class ReportService { private WalletDAO walletDAO; private TransactionDAO transactionsDAO; public ReportService() { walletDAO = new WalletDAOImpl(); transactionsDAO = new TransactionDAOImpl(); } public void generateReport(int userId) { try { Wallet wallet = walletDAO.findWalletByUserId(userId); if (wallet != null) { List<Transactions> transactions = transactionsDAO.getTransactionByWallet(wallet.getId()); if (!transactions.isEmpty()) { soutl(\"\") soutl(\"\") for (Transactions transaction : transactions) { soutl(\"\") } } else { soutl(\"\") } } else { soutl(\"\") } } catch (Exception e) { e.printStackTrace(); soutl(\"\") } } }", "dependencies": [{"file_path": "Digi-Wallet-Project-main/src/main/java/DAO/TransactionDAO.java", "file_content": "package DAO; import beans.Transactions; import java.util.List; public interface TransactionDAO { void saveTransaction(Transactions transactions); List<Transactions> getTransactionByWallet(int walletId); }"}, {"file_path": "Digi-Wallet-Project-main/src/main/java/DAO/TransactionDAOImpl.java", "file_content": "package DAO; import beans.Transactions; import org.hibernate.Session; import org.hibernate.Transaction; import util.HibernateUtil; import java.util.List; public class TransactionDAOImpl implements TransactionDAO { @Override public void saveTransaction(Transactions transactions) { Session s = HibernateUtil.getSessionFactory().openSession(); Transaction tx = s.beginTransaction(); s.save(transactions); tx.commit(); s.close(); } @Override public List<Transactions> getTransactionByWallet(int walletId) { Session session = HibernateUtil.getSessionFactory().openSession(); Transaction tx = null; List<Transactions> transactions = null; try { tx = session.beginTransaction(); transactions = session.createQuery(\"FROM Transactions WHERE wallet.id = :walletId ORDER BY date DESC\", Transactions.class) .setParameter(\"walletId\", walletId) .list(); tx.commit(); } catch (Exception e) { if (tx != null) tx.rollback(); e.printStackTrace(); } finally { session.close(); } return transactions; } }"}, {"file_path": "Digi-Wallet-Project-main/src/main/java/DAO/WalletDAO.java", "file_content": "package DAO; import beans.Wallet; import org.hibernate.Session; public interface WalletDAO { void saveWallet(Wallet wallet); Wallet findWalletByUserId(int userId); void updateWalletBalance(int walletID, double amount); }"}, {"file_path": "Digi-Wallet-Project-main/src/main/java/DAO/WalletDAOImpl.java", "file_content": "package DAO; import beans.Wallet; import org.hibernate.Session; import org.hibernate.Transaction; import util.HibernateUtil; public class WalletDAOImpl implements WalletDAO { @Override public void saveWallet(Wallet wallet) { Session s = HibernateUtil.getSessionFactory().openSession(); Transaction tx = null; try { tx = s.beginTransaction(); s.save(wallet); tx.commit(); } catch (Exception e) { if (tx != null) tx.rollback(); e.printStackTrace(); } finally { s.close(); } } @Override public Wallet findWalletByUserId(int userId) { Session s = HibernateUtil.getSessionFactory().openSession(); Wallet wallet = null; try { wallet = (Wallet) s.createQuery(\"FROM Wallet WHERE user.id = :userId\", Wallet.class) .setParameter(\"userId\", userId) .uniqueResult(); } catch (Exception e) { e.printStackTrace(); } finally { s.close(); } return wallet; } @Override public void updateWalletBalance(int walletID, double amount) { Session s = HibernateUtil.getSessionFactory().openSession(); Transaction tx = null; try { tx = s.beginTransaction(); Wallet wallet = s.get(Wallet.class, walletID); wallet.updateBalance(amount); s.update(wallet); tx.commit(); } catch (Exception e) { if (tx != null) tx.rollback(); e.printStackTrace(); } finally { s.close(); } } public void displayWalletInfo(int userId) { Wallet wallet = findWalletByUserId(userId); if (wallet != null) { soutl(\"\") soutl(\"\") } else { soutl(\"\") } } }"}, {"file_path": "Digi-Wallet-Project-main/src/main/java/beans/Transactions.java", "file_content": "package beans; import javax.persistence.*; import java.text.SimpleDateFormat; import java.util.Date; @Entity @Table(name = \"Transactions\") public class Transactions { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private int id; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \"wallet_id\") private Wallet wallet; @ManyToOne @JoinColumn(name = \"category_id\") private Category category; private Double amount; private String type; private String description; private Date date; private String madeTo; public String getMadeTo() { return madeTo; } public void setMadeTo(String madeTo) { this.madeTo = madeTo; } public int getId() { return id; } public void setId(int id) { this.id = id; } public Double getAmount() { return amount; } public void setAmount(Double amount) { this.amount = amount; } public String getType() { return type; } public void setType(String type) { this.type = type; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public Wallet getWallet() { return wallet; } public void setWallet(Wallet wallet) { this.wallet = wallet; } public Date getDate() { return date; } public void setDate(Date date) { this.date = date; } public Category getCategory() { return category; } public void setCategory(Category category) { this.category = category; } @Override public String toString() { SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); return String.format(\"Transaction ID: %d\\n\" + \"Amount: %.2f\\n\" + \"Type: %s\\n\" + \"Description: %s\\n\" + \"Date: %s\\n\" + \"Made To: %s\\n\" + \"Category: %s\\n\" + \"Wallet ID: %d\\n\", id, amount, type, description, sdf.format(date), madeTo, category != null ? category.getName() : \"N/A\", wallet != null ? wallet.getId() : \"N/A\"); } }"}, {"file_path": "Digi-Wallet-Project-main/src/main/java/beans/Wallet.java", "file_content": "package beans; import javax.persistence.*; import java.util.List; @Entity @Table(name = \"Wallet\") public class Wallet { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private int id; private Double balance; @OneToOne @JoinColumn(name = \"user_id\") private User user; @OneToMany(mappedBy = \"wallet\", cascade = CascadeType.ALL, fetch = FetchType.LAZY) private List<Transactions> transactions; public void updateBalance(double amount) { this.balance += amount; } public int getId() { return id; } public void setId(int id) { this.id = id; } public Double getBalance() { return balance; } public void setBalance(Double balance) { this.balance = balance; } public User getUser() { return user; } public void setUser(User user) { this.user = user; } public List<Transactions> getTransactions() { return transactions; } public void setTransactions(List<Transactions> transactions) { this.transactions = transactions; } @Override public String toString() { return \"Wallet{id=\" + id + \", balance=\" + balance + \", transactionsCount=\" + (transactions != null ? transactions.size() : 0) + \"}\"; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Digi-Wallet-Project-main/src/main/java/Service/ReportService.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "ReportService handles both report generation and output formatting, which are two distinct responsibilities. Changes in output logic or data retrieval would require modifying the same class."}, {"principle": "Dependency Inversion", "justification": "ReportService directly instantiates WalletDAOImpl and TransactionDAOImpl in its constructor, depending on concrete implementations instead of abstractions (WalletDAO/TransactionDAO interfaces)."}, {"principle": "Open-Closed", "justification": "ReportService's generateReport method is not extendable for new report formats or output mechanisms without modifying the existing code, violating the open for extension principle."}]}, {"file_path": "Digi-Wallet-Project-main/src/main/java/DAO/WalletDAOImpl.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "WalletDAOImpl includes displayWalletInfo(), which introduces presentation logic (console output) into a DAO class, mixing data access and UI responsibilities."}]}]}
{"project_id": 106, "chunk_id": 0, "prompt": {"main_file_path": "Digi-Wallet-Project-main/src/main/java/Service/WalletService.java", "main_file_content": "package Service; import beans.*; import DAO.*; import org.hibernate.Hibernate; import util.HibernateUtil; import org.hibernate.Session; import org.hibernate.Transaction; import javax.transaction.Transactional; public class WalletService { private UserDAO userDAO; private WalletDAO walletDAO; private TransactionDAO transactionDAO; public WalletService(UserDAO userDAO, WalletDAO walletDAO, TransactionDAO transactionDAO) { this.userDAO = userDAO; this.walletDAO = walletDAO; this.transactionDAO = transactionDAO; } @Transactional public Wallet getWalletWithTransactions(int walletId) { Wallet wallet = walletDAO.findWalletByUserId(walletId); Hibernate.initialize(wallet.getTransactions()); return wallet; } public void addTransaction(int userId, Transactions transactions) { try (Session s = HibernateUtil.getSessionFactory().openSession()) { Transaction tx = s.beginTransaction(); User user = userDAO.findUserById(userId); Wallet wallet = user.getWallet(); if (transactions.getType().equalsIgnoreCase(\"income\")) { wallet.setBalance(wallet.getBalance() + transactions.getAmount()); } else { wallet.setBalance(wallet.getBalance() - transactions.getAmount()); } transactions.setWallet(wallet); transactionDAO.saveTransaction(transactions); tx.commit(); } } }", "dependencies": [{"file_path": "Digi-Wallet-Project-main/src/main/java/util/HibernateUtil.java", "file_content": "package util; import org.hibernate.SessionFactory; import org.hibernate.cfg.Configuration; public class HibernateUtil { private static final SessionFactory sf; static { try { sf = new Configuration().configure().buildSessionFactory(); } catch (Throwable ex) { throw new ExceptionInInitializerError(ex); } } public static SessionFactory getSessionFactory() { return sf; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Digi-Wallet-Project-main/src/main/java/Service/WalletService.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "WalletService handles both wallet balance updates and transaction management, which are two distinct responsibilities."}, {"principle": "Open-Closed", "justification": "Adding new transaction types requires modifying the conditional logic in addTransaction, violating the principle of being closed for modification."}, {"principle": "Dependency Inversion", "justification": "WalletService directly depends on HibernateUtil (concrete class) for session management instead of an abstraction."}]}]}
{"project_id": 106, "chunk_id": 0, "prompt": {"main_file_path": "Digi-Wallet-Project-main/src/main/java/ExceptionHandling/CustomDatabaseException.java", "main_file_content": "package ExceptionHandling; public class CustomDatabaseException extends RuntimeException { public CustomDatabaseException(String message, Throwable cause) { super(message, cause); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Digi-Wallet-Project-main/src/main/java/ExceptionHandling/CustomDatabaseException.java", "violatedPrinciples": []}]}
{"project_id": 106, "chunk_id": 0, "prompt": {"main_file_path": "Digi-Wallet-Project-main/src/test/java/org/example/AppTest.java", "main_file_content": "package org.example; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; public class AppTest extends TestCase { public AppTest( String testName ) { super( testName ); } public static Test suite() { return new TestSuite( AppTest.class ); } public void testApp() { assertTrue( true ); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Digi-Wallet-Project-main/src/test/java/org/example/AppTest.java", "violatedPrinciples": []}]}
{"project_id": 107, "chunk_id": 0, "prompt": {"main_file_path": "sistemaCadastroDeProdutos-main/sistemaCadastroDeProdutos-main/src/ClienteAdministracao.java", "main_file_content": "public class ClienteAdministracao extends ClientesDados { private String consultType; private String consultData; private ProdutosDados produtosDados; public String getConsultType() { return this.consultType; } public void setConsultType(String consultType) { this.consultType = consultType; } public String getConsultData() { return this.consultData; } public void setConsultData(String consultData) { this.consultData = consultData; } public ProdutosDados getProdutosDados() { return produtosDados; } public void setProdutosDados(ProdutosDados produtosDados) { this.produtosDados = produtosDados; } @Override public void returnClientType() { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "sistemaCadastroDeProdutos-main/sistemaCadastroDeProdutos-main/src/ClienteAdministracao.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "ClienteAdministracao manages client data, product data (via ProdutosDados), and UI output (via returnClientType), indicating multiple responsibilities. Handling data management and UI rendering violates SRP by combining distinct functionalities in one class."}, {"principle": "Dependency Inversion", "justification": "ClienteAdministracao directly depends on the concrete ProdutosDados class instead of an abstraction. High-level modules should depend on interfaces, not low-level implementations, to decouple dependencies."}]}]}
{"project_id": 107, "chunk_id": 0, "prompt": {"main_file_path": "sistemaCadastroDeProdutos-main/sistemaCadastroDeProdutos-main/src/ClienteComputacao.java", "main_file_content": "public class ClienteComputacao extends ClientesDados { private String tech; private String companyDescription; private ProdutosDados produtosDados; public String getTech() { return tech; } public void setTech(String tech) { this.tech = tech; } public String getCompanyDescription() { return companyDescription; } public void setCompanyDescription(String companyDescription) { this.companyDescription = companyDescription; } public ProdutosDados getProdutosDados() { return produtosDados; } public void setProdutosDados(ProdutosDados produtosDados) { this.produtosDados = produtosDados; } @Override public void returnClientType() { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "sistemaCadastroDeProdutos-main/sistemaCadastroDeProdutos-main/src/ClienteComputacao.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "ClienteComputacao manages client data, product data (via ProdutosDados), and handles UI output (returnClientType), indicating multiple responsibilities."}, {"principle": "Dependency Inversion", "justification": "ClienteComputacao directly depends on concrete ProdutosDados instead of an abstraction, violating high-level module dependency rules."}]}]}
{"project_id": 107, "chunk_id": 0, "prompt": {"main_file_path": "sistemaCadastroDeProdutos-main/sistemaCadastroDeProdutos-main/src/ClientesDados.java", "main_file_content": "public class ClientesDados { private String name; private String phone; private String adress; private String postDate; private ProdutosDados produtosDados; public String getName() { return this.name; } public void setName(String name) { this.name = name; } public String getPhone() { return this.phone; } public void setPhone(String phone) { this.phone = phone; } public String getAdress() { return this.adress; } public void setAdress(String adress) { this.adress = adress; } public String getPostDate() { return this.postDate; } public void setPostDate(String postDate) { this.postDate = postDate; } public ProdutosDados getProdutosDados() { return this.produtosDados; } public void setProdutosDados(ProdutosDados produtosDados) { this.produtosDados = produtosDados; } public void returnClientType() { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "sistemaCadastroDeProdutos-main/sistemaCadastroDeProdutos-main/src/ClientesDados.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "ClientesDados handles both client data management (fields, getters/setters) and presentation logic (returnClientType method with multiple print statements), indicating multiple responsibilities."}, {"principle": "Dependency Inversion", "justification": "ClientesDados directly depends on the concrete ProdutosDados class instead of an abstraction (interface/abstract class), violating the requirement for high-level modules to depend on abstractions."}]}]}
{"project_id": 107, "chunk_id": 0, "prompt": {"main_file_path": "sistemaCadastroDeProdutos-main/sistemaCadastroDeProdutos-main/src/ClienteEngenharia.java", "main_file_content": "public class ClienteEngenharia extends ClientesDados { private String engineeringType; private String activityDescription; private ProdutosDados produtosDados; public String getEngineeringType() { return engineeringType; } public void setEngineeringType(String engineeringType) { this.engineeringType = engineeringType; } public String getActivityDescription() { return activityDescription; } public void setActivityDescription(String activityDescription) { this.activityDescription = activityDescription; } public ProdutosDados getProdutosDados() { return produtosDados; } public void setProdutosDados(ProdutosDados produtosDados) { this.produtosDados = produtosDados; } @Override public void returnClientType() { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "sistemaCadastroDeProdutos-main/sistemaCadastroDeProdutos-main/src/ClienteEngenharia.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "ClienteEngenharia manages client data, product dependencies, and output formatting (returnClientType), handling multiple responsibilities. This creates multiple reasons to change the class."}, {"principle": "Dependency Inversion", "justification": "ClienteEngenharia directly depends on the concrete ProdutosDados class instead of an abstraction, violating the requirement for high-level modules to depend on interfaces."}]}]}
{"project_id": 107, "chunk_id": 0, "prompt": {"main_file_path": "sistemaCadastroDeProdutos-main/sistemaCadastroDeProdutos-main/src/ProdutosDados.java", "main_file_content": "public class ProdutosDados { private String productName; private String productsData; private String productsPrice; public ProdutosDados(){} public ProdutosDados(String productName, String productsData, String productsPrice) { this.productName = productName; this.productsData = productsData; this.productsPrice = productsPrice; } public String getProductName() { return productName; } public void setProductName(String productName) { this.productName = productName; } public String getProductsData() { return productsData; } public void setProductsData(String productsData) { this.productsData = productsData; } public String getProductsPrice() { return productsPrice; } public void setProductsPrice(String productsPrice) { this.productsPrice = productsPrice; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "sistemaCadastroDeProdutos-main/sistemaCadastroDeProdutos-main/src/ProdutosDados.java", "violatedPrinciples": []}]}
{"project_id": 107, "chunk_id": 0, "prompt": {"main_file_path": "sistemaCadastroDeProdutos-main/sistemaCadastroDeProdutos-main/src/App.java", "main_file_content": "public class App { public static void main(String[] args) throws Exception { ClienteComputacao clienteComp = new ClienteComputacao(); ProdutosDados produtcComp = new ProdutosDados(); ClienteAdministracao clienteAdm = new ClienteAdministracao(); ProdutosDados produtcAdm = new ProdutosDados(); ClienteEngenharia clientEng = new ClienteEngenharia(); ProdutosDados produtcEng = new ProdutosDados(); clienteComp.setName(\"Adeobaldo Pinto\"); clienteComp.setPhone(\"(71) 9 9273-7787\"); clienteComp.setAdress(\"Garibalde\"); clienteComp.setPostDate(\"29/10/2021\"); clienteComp.setTech(\"Hardware company\"); clienteComp.setCompanyDescription(\"Uma empresa de constru\u00e7\u00e3o e manuten\u00e7\u00e3o de hardwares.\"); produtcComp.setProductName(\"CPU\"); produtcComp.setProductsData(\"Uma CPU i7 10th\"); produtcComp.setProductsPrice(\"1000.00\"); clienteComp.returnClientType(); clienteAdm.setName(\"Clodoaldo Moura\"); clienteAdm.setPhone(\"(71) 9 7962-6676\"); clienteAdm.setAdress(\"Pituba\"); clienteAdm.setPostDate(\"30/10/2021\"); clienteAdm.setConsultType(\"Qual a melhor forma de investir na minha empresa\"); clienteAdm.setConsultData(\"Estou com d\u00favida da melhor forma de investir meu dinheiro na minha empresa\"); produtcAdm.setProductName(\"Consulta b\u00e1sica no plano da empresa\"); produtcAdm.setProductsData(\"Como construir um neg\u00f3cio de sucesso\"); produtcAdm.setProductsPrice(\"1500.00\"); clienteAdm.returnClientType(); clientEng.setName(\"Shiryu de Drag\u00e3o\"); clientEng.setPhone(\"(71) 9 3617-1121\"); clientEng.setAdress(\"Alpha Ville\"); clientEng.setPostDate(\"08/11/2021\"); clientEng.setEngineeringType(\"Engenheiro Civil\"); clientEng.setActivityDescription(\"Construtor de pr\u00e9dios.\"); produtcEng.setProductName(\"Manuten\u00e7\u00e3o em uma constru\u00e7\u00e3o.\"); produtcEng.setProductsData(\"Revis\u00e3o no pr\u00e9dio.\"); produtcEng.setProductsPrice(\"900.00\"); clientEng.returnClientType(); } }", "dependencies": [{"file_path": "sistemaCadastroDeProdutos-main/sistemaCadastroDeProdutos-main/src/ClienteComputacao.java", "file_content": "public class ClienteComputacao extends ClientesDados { private String tech; private String companyDescription; private ProdutosDados produtosDados; public String getTech() { return tech; } public void setTech(String tech) { this.tech = tech; } public String getCompanyDescription() { return companyDescription; } public void setCompanyDescription(String companyDescription) { this.companyDescription = companyDescription; } public ProdutosDados getProdutosDados() { return produtosDados; } public void setProdutosDados(ProdutosDados produtosDados) { this.produtosDados = produtosDados; } @Override public void returnClientType() { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "sistemaCadastroDeProdutos-main/sistemaCadastroDeProdutos-main/src/App.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "App directly instantiates concrete ProdutosDados, violating DIP by depending on low-level modules instead of abstractions."}]}, {"file_path": "sistemaCadastroDeProdutos-main/sistemaCadastroDeProdutos-main/src/ClienteComputacao.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "ClienteComputacao depends on concrete ProdutosDados instead of an abstraction, violating DIP."}, {"principle": "Liskov", "justification": "returnClientType implementation (empty prints) likely violates the base class's contract, breaking substitutability."}]}]}
{"project_id": 109, "chunk_id": 0, "prompt": {"main_file_path": "socialMedia_Java-master/src/User.java", "main_file_content": "import java.util.*; public class User { String name, dob, location, password; int age; List<User> mutualFriends, matchedProfile, requests; User(String name, String password, String dob, String location, int age){ this.name=name; this.password=password; this.age=age; this.dob=dob; this.location=location; mutualFriends = new ArrayList<>(); matchedProfile = new ArrayList<>(); requests = new ArrayList<>(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "socialMedia_Java-master/src/User.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The User class handles multiple responsibilities: storing user data, managing mutual friends, tracking matched profiles, and processing requests. These distinct functionalities should be separated into different classes."}]}]}
{"project_id": 109, "chunk_id": 0, "prompt": {"main_file_path": "socialMedia_Java-master/src/Main.java", "main_file_content": "import java.util.*; public class Main { public static List<User> allUser = new ArrayList<>(); public static void main(String[] args) { Scanner sc = new Scanner(System.in); while(true){ soutl(\"\") int choice; choice=sc.nextInt(); if(choice>=3 || choice<=0) { break; } User newUser = null; if(choice==2){ String loginUser, loginPassword; sout(\"\") loginUser = sc.next(); boolean isFoundUser=false; for(User i:allUser) { if (i.name.equals(loginUser)) { isFoundUser=true; newUser = i; break; } } if(!isFoundUser){ soutl(\"\") continue; } sout(\"\") loginPassword = sc.next(); if(!newUser.password.equals(loginPassword)) { soutl(\"\") continue; } soutl(\"\") suggestion.connections(newUser); request.details(newUser); if(allUser.size()>1) { soutl(\"\") int opt=sc.nextInt(); if(opt==1) { soutl(\"\") String req = sc.next(); boolean alreadyFriend=false; for(User i:newUser.mutualFriends){ if(i.name.equals(req)){ soutl(\"\") alreadyFriend=true; break; } } if(!alreadyFriend) request.search(req, newUser); } } } else { String name, password, dob, location; int age; sout(\"\") sout(\"\") name = sc.next(); boolean exist=false; for(User i:allUser){ if(i.name.equals((name))){ soutl(\"\") exist=true; break; } } if(exist) continue; sout(\"\") password=sc.next(); sout(\"\") age = sc.nextInt(); sout(\"\") dob = sc.next(); sout(\"\") location = sc.next(); newUser = new User(name, password, dob, location, age); sout(\"\") allUser.add(newUser); } } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "socialMedia_Java-master/src/Main.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Main class handles user input, user creation, authentication, friend suggestions, and request processing, indicating multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Adding new user types or operations (e.g., authentication methods) would require modifying Main.java directly, as there are no abstractions to extend."}, {"principle": "Dependency Inversion", "justification": "Main directly depends on concrete User, suggestion, and request implementations without abstractions. High-level modules should depend on interfaces."}]}]}
{"project_id": 109, "chunk_id": 0, "prompt": {"main_file_path": "socialMedia_Java-master/src/suggestion.java", "main_file_content": "public class suggestion { public static void connections(User currUser){ soutl(\"\") if(currUser.mutualFriends!=null) { for (User i : currUser.mutualFriends) { soutl(\"\") } } for(User i: Main.allUser) { if (i != currUser && currUser.mutualFriends!=null && !currUser.mutualFriends.contains(i)) { if (i.name.equals(currUser.name) || i.age == currUser.age || i.location.equals(currUser.location)) { currUser.matchedProfile.add(i); } } } soutl(\"\") for(User i:currUser.matchedProfile){ soutl(\"\") } soutl(\"\") for(User i:Main.allUser){ if(i!=currUser && !currUser.matchedProfile.contains(i) && !currUser.mutualFriends.contains(i)) { soutl(\"\") } } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "socialMedia_Java-master/src/suggestion.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The suggestion class handles multiple responsibilities: calculating user connections, matching profiles based on criteria, and printing results. This violates SRP as it combines data processing and output logic in one class."}, {"principle": "Open-Closed", "justification": "The profile-matching logic in the connections method is hard-coded (e.g., name/age/location checks). To modify or extend the criteria, the class must be directly modified, violating OCP."}, {"principle": "Dependency Inversion", "justification": "The high-level connections method directly depends on the concrete Main.allUser static list and User implementation. It should depend on abstractions (e.g., interfaces for user repositories) instead."}]}]}
{"project_id": 109, "chunk_id": 0, "prompt": {"main_file_path": "socialMedia_Java-master/src/request.java", "main_file_content": "import java.util.*; public class request { static void search(String find, User currUser){ for(User i:Main.allUser) { if (i.name.equals(find)) { i.requests.add(currUser); } } } static void details(User currUser){ sout(\"\") if(currUser.requests.isEmpty()){ sout(\"\") return; } List<User> acceptedUser = new ArrayList<>(); for(User i:currUser.requests){ sout(\"\") sout(\"\") Scanner sc = new Scanner(System.in); int option =sc.nextInt(); if(option==1){ if(!currUser.mutualFriends.contains(i)) currUser.mutualFriends.add(i); if(!i.mutualFriends.contains(currUser)) i.mutualFriends.add(currUser); acceptedUser.add(i); } } for(User i:acceptedUser){ currUser.requests.remove(i); currUser.matchedProfile.remove(i); i.matchedProfile.remove(currUser); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "socialMedia_Java-master/src/request.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The request class handles multiple responsibilities: managing user requests and processing user input/UI interactions. These should be separated into distinct classes."}, {"principle": "Open-Closed", "justification": "The static methods in request cannot be extended without modifying their existing code. New request handling logic would require direct changes to the class."}, {"principle": "Dependency Inversion", "justification": "The request class directly depends on concrete classes User and Main instead of abstractions. High-level modules should depend on interfaces, not low-level implementations."}]}]}
{"project_id": 111, "chunk_id": 0, "prompt": {"main_file_path": "kothaaBot-main/src/main/java/org/kothaaa/MyBot.java", "main_file_content": "package org.kothaaa; import org.telegram.telegrambots.meta.TelegramBotsApi; import org.telegram.telegrambots.meta.exceptions.TelegramApiException; import org.telegram.telegrambots.updatesreceivers.DefaultBotSession; public class MyBot { public static void main(String[] args) { try { TelegramBotsApi botsApi = new TelegramBotsApi(DefaultBotSession.class); botsApi.registerBot(new BackEnd()); } catch (TelegramApiException e) { e.printStackTrace(); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "kothaaBot-main/src/main/java/org/kothaaa/MyBot.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "MyBot directly instantiates concrete TelegramBotsApi and BackEnd classes. High-level modules should depend on abstractions rather than concrete implementations."}]}]}
{"project_id": 111, "chunk_id": 0, "prompt": {"main_file_path": "kothaaBot-main/src/main/java/org/kothaaa/BackEnd.java", "main_file_content": "package org.kothaaa; import com.google.api.gax.core.FixedCredentialsProvider; import com.google.auth.oauth2.GoogleCredentials; import com.google.cloud.dialogflow.v2.*; import org.telegram.telegrambots.bots.TelegramLongPollingBot; import org.telegram.telegrambots.meta.api.methods.send.SendMessage; import org.telegram.telegrambots.meta.api.objects.Update; import org.telegram.telegrambots.meta.exceptions.TelegramApiException; import java.io.FileInputStream; import java.io.IOException; import java.util.UUID; public class BackEnd extends TelegramLongPollingBot { @Override public void onUpdateReceived(Update update) { if (update.hasMessage() && update.getMessage().hasText()) { String messageText = update.getMessage().getText(); String responseText = null; try { responseText = detectIntent(messageText); } catch (IOException e) { throw new RuntimeException(e); } SendMessage message = new SendMessage(); message.setChatId(update.getMessage().getChatId().toString()); message.setText(responseText); try { execute(message); } catch (TelegramApiException e) { e.printStackTrace(); } } } private String detectIntent(String message) throws IOException { String sessionId = UUID.randomUUID().toString(); String keyPath = \"F:\\\\Java Development\\\\KothaaBot\\\\Kotha\\\\kothabot.json\"; GoogleCredentials credentials = GoogleCredentials.fromStream(new FileInputStream(keyPath)); SessionsSettings sessionsSettings = SessionsSettings.newBuilder() .setCredentialsProvider(FixedCredentialsProvider.create(credentials)) .build(); SessionsClient sessionsClient = SessionsClient.create(sessionsSettings); String projectId = \"kothabot-lawe\"; SessionName session = SessionName.of(projectId, sessionId); TextInput.Builder textInput = TextInput.newBuilder().setText(message).setLanguageCode(\"en-US\"); QueryInput queryInput = QueryInput.newBuilder().setText(textInput).build(); DetectIntentResponse response = sessionsClient.detectIntent(session, queryInput); String responseText = response.getQueryResult().getFulfillmentText(); sessionsClient.close(); return responseText; } @Override public String getBotUsername() { return \"kothaa_bot\"; } @Override public String getBotToken() { return \"6177120334:AAERpsArCSdIZax6yXT-hWUERVYSp23gn1g\"; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "kothaaBot-main/src/main/java/org/kothaaa/BackEnd.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "BackEnd handles Telegram bot updates, DialogFlow integration, credentials management, and response processing. Multiple responsibilities violate SRP."}, {"principle": "Open-Closed", "justification": "DialogFlow integration logic cannot be extended without modifying detectIntent method. No abstraction allows behavioral changes via extension."}, {"principle": "Dependency Inversion", "justification": "High-level bot logic directly instantiates low-level DialogFlow components (SessionsClient, GoogleCredentials). No abstractions or dependency injection used."}]}]}
{"project_id": 118, "chunk_id": 0, "prompt": {"main_file_path": "VisiCalc-main/VisiCalc-main/TextCell.java", "main_file_content": "public class TextCell extends Cell{ public TextCell(String text, String command){ super(text, command); } public int compareTo(Cell c) { if(c==null || c instanceof DateCell || c instanceof FormulaCell) { return 1; } else if(c instanceof TextCell) { int length1 = this.getValue().length(); int length2 = c.getValue().length(); int length = Math.min(length1, length2); int i = 0; while (i < length) { char ch1 = this.getValue().charAt(i); char ch2 = c.getValue().charAt(i); if (ch1 != ch2) { return ch1 - ch2; } i++; } return length1 - length2; } return -1; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "VisiCalc-main/VisiCalc-main/TextCell.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "The compareTo method checks concrete Cell subtypes with instanceof, requiring modification when new Cell types are added, violating OCP."}, {"principle": "Dependency Inversion", "justification": "TextCell's compareTo depends on concrete classes (DateCell, FormulaCell) instead of abstractions, violating DIP by referencing low-level modules directly."}]}]}
{"project_id": 118, "chunk_id": 0, "prompt": {"main_file_path": "VisiCalc-main/VisiCalc-main/FormulaCell.java", "main_file_content": "import java.util.*; public class FormulaCell extends Cell{ String formula; public FormulaCell(String formula) { super(evaluate(formula), formula); } public static String evaluate(String formula){ if(formula.contains(\" \") && formula.substring(0, formula.indexOf(\" \")).equals(\"SUM\")) { return SumOrAverage(formula.substring(formula.indexOf(\" \")+1), false); } else if(formula.contains(\" \") && formula.substring(0, formula.indexOf(\" \")).equals(\"AVG\")) { return SumOrAverage(formula.substring(formula.indexOf(\" \")+1), true); } else if(formula.length()>1 && formula.length()<4 && formula.charAt(0) > 64 && formula.charAt(0) < 72 && formula.charAt(1) > 48 && formula.charAt(1) < 58 && ((formula.length()==3&&formula.charAt(2) == '0') ||formula.length()==2)) { return ((Grid.spreadsheet[Cell.getRowAddress(formula.substring(1))][Cell.getColumnAddress(formula.substring(0,1))]).getValue()); }else { String [] split = formula.split(\" \"); for(int i = 0; i < split.length; i++) { if(split[i].length()>1 && split[i].length()<4 && split[i].charAt(0) > 64 && split[i].charAt(0) < 72 && split[i].charAt(1) > 48 && split[i].charAt(1) < 58) { if((split[i].length()==3&&split[i].charAt(1)=='1'&&split[i].charAt(2)=='0') || split[i].length() == 2){ if(Grid.spreadsheet[getRowAddress(split[i].substring(1))][getColumnAddress(split[i].substring(0,1))] instanceof TextCell || Grid.spreadsheet[getRowAddress(split[i].substring(1))][getColumnAddress(split[i].substring(0,1))] instanceof DateCell || Grid.spreadsheet[getRowAddress(split[i].substring(1))][getColumnAddress(split[i].substring(0,1))] == null) { split[i] = \"0\"; } else if(Grid.spreadsheet[getRowAddress(split[i].substring(1))][getColumnAddress(split[i].substring(0,1))] instanceof FormulaCell) { split[i]= evaluate(Grid.spreadsheet[getRowAddress(split[i].substring(1))][getColumnAddress(split[i].substring(0,1))].getCommand()); } else { split[i] = Grid.spreadsheet[getRowAddress(split[i].substring(1))][getColumnAddress(split[i].substring(0,1))].getValue(); } } } } String solution = \"\"; for(int i = 0; i < split.length; i++) { solution += split[i]; if(i != split.length-1) { solution += \" \"; } } int paras = 0; String left = \"\"; String op = \"\"; String right = \"\"; int[] numOfOpenParas = new int[solution.length()]; while(solution.contains(\"(\") || solution.contains(\")\")) { for(int i = 0; i < solution.length(); i++){ if(solution.charAt(i) == '('){ paras++; } else if(solution.charAt(i) == ')'){ paras--; } numOfOpenParas[i] = paras; if(numOfOpenParas[i] == 0 && i > solution.indexOf(\"(\") && solution.contains(\"(\")){ left = solution.substring(0, solution.indexOf(\"(\")); op = solution.substring(solution.indexOf(\"(\") + 2, i-1); right = solution.substring(i+1); op = evaluate(op); solution = left + op + right; } } } String prev = \"\"; String next = \"\"; String temp = \"\"; String last = \"\"; String solved = \"\"; while(solution.contains(\" * \") || solution.contains(\" / \") || solution.contains(\" + \") || solution.contains(\" - \")) { while(solution.contains(\"*\") || solution.contains(\"/\")) { solved = \"\"; String[] split1 = solution.split(\" \"); for(int i = 0; i<split1.length; i++) { if(split1[i].equals(\"*\")){ prev = split1[i-1]; next = split1[i+1]; solved = \"\" + (int) Math.floor(Double.parseDouble(prev) * Double.parseDouble(next)); temp = solution; if(temp.indexOf(\"*\")+2+next.length()<temp.length()) { last = temp.substring(temp.indexOf(\"*\")+2+next.length()); } else { last = \"\"; } solution = temp.substring(0, (temp.indexOf(\"*\") -1 - prev.length())) + solved + last; split1 = solution.split(\" \"); i = 0; } else if(split1[i].equals(\"/\")){ prev = split1[i-1]; next = split1[i+1]; solved = \"\" + (int) Math.floor(Double.parseDouble(prev) / Double.parseDouble(next)); temp = solution; if(temp.indexOf(\"/\")+2+next.length()<temp.length()) { last = temp.substring(temp.indexOf(\"/\")+2+next.length()); } else { last = \"\"; } solution = temp.substring(0, (temp.indexOf(\"/\") -1 - prev.length())) + solved + last; split1 = solution.split(\" \"); i = 0; } } prev = \"\"; next = \"\"; temp = \"\"; last = \"\"; } while(solution.contains(\" + \") || solution.contains(\" - \")) { solved = \"\"; String[] split1 = solution.split(\" \"); for(int i = 0; i<split1.length; i++) { if(split1[i].equals(\"+\")){ prev = split1[i-1]; next = split1[i+1]; solved = \"\" + (int) Math.floor(Double.parseDouble(prev) + Double.parseDouble(next)); temp = solution; if(temp.indexOf(\"+\")+2+next.length()<temp.length()) { last = temp.substring(temp.indexOf(\"+\")+2+next.length()); } else { last = \"\"; } solution = temp.substring(0, (temp.indexOf(\"+\") -1 - prev.length())) + solved + last; split1 = solution.split(\" \"); i = 0; } else if(split1[i].equals(\"-\")){ prev = split1[i-1]; next = split1[i+1]; solved = \"\" + (int) Math.floor(Double.parseDouble(prev) - Double.parseDouble(next)); temp = solution; if(temp.indexOf(\"-\")+2+next.length()<temp.length()) { last = temp.substring(temp.indexOf(\"-\")+2+next.length()); } else { last = \"\"; } solution = temp.substring(0, (temp.indexOf(\"- \") -1 - prev.length())) + solved + last; split1 = solution.split(\" \"); i = 0; } } prev = \"\"; next = \"\"; temp = \"\"; last = \"\"; } } return solution; } } public static String SumOrAverage(String formula, Boolean Average) { String[]split = formula.split(\" \"); int row1 = Math.min(Cell.getRowAddress(split[0].substring(1)), Cell.getRowAddress(split[2].substring(1))); int row2 = Math.max(Cell.getRowAddress(split[0].substring(1)), Cell.getRowAddress(split[2].substring(1))); int column1 = Math.min(Cell.getColumnAddress(split[0].substring(0,1)), Cell.getColumnAddress(split[2].substring(0,1))); int column2 = Math.max(Cell.getColumnAddress(split[0].substring(0,1)), Cell.getColumnAddress(split[2].substring(0,1))); double sum = 0; int count = 1; for(int r = row1; r<= row2; r++) { for(int c = column1; c <= column2; c++) { if(Grid.spreadsheet[r][c] instanceof TextCell || Grid.spreadsheet[r][c] instanceof DateCell || Grid.spreadsheet[r][c] == null){ } else if(Grid.spreadsheet[r][c] instanceof FormulaCell) { sum += Double.parseDouble(evaluate(Grid.spreadsheet[r][c].getCommand())); } else { sum += Double.parseDouble(Grid.spreadsheet[r][c].getValue()); } } } if(Average) { count = (row2-row1+1)*(column2-column1+1); } if((sum/count) % 1 == 0.0) { return \"\" + (int)(sum/count); } return \"\" + (sum / count); } public int compareTo(Cell c) { if(c==null) { return 1; } else if(c instanceof FormulaCell) { return Integer.parseInt(evaluate(this.getCommand())) - Integer.parseInt(evaluate(c.getCommand())); } return -1; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "VisiCalc-main/VisiCalc-main/FormulaCell.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "FormulaCell handles formula parsing, evaluation, arithmetic operations, and grid traversal. These multiple responsibilities violate SRP, as changes to any of these areas would require modifying the class."}, {"principle": "Open-Closed", "justification": "Adding new formula functions (e.g., MAX) requires modifying the evaluate method directly, violating OCP by not allowing extension without changing existing code."}, {"principle": "Liskov", "justification": "The compareTo method returns -1 for non-FormulaCell instances, breaking substitutability with the Cell base type if comparison logic is expected to handle all subtypes uniformly."}, {"principle": "Dependency Inversion", "justification": "FormulaCell directly depends on concrete Grid.spreadsheet and checks concrete cell types (TextCell, DateCell), violating DIP by coupling high-level logic to low-level implementations."}]}]}
{"project_id": 118, "chunk_id": 0, "prompt": {"main_file_path": "VisiCalc-main/VisiCalc-main/DateCell.java", "main_file_content": "public class DateCell extends Cell{ int month; int day; int year; public DateCell(int month, int day, int year, String command) { super(\"0\", command); this.setValue(month + \"/\" + day + \"/\" + year); this.month = month; this.day = day; this.year = year; this.command = command; } public int compareTo(Cell c) { if(c==null || c instanceof FormulaCell) { return 1; } else if(c instanceof DateCell) { soutl(\"\") soutl(\"\") soutl(\"\") if (this.year != c.year) { return this.year - c.year; } else if (this.month != c.month) { return this.month - c.month; } else if (this.day != c.day) { soutl(\"\") return this.day - c.day; } return 0; } return -1; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "VisiCalc-main/VisiCalc-main/DateCell.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "The compareTo method checks concrete subtypes (e.g., FormulaCell), requiring modification to support new Cell types, violating OCP."}, {"principle": "Liskov", "justification": "compareTo behavior is inconsistent across Cell subtypes (e.g., returns 1 for FormulaCell), breaking substitution expectations."}, {"principle": "Dependency Inversion", "justification": "High-level DateCell directly depends on low-level concrete classes (FormulaCell) instead of abstractions, violating DIP."}]}]}
{"project_id": 118, "chunk_id": 0, "prompt": {"main_file_path": "VisiCalc-main/VisiCalc-main/Grid.java", "main_file_content": "import java.io.*; import java.util.*; public class Grid { static Cell[][] spreadsheet = new Cell[10][7]; public static void print(){ sout(\"\") for(int i = 65; i <72; i++) { sout(\"\") } soutl(\"\") for(int i = 0; i<64; i++) { sout(\"\") } sout(\"\") for(int r = 0; r<10; r++) { System.out.printf(\" %2d |\", (r+1)); for(int c = 0; c<7; c++) { if(spreadsheet[r][c] instanceof FormulaCell) { spreadsheet[r][c].setValue(FormulaCell.evaluate(spreadsheet[r][c].getCommand())); } if(spreadsheet[r][c] == null) { sout(\"\") } else if((spreadsheet[r][c].getValue()).length() < 5) { System.out.printf(\"%4s \", spreadsheet[r][c].getValue()); } else if((spreadsheet[r][c].getValue()).length() < 8) { sout(\"\") for(int i = (spreadsheet[r][c].getValue()).length(); i < 7; i++) { sout(\"\") } } else { sout(\"\") } sout(\"\") } sout(\"\") for(int i = 0; i<64; i++) { sout(\"\") } sout(\"\") } } public static void saveGrid(String file, ArrayList<String> inputs) throws FileNotFoundException { PrintStream ps = new PrintStream(file); for(int i = 0; i < inputs.size(); i++) { String temp = inputs.get(i); if(!(temp.equals(\"load \" + file) || temp.equals(\"save \" + file))) { ps.printf(\"%s\\n\", temp); } } } public static void loadFile(String file, ArrayList<String> inputs) throws FileNotFoundException, UnsupportedEncodingException { File f = new File(file); if(f.exists()){ Scanner fileReader = new Scanner(f); while(fileReader.hasNext()) { String temp = fileReader.nextLine(); if(!(temp.equals(\"load \" + file) || temp.equals(\"save \" + file))) { inputs.add(temp); soutl(\"\") VisiCalc.processCommand(temp, inputs); } } } else { soutl(\"\") } } public static void clear() { for(int r = 0; r < 10; r++) { for(int c = 0; c<7; c++) { spreadsheet[r][c] = null; } } } public static void sort(String formula, boolean descending) { String[]split = formula.split(\" \"); int row1 = Math.min(Cell.getRowAddress(split[0].substring(1)), Cell.getRowAddress(split[2].substring(1))); int row2 = Math.max(Cell.getRowAddress(split[0].substring(1)), Cell.getRowAddress(split[2].substring(1))); int column1 = Math.min(Cell.getColumnAddress(split[0].substring(0,1)), Cell.getColumnAddress(split[2].substring(0,1))); int column2 = Math.max(Cell.getColumnAddress(split[0].substring(0,1)), Cell.getColumnAddress(split[2].substring(0,1))); soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") Cell [] sorted = new Cell [(row2-row1+1)*(column2-column1+1)]; ArrayList<Cell> sortNotNull = new ArrayList<Cell>(); for(int r = row1; r<= row2; r++) { for(int c = column1; c <= column2; c++) { if(spreadsheet[r][c] != null) { sortNotNull.add(spreadsheet[r][c]); } } } Cell[] notNullArray = new Cell[sortNotNull.size()]; for(int i = 0; i < sortNotNull.size(); i++) { notNullArray[i] = sortNotNull.get(i); } Arrays.sort(notNullArray); soutl(\"\") for(int i = 0; i < notNullArray.length; i++) { sorted[sorted.length-notNullArray.length + i] = notNullArray[i]; } if(descending) { soutl(\"\") int end = sorted.length-1; soutl(\"\") for (int start = 0; start < end; start++){ Cell temp = sorted[start]; sorted[start] = sorted[end]; sorted[end] = temp; end--; } soutl(\"\") soutl(\"\") } for(int r = row1; r<= row2; r++) { for(int c = column1; c <= column2; c++) { spreadsheet[r][c] = sorted[r*(column2-column1+1)+c-row1]; } } } }", "dependencies": [{"file_path": "VisiCalc-main/VisiCalc-main/TextCell.java", "file_content": "public class TextCell extends Cell{ public TextCell(String text, String command){ super(text, command); } public int compareTo(Cell c) { if(c==null || c instanceof DateCell || c instanceof FormulaCell) { return 1; } else if(c instanceof TextCell) { int length1 = this.getValue().length(); int length2 = c.getValue().length(); int length = Math.min(length1, length2); int i = 0; while (i < length) { char ch1 = this.getValue().charAt(i); char ch2 = c.getValue().charAt(i); if (ch1 != ch2) { return ch1 - ch2; } i++; } return length1 - length2; } return -1; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "VisiCalc-main/VisiCalc-main/Grid.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Grid handles printing, file I/O, sorting, and grid management. Multiple responsibilities mean multiple reasons to change."}, {"principle": "Open-Closed", "justification": "print() directly checks for FormulaCell type and calls its static method. Adding new cell types requires modifying print()."}, {"principle": "Dependency Inversion", "justification": "Grid directly references FormulaCell (concrete implementation) and uses static methods, creating a direct dependency on low-level modules."}]}, {"file_path": "VisiCalc-main/VisiCalc-main/TextCell.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "compareTo() checks concrete subtypes (DateCell/FormulaCell). Adding new cell types requires modifying this method."}, {"principle": "Liskov", "justification": "compareTo() returns 1 when compared to DateCell/FormulaCell, breaking substitutability expectations for Cell subclasses."}]}]}
{"project_id": 118, "chunk_id": 0, "prompt": {"main_file_path": "VisiCalc-main/VisiCalc-main/VisiCalc.java", "main_file_content": "import java.util.ArrayList; import java.util.Scanner; import java.io.*; public class VisiCalc { public static void main(String[]args) throws FileNotFoundException, UnsupportedEncodingException{ Scanner scan = new Scanner(System.in); boolean quit = false; String in = \"\"; ArrayList<String> inputs = new ArrayList<String>(); soutl(\"\") while(!quit){ sout(\"\") in = scan.nextLine(); inputs.add(in); quit = processCommand(in, inputs); } } public static boolean processCommand(String command, ArrayList<String> inputs) throws FileNotFoundException, UnsupportedEncodingException{ boolean quit = false; if(command.equalsIgnoreCase(\"quit\")){ quit = true; soutl(\"\") } else if(command.equalsIgnoreCase(\"help\")){ soutl(\"\") } else if(command.equalsIgnoreCase(\"print\")){ Grid.print(); } else if(command.length()>1&&command.length()<4) { if(command.charAt(0) > 64 && command.charAt(0) < 72 && command.charAt(1) > 48 && command.charAt(1) < 58){ if((command.length()==3&&command.charAt(2) == '0') ||command.length()==2) { soutl(\"\") } } } else if(command.contains(\" = \") || command.substring(0,4).equalsIgnoreCase(\"SORT\")) { String[] split = command.split(\" \"); if(split.length == 4 && split[0].substring(0,4).equalsIgnoreCase(\"sort\") && split[2].equals(\"-\")) { String sort = split[1] + \" \" + split[2] + \" \" + split[3]; if(split[0].equalsIgnoreCase(\"SORTA\")) { Grid.sort(sort, false); } else if(split[0].equalsIgnoreCase(\"SORTD\")) { Grid.sort(sort, true); } } if(split[1].equals(\"=\")){ if(split[2].equals(\"\\\"\")) { Grid.spreadsheet[Cell.getRowAddress(split[0].substring(1))][Cell.getColumnAddress(split[0].substring(0,1))]= new TextCell(command.substring(command.indexOf(\"\\\"\")+2, command.lastIndexOf(\"\\\"\")-1), command); } else if(split[2].equals(\"(\")){ Grid.spreadsheet[Cell.getRowAddress(split[0].substring(1))][Cell.getColumnAddress(split[0].substring(0,1))] = new FormulaCell(command.substring(command.indexOf(\"(\")+2, command.lastIndexOf(\")\")-1)); } else if(split.length == 3){ if(split[2].contains(\"/\")) { String[] dateSplit = split[2].split(\"/\"); int month = Integer.parseInt(dateSplit[0]); int day = Integer.parseInt(dateSplit[1]); int year = Integer.parseInt(dateSplit[2]); Grid.spreadsheet[Cell.getRowAddress(split[0].substring(1))][Cell.getColumnAddress(split[0].substring(0,1))] = new DateCell(month,day,year, command); }else { Grid.spreadsheet[Cell.getRowAddress(split[0].substring(1))][Cell.getColumnAddress(split[0].substring(0,1))] = new Cell(split[2], command); } } } } else if(command.contains(\".txt\")){ String[] split = command.split(\" \"); if(split[0].equals(\"save\")) { Grid.saveGrid(split[1], inputs); } else if(split[0].equals(\"load\")) { Grid.loadFile(split[1], inputs); } } else if(command.contains(\"clear\")){ String[]split = command.split(\" \"); if(split[0].equalsIgnoreCase(\"clear\")){ if(split.length > 1) { Grid.spreadsheet[Cell.getRowAddress(split[1].substring(1))][Cell.getColumnAddress(split[1].substring(0,1))] = null; } else { Grid.clear(); } } } else{ soutl(\"\") } return quit; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "VisiCalc-main/VisiCalc-main/VisiCalc.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The VisiCalc class handles command processing, input management, and direct grid interactions. This combines user input handling, business logic execution, and grid manipulation into a single class."}, {"principle": "Open-Closed", "justification": "The processCommand method uses rigid if-else chains to handle commands. Adding new command types requires modifying this method instead of extending through abstractions."}, {"principle": "Dependency Inversion", "justification": "VisiCalc directly depends on concrete Grid class and its static methods. High-level policy logic (command processing) should depend on grid abstractions rather than low-level implementation details."}]}]}
{"project_id": 118, "chunk_id": 0, "prompt": {"main_file_path": "VisiCalc-main/VisiCalc-main/Cell.java", "main_file_content": "public class Cell implements Comparable<Cell>{ int num; int month; int day; int year; private String value; String command; public Cell(String value, String command){ this.setValue(value); this.command = command; } public static int getRowAddress(String address){ return Integer.parseInt(address)-1; } public static int getColumnAddress(String address){ return ((int)(address.toUpperCase().charAt(0)))-65; } public String getCommand() { return this.command; } public String getValue() { if(this.value.equals(null)) { return \"0\"; } return this.value; } public void setValue(String value) { this.value = value; } public int compareTo(Cell c) { if(c==null || c instanceof TextCell || c instanceof DateCell || c instanceof FormulaCell) { return 1; } return Integer.parseInt(this.getValue()) - Integer.parseInt(c.getValue()); } public String toString() { return this.value; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "VisiCalc-main/VisiCalc-main/Cell.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Cell handles address parsing, value storage, and comparison logic. It also contains date-related fields (month, day, year) despite being a base class for specialized cell types like DateCell."}, {"principle": "Open-Closed", "justification": "compareTo() explicitly checks for concrete subtypes (TextCell, DateCell, FormulaCell), requiring modification to support new cell types."}, {"principle": "Liskov", "justification": "compareTo() returns 1 when comparing against subclasses, violating symmetry. Subtypes cannot be substituted without altering sorting behavior."}]}]}
{"project_id": 119, "chunk_id": 0, "prompt": {"main_file_path": "QuickShot-master/QuickShot-master/quickshot/src/main/java/io/github/muddz/quickshot/QuickShotUtils.java", "main_file_content": "package io.github.muddz.quickshot; import android.graphics.Bitmap; import android.graphics.Canvas; import android.graphics.drawable.Drawable; import android.os.Build; import android.view.View; import androidx.recyclerview.widget.RecyclerView; import java.io.File; class QuickShotUtils { static String getMimeType(String src) { src = src.substring(1); if (src.equals(\"jpg\")) { src = \"jpeg\"; } return \"image\" + File.separator + src; } static boolean isAboveAPI29() { return Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q; } private Bitmap generateLongBitmap(RecyclerView recyclerView) { int itemCount = recyclerView.getAdapter().getItemCount(); RecyclerView.ViewHolder viewHolder = recyclerView.getAdapter().createViewHolder(recyclerView, 0); viewHolder.itemView.measure(View.MeasureSpec.makeMeasureSpec(recyclerView.getWidth(), View.MeasureSpec.EXACTLY), View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED)); int measuredItemHeight = viewHolder.itemView.getMeasuredHeight(); int measuredItemWidth = viewHolder.itemView.getMeasuredWidth(); viewHolder.itemView.layout(0, 0, measuredItemWidth, measuredItemHeight); Bitmap recyclerViewBitmap = Bitmap.createBitmap(recyclerView.getMeasuredWidth(), measuredItemHeight * itemCount, Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(recyclerViewBitmap); if (recyclerView.getBackground() != null) { Drawable drawable = recyclerView.getBackground().mutate(); drawable.setBounds(measuredItemWidth, measuredItemHeight * itemCount, 0, 0); drawable.draw(canvas); } int viewHolderTopPadding = 0; for (int i = 0; i < itemCount; i++) { recyclerView.getAdapter().onBindViewHolder(viewHolder, i); viewHolder.itemView.setDrawingCacheEnabled(true); viewHolder.itemView.buildDrawingCache(); canvas.drawBitmap(viewHolder.itemView.getDrawingCache(), 0f, viewHolderTopPadding, null); viewHolderTopPadding += measuredItemHeight; viewHolder.itemView.setDrawingCacheEnabled(false); viewHolder.itemView.destroyDrawingCache(); } return recyclerViewBitmap; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "QuickShot-master/QuickShot-master/quickshot/src/main/java/io/github/muddz/quickshot/QuickShotUtils.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The QuickShotUtils class handles multiple responsibilities: generating RecyclerView bitmaps, determining MIME types, and checking API levels. Each is a distinct reason to modify the class."}, {"principle": "Open-Closed", "justification": "The class cannot be extended without modification. New bitmap generation logic would require altering existing code rather than extending via abstractions."}]}]}
{"project_id": 119, "chunk_id": 0, "prompt": {"main_file_path": "QuickShot-master/QuickShot-master/quickshot/src/main/java/io/github/muddz/quickshot/PixelCopyHelper.java", "main_file_content": "package io.github.muddz.quickshot; import android.graphics.Bitmap; import android.os.Build; import android.os.Handler; import android.os.HandlerThread; import android.view.PixelCopy; import android.view.SurfaceView; import androidx.annotation.NonNull; class PixelCopyHelper { static void getSurfaceBitmap(@NonNull SurfaceView surfaceView, @NonNull final PixelCopyListener listener) { final Bitmap bitmap = Bitmap.createBitmap(surfaceView.getWidth(), surfaceView.getHeight(), Bitmap.Config.ARGB_8888); final HandlerThread handlerThread = new HandlerThread(PixelCopyHelper.class.getSimpleName()); handlerThread.start(); if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) { PixelCopy.request(surfaceView, bitmap, new PixelCopy.OnPixelCopyFinishedListener() { @Override public void onPixelCopyFinished(int copyResult) { if (copyResult == PixelCopy.SUCCESS) { listener.onSurfaceBitmapReady(bitmap); } else { listener.onSurfaceBitmapError(\"Couldn't create bitmap of the SurfaceView\"); } handlerThread.quitSafely(); } }, new Handler(handlerThread.getLooper())); } else { listener.onSurfaceBitmapError(\"Saving an image of a SurfaceView is only supported for API 24 and above\"); } } interface PixelCopyListener { void onSurfaceBitmapReady(Bitmap bitmap); void onSurfaceBitmapError(String errorMsg); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "QuickShot-master/QuickShot-master/quickshot/src/main/java/io/github/muddz/quickshot/PixelCopyHelper.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "PixelCopyHelper handles multiple responsibilities: creating bitmaps, managing threads, handling PixelCopy requests, and invoking callbacks. These should be separated into distinct classes."}, {"principle": "Interface Segregation", "justification": "PixelCopyListener interface forces clients to implement both onSurfaceBitmapReady and onSurfaceBitmapError, even if they only need one. It should be split into separate interfaces."}]}]}
{"project_id": 119, "chunk_id": 0, "prompt": {"main_file_path": "QuickShot-master/QuickShot-master/quickshot/src/main/java/io/github/muddz/quickshot/QuickShot.java", "main_file_content": "package io.github.muddz.quickshot; import android.content.ContentResolver; import android.content.ContentValues; import android.content.Context; import android.graphics.Bitmap; import android.graphics.Canvas; import android.media.MediaScannerConnection; import android.net.Uri; import android.os.AsyncTask; import android.os.Build; import android.os.Environment; import android.os.Handler; import android.os.Looper; import android.provider.MediaStore; import android.util.Log; import android.view.SurfaceView; import android.view.TextureView; import android.view.View; import androidx.annotation.NonNull; import androidx.annotation.RequiresApi; import java.io.BufferedOutputStream; import java.io.File; import java.io.FileOutputStream; import java.io.OutputStream; import java.lang.ref.WeakReference; import static android.os.Environment.DIRECTORY_PICTURES; public class QuickShot { private static final String EXTENSION_JPG = \".jpg\"; private static final String EXTENSION_PNG = \".png\"; private static final String EXTENSION_NOMEDIA = \".nomedia\"; private static final int JPG_MAX_QUALITY = 100; private boolean printStackTrace; private int jpgQuality = JPG_MAX_QUALITY; private String fileExtension = EXTENSION_JPG; private String filename = String.valueOf(System.currentTimeMillis()); private String path; private Bitmap bitmap; private View view; private Context context; private QuickShotListener listener; private QuickShot(@NonNull View view) { this.view = view; this.context = view.getContext(); } private QuickShot(@NonNull Bitmap bitmap, @NonNull Context context) { this.bitmap = bitmap; this.context = context; } public static QuickShot of(@NonNull View view) { return new QuickShot(view); } public static QuickShot of(@NonNull Bitmap bitmap, @NonNull Context context) { return new QuickShot(bitmap, context); } public QuickShot setFilename(String filename) { this.filename = filename; return this; } public QuickShot setPath(String path) { this.path = path; return this; } private void setFileExtension(String fileExtension) { this.fileExtension = fileExtension; } public QuickShot toJPG() { jpgQuality = JPG_MAX_QUALITY; setFileExtension(EXTENSION_JPG); return this; } public QuickShot toJPG(int jpgQuality) { this.jpgQuality = jpgQuality; setFileExtension(EXTENSION_JPG); return this; } public QuickShot toPNG() { setFileExtension(EXTENSION_PNG); return this; } public QuickShot toNomedia() { setFileExtension(EXTENSION_NOMEDIA); return this; } public QuickShot enableLogging() { printStackTrace = true; return this; } public QuickShot setResultListener(@NonNull QuickShotListener listener) { this.listener = listener; if (listener == null) { throw new NullPointerException(\"QuickShot.setResultListener() was provided with a null object reference\"); } return this; } private Context getContext() { if (context == null) { throw new NullPointerException(\"Attempt to save the picture failed: View or Context was null\"); } return context; } private Bitmap getBitmap() { if (bitmap != null) { return bitmap; } else if (view instanceof TextureView) { bitmap = ((TextureView) view).getBitmap(); Canvas canvas = new Canvas(bitmap); view.draw(canvas); canvas.setBitmap(null); return bitmap; } else { bitmap = Bitmap.createBitmap(view.getWidth(), view.getHeight(), Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bitmap); view.draw(canvas); canvas.setBitmap(null); return bitmap; } } public void save() throws NullPointerException { if (view instanceof SurfaceView) { PixelCopyHelper.getSurfaceBitmap((SurfaceView) view, new PixelCopyHelper.PixelCopyListener() { @Override public void onSurfaceBitmapReady(Bitmap surfaceBitmap) { new BitmapSaver(getContext(), surfaceBitmap, printStackTrace, path, filename, fileExtension, jpgQuality, listener).execute(); } @Override public void onSurfaceBitmapError(String errorMsg) { listener.onQuickShotFailed(path, errorMsg); } }); } else { new BitmapSaver(getContext(), getBitmap(), printStackTrace, path, filename, fileExtension, jpgQuality, listener).execute(); } } public interface QuickShotListener { void onQuickShotSuccess(String path); void onQuickShotFailed(String path, String errorMsg); } static class BitmapSaver extends AsyncTask<Void, Void, Void> { private final WeakReference<Context> weakContext; private Handler mainThreadHandler = new Handler(Looper.getMainLooper()); private boolean printStacktrace; private int jpgQuality; private String errorMsg; private String path; private String filename; private String fileExtension; private Bitmap bitmap; private File file; private QuickShotListener listener; BitmapSaver(Context context, Bitmap bitmap, boolean printStacktrace, String path, String filename, String fileExtension, int jpgQuality, QuickShotListener listener) { this.weakContext = new WeakReference<>(context); this.bitmap = bitmap; this.printStacktrace = printStacktrace; this.path = path; this.filename = filename; this.fileExtension = fileExtension; this.jpgQuality = jpgQuality; this.listener = listener; } private void saveLegacy() { if (path == null) { path = Environment.getExternalStorageDirectory() + File.separator + DIRECTORY_PICTURES; } File directory = new File(path); directory.mkdirs(); file = new File(directory, filename + fileExtension); try (OutputStream out = new BufferedOutputStream(new FileOutputStream(file))) { switch (fileExtension) { case EXTENSION_JPG: bitmap.compress(Bitmap.CompressFormat.JPEG, jpgQuality, out); break; case EXTENSION_PNG: bitmap.compress(Bitmap.CompressFormat.PNG, 0, out); break; } } catch (Exception e) { if (printStacktrace) { e.printStackTrace(); } errorMsg = e.toString(); cancel(true); } finally { bitmap = null; } } @RequiresApi(Build.VERSION_CODES.Q) private void saveScopedStorage() { path = path != null ? (DIRECTORY_PICTURES + File.separator + path) : DIRECTORY_PICTURES; ContentValues contentValues = new ContentValues(); contentValues.put(MediaStore.MediaColumns.DISPLAY_NAME, filename); contentValues.put(MediaStore.MediaColumns.RELATIVE_PATH, path); contentValues.put(MediaStore.MediaColumns.MIME_TYPE, QuickShotUtils.getMimeType(fileExtension)); ContentResolver resolver = weakContext.get().getContentResolver(); Uri imageUri = resolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, contentValues); if (imageUri == null) { errorMsg = String.format(\"Couldn't insert ContentValues with data: [%s] into the ContentResolver\", contentValues.toString()); cancel(true); return; } try (OutputStream out = resolver.openOutputStream(imageUri)) { switch (fileExtension) { case EXTENSION_JPG: bitmap.compress(Bitmap.CompressFormat.JPEG, jpgQuality, out); break; case EXTENSION_PNG: bitmap.compress(Bitmap.CompressFormat.PNG, 0, out); break; } file = new File(path, filename + fileExtension); } catch (Exception e) { if (printStacktrace) { e.printStackTrace(); } errorMsg = e.toString(); resolver.delete(imageUri, null, null); cancel(true); } finally { bitmap = null; } } @Override protected Void doInBackground(Void... voids) { if (QuickShotUtils.isAboveAPI29()) { saveScopedStorage(); } else { saveLegacy(); } return null; } @Override protected void onPostExecute(Void v) { listener.onQuickShotSuccess(file.getAbsolutePath()); if (!QuickShotUtils.isAboveAPI29()) { MediaScannerConnection.scanFile(weakContext.get(), new String[]{file.getAbsolutePath()}, null, null); } } @Override protected void onCancelled() { mainThreadHandler.post(new Runnable() { @Override public void run() { listener.onQuickShotFailed(file.getAbsolutePath(), errorMsg); } }); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "QuickShot-master/QuickShot-master/quickshot/src/main/java/io/github/muddz/quickshot/QuickShot.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "QuickShot handles capturing bitmaps, configuration (filename, path, format), and saving logic. BitmapSaver handles both legacy and scoped storage saving, combining multiple responsibilities."}, {"principle": "Open-Closed", "justification": "BitmapSaver's saveLegacy and saveScopedStorage methods require modifying the class to add new storage mechanisms instead of extending via abstractions."}, {"principle": "Interface Segregation", "justification": "QuickShotListener forces clients to implement both success and failure methods even if they only need one, violating ISP by requiring unused method implementations."}, {"principle": "Dependency Inversion", "justification": "QuickShot directly depends on the concrete BitmapSaver class instead of an abstraction. High-level modules should depend on interfaces, not low-level implementations."}]}]}
{"project_id": 119, "chunk_id": 0, "prompt": {"main_file_path": "QuickShot-master/QuickShot-master/quickshot/src/androidTest/java/io/github/muddz/quickshot/QuickShotTest.java", "main_file_content": "package io.github.muddz.quickshot; import static android.view.View.MeasureSpec.EXACTLY; import android.content.Context; import android.graphics.Color; import android.view.View; import androidx.test.InstrumentationRegistry; import androidx.test.runner.AndroidJUnit4; import org.junit.Assert; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import java.io.File; @RunWith(AndroidJUnit4.class) public class QuickShotTest { private Context context; private View testView; @Before public void setup() { testView = generateTestView(); context = androidx.test.platform.app.InstrumentationRegistry.getInstrumentation().getContext(); } @Test public void testCallbackPathNotNull() { QuickShot.of(testView).setResultListener(new QuickShot.QuickShotListener() { @Override public void onQuickShotSuccess(String path) { Assert.assertNotNull(path); } @Override public void onQuickShotFailed(String path, String errorMsg) { } }).save(); sleepThread(); } @Test public void testIfSavedInJPG() { QuickShot.of(testView).setResultListener(new QuickShot.QuickShotListener() { @Override public void onQuickShotSuccess(String path) { Assert.assertTrue(path.contains(\".jpg\")); } @Override public void onQuickShotFailed(String path, String errorMsg) { } }).save(); sleepThread(); } @Test public void testIfSavedInPNG() { QuickShot.of(testView).toPNG().setResultListener(new QuickShot.QuickShotListener() { @Override public void onQuickShotSuccess(String path) { Assert.assertTrue(path.contains(\".png\")); } @Override public void onQuickShotFailed(String path, String errorMsg) { } }).save(); sleepThread(); } @Test public void testIfSavedInNomedia() { QuickShot.of(testView).toNomedia().setResultListener(new QuickShot.QuickShotListener() { @Override public void onQuickShotSuccess(String path) { Assert.assertTrue(path.contains(\".nomedia\")); } @Override public void onQuickShotFailed(String path, String errorMsg) { } }).save(); sleepThread(); } @Test public void testIfDirectoryWasCreated() { QuickShot.of(testView).setPath(\"QuickShotTestDirectory\").setResultListener(new QuickShot.QuickShotListener() { @Override public void onQuickShotSuccess(String path) { if (QuickShotUtils.isAboveAPI29()) { Assert.assertTrue(path.contains(\"QuickShotTestDirectory\")); } else { File file = new File(path); File directory = new File(file.getParent()); boolean isDirectory = directory.exists() && directory.isDirectory(); Assert.assertTrue(isDirectory); } } @Override public void onQuickShotFailed(String path, String errorMsg) { } }).save(); sleepThread(); } @Test public void testIfFileExist() { QuickShot.of(testView).setPath(\"QuickShotTestDirectory\").setResultListener(new QuickShot.QuickShotListener() { @Override public void onQuickShotSuccess(String path) { if (QuickShotUtils.isAboveAPI29()) { Assert.assertTrue(path != null && path.length() > 0); } else { File file = new File(path); Assert.assertTrue(file.exists()); } } @Override public void onQuickShotFailed(String path, String errorMsg) { } }).save(); sleepThread(); } private View generateTestView() { int width = 950; int height = 950; int widthMS = View.MeasureSpec.makeMeasureSpec(width, EXACTLY); int heightMS = View.MeasureSpec.makeMeasureSpec(height, EXACTLY); View view = new View(InstrumentationRegistry.getTargetContext()); view.measure(widthMS, heightMS); view.layout(0, 0, view.getMeasuredWidth(), view.getMeasuredHeight()); view.setBackgroundColor(Color.GRAY); return view; } private void sleepThread() { try { Thread.sleep(1500); } catch (InterruptedException e) { e.printStackTrace(); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "QuickShot-master/QuickShot-master/quickshot/src/androidTest/java/io/github/muddz/quickshot/QuickShotTest.java", "violatedPrinciples": [{"principle": "Interface Segregation", "justification": "QuickShot.QuickShotListener interface forces clients to implement onQuickShotFailed even when they only care about onQuickShotSuccess (and vice versa). Tests implement empty methods for unused callbacks, violating ISP."}]}]}
{"project_id": 119, "chunk_id": 0, "prompt": {"main_file_path": "QuickShot-master/QuickShot-master/demo/src/main/java/io/github/muddz/quickshot/demo/MainActivity.java", "main_file_content": "package io.github.muddz.quickshot.demo; import android.Manifest; import android.os.Bundle; import android.view.Menu; import android.view.MenuItem; import android.view.View; import android.widget.Toast; import androidx.appcompat.app.AppCompatActivity; import androidx.appcompat.widget.Toolbar; import androidx.core.app.ActivityCompat; import androidx.core.content.ContextCompat; import androidx.core.content.PermissionChecker; import com.google.android.material.tabs.TabLayout; import io.github.muddz.quickshot.QuickShot; import io.github.muddz.quickshot.demo.fragments.BaseFragment; public class MainActivity extends AppCompatActivity implements QuickShot.QuickShotListener { private NonSwipeViewPager viewPager; private ViewPagerAdapter viewPagerAdapter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); askPermissions(); setupToolbar(); setupViewPager(); } private void setupToolbar() { Toolbar toolbar = findViewById(R.id.toolbar); toolbar.setOverflowIcon(ContextCompat.getDrawable(this, R.drawable.ic_save_black_24dp)); setSupportActionBar(toolbar); } private void setupViewPager() { viewPager = findViewById(R.id.viewpager); viewPagerAdapter = new ViewPagerAdapter(getSupportFragmentManager()); viewPager.setAdapter(viewPagerAdapter); viewPager.setOffscreenPageLimit(0); TabLayout tabLayout = findViewById(R.id.tablayout); tabLayout.setupWithViewPager(viewPager); } @Override public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.menu_toolbar, menu); return true; } @Override public boolean onOptionsItemSelected(MenuItem item) { switch (item.getItemId()) { case R.id.menu_jpg: QuickShot.of(getTargetView()).setFilename(\"QuickShotJPG\").setResultListener(this).toJPG().save(); break; case R.id.menu_pgn: QuickShot.of(getTargetView()).setResultListener(this).toPNG().enableLogging().save(); break; case R.id.menu_nomedia: QuickShot.of(getTargetView()).setResultListener(this).toNomedia().save(); break; } return true; } private View getTargetView() { int currentItem = viewPager.getCurrentItem(); BaseFragment fragment = (BaseFragment) viewPagerAdapter.getItem(currentItem); return fragment.getTargetView(); } @Override public void onQuickShotSuccess(String path) { Toast.makeText(this, \"Image saved at: \" + path, Toast.LENGTH_LONG).show(); } @Override public void onQuickShotFailed(String path, String errorMsg) { Toast.makeText(this, errorMsg, Toast.LENGTH_LONG).show(); } private void askPermissions() { int requestCode = 232; String[] permissions = {Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.CAMERA}; for (String permission : permissions) { if (ContextCompat.checkSelfPermission(this, permission) != PermissionChecker.PERMISSION_GRANTED) { ActivityCompat.requestPermissions(this, permissions, requestCode); } } } }", "dependencies": [{"file_path": "QuickShot-master/QuickShot-master/quickshot/src/main/java/io/github/muddz/quickshot/QuickShot.java", "file_content": "package io.github.muddz.quickshot; import android.content.ContentResolver; import android.content.ContentValues; import android.content.Context; import android.graphics.Bitmap; import android.graphics.Canvas; import android.media.MediaScannerConnection; import android.net.Uri; import android.os.AsyncTask; import android.os.Build; import android.os.Environment; import android.os.Handler; import android.os.Looper; import android.provider.MediaStore; import android.util.Log; import android.view.SurfaceView; import android.view.TextureView; import android.view.View; import androidx.annotation.NonNull; import androidx.annotation.RequiresApi; import java.io.BufferedOutputStream; import java.io.File; import java.io.FileOutputStream; import java.io.OutputStream; import java.lang.ref.WeakReference; import static android.os.Environment.DIRECTORY_PICTURES; public class QuickShot { private static final String EXTENSION_JPG = \".jpg\"; private static final String EXTENSION_PNG = \".png\"; private static final String EXTENSION_NOMEDIA = \".nomedia\"; private static final int JPG_MAX_QUALITY = 100; private boolean printStackTrace; private int jpgQuality = JPG_MAX_QUALITY; private String fileExtension = EXTENSION_JPG; private String filename = String.valueOf(System.currentTimeMillis()); private String path; private Bitmap bitmap; private View view; private Context context; private QuickShotListener listener; private QuickShot(@NonNull View view) { this.view = view; this.context = view.getContext(); } private QuickShot(@NonNull Bitmap bitmap, @NonNull Context context) { this.bitmap = bitmap; this.context = context; } public static QuickShot of(@NonNull View view) { return new QuickShot(view); } public static QuickShot of(@NonNull Bitmap bitmap, @NonNull Context context) { return new QuickShot(bitmap, context); } public QuickShot setFilename(String filename) { this.filename = filename; return this; } public QuickShot setPath(String path) { this.path = path; return this; } private void setFileExtension(String fileExtension) { this.fileExtension = fileExtension; } public QuickShot toJPG() { jpgQuality = JPG_MAX_QUALITY; setFileExtension(EXTENSION_JPG); return this; } public QuickShot toJPG(int jpgQuality) { this.jpgQuality = jpgQuality; setFileExtension(EXTENSION_JPG); return this; } public QuickShot toPNG() { setFileExtension(EXTENSION_PNG); return this; } public QuickShot toNomedia() { setFileExtension(EXTENSION_NOMEDIA); return this; } public QuickShot enableLogging() { printStackTrace = true; return this; } public QuickShot setResultListener(@NonNull QuickShotListener listener) { this.listener = listener; if (listener == null) { throw new NullPointerException(\"QuickShot.setResultListener() was provided with a null object reference\"); } return this; } private Context getContext() { if (context == null) { throw new NullPointerException(\"Attempt to save the picture failed: View or Context was null\"); } return context; } private Bitmap getBitmap() { if (bitmap != null) { return bitmap; } else if (view instanceof TextureView) { bitmap = ((TextureView) view).getBitmap(); Canvas canvas = new Canvas(bitmap); view.draw(canvas); canvas.setBitmap(null); return bitmap; } else { bitmap = Bitmap.createBitmap(view.getWidth(), view.getHeight(), Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bitmap); view.draw(canvas); canvas.setBitmap(null); return bitmap; } } public void save() throws NullPointerException { if (view instanceof SurfaceView) { PixelCopyHelper.getSurfaceBitmap((SurfaceView) view, new PixelCopyHelper.PixelCopyListener() { @Override public void onSurfaceBitmapReady(Bitmap surfaceBitmap) { new BitmapSaver(getContext(), surfaceBitmap, printStackTrace, path, filename, fileExtension, jpgQuality, listener).execute(); } @Override public void onSurfaceBitmapError(String errorMsg) { listener.onQuickShotFailed(path, errorMsg); } }); } else { new BitmapSaver(getContext(), getBitmap(), printStackTrace, path, filename, fileExtension, jpgQuality, listener).execute(); } } public interface QuickShotListener { void onQuickShotSuccess(String path); void onQuickShotFailed(String path, String errorMsg); } static class BitmapSaver extends AsyncTask<Void, Void, Void> { private final WeakReference<Context> weakContext; private Handler mainThreadHandler = new Handler(Looper.getMainLooper()); private boolean printStacktrace; private int jpgQuality; private String errorMsg; private String path; private String filename; private String fileExtension; private Bitmap bitmap; private File file; private QuickShotListener listener; BitmapSaver(Context context, Bitmap bitmap, boolean printStacktrace, String path, String filename, String fileExtension, int jpgQuality, QuickShotListener listener) { this.weakContext = new WeakReference<>(context); this.bitmap = bitmap; this.printStacktrace = printStacktrace; this.path = path; this.filename = filename; this.fileExtension = fileExtension; this.jpgQuality = jpgQuality; this.listener = listener; } private void saveLegacy() { if (path == null) { path = Environment.getExternalStorageDirectory() + File.separator + DIRECTORY_PICTURES; } File directory = new File(path); directory.mkdirs(); file = new File(directory, filename + fileExtension); try (OutputStream out = new BufferedOutputStream(new FileOutputStream(file))) { switch (fileExtension) { case EXTENSION_JPG: bitmap.compress(Bitmap.CompressFormat.JPEG, jpgQuality, out); break; case EXTENSION_PNG: bitmap.compress(Bitmap.CompressFormat.PNG, 0, out); break; } } catch (Exception e) { if (printStacktrace) { e.printStackTrace(); } errorMsg = e.toString(); cancel(true); } finally { bitmap = null; } } @RequiresApi(Build.VERSION_CODES.Q) private void saveScopedStorage() { path = path != null ? (DIRECTORY_PICTURES + File.separator + path) : DIRECTORY_PICTURES; ContentValues contentValues = new ContentValues(); contentValues.put(MediaStore.MediaColumns.DISPLAY_NAME, filename); contentValues.put(MediaStore.MediaColumns.RELATIVE_PATH, path); contentValues.put(MediaStore.MediaColumns.MIME_TYPE, QuickShotUtils.getMimeType(fileExtension)); ContentResolver resolver = weakContext.get().getContentResolver(); Uri imageUri = resolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, contentValues); if (imageUri == null) { errorMsg = String.format(\"Couldn't insert ContentValues with data: [%s] into the ContentResolver\", contentValues.toString()); cancel(true); return; } try (OutputStream out = resolver.openOutputStream(imageUri)) { switch (fileExtension) { case EXTENSION_JPG: bitmap.compress(Bitmap.CompressFormat.JPEG, jpgQuality, out); break; case EXTENSION_PNG: bitmap.compress(Bitmap.CompressFormat.PNG, 0, out); break; } file = new File(path, filename + fileExtension); } catch (Exception e) { if (printStacktrace) { e.printStackTrace(); } errorMsg = e.toString(); resolver.delete(imageUri, null, null); cancel(true); } finally { bitmap = null; } } @Override protected Void doInBackground(Void... voids) { if (QuickShotUtils.isAboveAPI29()) { saveScopedStorage(); } else { saveLegacy(); } return null; } @Override protected void onPostExecute(Void v) { listener.onQuickShotSuccess(file.getAbsolutePath()); if (!QuickShotUtils.isAboveAPI29()) { MediaScannerConnection.scanFile(weakContext.get(), new String[]{file.getAbsolutePath()}, null, null); } } @Override protected void onCancelled() { mainThreadHandler.post(new Runnable() { @Override public void run() { listener.onQuickShotFailed(file.getAbsolutePath(), errorMsg); } }); } } }"}, {"file_path": "QuickShot-master/QuickShot-master/demo/src/main/java/io/github/muddz/quickshot/demo/fragments/BaseFragment.java", "file_content": "package io.github.muddz.quickshot.demo.fragments; import android.view.View; import androidx.fragment.app.Fragment; public abstract class BaseFragment extends Fragment { public abstract View getTargetView(); }"}, {"file_path": "QuickShot-master/QuickShot-master/demo/src/main/java/io/github/muddz/quickshot/demo/ViewPagerAdapter.java", "file_content": "package io.github.muddz.quickshot.demo; import androidx.annotation.NonNull; import androidx.fragment.app.Fragment; import androidx.fragment.app.FragmentManager; import androidx.fragment.app.FragmentPagerAdapter; import io.github.muddz.quickshot.demo.fragments.SurfaceViewFragment; import io.github.muddz.quickshot.demo.fragments.TextureViewFragment; import io.github.muddz.quickshot.demo.fragments.ViewFragment; public class ViewPagerAdapter extends FragmentPagerAdapter { private String[] titles = {\"View\", \"SurfaceView\", \"TextureView\"}; private Fragment[] fragments = {new ViewFragment(), new SurfaceViewFragment(), new TextureViewFragment()}; public ViewPagerAdapter(FragmentManager fm) { super(fm); } @Override public CharSequence getPageTitle(int position) { return titles[position]; } @NonNull @Override public Fragment getItem(int position) { return fragments[position]; } @Override public int getCount() { return fragments.length; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "QuickShot-master/QuickShot-master/demo/src/main/java/io/github/muddz/quickshot/demo/MainActivity.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "MainActivity handles UI setup, permissions, image capture logic, and Toast notifications. Multiple responsibilities increase reasons for change."}, {"principle": "Dependency Inversion", "justification": "Directly instantiates QuickShot (concrete implementation) in menu handlers without depending on abstractions for image capture functionality."}]}, {"file_path": "QuickShot-master/QuickShot-master/quickshot/src/main/java/io/github/muddz/quickshot/QuickShot.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "BitmapSaver's saveLegacy/saveScopedStorage methods require modification when adding new storage strategies. No extension mechanism for new formats."}, {"principle": "Interface Segregation", "justification": "QuickShotListener forces implementers to handle both success and failure cases even if they only care about one outcome."}]}, {"file_path": "QuickShot-master/QuickShot-master/demo/src/main/java/io/github/muddz/quickshot/demo/ViewPagerAdapter.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "Directly instantiates concrete Fragment implementations (ViewFragment, SurfaceViewFragment) instead of depending on abstractions."}]}]}
{"project_id": 119, "chunk_id": 0, "prompt": {"main_file_path": "QuickShot-master/QuickShot-master/demo/src/main/java/io/github/muddz/quickshot/demo/ViewPagerAdapter.java", "main_file_content": "package io.github.muddz.quickshot.demo; import androidx.annotation.NonNull; import androidx.fragment.app.Fragment; import androidx.fragment.app.FragmentManager; import androidx.fragment.app.FragmentPagerAdapter; import io.github.muddz.quickshot.demo.fragments.SurfaceViewFragment; import io.github.muddz.quickshot.demo.fragments.TextureViewFragment; import io.github.muddz.quickshot.demo.fragments.ViewFragment; public class ViewPagerAdapter extends FragmentPagerAdapter { private String[] titles = {\"View\", \"SurfaceView\", \"TextureView\"}; private Fragment[] fragments = {new ViewFragment(), new SurfaceViewFragment(), new TextureViewFragment()}; public ViewPagerAdapter(FragmentManager fm) { super(fm); } @Override public CharSequence getPageTitle(int position) { return titles[position]; } @NonNull @Override public Fragment getItem(int position) { return fragments[position]; } @Override public int getCount() { return fragments.length; } }", "dependencies": [{"file_path": "QuickShot-master/QuickShot-master/demo/src/main/java/io/github/muddz/quickshot/demo/fragments/SurfaceViewFragment.java", "file_content": "package io.github.muddz.quickshot.demo.fragments; import android.media.MediaPlayer; import android.net.Uri; import android.os.Bundle; import android.view.LayoutInflater; import android.view.SurfaceHolder; import android.view.SurfaceView; import android.view.View; import android.view.ViewGroup; import androidx.annotation.NonNull; import androidx.annotation.Nullable; import io.github.muddz.quickshot.demo.R; public class SurfaceViewFragment extends BaseFragment implements SurfaceHolder.Callback { private SurfaceView surfaceView; private MediaPlayer mediaPlayer; @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View v = inflater.inflate(R.layout.surface_fragment, container, false); surfaceView = v.findViewById(R.id.surfaceview); surfaceView.getHolder().addCallback(this); Uri uri = Uri.parse(\"android.resource: mediaPlayer = MediaPlayer.create(getContext(), uri); return v; } @Override public View getTargetView() { return surfaceView; } @Override public void surfaceCreated(SurfaceHolder holder) { mediaPlayer.setSurface(holder.getSurface()); mediaPlayer.setLooping(true); mediaPlayer.start(); } @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) { } @Override public void surfaceDestroyed(SurfaceHolder holder) { } }"}, {"file_path": "QuickShot-master/QuickShot-master/demo/src/main/java/io/github/muddz/quickshot/demo/fragments/TextureViewFragment.java", "file_content": "package io.github.muddz.quickshot.demo.fragments; import android.graphics.SurfaceTexture; import android.hardware.Camera; import android.os.Bundle; import android.view.LayoutInflater; import android.view.TextureView; import android.view.View; import android.view.ViewGroup; import androidx.annotation.NonNull; import androidx.annotation.Nullable; import java.io.IOException; import java.util.List; import io.github.muddz.quickshot.demo.R; public class TextureViewFragment extends BaseFragment implements TextureView.SurfaceTextureListener { private Camera camera; private TextureView textureView; @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View v = inflater.inflate(R.layout.texture_fragment, container, false); textureView = v.findViewById(R.id.textureview); textureView.setSurfaceTextureListener(this); return v; } @Override public View getTargetView() { return textureView; } @Override public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) { camera = Camera.open(); camera.setDisplayOrientation(90); Camera.Parameters parameters = camera.getParameters(); List<Camera.Size> previewSizes = parameters.getSupportedPreviewSizes(); Camera.Size cameraSize = getOptimalPreviewSize(previewSizes, width, height); if (isAutoFocusSupported(camera)) { parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE); } parameters.setPreviewSize(cameraSize.width, cameraSize.height); camera.setParameters(parameters); try { camera.setPreviewTexture(surface); camera.startPreview(); } catch (IOException e) { e.printStackTrace(); } } private boolean isAutoFocusSupported(Camera camera) { if (camera != null) { for (String supportedMode : camera.getParameters().getSupportedFocusModes()) { if (supportedMode.equals(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE)) { return true; } } } return false; } private Camera.Size getOptimalPreviewSize(List<Camera.Size> sizes, int w, int h) { final double ASPECT_TOLERANCE = 0.1; double targetRatio = (double) h / w; if (sizes == null) return null; Camera.Size optimalSize = null; double minDiff = Double.MAX_VALUE; for (Camera.Size size : sizes) { double ratio = (double) size.width / size.height; if (Math.abs(ratio - targetRatio) > ASPECT_TOLERANCE) continue; if (Math.abs(size.height - h) < minDiff) { optimalSize = size; minDiff = Math.abs(size.height - h); } } if (optimalSize == null) { minDiff = Double.MAX_VALUE; for (Camera.Size size : sizes) { if (Math.abs(size.height - h) < minDiff) { optimalSize = size; minDiff = Math.abs(size.height - h); } } } return optimalSize; } @Override public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) { camera.stopPreview(); camera.release(); return true; } @Override public void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width, int height) { } @Override public void onSurfaceTextureUpdated(SurfaceTexture surface) { } }"}, {"file_path": "QuickShot-master/QuickShot-master/demo/src/main/java/io/github/muddz/quickshot/demo/fragments/ViewFragment.java", "file_content": "package io.github.muddz.quickshot.demo.fragments; import android.os.Bundle; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.LinearLayout; import androidx.annotation.NonNull; import androidx.annotation.Nullable; import io.github.muddz.quickshot.demo.DrawingBoardView; import io.github.muddz.quickshot.demo.R; public class ViewFragment extends BaseFragment implements DrawingBoardView.OnDrawingListener { private DrawingBoardView drawingBoardView; private LinearLayout drawHint; @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View v = inflater.inflate(R.layout.view_fragment, container, false); drawingBoardView = v.findViewById(R.id.drawingview); drawingBoardView.setOnDrawingListener(this); drawHint = v.findViewById(R.id.drawhint); return v; } @Override public View getTargetView() { return drawingBoardView; } @Override public void onDrawingStarted() { drawHint.setVisibility(View.GONE); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "QuickShot-master/QuickShot-master/demo/src/main/java/io/github/muddz/quickshot/demo/ViewPagerAdapter.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "Adding new fragment types requires modifying the fragments array and titles array directly in ViewPagerAdapter, violating extension-through-inheritance/abstraction rather than modification."}, {"principle": "Dependency Inversion", "justification": "ViewPagerAdapter directly instantiates concrete Fragment implementations rather than depending on abstractions, creating tight coupling between high-level component and low-level fragments."}]}]}
{"project_id": 119, "chunk_id": 0, "prompt": {"main_file_path": "QuickShot-master/QuickShot-master/demo/src/main/java/io/github/muddz/quickshot/demo/DrawingBoardView.java", "main_file_content": "package io.github.muddz.quickshot.demo; import android.annotation.SuppressLint; import android.content.Context; import android.graphics.Canvas; import android.graphics.Color; import android.graphics.Paint; import android.graphics.Path; import android.util.AttributeSet; import android.util.TypedValue; import android.view.MotionEvent; import android.view.View; import androidx.annotation.Nullable; public class DrawingBoardView extends View { private OnDrawingListener listener; private Paint drawingPaint; private Path path = new Path(); public DrawingBoardView(Context context) { super(context); setup(); } public DrawingBoardView(Context context, @Nullable AttributeSet attrs) { super(context, attrs); setup(); } private void setup() { setFocusableInTouchMode(true); setFocusable(true); drawingPaint = new Paint(); drawingPaint.setColor(Color.BLACK); drawingPaint.setAntiAlias(true); drawingPaint.setStrokeWidth(convertToDP(5)); drawingPaint.setStyle(Paint.Style.STROKE); drawingPaint.setStrokeJoin(Paint.Join.ROUND); drawingPaint.setStrokeCap(Paint.Cap.ROUND); } @Override protected void onDraw(Canvas canvas) { canvas.drawPath(path, drawingPaint); } @SuppressLint(\"ClickableViewAccessibility\") @Override public boolean onTouchEvent(MotionEvent event) { float xTouchPos = event.getX(); float yTouchPos = event.getY(); switch (event.getAction()) { case MotionEvent.ACTION_DOWN: path.moveTo(xTouchPos, yTouchPos); path.lineTo(xTouchPos, yTouchPos); if (listener != null) { listener.onDrawingStarted(); } break; case MotionEvent.ACTION_MOVE: path.lineTo(xTouchPos, yTouchPos); break; default: return false; } postInvalidate(); return true; } public void setOnDrawingListener(OnDrawingListener listener) { this.listener = listener; } private float convertToDP(int value) { return TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, value, getResources().getDisplayMetrics()); } public interface OnDrawingListener { void onDrawingStarted(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "QuickShot-master/QuickShot-master/demo/src/main/java/io/github/muddz/quickshot/demo/DrawingBoardView.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "DrawingBoardView handles multiple responsibilities: managing touch input, drawing paths, converting DP units, and notifying listeners. Changes in touch handling, rendering, or unit conversion logic would require modifying the same class."}]}]}
{"project_id": 119, "chunk_id": 0, "prompt": {"main_file_path": "QuickShot-master/QuickShot-master/demo/src/main/java/io/github/muddz/quickshot/demo/NonSwipeViewPager.java", "main_file_content": "package io.github.muddz.quickshot.demo; import android.content.Context; import android.util.AttributeSet; import android.view.MotionEvent; import androidx.annotation.NonNull; import androidx.annotation.Nullable; import androidx.viewpager.widget.ViewPager; public class NonSwipeViewPager extends ViewPager { public NonSwipeViewPager(@NonNull Context context, @Nullable AttributeSet attrs) { super(context, attrs); } @Override public boolean onTouchEvent(MotionEvent ev) { return false; } @Override public boolean onInterceptTouchEvent(MotionEvent ev) { return false; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 119, "chunk_id": 0, "prompt": {"main_file_path": "QuickShot-master/QuickShot-master/demo/src/main/java/io/github/muddz/quickshot/demo/fragments/SurfaceViewFragment.java", "main_file_content": "package io.github.muddz.quickshot.demo.fragments; import android.media.MediaPlayer; import android.net.Uri; import android.os.Bundle; import android.view.LayoutInflater; import android.view.SurfaceHolder; import android.view.SurfaceView; import android.view.View; import android.view.ViewGroup; import androidx.annotation.NonNull; import androidx.annotation.Nullable; import io.github.muddz.quickshot.demo.R; public class SurfaceViewFragment extends BaseFragment implements SurfaceHolder.Callback { private SurfaceView surfaceView; private MediaPlayer mediaPlayer; @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View v = inflater.inflate(R.layout.surface_fragment, container, false); surfaceView = v.findViewById(R.id.surfaceview); surfaceView.getHolder().addCallback(this); Uri uri = Uri.parse(\"android.resource: mediaPlayer = MediaPlayer.create(getContext(), uri); return v; } @Override public View getTargetView() { return surfaceView; } @Override public void surfaceCreated(SurfaceHolder holder) { mediaPlayer.setSurface(holder.getSurface()); mediaPlayer.setLooping(true); mediaPlayer.start(); } @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) { } @Override public void surfaceDestroyed(SurfaceHolder holder) { } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "QuickShot-master/QuickShot-master/demo/src/main/java/io/github/muddz/quickshot/demo/fragments/SurfaceViewFragment.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "SurfaceViewFragment handles multiple responsibilities: managing UI components (SurfaceView), initializing MediaPlayer, and controlling media playback lifecycle. This combines view management and media control logic, giving multiple reasons to change."}]}]}
{"project_id": 119, "chunk_id": 0, "prompt": {"main_file_path": "QuickShot-master/QuickShot-master/demo/src/main/java/io/github/muddz/quickshot/demo/fragments/ViewFragment.java", "main_file_content": "package io.github.muddz.quickshot.demo.fragments; import android.os.Bundle; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.LinearLayout; import androidx.annotation.NonNull; import androidx.annotation.Nullable; import io.github.muddz.quickshot.demo.DrawingBoardView; import io.github.muddz.quickshot.demo.R; public class ViewFragment extends BaseFragment implements DrawingBoardView.OnDrawingListener { private DrawingBoardView drawingBoardView; private LinearLayout drawHint; @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View v = inflater.inflate(R.layout.view_fragment, container, false); drawingBoardView = v.findViewById(R.id.drawingview); drawingBoardView.setOnDrawingListener(this); drawHint = v.findViewById(R.id.drawhint); return v; } @Override public View getTargetView() { return drawingBoardView; } @Override public void onDrawingStarted() { drawHint.setVisibility(View.GONE); } }", "dependencies": [{"file_path": "QuickShot-master/QuickShot-master/demo/src/main/java/io/github/muddz/quickshot/demo/DrawingBoardView.java", "file_content": "package io.github.muddz.quickshot.demo; import android.annotation.SuppressLint; import android.content.Context; import android.graphics.Canvas; import android.graphics.Color; import android.graphics.Paint; import android.graphics.Path; import android.util.AttributeSet; import android.util.TypedValue; import android.view.MotionEvent; import android.view.View; import androidx.annotation.Nullable; public class DrawingBoardView extends View { private OnDrawingListener listener; private Paint drawingPaint; private Path path = new Path(); public DrawingBoardView(Context context) { super(context); setup(); } public DrawingBoardView(Context context, @Nullable AttributeSet attrs) { super(context, attrs); setup(); } private void setup() { setFocusableInTouchMode(true); setFocusable(true); drawingPaint = new Paint(); drawingPaint.setColor(Color.BLACK); drawingPaint.setAntiAlias(true); drawingPaint.setStrokeWidth(convertToDP(5)); drawingPaint.setStyle(Paint.Style.STROKE); drawingPaint.setStrokeJoin(Paint.Join.ROUND); drawingPaint.setStrokeCap(Paint.Cap.ROUND); } @Override protected void onDraw(Canvas canvas) { canvas.drawPath(path, drawingPaint); } @SuppressLint(\"ClickableViewAccessibility\") @Override public boolean onTouchEvent(MotionEvent event) { float xTouchPos = event.getX(); float yTouchPos = event.getY(); switch (event.getAction()) { case MotionEvent.ACTION_DOWN: path.moveTo(xTouchPos, yTouchPos); path.lineTo(xTouchPos, yTouchPos); if (listener != null) { listener.onDrawingStarted(); } break; case MotionEvent.ACTION_MOVE: path.lineTo(xTouchPos, yTouchPos); break; default: return false; } postInvalidate(); return true; } public void setOnDrawingListener(OnDrawingListener listener) { this.listener = listener; } private float convertToDP(int value) { return TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, value, getResources().getDisplayMetrics()); } public interface OnDrawingListener { void onDrawingStarted(); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "QuickShot-master/QuickShot-master/demo/src/main/java/io/github/muddz/quickshot/demo/fragments/ViewFragment.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "ViewFragment directly depends on concrete DrawingBoardView. High-level modules should depend on abstractions, not concrete implementations."}]}]}
{"project_id": 119, "chunk_id": 0, "prompt": {"main_file_path": "QuickShot-master/QuickShot-master/demo/src/main/java/io/github/muddz/quickshot/demo/fragments/BaseFragment.java", "main_file_content": "package io.github.muddz.quickshot.demo.fragments; import android.view.View; import androidx.fragment.app.Fragment; public abstract class BaseFragment extends Fragment { public abstract View getTargetView(); }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 119, "chunk_id": 0, "prompt": {"main_file_path": "QuickShot-master/QuickShot-master/demo/src/main/java/io/github/muddz/quickshot/demo/fragments/TextureViewFragment.java", "main_file_content": "package io.github.muddz.quickshot.demo.fragments; import android.graphics.SurfaceTexture; import android.hardware.Camera; import android.os.Bundle; import android.view.LayoutInflater; import android.view.TextureView; import android.view.View; import android.view.ViewGroup; import androidx.annotation.NonNull; import androidx.annotation.Nullable; import java.io.IOException; import java.util.List; import io.github.muddz.quickshot.demo.R; public class TextureViewFragment extends BaseFragment implements TextureView.SurfaceTextureListener { private Camera camera; private TextureView textureView; @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View v = inflater.inflate(R.layout.texture_fragment, container, false); textureView = v.findViewById(R.id.textureview); textureView.setSurfaceTextureListener(this); return v; } @Override public View getTargetView() { return textureView; } @Override public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) { camera = Camera.open(); camera.setDisplayOrientation(90); Camera.Parameters parameters = camera.getParameters(); List<Camera.Size> previewSizes = parameters.getSupportedPreviewSizes(); Camera.Size cameraSize = getOptimalPreviewSize(previewSizes, width, height); if (isAutoFocusSupported(camera)) { parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE); } parameters.setPreviewSize(cameraSize.width, cameraSize.height); camera.setParameters(parameters); try { camera.setPreviewTexture(surface); camera.startPreview(); } catch (IOException e) { e.printStackTrace(); } } private boolean isAutoFocusSupported(Camera camera) { if (camera != null) { for (String supportedMode : camera.getParameters().getSupportedFocusModes()) { if (supportedMode.equals(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE)) { return true; } } } return false; } private Camera.Size getOptimalPreviewSize(List<Camera.Size> sizes, int w, int h) { final double ASPECT_TOLERANCE = 0.1; double targetRatio = (double) h / w; if (sizes == null) return null; Camera.Size optimalSize = null; double minDiff = Double.MAX_VALUE; for (Camera.Size size : sizes) { double ratio = (double) size.width / size.height; if (Math.abs(ratio - targetRatio) > ASPECT_TOLERANCE) continue; if (Math.abs(size.height - h) < minDiff) { optimalSize = size; minDiff = Math.abs(size.height - h); } } if (optimalSize == null) { minDiff = Double.MAX_VALUE; for (Camera.Size size : sizes) { if (Math.abs(size.height - h) < minDiff) { optimalSize = size; minDiff = Math.abs(size.height - h); } } } return optimalSize; } @Override public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) { camera.stopPreview(); camera.release(); return true; } @Override public void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width, int height) { } @Override public void onSurfaceTextureUpdated(SurfaceTexture surface) { } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "QuickShot-master/QuickShot-master/demo/src/main/java/io/github/muddz/quickshot/demo/fragments/TextureViewFragment.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "TextureViewFragment manages both UI (TextureView) and camera operations (initialization, configuration, preview), violating SRP by handling multiple responsibilities."}, {"principle": "Interface Segregation", "justification": "Implements TextureView.SurfaceTextureListener but does not use onSurfaceTextureSizeChanged/Updated, forcing dependency on unused methods."}, {"principle": "Dependency Inversion", "justification": "High-level fragment directly depends on low-level Camera class instead of an abstraction, creating tight coupling."}]}]}
{"project_id": 122, "chunk_id": 0, "prompt": {"main_file_path": "Product360-main/Product360-main/src/main/java/com/jbk/Test.java", "main_file_content": "package com.jbk; import java.util.List; import java.util.Scanner; import com.jbk.entity.Product; import com.jbk.operation.Operation; import com.jbk.utility.UserData; public class Test { public static void main(String[] args) { Scanner sc = new Scanner(System.in); Operation operation = new Operation(); int choice; boolean wantToContinue = true; do { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") choice = sc.nextInt(); switch (choice) { case 0: { wantToContinue = false; break; } case 1: { Product product = UserData.getProductInfoFromUser(); String msg = operation.addProduct(product); soutl(\"\") break; } case 2: { soutl(\"\") int productId = sc.nextInt(); String msg = operation.deleteProduct(productId); soutl(\"\") break; } case 3: { soutl(\"\") int productId = sc.nextInt(); Object obj = operation.getProductById(productId); soutl(\"\") break; } case 4: { soutl(\"\") int id = sc.nextInt(); Product product = UserData.getProductInfoFromUser(); product.setProductId(id); String msg = operation.updateProduct(product); soutl(\"\") break; } case 5: { List<Product> allProducts = operation.getAllProducts(); if (!allProducts.isEmpty()) { for (Product product : allProducts) { soutl(\"\") } } else { soutl(\"\") } break; } case 6: { List<Product> allProducts = operation.getAllProductsByOrder(); if (!allProducts.isEmpty()) { for (Product product : allProducts) { soutl(\"\") } } else { soutl(\"\") } break; } case 7: { List<Product> allProducts = operation.getLimitedProduct(); if (!allProducts.isEmpty()) { for (Product product : allProducts) { soutl(\"\") } } else { soutl(\"\") } break; } case 8: { List<Product> allProducts = operation.getLimitedProductByOrder(); if (!allProducts.isEmpty()) { for (Product product : allProducts) { soutl(\"\") } } else { soutl(\"\") } break; } case 9: { sout(\"\") String name = sc.next(); List<Product> allProducts = operation.getProductByName(name); if (!allProducts.isEmpty()) { for (Product product : allProducts) { soutl(\"\") } } else { soutl(\"\") } break; } case 10: { sout(\"\") double price = sc.nextDouble(); List<Product> allProducts = operation.getProductWhosePriceIsGreaterThan(price); if (!allProducts.isEmpty()) { for (Product product : allProducts) { soutl(\"\") } } else { soutl(\"\") } break; } case 11: { long Count = operation.getproductCount(); soutl(\"\") break; } case 12: { double Count = operation.getMinPriceOfProduct(); soutl(\"\") break; } case 13: { double Count = operation.getMaxPriceOfProduct(); soutl(\"\") break; } case 14: { List<Product> list = operation.queryEx1(); if (!list.isEmpty()) { for (Product product : list) { soutl(\"\") } } else { soutl(\"\") } break; } case 15: { List<Object[]> list = operation.queryEx2(); if (!list.isEmpty()) { for (Object[] obj : list) { sout(\"\") sout(\"\") soutl(\"\") } } else { soutl(\"\") } break; } case 16: { List<Product> list = operation.queryEx3(); if (!list.isEmpty()) { for (Object obj : list) { soutl(\"\") } } else { soutl(\"\") } break; } case 17: { List<Product> list = operation.getproductInBetween(); if (!list.isEmpty()) { for (Object obj : list) { soutl(\"\") } } else { soutl(\"\") } break; } case 18: { soutl(\"\") String Pattern = sc.next(); List<Product> list = operation.getProductsByNamePattern(Pattern); if (!list.isEmpty()) { for (Object obj : list) { soutl(\"\") } } else { soutl(\"\") } break; } default: { soutl(\"\") break; } } } while (wantToContinue); { soutl(\"\") } } }", "dependencies": [{"file_path": "Product360-main/Product360-main/src/main/java/com/jbk/entity/Product.java", "file_content": "package com.jbk.entity; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.Table; @Entity @Table(name = \"product\") public class Product { @Id @GeneratedValue(strategy = GenerationType.AUTO) private int productId; private String productName; private int productQty; private double productPrice; private String mfgDate; private String expDate; public Product() { } public Product( String productName, int productQty, double productPrice, String mfgDate, String expDate) { super(); this.productName = productName; this.productQty = productQty; this.productPrice = productPrice; this.mfgDate = mfgDate; this.expDate = expDate; } public Product(int productId, String productName, int productQty, double productPrice, String mfgDate, String expDate) { super(); this.productId = productId; this.productName = productName; this.productQty = productQty; this.productPrice = productPrice; this.mfgDate = mfgDate; this.expDate = expDate; } public int getProductId() { return productId; } public void setProductId(int productId) { this.productId = productId; } public String getProductName() { return productName; } public void setProductName(String productName) { this.productName = productName; } public int getProductQty() { return productQty; } public void setProductQty(int productQty) { this.productQty = productQty; } public double getProductPrice() { return productPrice; } public void setProductPrice(double productPrice) { this.productPrice = productPrice; } public String getMfgDate() { return mfgDate; } public void setMfgDate(String mfgDate) { this.mfgDate = mfgDate; } public String getExpDate() { return expDate; } public void setExpDate(String expDate) { this.expDate = expDate; } @Override public String toString() { return \"Product [productId=\" + productId + \", productName=\" + productName + \", productQty=\" + productQty + \", productPrice=\" + productPrice + \", mfgDate=\" + mfgDate + \", expDate=\" + expDate + \"]\"; } }"}, {"file_path": "Product360-main/Product360-main/src/main/java/com/jbk/operation/Operation.java", "file_content": "package com.jbk.operation; import java.util.List; import org.hibernate.Criteria; import org.hibernate.Session; import org.hibernate.SessionFactory; import org.hibernate.criterion.Order; import org.hibernate.criterion.Projections; import org.hibernate.criterion.Restrictions; import org.hibernate.query.Query; import com.jbk.config.HibernateConfig; import com.jbk.entity.Product; public class Operation { SessionFactory sessionFactory = HibernateConfig.getSessionFactory(); public String addProduct(Product product) { try { Session session = sessionFactory.openSession(); Product dbProduct = session.get(Product.class, product.getProductId()); if (dbProduct == null) { session.save(product); session.beginTransaction().commit(); return \"Added Successfully\"; } else { return \"Product Already exists\"; } } catch (Exception e) { return \" Something Went Wrong\"; } } public String deleteProduct(int productId) { Session session = sessionFactory.openSession(); try { Product dbProduct = session.get(Product.class, productId); if (dbProduct != null) { session.delete(dbProduct); session.beginTransaction().commit(); return \"Product Deleted\"; } else { return \"Product Not exists to delete\"; } } catch (Exception e) { return \"Something Went Wrong\"; } } public Object getProductById(int productId) { Session session = sessionFactory.openSession(); try { Product dbProduct = session.get(Product.class, productId); if (dbProduct != null) { return dbProduct; } else { return \"Product Not exists\"; } } catch (Exception e) { return \"Something Went Wrong\"; } } public String updateProduct(Product product) { try { Session session = sessionFactory.openSession(); Product dbProduct = session.get(Product.class, product.getProductId()); if (dbProduct != null) { session.evict(dbProduct); session.update(product); session.beginTransaction().commit(); return \"Updated Successfully\"; } else { return \"Product Not exists to update\"; } } catch (Exception e) { return \"Something went wrong\"; } } public List<Product> getAllProducts() { Session session = sessionFactory.openSession(); List<Product> list = null; try { Criteria criteria = session.createCriteria(Product.class); list = criteria.list(); } catch (Exception e) { e.printStackTrace(); } return list; } public List<Product> getAllProductsByOrder() { Session session = sessionFactory.openSession(); List<Product> list = null; try { Criteria criteria = session.createCriteria(Product.class); criteria.addOrder(Order.asc(\"productName\")); list = criteria.list(); } catch (Exception e) { e.printStackTrace(); } return list; } public List<Product> getLimitedProduct() { Session session = sessionFactory.openSession(); List<Product> list = null; try { Criteria criteria = session.createCriteria(Product.class); criteria.setMaxResults(2); list = criteria.list(); } catch (Exception e) { e.printStackTrace(); } return list; } public List<Product> getLimitedProductByOrder() { Session session = sessionFactory.openSession(); List<Product> list = null; try { Criteria criteria = session.createCriteria(Product.class); criteria.setMaxResults(2); criteria.addOrder(Order.asc(\"productName\")); list = criteria.list(); } catch (Exception e) { e.printStackTrace(); } return list; } public List<Product> getProductByName(String name) { Session session = sessionFactory.openSession(); List<Product> list = null; try { Criteria criteria = session.createCriteria(Product.class); criteria.add(Restrictions.eq(\"productName\", name)); list = criteria.list(); } catch (Exception e) { e.printStackTrace(); } return list; } public List<Product> getProductWhosePriceIsGreaterThan(double price) { Session session = sessionFactory.openSession(); List<Product> list = null; try { Criteria criteria = session.createCriteria(Product.class); criteria.add(Restrictions.gt(\"productPrice\", price)); list = criteria.list(); } catch (Exception e) { e.printStackTrace(); } return list; } public long getproductCount() { Session session = sessionFactory.openSession(); long count = 0; try { Criteria criteria = session.createCriteria(Product.class); criteria.setProjection(Projections.rowCount()); List<Long> list = criteria.list(); if (!list.isEmpty()) { count = list.get(0); } } catch (Exception e) { } return count; } public Double getMinPriceOfProduct() { Session session = sessionFactory.openSession(); double count = 0; try { Criteria criteria = session.createCriteria(Product.class); criteria.setProjection(Projections.min(\"productPrice\")); List<Double> list = criteria.list(); if (!list.isEmpty()) { count = list.get(0); } } catch (Exception e) { } return count; } public Double getMaxPriceOfProduct() { Session session = sessionFactory.openSession(); double count = 0; try { Criteria criteria = session.createCriteria(Product.class); criteria.setProjection(Projections.max(\"productPrice\")); List<Double> list = criteria.list(); if (!list.isEmpty()) { count = list.get(0); } } catch (Exception e) { } return count; } public List<Product> getproductInBetween() { Session session = sessionFactory.openSession(); List<Product> list = null; try { Criteria criteria = session.createCriteria(Product.class); criteria.add(Restrictions.between(\"productId\", 1, 4)); list = criteria.list(); } catch (Exception e) { } return list; } public List<Product> queryEx1() { Session session = sessionFactory.openSession(); List<Product> list = null; try { String hql = \"FROM Product\"; Query query = session.createQuery(hql); list = query.list(); } catch (Exception e) { } return list; } public List<Object[]> queryEx2() { Session session = sessionFactory.openSession(); List<Object[]> list = null; try { String hql = \"SELECT productId,productName,productPrice FROM Product\"; Query query = session.createQuery(hql); list = query.list(); } catch (Exception e) { } return list; } public List<Product> queryEx3() { Session session = sessionFactory.openSession(); List<Product> list = null; try { String hql = \"FROM Product WHERE productName= :pname\"; Query query = session.createQuery(hql); query.setString(\"pname\", \"pen\"); list = query.list(); } catch (Exception e) { } return list; } public List<Product> getProductsByNamePattern(String namePattern) { Session session = sessionFactory.openSession(); try { String hql = \"FROM Product WHERE productName LIKE :namePattern\"; Query<Product> query = session.createQuery(hql, Product.class); query.setParameter(\"namePattern\", \"%\" + namePattern + \"%\"); return query.list(); } catch (Exception e) { e.printStackTrace(); return null; } } }"}, {"file_path": "Product360-main/Product360-main/src/main/java/com/jbk/utility/UserData.java", "file_content": "package com.jbk.utility; import java.util.Scanner; import com.jbk.entity.Product; public class UserData { public static Product getProductInfoFromUser() { Scanner sc = new Scanner(System.in); sout(\"\") String productName = sc.nextLine(); sout(\"\") int productQty = sc.nextInt(); sout(\"\") double productPrice = sc.nextDouble(); sout(\"\") String productMfgDate = sc.next(); sout(\"\") String productExpDate = sc.next(); Product product = new Product(productName, productQty, productPrice, productMfgDate, productExpDate); return product; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Product360-main/Product360-main/src/main/java/com/jbk/operation/Operation.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Operation class handles multiple responsibilities: CRUD operations, query execution, and criteria management. Changes in any of these areas require modifying the same class."}, {"principle": "Open-Closed", "justification": "Adding new query methods requires modifying the existing Operation class. No abstraction allows extending functionality without altering existing code."}, {"principle": "Dependency Inversion", "justification": "Operation directly depends on Hibernate's concrete classes (Session, SessionFactory). High-level modules should depend on abstractions, not low-level implementations."}]}, {"file_path": "Product360-main/Product360-main/src/main/java/com/jbk/Test.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "Test directly instantiates and depends on the concrete Operation class. High-level modules should depend on abstractions (interfaces) instead."}]}]}
{"project_id": 122, "chunk_id": 0, "prompt": {"main_file_path": "Product360-main/Product360-main/src/main/java/com/jbk/operation/Operation.java", "main_file_content": "package com.jbk.operation; import java.util.List; import org.hibernate.Criteria; import org.hibernate.Session; import org.hibernate.SessionFactory; import org.hibernate.criterion.Order; import org.hibernate.criterion.Projections; import org.hibernate.criterion.Restrictions; import org.hibernate.query.Query; import com.jbk.config.HibernateConfig; import com.jbk.entity.Product; public class Operation { SessionFactory sessionFactory = HibernateConfig.getSessionFactory(); public String addProduct(Product product) { try { Session session = sessionFactory.openSession(); Product dbProduct = session.get(Product.class, product.getProductId()); if (dbProduct == null) { session.save(product); session.beginTransaction().commit(); return \"Added Successfully\"; } else { return \"Product Already exists\"; } } catch (Exception e) { return \" Something Went Wrong\"; } } public String deleteProduct(int productId) { Session session = sessionFactory.openSession(); try { Product dbProduct = session.get(Product.class, productId); if (dbProduct != null) { session.delete(dbProduct); session.beginTransaction().commit(); return \"Product Deleted\"; } else { return \"Product Not exists to delete\"; } } catch (Exception e) { return \"Something Went Wrong\"; } } public Object getProductById(int productId) { Session session = sessionFactory.openSession(); try { Product dbProduct = session.get(Product.class, productId); if (dbProduct != null) { return dbProduct; } else { return \"Product Not exists\"; } } catch (Exception e) { return \"Something Went Wrong\"; } } public String updateProduct(Product product) { try { Session session = sessionFactory.openSession(); Product dbProduct = session.get(Product.class, product.getProductId()); if (dbProduct != null) { session.evict(dbProduct); session.update(product); session.beginTransaction().commit(); return \"Updated Successfully\"; } else { return \"Product Not exists to update\"; } } catch (Exception e) { return \"Something went wrong\"; } } public List<Product> getAllProducts() { Session session = sessionFactory.openSession(); List<Product> list = null; try { Criteria criteria = session.createCriteria(Product.class); list = criteria.list(); } catch (Exception e) { e.printStackTrace(); } return list; } public List<Product> getAllProductsByOrder() { Session session = sessionFactory.openSession(); List<Product> list = null; try { Criteria criteria = session.createCriteria(Product.class); criteria.addOrder(Order.asc(\"productName\")); list = criteria.list(); } catch (Exception e) { e.printStackTrace(); } return list; } public List<Product> getLimitedProduct() { Session session = sessionFactory.openSession(); List<Product> list = null; try { Criteria criteria = session.createCriteria(Product.class); criteria.setMaxResults(2); list = criteria.list(); } catch (Exception e) { e.printStackTrace(); } return list; } public List<Product> getLimitedProductByOrder() { Session session = sessionFactory.openSession(); List<Product> list = null; try { Criteria criteria = session.createCriteria(Product.class); criteria.setMaxResults(2); criteria.addOrder(Order.asc(\"productName\")); list = criteria.list(); } catch (Exception e) { e.printStackTrace(); } return list; } public List<Product> getProductByName(String name) { Session session = sessionFactory.openSession(); List<Product> list = null; try { Criteria criteria = session.createCriteria(Product.class); criteria.add(Restrictions.eq(\"productName\", name)); list = criteria.list(); } catch (Exception e) { e.printStackTrace(); } return list; } public List<Product> getProductWhosePriceIsGreaterThan(double price) { Session session = sessionFactory.openSession(); List<Product> list = null; try { Criteria criteria = session.createCriteria(Product.class); criteria.add(Restrictions.gt(\"productPrice\", price)); list = criteria.list(); } catch (Exception e) { e.printStackTrace(); } return list; } public long getproductCount() { Session session = sessionFactory.openSession(); long count = 0; try { Criteria criteria = session.createCriteria(Product.class); criteria.setProjection(Projections.rowCount()); List<Long> list = criteria.list(); if (!list.isEmpty()) { count = list.get(0); } } catch (Exception e) { } return count; } public Double getMinPriceOfProduct() { Session session = sessionFactory.openSession(); double count = 0; try { Criteria criteria = session.createCriteria(Product.class); criteria.setProjection(Projections.min(\"productPrice\")); List<Double> list = criteria.list(); if (!list.isEmpty()) { count = list.get(0); } } catch (Exception e) { } return count; } public Double getMaxPriceOfProduct() { Session session = sessionFactory.openSession(); double count = 0; try { Criteria criteria = session.createCriteria(Product.class); criteria.setProjection(Projections.max(\"productPrice\")); List<Double> list = criteria.list(); if (!list.isEmpty()) { count = list.get(0); } } catch (Exception e) { } return count; } public List<Product> getproductInBetween() { Session session = sessionFactory.openSession(); List<Product> list = null; try { Criteria criteria = session.createCriteria(Product.class); criteria.add(Restrictions.between(\"productId\", 1, 4)); list = criteria.list(); } catch (Exception e) { } return list; } public List<Product> queryEx1() { Session session = sessionFactory.openSession(); List<Product> list = null; try { String hql = \"FROM Product\"; Query query = session.createQuery(hql); list = query.list(); } catch (Exception e) { } return list; } public List<Object[]> queryEx2() { Session session = sessionFactory.openSession(); List<Object[]> list = null; try { String hql = \"SELECT productId,productName,productPrice FROM Product\"; Query query = session.createQuery(hql); list = query.list(); } catch (Exception e) { } return list; } public List<Product> queryEx3() { Session session = sessionFactory.openSession(); List<Product> list = null; try { String hql = \"FROM Product WHERE productName= :pname\"; Query query = session.createQuery(hql); query.setString(\"pname\", \"pen\"); list = query.list(); } catch (Exception e) { } return list; } public List<Product> getProductsByNamePattern(String namePattern) { Session session = sessionFactory.openSession(); try { String hql = \"FROM Product WHERE productName LIKE :namePattern\"; Query<Product> query = session.createQuery(hql, Product.class); query.setParameter(\"namePattern\", \"%\" + namePattern + \"%\"); return query.list(); } catch (Exception e) { e.printStackTrace(); return null; } } }", "dependencies": [{"file_path": "Product360-main/Product360-main/src/main/java/com/jbk/config/HibernateConfig.java", "file_content": "package com.jbk.config; import org.hibernate.SessionFactory; import org.hibernate.cfg.Configuration; import com.jbk.entity.Product; public class HibernateConfig { public static SessionFactory getSessionFactory() { Configuration cfg = new Configuration(); cfg.configure().addAnnotatedClass(Product.class); SessionFactory sessionFactory = cfg.buildSessionFactory(); return sessionFactory; } }"}, {"file_path": "Product360-main/Product360-main/src/main/java/com/jbk/entity/Product.java", "file_content": "package com.jbk.entity; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.Table; @Entity @Table(name = \"product\") public class Product { @Id @GeneratedValue(strategy = GenerationType.AUTO) private int productId; private String productName; private int productQty; private double productPrice; private String mfgDate; private String expDate; public Product() { } public Product( String productName, int productQty, double productPrice, String mfgDate, String expDate) { super(); this.productName = productName; this.productQty = productQty; this.productPrice = productPrice; this.mfgDate = mfgDate; this.expDate = expDate; } public Product(int productId, String productName, int productQty, double productPrice, String mfgDate, String expDate) { super(); this.productId = productId; this.productName = productName; this.productQty = productQty; this.productPrice = productPrice; this.mfgDate = mfgDate; this.expDate = expDate; } public int getProductId() { return productId; } public void setProductId(int productId) { this.productId = productId; } public String getProductName() { return productName; } public void setProductName(String productName) { this.productName = productName; } public int getProductQty() { return productQty; } public void setProductQty(int productQty) { this.productQty = productQty; } public double getProductPrice() { return productPrice; } public void setProductPrice(double productPrice) { this.productPrice = productPrice; } public String getMfgDate() { return mfgDate; } public void setMfgDate(String mfgDate) { this.mfgDate = mfgDate; } public String getExpDate() { return expDate; } public void setExpDate(String expDate) { this.expDate = expDate; } @Override public String toString() { return \"Product [productId=\" + productId + \", productName=\" + productName + \", productQty=\" + productQty + \", productPrice=\" + productPrice + \", mfgDate=\" + mfgDate + \", expDate=\" + expDate + \"]\"; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Product360-main/Product360-main/src/main/java/com/jbk/operation/Operation.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Operation class handles multiple responsibilities such as CRUD operations, query execution, and session management, which violates SRP as it has multiple reasons to change."}, {"principle": "Open-Closed", "justification": "Adding new query types or data access logic requires modifying the Operation class directly, violating OCP as it is not open for extension without modification."}, {"principle": "Dependency Inversion", "justification": "Operation directly depends on concrete Hibernate classes (SessionFactory, Session) and HibernateConfig instead of abstractions, violating DIP by tying high-level logic to low-level implementations."}]}]}
{"project_id": 122, "chunk_id": 0, "prompt": {"main_file_path": "Product360-main/Product360-main/src/main/java/com/jbk/config/HibernateConfig.java", "main_file_content": "package com.jbk.config; import org.hibernate.SessionFactory; import org.hibernate.cfg.Configuration; import com.jbk.entity.Product; public class HibernateConfig { public static SessionFactory getSessionFactory() { Configuration cfg = new Configuration(); cfg.configure().addAnnotatedClass(Product.class); SessionFactory sessionFactory = cfg.buildSessionFactory(); return sessionFactory; } }", "dependencies": [{"file_path": "Product360-main/Product360-main/src/main/java/com/jbk/entity/Product.java", "file_content": "package com.jbk.entity; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.Table; @Entity @Table(name = \"product\") public class Product { @Id @GeneratedValue(strategy = GenerationType.AUTO) private int productId; private String productName; private int productQty; private double productPrice; private String mfgDate; private String expDate; public Product() { } public Product( String productName, int productQty, double productPrice, String mfgDate, String expDate) { super(); this.productName = productName; this.productQty = productQty; this.productPrice = productPrice; this.mfgDate = mfgDate; this.expDate = expDate; } public Product(int productId, String productName, int productQty, double productPrice, String mfgDate, String expDate) { super(); this.productId = productId; this.productName = productName; this.productQty = productQty; this.productPrice = productPrice; this.mfgDate = mfgDate; this.expDate = expDate; } public int getProductId() { return productId; } public void setProductId(int productId) { this.productId = productId; } public String getProductName() { return productName; } public void setProductName(String productName) { this.productName = productName; } public int getProductQty() { return productQty; } public void setProductQty(int productQty) { this.productQty = productQty; } public double getProductPrice() { return productPrice; } public void setProductPrice(double productPrice) { this.productPrice = productPrice; } public String getMfgDate() { return mfgDate; } public void setMfgDate(String mfgDate) { this.mfgDate = mfgDate; } public String getExpDate() { return expDate; } public void setExpDate(String expDate) { this.expDate = expDate; } @Override public String toString() { return \"Product [productId=\" + productId + \", productName=\" + productName + \", productQty=\" + productQty + \", productPrice=\" + productPrice + \", mfgDate=\" + mfgDate + \", expDate=\" + expDate + \"]\"; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Product360-main/Product360-main/src/main/java/com/jbk/config/HibernateConfig.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "HibernateConfig violates OCP because adding a new entity class (beyond Product) requires modifying getSessionFactory() to call addAnnotatedClass again. The class is not closed for modification when configuration needs to change."}, {"principle": "Dependency Inversion", "justification": "HibernateConfig directly depends on concrete Hibernate classes (Configuration, SessionFactory) instead of abstractions. High-level configuration logic should depend on interfaces, not framework implementation details."}]}]}
{"project_id": 122, "chunk_id": 0, "prompt": {"main_file_path": "Product360-main/Product360-main/src/main/java/com/jbk/entity/Product.java", "main_file_content": "package com.jbk.entity; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.Table; @Entity @Table(name = \"product\") public class Product { @Id @GeneratedValue(strategy = GenerationType.AUTO) private int productId; private String productName; private int productQty; private double productPrice; private String mfgDate; private String expDate; public Product() { } public Product( String productName, int productQty, double productPrice, String mfgDate, String expDate) { super(); this.productName = productName; this.productQty = productQty; this.productPrice = productPrice; this.mfgDate = mfgDate; this.expDate = expDate; } public Product(int productId, String productName, int productQty, double productPrice, String mfgDate, String expDate) { super(); this.productId = productId; this.productName = productName; this.productQty = productQty; this.productPrice = productPrice; this.mfgDate = mfgDate; this.expDate = expDate; } public int getProductId() { return productId; } public void setProductId(int productId) { this.productId = productId; } public String getProductName() { return productName; } public void setProductName(String productName) { this.productName = productName; } public int getProductQty() { return productQty; } public void setProductQty(int productQty) { this.productQty = productQty; } public double getProductPrice() { return productPrice; } public void setProductPrice(double productPrice) { this.productPrice = productPrice; } public String getMfgDate() { return mfgDate; } public void setMfgDate(String mfgDate) { this.mfgDate = mfgDate; } public String getExpDate() { return expDate; } public void setExpDate(String expDate) { this.expDate = expDate; } @Override public String toString() { return \"Product [productId=\" + productId + \", productName=\" + productName + \", productQty=\" + productQty + \", productPrice=\" + productPrice + \", mfgDate=\" + mfgDate + \", expDate=\" + expDate + \"]\"; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 122, "chunk_id": 0, "prompt": {"main_file_path": "Product360-main/Product360-main/src/main/java/com/jbk/utility/UserData.java", "main_file_content": "package com.jbk.utility; import java.util.Scanner; import com.jbk.entity.Product; public class UserData { public static Product getProductInfoFromUser() { Scanner sc = new Scanner(System.in); sout(\"\") String productName = sc.nextLine(); sout(\"\") int productQty = sc.nextInt(); sout(\"\") double productPrice = sc.nextDouble(); sout(\"\") String productMfgDate = sc.next(); sout(\"\") String productExpDate = sc.next(); Product product = new Product(productName, productQty, productPrice, productMfgDate, productExpDate); return product; } }", "dependencies": [{"file_path": "Product360-main/Product360-main/src/main/java/com/jbk/entity/Product.java", "file_content": "package com.jbk.entity; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.Table; @Entity @Table(name = \"product\") public class Product { @Id @GeneratedValue(strategy = GenerationType.AUTO) private int productId; private String productName; private int productQty; private double productPrice; private String mfgDate; private String expDate; public Product() { } public Product( String productName, int productQty, double productPrice, String mfgDate, String expDate) { super(); this.productName = productName; this.productQty = productQty; this.productPrice = productPrice; this.mfgDate = mfgDate; this.expDate = expDate; } public Product(int productId, String productName, int productQty, double productPrice, String mfgDate, String expDate) { super(); this.productId = productId; this.productName = productName; this.productQty = productQty; this.productPrice = productPrice; this.mfgDate = mfgDate; this.expDate = expDate; } public int getProductId() { return productId; } public void setProductId(int productId) { this.productId = productId; } public String getProductName() { return productName; } public void setProductName(String productName) { this.productName = productName; } public int getProductQty() { return productQty; } public void setProductQty(int productQty) { this.productQty = productQty; } public double getProductPrice() { return productPrice; } public void setProductPrice(double productPrice) { this.productPrice = productPrice; } public String getMfgDate() { return mfgDate; } public void setMfgDate(String mfgDate) { this.mfgDate = mfgDate; } public String getExpDate() { return expDate; } public void setExpDate(String expDate) { this.expDate = expDate; } @Override public String toString() { return \"Product [productId=\" + productId + \", productName=\" + productName + \", productQty=\" + productQty + \", productPrice=\" + productPrice + \", mfgDate=\" + mfgDate + \", expDate=\" + expDate + \"]\"; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Product360-main/Product360-main/src/main/java/com/jbk/utility/UserData.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "UserData handles user input, prompts, and Product object creation. These are multiple responsibilities within a single class."}, {"principle": "Open-Closed", "justification": "UserData is not extendable for new input methods without modifying its code. Static method and lack of abstractions prevent extension."}, {"principle": "Dependency Inversion", "justification": "UserData directly depends on the concrete Product class. High-level modules should depend on abstractions, not concrete implementations."}]}]}
{"project_id": 126, "chunk_id": 0, "prompt": {"main_file_path": "Cifra-de-Cesar-main/Cifra-de-Cesar-main/src/App.java", "main_file_content": "import java.util.Scanner; public class App { public static String encriptar(int chave, String texto) { StringBuilder textoCifrado = new StringBuilder(); int tamanhoTexto = texto.length(); for (int c = 0; c < tamanhoTexto; c++) { int letraCifradaASCII = ((int) texto.charAt(c)) + chave; while (letraCifradaASCII > 126) letraCifradaASCII -= 94; textoCifrado.append((char) letraCifradaASCII); } return textoCifrado.toString(); } public static String decriptar(int chave, String textoCifrado) { StringBuilder texto = new StringBuilder(); int tamanhoTexto = textoCifrado.length(); for (int c = 0; c < tamanhoTexto; c++) { int letraDecifradaASCII = ((int) textoCifrado.charAt(c)) - chave; while (letraDecifradaASCII < 32) letraDecifradaASCII += 94; texto.append((char) letraDecifradaASCII); } return texto.toString(); } public static void main(String[] args) { try { Scanner entrada = new Scanner(System.in); soutl(\"\") soutl(\"\") sout(\"\") String texto = entrada.nextLine(); sout(\"\") int chave = entrada.nextInt(); String textoCriptografado = encriptar(chave, texto); String textoDescriptografado = decriptar(chave, textoCriptografado); soutl(\"\") soutl(\"\") soutl(\"\") } catch (RuntimeException e) { soutl(\"\") soutl(\"\") } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Cifra-de-Cesar-main/Cifra-de-Cesar-main/src/App.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The App class handles encryption, decryption, user input, and output. These multiple responsibilities violate SRP as the class has more than one reason to change."}, {"principle": "Open-Closed", "justification": "The encryption/decryption logic is directly implemented in the App class. Adding new ciphers would require modifying existing code instead of extending via abstractions, violating OCP."}]}]}
{"project_id": 127, "chunk_id": 0, "prompt": {"main_file_path": "Java-SnakeGame-main/src/Snake.java", "main_file_content": "import java.awt.Rectangle; import java.util.ArrayList; public class Snake { private ArrayList<Rectangle> body; private int w = Game.width; private int h = Game.height; private int d = Game.dimension; private String move; public Snake() { body = new ArrayList<>(); Rectangle temp = new Rectangle(Game.dimension, Game.dimension); temp.setLocation(Game.width / 2 * Game.dimension, Game.height / 2 * Game.dimension); body.add(temp); temp = new Rectangle(d, d); temp.setLocation((w / 2 - 1) * d, (h / 2) * d); body.add(temp); temp = new Rectangle(d, d); temp.setLocation((w / 2 - 2) * d, (h / 2) * d); body.add(temp); move = \"NOTHING\"; } public void move() { if (!move.equals(\"NOTHING\")) { Rectangle first = body.get(0); Rectangle temp = new Rectangle(Game.dimension, Game.dimension); if (move.equals(\"UP\")) { temp.setLocation(first.x, first.y - Game.dimension); } else if (move.equals(\"DOWN\")) { temp.setLocation(first.x, first.y + Game.dimension); } else if (move.equals(\"LEFT\")) { temp.setLocation(first.x - Game.dimension, first.y); } else { temp.setLocation(first.x + Game.dimension, first.y); } body.add(0, temp); body.remove(body.size() - 1); } } public void grow() { Rectangle first = body.get(0); Rectangle temp = new Rectangle(Game.dimension, Game.dimension); if (move.equals(\"UP\")) { temp.setLocation(first.x, first.y - Game.dimension); } else if (move.equals(\"DOWN\")) { temp.setLocation(first.x, first.y + Game.dimension); } else if (move.equals(\"LEFT\")) { temp.setLocation(first.x - Game.dimension, first.y); } else { temp.setLocation(first.x + Game.dimension, first.y); } body.add(0, temp); } public ArrayList<Rectangle> getBody() { return body; } public void setBody(ArrayList<Rectangle> body) { this.body = body; } public int getX() { return body.get(0).x; } public int getY() { return body.get(0).y; } public String getMove() { return move; } public void up() { move = \"UP\"; } public void down() { move = \"DOWN\"; } public void left() { move = \"LEFT\"; } public void right() { move = \"RIGHT\"; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Java-SnakeGame-main/src/Snake.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Snake class handles managing the body state, movement logic, and growth behavior, which are multiple responsibilities. Changes in movement logic, growth, or body management would all require modifying this class."}, {"principle": "Open-Closed", "justification": "Adding new movement directions or behaviors requires modifying existing methods (move, grow) instead of extending the class. The code isn't closed for modification."}, {"principle": "Dependency Inversion", "justification": "Snake directly depends on the concrete Game class for dimension/position values. High-level modules should depend on abstractions rather than concrete implementations."}]}]}
{"project_id": 127, "chunk_id": 0, "prompt": {"main_file_path": "Java-SnakeGame-main/src/Food.java", "main_file_content": "import java.awt.Rectangle; public class Food { private int x; private int y; public Food(Snake player) { this.random_spawn(player); } public void random_spawn(Snake player) { boolean onSnake = true; while (onSnake) { onSnake = false; x = (int) (Math.random() * (Game.width - 1)); y = (int) (Math.random() * (Game.height - 1)); for (Rectangle r : player.getBody()) { if (r.x / Game.dimension == x && r.y / Game.dimension == y) { onSnake = true; break; } } } } public int getX() { return x; } public void setX(int x) { this.x = x; } public int getY() { return y; } public void setY(int y) { this.y = y; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Java-SnakeGame-main/src/Food.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Food class manages its coordinates and handles collision-checking with Snake, combining position management and spawning logic into one responsibility."}, {"principle": "Open-Closed", "justification": "Modifying spawning logic (e.g., new collision rules) requires direct changes to Food's code instead of extending via abstractions."}, {"principle": "Dependency Inversion", "justification": "Food directly depends on concrete Snake and Game classes instead of abstractions (e.g., interfaces for collision detection or game dimensions)."}]}]}
{"project_id": 127, "chunk_id": 0, "prompt": {"main_file_path": "Java-SnakeGame-main/src/Graphics.java", "main_file_content": "import java.awt.Color; import java.awt.Graphics2D; import java.awt.Rectangle; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import javax.swing.JPanel; import javax.swing.Timer; public class Graphics extends JPanel implements ActionListener { private Timer t = new Timer(100, this); public String state; private Snake s; private Food f; private Game game; public Graphics(Game g) { t.start(); state = \"START\"; game = g; s = g.getPlayer(); f = g.getFood(); this.addKeyListener(g); this.setFocusable(true); this.setFocusTraversalKeysEnabled(false); } @Override public void paintComponent(java.awt.Graphics g) { super.paintComponent(g); Graphics2D g2d = (Graphics2D) g; g2d.setColor(Color.black); g2d.fillRect(0, 0, Game.width * Game.dimension + 5, Game.height * Game.dimension + 5); if (state.equals(\"START\")) { g2d.setColor(Color.white); int centerX = Game.width * Game.dimension / 2; int centerY = Game.height * Game.dimension / 2; g2d.drawString(\"Press Any Key to Start\", centerX - 60, centerY - 50); g2d.drawString(\"Controls:\", centerX - 30, centerY - 20); g2d.drawString(\"W - Move Up\", centerX - 40, centerY); g2d.drawString(\"S - Move Down\", centerX - 40, centerY + 20); g2d.drawString(\"A - Move Left\", centerX - 40, centerY + 40); g2d.drawString(\"D - Move Right\", centerX - 40, centerY + 60); g2d.drawString(\"Avoid hitting walls and yourself!\", centerX - 90, centerY + 100); } else if (state.equals(\"RUNNING\")) { g2d.setColor(Color.red); g2d.fillRect(f.getX() * Game.dimension, f.getY() * Game.dimension, Game.dimension, Game.dimension); g2d.setColor(Color.green); for (Rectangle r : s.getBody()) { g2d.fill(r); } } else { g2d.setColor(Color.white); g2d.drawString(\"Game Over! Your Score: \" + (s.getBody().size() - 3), Game.width / 2 * Game.dimension - 70, Game.height / 2 * Game.dimension - 20); } } @Override public void actionPerformed(ActionEvent e) { repaint(); game.update(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Java-SnakeGame-main/src/Graphics.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Graphics class handles UI rendering, game state management (START/RUNNING/Game Over), and user input setup. These are multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Adding new game states requires modifying paintComponent's conditional logic instead of extending through abstractions."}, {"principle": "Dependency Inversion", "justification": "High-level Graphics directly depends on concrete Game, Snake, and Food classes instead of abstractions."}]}]}
{"project_id": 127, "chunk_id": 0, "prompt": {"main_file_path": "Java-SnakeGame-main/src/Game.java", "main_file_content": "import java.awt.event.KeyEvent; import java.awt.event.KeyListener; import javax.swing.JFrame; public class Game implements KeyListener { private Snake player; private Food food; private Graphics graphics; private JFrame window; public static final int width = 30; public static final int height = 30; public static final int dimension = 20; public Game() { window = new JFrame(); player = new Snake(); food = new Food(player); graphics = new Graphics(this); window.add(graphics); window.setTitle(\"Snake\"); window.setSize(width * dimension + 2, height * dimension + dimension + 4); window.setVisible(true); window.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } public void start() { graphics.state = \"RUNNING\"; } public void update() { if (graphics.state.equals(\"RUNNING\")) { if (check_food_collision()) { player.grow(); food.random_spawn(player); } else if (check_wall_collision() || check_self_collision()) { graphics.state = \"END\"; } else { player.move(); } } } private boolean check_wall_collision() { return (player.getX() < 0 || player.getX() >= width * dimension || player.getY() < 0 || player.getY() >= height * dimension); } private boolean check_food_collision() { return (player.getX() == food.getX() * dimension && player.getY() == food.getY() * dimension); } private boolean check_self_collision() { for (int i = 1; i < player.getBody().size(); i++) { if (player.getX() == player.getBody().get(i).x && player.getY() == player.getBody().get(i).y) { return true; } } return false; } @Override public void keyTyped(KeyEvent e) { } @Override public void keyPressed(KeyEvent e) { int keyCode = e.getKeyCode(); if (graphics.state.equals(\"RUNNING\")) { if (keyCode == KeyEvent.VK_W && !player.getMove().equals(\"DOWN\")) { player.up(); } if (keyCode == KeyEvent.VK_S && !player.getMove().equals(\"UP\")) { player.down(); } if (keyCode == KeyEvent.VK_A && !player.getMove().equals(\"RIGHT\")) { player.left(); } if (keyCode == KeyEvent.VK_D && !player.getMove().equals(\"LEFT\")) { player.right(); } } else { this.start(); } } @Override public void keyReleased(KeyEvent e) { } public Snake getPlayer() { return player; } public void setPlayer(Snake player) { this.player = player; } public Food getFood() { return food; } public void setFood(Food food) { this.food = food; } public JFrame getWindow() { return window; } public void setWindow(JFrame window) { this.window = window; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Java-SnakeGame-main/src/Game.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Game class handles multiple responsibilities: game loop management, input handling, collision detection, and UI setup. This creates multiple reasons for the class to change."}, {"principle": "Interface Segregation", "justification": "Game implements KeyListener but only uses keyPressed, forcing empty implementations of keyTyped/keyReleased. Clients depend on unused methods."}, {"principle": "Dependency Inversion", "justification": "Game directly instantiates concrete classes (Snake, Food, Graphics) instead of depending on abstractions. High-level module depends on low-level implementations."}]}]}
{"project_id": 127, "chunk_id": 0, "prompt": {"main_file_path": "Java-SnakeGame-main/src/Main.java", "main_file_content": "public class Main { public static void main(String[] args) { soutl(\"\") Game start = new Game(); } }", "dependencies": [{"file_path": "Java-SnakeGame-main/src/Game.java", "file_content": "import java.awt.event.KeyEvent; import java.awt.event.KeyListener; import javax.swing.JFrame; public class Game implements KeyListener { private Snake player; private Food food; private Graphics graphics; private JFrame window; public static final int width = 30; public static final int height = 30; public static final int dimension = 20; public Game() { window = new JFrame(); player = new Snake(); food = new Food(player); graphics = new Graphics(this); window.add(graphics); window.setTitle(\"Snake\"); window.setSize(width * dimension + 2, height * dimension + dimension + 4); window.setVisible(true); window.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } public void start() { graphics.state = \"RUNNING\"; } public void update() { if (graphics.state.equals(\"RUNNING\")) { if (check_food_collision()) { player.grow(); food.random_spawn(player); } else if (check_wall_collision() || check_self_collision()) { graphics.state = \"END\"; } else { player.move(); } } } private boolean check_wall_collision() { return (player.getX() < 0 || player.getX() >= width * dimension || player.getY() < 0 || player.getY() >= height * dimension); } private boolean check_food_collision() { return (player.getX() == food.getX() * dimension && player.getY() == food.getY() * dimension); } private boolean check_self_collision() { for (int i = 1; i < player.getBody().size(); i++) { if (player.getX() == player.getBody().get(i).x && player.getY() == player.getBody().get(i).y) { return true; } } return false; } @Override public void keyTyped(KeyEvent e) { } @Override public void keyPressed(KeyEvent e) { int keyCode = e.getKeyCode(); if (graphics.state.equals(\"RUNNING\")) { if (keyCode == KeyEvent.VK_W && !player.getMove().equals(\"DOWN\")) { player.up(); } if (keyCode == KeyEvent.VK_S && !player.getMove().equals(\"UP\")) { player.down(); } if (keyCode == KeyEvent.VK_A && !player.getMove().equals(\"RIGHT\")) { player.left(); } if (keyCode == KeyEvent.VK_D && !player.getMove().equals(\"LEFT\")) { player.right(); } } else { this.start(); } } @Override public void keyReleased(KeyEvent e) { } public Snake getPlayer() { return player; } public void setPlayer(Snake player) { this.player = player; } public Food getFood() { return food; } public void setFood(Food food) { this.food = food; } public JFrame getWindow() { return window; } public void setWindow(JFrame window) { this.window = window; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Java-SnakeGame-main/src/Game.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Game class handles multiple responsibilities: window management, input handling, game state logic, and collision detection. Changes in any of these areas require modifying the class."}, {"principle": "Open-Closed", "justification": "Game class cannot be extended for new collision types or game states without modifying existing code. No abstractions allow closed modification."}, {"principle": "Interface Segregation", "justification": "Implements KeyListener but only uses keyPressed. Forced empty implementations of keyTyped/keyReleased violate ISP by depending on unused methods."}, {"principle": "Dependency Inversion", "justification": "Directly instantiates concrete Snake, Food, Graphics, JFrame. High-level game logic depends on low-level implementations instead of abstractions."}]}]}
{"project_id": 128, "chunk_id": 0, "prompt": {"main_file_path": "PortScanner-main/PortScanner-main/src/ArgumentParser.java", "main_file_content": "import java.util.Scanner; public class ArgumentParser { public static void parseArgumentsAndScanPorts(String[] args) { Scanner scanner = new Scanner(System.in); String target; int startPort = 1; int endPort = 1024; int timeout = 200; if (args.length < 1) { soutl(\"\") target = scanner.nextLine(); soutl(\"\") try { startPort = Integer.parseInt(scanner.nextLine()); } catch (NumberFormatException e) { startPort = 1; } soutl(\"\") try { endPort = Integer.parseInt(scanner.nextLine()); } catch (NumberFormatException e) { endPort = 1024; } soutl(\"\") try { timeout = Integer.parseInt(scanner.nextLine()); } catch (NumberFormatException e) { timeout = 200; } } else { target = args[0]; if (args.length >= 3) { try { startPort = Integer.parseInt(args[1]); endPort = Integer.parseInt(args[2]); if (startPort < 1 || endPort > 65535 || startPort > endPort) { soutl(\"\") return; } } catch (NumberFormatException e) { soutl(\"\") } } if (args.length == 4) { try { timeout = Integer.parseInt(args[3]); if (timeout < 1) { soutl(\"\") return; } } catch (NumberFormatException e) { soutl(\"\") } } } PortScanner.scanPorts(target, startPort, endPort, timeout); } }", "dependencies": [{"file_path": "PortScanner-main/PortScanner-main/src/PortScanner.java", "file_content": "import java.net.Socket; import java.net.InetSocketAddress; public class PortScanner { public static void scanPorts(String target, int startPort, int endPort, int timeout) { soutl(\"\") for (int port = startPort; port <= endPort; port++) { try (Socket socket = new Socket()) { socket.connect(new InetSocketAddress(target, port), timeout); soutl(\"\") } catch (Exception e) { soutl(\"\") } } soutl(\"\") } public static void scanPorts(String target, int startPort, int endPort) { scanPorts(target, startPort, endPort, 200); } public static void scanPorts(String target) { scanPorts(target, 1, 1024, 200); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "PortScanner-main/PortScanner-main/src/ArgumentParser.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The class handles argument parsing, input validation, user interaction, and directly initiates port scanning, combining multiple responsibilities into one class."}, {"principle": "Open-Closed", "justification": "The class is not designed for extension (e.g., adding new argument formats would require modifying existing code instead of extending via abstractions)."}, {"principle": "Dependency Inversion", "justification": "The high-level ArgumentParser directly depends on the concrete PortScanner class instead of an abstraction for scanning functionality."}]}, {"file_path": "PortScanner-main/PortScanner-main/src/PortScanner.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "The class uses static methods and lacks abstractions, making it impossible to extend scanning behavior without modifying existing code."}]}]}
{"project_id": 128, "chunk_id": 0, "prompt": {"main_file_path": "PortScanner-main/PortScanner-main/src/PortScanner.java", "main_file_content": "import java.net.Socket; import java.net.InetSocketAddress; public class PortScanner { public static void scanPorts(String target, int startPort, int endPort, int timeout) { soutl(\"\") for (int port = startPort; port <= endPort; port++) { try (Socket socket = new Socket()) { socket.connect(new InetSocketAddress(target, port), timeout); soutl(\"\") } catch (Exception e) { soutl(\"\") } } soutl(\"\") } public static void scanPorts(String target, int startPort, int endPort) { scanPorts(target, startPort, endPort, 200); } public static void scanPorts(String target) { scanPorts(target, 1, 1024, 200); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "PortScanner-main/PortScanner-main/src/PortScanner.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The PortScanner class handles both port scanning logic and output presentation. Changing scanning parameters or output formatting would require modifying the same class, indicating multiple responsibilities."}, {"principle": "Open-Closed", "justification": "The class cannot be extended to support new scanning strategies (e.g., UDP scanning) without modifying its existing code. No abstractions or extension points are provided."}]}]}
{"project_id": 128, "chunk_id": 0, "prompt": {"main_file_path": "PortScanner-main/PortScanner-main/src/Main.java", "main_file_content": "public class Main { public static void main(String[] args) { ArgumentParser.parseArgumentsAndScanPorts(args); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "PortScanner-main/PortScanner-main/src/Main.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "Main directly depends on the concrete ArgumentParser class. High-level modules should depend on abstractions, not concrete implementations."}]}]}
{"project_id": 130, "chunk_id": 0, "prompt": {"main_file_path": "ThirdPartyLoginDemo-master/ThirdPartyLoginDemo-master/src/cn/sharesdk/tpl/CommonDialog.java", "main_file_content": "package cn.sharesdk.tpl; import android.app.Dialog; import android.content.Context; import cn.sharesdk.demo.tpl.R; public class CommonDialog { public static final Dialog ProgressDialog(Context context){ final Dialog dialog = new Dialog(context, R.style.CommonDialog); dialog.setContentView(R.layout.tpl_progress_dialog); return dialog; } }", "dependencies": [{"file_path": "ThirdPartyLoginDemo-master/ThirdPartyLoginDemo-master/gen/cn/sharesdk/demo/tpl/R.java", "file_content": "package cn.sharesdk.demo.tpl; public final class R { public static final class attr { } public static final class color { public static final int dialog_white_bg=0x7f040004; public static final int login_with_other_plat_text_color=0x7f040003; public static final int logo_text_color=0x7f040001; public static final int page_back=0x7f040000; public static final int white=0x7f040002; } public static final class drawable { public static final int checked=0x7f020000; public static final int dialog_et_bg=0x7f020001; public static final int et_bg=0x7f020002; public static final int ic_launcher=0x7f020003; public static final int logo_facebook=0x7f020004; public static final int logo_qq=0x7f020005; public static final int logo_qzone=0x7f020006; public static final int logo_sinaweibo=0x7f020007; public static final int logo_tencentweibo=0x7f020008; public static final int logo_twitter=0x7f020009; public static final int msg_login=0x7f02000a; public static final int other_login=0x7f02000b; public static final int qq_login=0x7f02000c; public static final int ssdk_auth_title_back=0x7f02000d; public static final int ssdk_back_arr=0x7f02000e; public static final int ssdk_logo=0x7f02000f; public static final int ssdk_title_div=0x7f020010; public static final int tpl_logo=0x7f020011; public static final int tpl_title_back_arrow=0x7f020012; public static final int user_icon=0x7f020013; public static final int wechat_login=0x7f020014; public static final int weibo_login=0x7f020015; } public static final class id { public static final int btn_get_verify_code=0x7f080013; public static final int btn_send_verify_code=0x7f080015; public static final int dialog_btn_save=0x7f080001; public static final int dialog_camera=0x7f08000a; public static final int dialog_ev_info=0x7f080002; public static final int dialog_iv_boy=0x7f080006; public static final int dialog_iv_girl=0x7f080009; public static final int dialog_picture=0x7f08000b; public static final int dialog_tv_boy=0x7f080005; public static final int dialog_tv_girl=0x7f080008; public static final int dialog_tv_hint=0x7f080003; public static final int dialog_tv_title=0x7f080000; public static final int et_phone=0x7f080012; public static final int et_verify_code=0x7f080014; public static final int iv_user_icon=0x7f08001a; public static final int ll_back=0x7f080021; public static final int ll_title_bar=0x7f080018; public static final int rl_boy=0x7f080004; public static final int rl_gender=0x7f08001d; public static final int rl_girl=0x7f080007; public static final int rl_icon=0x7f080019; public static final int rl_name=0x7f08001b; public static final int rl_note=0x7f08001f; public static final int textView1=0x7f08000c; public static final int tvFacebook=0x7f080016; public static final int tvMsgRegister=0x7f08000d; public static final int tvOther=0x7f080011; public static final int tvQq=0x7f080010; public static final int tvTwitter=0x7f080017; public static final int tvWeibo=0x7f08000f; public static final int tvWeixin=0x7f08000e; public static final int tv_ensure=0x7f080023; public static final int tv_title=0x7f080022; public static final int tv_user_gender=0x7f08001e; public static final int tv_user_name=0x7f08001c; public static final int tv_user_note=0x7f080020; } public static final class integer { public static final int app_version_code=0x7f060000; } public static final class layout { public static final int tpl_change_userinfo_dialog=0x7f030000; public static final int tpl_gender_select_dialog=0x7f030001; public static final int tpl_icon_select_dialog=0x7f030002; public static final int tpl_login_page=0x7f030003; public static final int tpl_msg_login_dialog=0x7f030004; public static final int tpl_other_plat_dialog=0x7f030005; public static final int tpl_page_signup=0x7f030006; public static final int tpl_progress_dialog=0x7f030007; public static final int tpl_title_layout=0x7f030008; } public static final class string { public static final int after_auth=0x7f05003f; public static final int app_name=0x7f050030; public static final int app_version=0x7f050031; public static final int auth_cancel=0x7f05003b; public static final int auth_complete=0x7f05003d; public static final int auth_error=0x7f05003c; public static final int douban=0x7f050019; public static final int dropbox=0x7f050023; public static final int email=0x7f050014; public static final int evernote=0x7f05001b; public static final int facebook=0x7f050010; public static final int flickr=0x7f050021; public static final int foursquare=0x7f05001e; public static final int google_plus_client_inavailable=0x7f050004; public static final int googleplus=0x7f05001d; public static final int if_register_needed=0x7f05003e; public static final int instagram=0x7f050025; public static final int instagram_client_inavailable=0x7f050007; public static final int kaixin=0x7f050013; public static final int line=0x7f050029; public static final int line_client_inavailable=0x7f050009; public static final int linkedin=0x7f05001c; public static final int login_with_msg=0x7f050034; public static final int login_with_other_plat=0x7f050038; public static final int login_with_qzone=0x7f050037; public static final int login_with_sina_weibo=0x7f050036; public static final int login_with_weixin=0x7f050035; public static final int logining=0x7f05003a; public static final int mingdao=0x7f050028; public static final int mingdao_share_content=0x7f05002c; public static final int neteasemicroblog=0x7f050018; public static final int pinterest=0x7f050020; public static final int pinterest_client_inavailable=0x7f050006; public static final int proj_name=0x7f050032; public static final int qq=0x7f05001f; public static final int qq_client_inavailable=0x7f050005; public static final int qzone=0x7f05000c; public static final int renren=0x7f050012; public static final int share_sdk=0x7f050033; public static final int share_to_mingdao=0x7f05002d; public static final int share_to_qq=0x7f05002b; public static final int share_to_qzone=0x7f05002a; public static final int share_to_qzone_default=0x7f05002e; public static final int shortmessage=0x7f050015; public static final int signup_failed=0x7f050059; public static final int signup_success=0x7f050058; public static final int sinaweibo=0x7f05000a; public static final int sohumicroblog=0x7f050016; public static final int sohusuishenkan=0x7f050017; public static final int tencentweibo=0x7f05000b; public static final int tpl_boy=0x7f05004c; public static final int tpl_camera=0x7f05004d; public static final int tpl_cancel=0x7f050041; public static final int tpl_change_user_name_title=0x7f05004f; public static final int tpl_change_user_note_title=0x7f050050; public static final int tpl_get_verify_code=0x7f050056; public static final int tpl_girl=0x7f05004b; public static final int tpl_input_user_name_hint=0x7f050051; public static final int tpl_input_user_note_hint=0x7f050052; public static final int tpl_key_user_gender=0x7f050044; public static final int tpl_key_user_icon=0x7f050042; public static final int tpl_key_user_name=0x7f050043; public static final int tpl_key_user_note=0x7f050045; public static final int tpl_msg_login_hint=0x7f050054; public static final int tpl_no_sdcard=0x7f050053; public static final int tpl_ok=0x7f050040; public static final int tpl_picture=0x7f05004e; public static final int tpl_send_verify_code=0x7f050057; public static final int tpl_sign_up=0x7f05004a; public static final int tpl_sign_user_info=0x7f050049; public static final int tpl_value_user_gender=0x7f050047; public static final int tpl_value_user_name=0x7f050046; public static final int tpl_value_user_note=0x7f050048; public static final int tpl_verify_code_hint=0x7f050055; public static final int tumblr=0x7f050022; public static final int twitter=0x7f050011; public static final int use_login_button=0x7f05002f; public static final int userid_found=0x7f050039; public static final int vkontakte=0x7f050024; public static final int website=0x7f050001; public static final int wechat=0x7f05000d; public static final int wechat_client_inavailable=0x7f050003; public static final int wechatfavorite=0x7f05000f; public static final int wechatmoments=0x7f05000e; public static final int weibo_oauth_regiseter=0x7f050000; public static final int weibo_upload_content=0x7f050002; public static final int yixin=0x7f050026; public static final int yixin_client_inavailable=0x7f050008; public static final int yixinmoments=0x7f050027; public static final int youdao=0x7f05001a; } public static final class style { public static final int AppTheme=0x7f070000; public static final int CommonDialog=0x7f070001; public static final int WhiteDialog=0x7f070002; } }"}, {"file_path": "ThirdPartyLoginDemo-master/ThirdPartyLoginDemo-master/src/cn/sharesdk/tpl/CommonDialog.java", "file_content": "package cn.sharesdk.tpl; import android.app.Dialog; import android.content.Context; import cn.sharesdk.demo.tpl.R; public class CommonDialog { public static final Dialog ProgressDialog(Context context){ final Dialog dialog = new Dialog(context, R.style.CommonDialog); dialog.setContentView(R.layout.tpl_progress_dialog); return dialog; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "ThirdPartyLoginDemo-master/ThirdPartyLoginDemo-master/src/cn/sharesdk/tpl/CommonDialog.java", "violatedPrinciples": [{"principle": "Open-Closed", "justification": "CommonDialog uses a static method to create a specific Dialog type. Adding new dialog types would require modifying the class instead of extending it through abstractions."}]}]}
{"project_id": 130, "chunk_id": 0, "prompt": {"main_file_path": "ThirdPartyLoginDemo-master/ThirdPartyLoginDemo-master/src/cn/sharesdk/tpl/PicViewer.java", "main_file_content": "package cn.sharesdk.tpl; import android.graphics.Bitmap; import android.graphics.BitmapFactory; import android.graphics.Bitmap.Config; import android.net.Uri; import android.text.TextUtils; import android.view.View; import android.view.View.OnClickListener; import android.widget.ImageView; import android.widget.ImageView.ScaleType; import cn.sharesdk.framework.FakeActivity; public class PicViewer extends FakeActivity implements OnClickListener { private ImageView ivViewer; private Bitmap pic; private Uri pictureUri; private String picturePath; @Deprecated public void setImageBitmap(Bitmap pic) { this.pic = pic; if (ivViewer != null) { ivViewer.setImageBitmap(pic); } } public void setImagePath(String path) { if (!TextUtils.isEmpty(path)) { picturePath = path; pictureUri = Uri.parse(path); if (ivViewer != null) { ivViewer.setImageBitmap(compressImageFromFile(picturePath)); } } } public void onCreate() { ivViewer = new ImageView(activity); ivViewer.setScaleType(ScaleType.FIT_CENTER); ivViewer.setBackgroundColor(0xc0000000); ivViewer.setOnClickListener(this); activity.setContentView(ivViewer); if (pic != null && !pic.isRecycled()) { ivViewer.setImageBitmap(pic); } else if(!TextUtils.isEmpty(picturePath)){ ivViewer.setImageBitmap(compressImageFromFile(picturePath)); } else if (pictureUri != null && !TextUtils.isEmpty(pictureUri.getPath())) { ivViewer.setImageBitmap(compressImageFromFile(pictureUri.getPath())); } } public void onClick(View v) { finish(); } private Bitmap compressImageFromFile(String srcPath) { BitmapFactory.Options newOpts = new BitmapFactory.Options(); newOpts.inJustDecodeBounds = true; Bitmap bitmap = BitmapFactory.decodeFile(srcPath, newOpts); newOpts.inJustDecodeBounds = false; int w = newOpts.outWidth; int h = newOpts.outHeight; float hh = 800f; float ww = 480f; int be = 1; if (w > h && w > ww) { be = (int) (newOpts.outWidth / ww); } else if (w < h && h > hh) { be = (int) (newOpts.outHeight / hh); } if (be <= 0) be = 1; newOpts.inSampleSize = be; newOpts.inPreferredConfig = Config.ARGB_8888; newOpts.inPurgeable = true; newOpts.inInputShareable = true; bitmap = BitmapFactory.decodeFile(srcPath, newOpts); return bitmap; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "ThirdPartyLoginDemo-master/ThirdPartyLoginDemo-master/src/cn/sharesdk/tpl/PicViewer.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "PicViewer handles both UI management (image display, click listener) and image processing (compression logic via compressImageFromFile), violating the single responsibility principle."}, {"principle": "Open-Closed", "justification": "Adding new image compression strategies or display behaviors would require modifying PicViewer's existing code instead of extending it through abstractions or composition."}, {"principle": "Dependency Inversion", "justification": "PicViewer directly depends on concrete Bitmap/BitmapFactory implementations for image processing instead of abstractions, coupling high-level logic to low-level details."}]}]}
{"project_id": 130, "chunk_id": 0, "prompt": {"main_file_path": "ThirdPartyLoginDemo-master/ThirdPartyLoginDemo-master/src/cn/sharesdk/tpl/ThirdPartyLogin.java", "main_file_content": "package cn.sharesdk.tpl; import java.util.HashMap; import android.app.Dialog; import android.content.Context; import android.os.Handler; import android.os.Handler.Callback; import android.os.Message; import android.text.TextUtils; import android.view.View; import android.view.Window; import android.view.View.OnClickListener; import android.widget.Button; import android.widget.EditText; import android.widget.Toast; import cn.sharesdk.demo.tpl.R; import cn.sharesdk.facebook.Facebook; import cn.sharesdk.framework.FakeActivity; import cn.sharesdk.framework.Platform; import cn.sharesdk.framework.PlatformActionListener; import cn.sharesdk.framework.ShareSDK; import cn.sharesdk.sina.weibo.SinaWeibo; import cn.sharesdk.tencent.qzone.QZone; import cn.sharesdk.twitter.Twitter; import cn.sharesdk.wechat.friends.Wechat; import cn.smssdk.EventHandler; import cn.smssdk.SMSSDK; public class ThirdPartyLogin extends FakeActivity implements OnClickListener, Callback, PlatformActionListener { private static final int MSG_SMSSDK_CALLBACK = 1; private static final int MSG_AUTH_CANCEL = 2; private static final int MSG_AUTH_ERROR= 3; private static final int MSG_AUTH_COMPLETE = 4; private String smssdkAppkey; private String smssdkAppSecret; private OnLoginListener signupListener; private Handler handler; private Dialog msgLoginDlg; public void setSMSSDKAppkey(String appkey, String appSecret) { smssdkAppkey = appkey; smssdkAppSecret = appSecret; } public void setOnLoginListener(OnLoginListener l) { this.signupListener = l; } public void onCreate() { handler = new Handler(this); activity.setContentView(R.layout.tpl_login_page); (activity.findViewById(R.id.tvMsgRegister)).setOnClickListener(this); (activity.findViewById(R.id.tvWeixin)).setOnClickListener(this); (activity.findViewById(R.id.tvWeibo)).setOnClickListener(this); (activity.findViewById(R.id.tvQq)).setOnClickListener(this); (activity.findViewById(R.id.tvOther)).setOnClickListener(this); } public void onDestroy() { SMSSDK.unregisterAllEventHandler(); } public void onClick(View v) { switch(v.getId()) { case R.id.tvMsgRegister: { popupMsgLogin(); } break; case R.id.tvWeixin: { Platform wechat = ShareSDK.getPlatform(Wechat.NAME); authorize(wechat); } break; case R.id.tvWeibo: { Platform sina = ShareSDK.getPlatform(SinaWeibo.NAME); authorize(sina); } break; case R.id.tvQq: { Platform qzone = ShareSDK.getPlatform(QZone.NAME); authorize(qzone); } break; case R.id.tvOther: { authorize(null); } break; case R.id.tvFacebook: { Dialog dlg = (Dialog) v.getTag(); dlg.dismiss(); Platform facebook = ShareSDK.getPlatform(Facebook.NAME); authorize(facebook); } break; case R.id.tvTwitter: { Dialog dlg = (Dialog) v.getTag(); dlg.dismiss(); Platform twitter = ShareSDK.getPlatform(Twitter.NAME); authorize(twitter); } break; } } private void popupMsgLogin() { msgLoginDlg = new Dialog(activity, R.style.WhiteDialog); View dlgView = View.inflate(activity, R.layout.tpl_msg_login_dialog, null); final EditText etPhone = (EditText) dlgView.findViewById(R.id.et_phone); final EditText etVerifyCode = (EditText) dlgView.findViewById(R.id.et_verify_code); Button btnGetVerifyCode = (Button) dlgView.findViewById(R.id.btn_get_verify_code); Button btnSendVerifyCode = (Button) dlgView.findViewById(R.id.btn_send_verify_code); btnGetVerifyCode.setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { String phone = etPhone.getText().toString(); if(TextUtils.isEmpty(phone)){ Toast.makeText(activity, \"\u8bf7\u8f93\u5165\u624b\u673a\u53f7\u7801\", Toast.LENGTH_SHORT).show(); }else{ SMSSDK.getVerificationCode(\"86\", phone); } } }); btnSendVerifyCode.setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { String phone = etPhone.getText().toString(); String verifyCode = etVerifyCode.getText().toString(); if(TextUtils.isEmpty(verifyCode)){ Toast.makeText(activity, \"\u8bf7\u8f93\u5165\u9a8c\u8bc1\u7801\", Toast.LENGTH_SHORT).show(); }else{ SMSSDK.submitVerificationCode(\"86\", phone, verifyCode); } } }); msgLoginDlg.requestWindowFeature(Window.FEATURE_NO_TITLE); msgLoginDlg.setContentView(dlgView); msgLoginDlg.show(); } private void authorize(Platform plat) { if (plat == null) { popupOthers(); return; } plat.setPlatformActionListener(this); plat.SSOSetting(true); plat.showUser(null); } private void popupOthers() { Dialog dlg = new Dialog(activity, R.style.WhiteDialog); View dlgView = View.inflate(activity, R.layout.tpl_other_plat_dialog, null); View tvFacebook = dlgView.findViewById(R.id.tvFacebook); tvFacebook.setTag(dlg); tvFacebook.setOnClickListener(this); View tvTwitter = dlgView.findViewById(R.id.tvTwitter); tvTwitter.setTag(dlg); tvTwitter.setOnClickListener(this); dlg.requestWindowFeature(Window.FEATURE_NO_TITLE); dlg.setContentView(dlgView); dlg.show(); } public void onComplete(Platform platform, int action, HashMap<String, Object> res) { if (action == Platform.ACTION_USER_INFOR) { Message msg = new Message(); msg.what = MSG_AUTH_COMPLETE; msg.obj = new Object[] {platform.getName(), res}; handler.sendMessage(msg); } } public void onError(Platform platform, int action, Throwable t) { if (action == Platform.ACTION_USER_INFOR) { handler.sendEmptyMessage(MSG_AUTH_ERROR); } t.printStackTrace(); } public void onCancel(Platform platform, int action) { if (action == Platform.ACTION_USER_INFOR) { handler.sendEmptyMessage(MSG_AUTH_CANCEL); } } @SuppressWarnings(\"unchecked\") public boolean handleMessage(Message msg) { switch(msg.what) { case MSG_AUTH_CANCEL: { Toast.makeText(activity, R.string.auth_cancel, Toast.LENGTH_SHORT).show(); } break; case MSG_AUTH_ERROR: { Toast.makeText(activity, R.string.auth_error, Toast.LENGTH_SHORT).show(); } break; case MSG_AUTH_COMPLETE: { Toast.makeText(activity, R.string.auth_complete, Toast.LENGTH_SHORT).show(); Object[] objs = (Object[]) msg.obj; String platform = (String) objs[0]; HashMap<String, Object> res = (HashMap<String, Object>) objs[1]; if (signupListener != null && signupListener.onSignin(platform, res)) { SignupPage signupPage = new SignupPage(); signupPage.setOnLoginListener(signupListener); signupPage.setPlatform(platform); signupPage.show(activity, null); } } break; case MSG_SMSSDK_CALLBACK: { if (msg.arg2 == SMSSDK.RESULT_ERROR) { Toast.makeText(activity, \"\u64cd\u4f5c\u5931\u8d25\", Toast.LENGTH_SHORT).show(); } else { switch (msg.arg1) { case SMSSDK.EVENT_SUBMIT_VERIFICATION_CODE: { if(msgLoginDlg != null && msgLoginDlg.isShowing()){ msgLoginDlg.dismiss(); } Toast.makeText(activity, \"\u63d0\u4ea4\u9a8c\u8bc1\u7801\u6210\u529f\", Toast.LENGTH_SHORT).show(); Message m = new Message(); m.what = MSG_AUTH_COMPLETE; m.obj = new Object[] {\"SMSSDK\", (HashMap<String, Object>) msg.obj}; handler.sendMessage(m); } break; case SMSSDK.EVENT_GET_VERIFICATION_CODE:{ Toast.makeText(activity, \"\u9a8c\u8bc1\u7801\u5df2\u7ecf\u53d1\u9001\", Toast.LENGTH_SHORT).show(); } break; } } } break; } return false; } public void show(Context context) { initSDK(context); super.show(context, null); } private void initSDK(Context context) { ShareSDK.initSDK(context); SMSSDK.initSDK(context, smssdkAppkey, smssdkAppSecret); EventHandler eh = new EventHandler(){ public void afterEvent(int event, int result, Object data) { Message msg = new Message(); msg.arg1 = event; msg.arg2 = result; msg.obj = data; handler.sendMessage(msg); } }; SMSSDK.registerEventHandler(eh); } }", "dependencies": [{"file_path": "ThirdPartyLoginDemo-master/ThirdPartyLoginDemo-master/gen/cn/sharesdk/demo/tpl/R.java", "file_content": "package cn.sharesdk.demo.tpl; public final class R { public static final class attr { } public static final class color { public static final int dialog_white_bg=0x7f040004; public static final int login_with_other_plat_text_color=0x7f040003; public static final int logo_text_color=0x7f040001; public static final int page_back=0x7f040000; public static final int white=0x7f040002; } public static final class drawable { public static final int checked=0x7f020000; public static final int dialog_et_bg=0x7f020001; public static final int et_bg=0x7f020002; public static final int ic_launcher=0x7f020003; public static final int logo_facebook=0x7f020004; public static final int logo_qq=0x7f020005; public static final int logo_qzone=0x7f020006; public static final int logo_sinaweibo=0x7f020007; public static final int logo_tencentweibo=0x7f020008; public static final int logo_twitter=0x7f020009; public static final int msg_login=0x7f02000a; public static final int other_login=0x7f02000b; public static final int qq_login=0x7f02000c; public static final int ssdk_auth_title_back=0x7f02000d; public static final int ssdk_back_arr=0x7f02000e; public static final int ssdk_logo=0x7f02000f; public static final int ssdk_title_div=0x7f020010; public static final int tpl_logo=0x7f020011; public static final int tpl_title_back_arrow=0x7f020012; public static final int user_icon=0x7f020013; public static final int wechat_login=0x7f020014; public static final int weibo_login=0x7f020015; } public static final class id { public static final int btn_get_verify_code=0x7f080013; public static final int btn_send_verify_code=0x7f080015; public static final int dialog_btn_save=0x7f080001; public static final int dialog_camera=0x7f08000a; public static final int dialog_ev_info=0x7f080002; public static final int dialog_iv_boy=0x7f080006; public static final int dialog_iv_girl=0x7f080009; public static final int dialog_picture=0x7f08000b; public static final int dialog_tv_boy=0x7f080005; public static final int dialog_tv_girl=0x7f080008; public static final int dialog_tv_hint=0x7f080003; public static final int dialog_tv_title=0x7f080000; public static final int et_phone=0x7f080012; public static final int et_verify_code=0x7f080014; public static final int iv_user_icon=0x7f08001a; public static final int ll_back=0x7f080021; public static final int ll_title_bar=0x7f080018; public static final int rl_boy=0x7f080004; public static final int rl_gender=0x7f08001d; public static final int rl_girl=0x7f080007; public static final int rl_icon=0x7f080019; public static final int rl_name=0x7f08001b; public static final int rl_note=0x7f08001f; public static final int textView1=0x7f08000c; public static final int tvFacebook=0x7f080016; public static final int tvMsgRegister=0x7f08000d; public static final int tvOther=0x7f080011; public static final int tvQq=0x7f080010; public static final int tvTwitter=0x7f080017; public static final int tvWeibo=0x7f08000f; public static final int tvWeixin=0x7f08000e; public static final int tv_ensure=0x7f080023; public static final int tv_title=0x7f080022; public static final int tv_user_gender=0x7f08001e; public static final int tv_user_name=0x7f08001c; public static final int tv_user_note=0x7f080020; } public static final class integer { public static final int app_version_code=0x7f060000; } public static final class layout { public static final int tpl_change_userinfo_dialog=0x7f030000; public static final int tpl_gender_select_dialog=0x7f030001; public static final int tpl_icon_select_dialog=0x7f030002; public static final int tpl_login_page=0x7f030003; public static final int tpl_msg_login_dialog=0x7f030004; public static final int tpl_other_plat_dialog=0x7f030005; public static final int tpl_page_signup=0x7f030006; public static final int tpl_progress_dialog=0x7f030007; public static final int tpl_title_layout=0x7f030008; } public static final class string { public static final int after_auth=0x7f05003f; public static final int app_name=0x7f050030; public static final int app_version=0x7f050031; public static final int auth_cancel=0x7f05003b; public static final int auth_complete=0x7f05003d; public static final int auth_error=0x7f05003c; public static final int douban=0x7f050019; public static final int dropbox=0x7f050023; public static final int email=0x7f050014; public static final int evernote=0x7f05001b; public static final int facebook=0x7f050010; public static final int flickr=0x7f050021; public static final int foursquare=0x7f05001e; public static final int google_plus_client_inavailable=0x7f050004; public static final int googleplus=0x7f05001d; public static final int if_register_needed=0x7f05003e; public static final int instagram=0x7f050025; public static final int instagram_client_inavailable=0x7f050007; public static final int kaixin=0x7f050013; public static final int line=0x7f050029; public static final int line_client_inavailable=0x7f050009; public static final int linkedin=0x7f05001c; public static final int login_with_msg=0x7f050034; public static final int login_with_other_plat=0x7f050038; public static final int login_with_qzone=0x7f050037; public static final int login_with_sina_weibo=0x7f050036; public static final int login_with_weixin=0x7f050035; public static final int logining=0x7f05003a; public static final int mingdao=0x7f050028; public static final int mingdao_share_content=0x7f05002c; public static final int neteasemicroblog=0x7f050018; public static final int pinterest=0x7f050020; public static final int pinterest_client_inavailable=0x7f050006; public static final int proj_name=0x7f050032; public static final int qq=0x7f05001f; public static final int qq_client_inavailable=0x7f050005; public static final int qzone=0x7f05000c; public static final int renren=0x7f050012; public static final int share_sdk=0x7f050033; public static final int share_to_mingdao=0x7f05002d; public static final int share_to_qq=0x7f05002b; public static final int share_to_qzone=0x7f05002a; public static final int share_to_qzone_default=0x7f05002e; public static final int shortmessage=0x7f050015; public static final int signup_failed=0x7f050059; public static final int signup_success=0x7f050058; public static final int sinaweibo=0x7f05000a; public static final int sohumicroblog=0x7f050016; public static final int sohusuishenkan=0x7f050017; public static final int tencentweibo=0x7f05000b; public static final int tpl_boy=0x7f05004c; public static final int tpl_camera=0x7f05004d; public static final int tpl_cancel=0x7f050041; public static final int tpl_change_user_name_title=0x7f05004f; public static final int tpl_change_user_note_title=0x7f050050; public static final int tpl_get_verify_code=0x7f050056; public static final int tpl_girl=0x7f05004b; public static final int tpl_input_user_name_hint=0x7f050051; public static final int tpl_input_user_note_hint=0x7f050052; public static final int tpl_key_user_gender=0x7f050044; public static final int tpl_key_user_icon=0x7f050042; public static final int tpl_key_user_name=0x7f050043; public static final int tpl_key_user_note=0x7f050045; public static final int tpl_msg_login_hint=0x7f050054; public static final int tpl_no_sdcard=0x7f050053; public static final int tpl_ok=0x7f050040; public static final int tpl_picture=0x7f05004e; public static final int tpl_send_verify_code=0x7f050057; public static final int tpl_sign_up=0x7f05004a; public static final int tpl_sign_user_info=0x7f050049; public static final int tpl_value_user_gender=0x7f050047; public static final int tpl_value_user_name=0x7f050046; public static final int tpl_value_user_note=0x7f050048; public static final int tpl_verify_code_hint=0x7f050055; public static final int tumblr=0x7f050022; public static final int twitter=0x7f050011; public static final int use_login_button=0x7f05002f; public static final int userid_found=0x7f050039; public static final int vkontakte=0x7f050024; public static final int website=0x7f050001; public static final int wechat=0x7f05000d; public static final int wechat_client_inavailable=0x7f050003; public static final int wechatfavorite=0x7f05000f; public static final int wechatmoments=0x7f05000e; public static final int weibo_oauth_regiseter=0x7f050000; public static final int weibo_upload_content=0x7f050002; public static final int yixin=0x7f050026; public static final int yixin_client_inavailable=0x7f050008; public static final int yixinmoments=0x7f050027; public static final int youdao=0x7f05001a; } public static final class style { public static final int AppTheme=0x7f070000; public static final int CommonDialog=0x7f070001; public static final int WhiteDialog=0x7f070002; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "ThirdPartyLoginDemo-master/ThirdPartyLoginDemo-master/src/cn/sharesdk/tpl/ThirdPartyLogin.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "ThirdPartyLogin handles UI interactions, platform authorization, SMS verification, and dialog management, violating SRP by managing multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Adding new login platforms requires modifying the onClick method's switch-case logic, violating OCP by not allowing extension without code changes."}, {"principle": "Dependency Inversion", "justification": "Directly depends on concrete platforms (Facebook, Twitter) and SMSSDK/ShareSDK instead of abstractions, violating DIP by coupling high-level logic to low-level implementations."}]}]}
{"project_id": 130, "chunk_id": 0, "prompt": {"main_file_path": "ThirdPartyLoginDemo-master/ThirdPartyLoginDemo-master/src/cn/sharesdk/tpl/OnLoginListener.java", "main_file_content": "package cn.sharesdk.tpl; import java.util.HashMap; public interface OnLoginListener { public boolean onSignin(String platform, HashMap<String, Object> res); public boolean onSignUp(UserInfo info) ; }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "ThirdPartyLoginDemo-master/ThirdPartyLoginDemo-master/src/cn/sharesdk/tpl/OnLoginListener.java", "violatedPrinciples": [{"principle": "Interface Segregation", "justification": "The OnLoginListener interface forces implementing classes to define both onSignin and onSignUp methods, even if a client only needs one, violating ISP by imposing unnecessary method dependencies."}, {"principle": "Dependency Inversion", "justification": "The onSignUp method depends on the concrete UserInfo class instead of an abstraction, violating DIP by creating a direct dependency from a high-level interface to a low-level implementation."}]}]}
{"project_id": 130, "chunk_id": 0, "prompt": {"main_file_path": "ThirdPartyLoginDemo-master/ThirdPartyLoginDemo-master/src/cn/sharesdk/tpl/UserInfo.java", "main_file_content": "package cn.sharesdk.tpl; public class UserInfo { private String userIcon; private String userName; private Gender userGender; private String userNote; public String getUserIcon() { return userIcon; } public void setUserIcon(String userIcon) { this.userIcon = userIcon; } public String getUserName() { return userName; } public void setUserName(String userName) { this.userName = userName; } public Gender getUserGender() { return userGender; } public void setUserGender(Gender userGender) { this.userGender = userGender; } public String getUserNote() { return userNote; } public void setUserNote(String userNote) { this.userNote = userNote; } public static enum Gender {BOY, GIRL} }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 130, "chunk_id": 0, "prompt": {"main_file_path": "ThirdPartyLoginDemo-master/ThirdPartyLoginDemo-master/src/cn/sharesdk/tpl/SignupPage.java", "main_file_content": "package cn.sharesdk.tpl; import java.io.File; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.net.URL; import android.app.Activity; import android.app.Dialog; import android.content.Intent; import android.database.Cursor; import android.graphics.Bitmap; import android.graphics.Bitmap.Config; import android.graphics.BitmapFactory; import android.graphics.drawable.Drawable; import android.net.Uri; import android.os.Environment; import android.os.Handler.Callback; import android.os.Message; import android.provider.MediaStore; import android.text.TextUtils; import android.util.Log; import android.view.View; import android.view.View.OnClickListener; import android.widget.EditText; import android.widget.ImageView; import android.widget.LinearLayout.LayoutParams; import android.widget.TextView; import android.widget.Toast; import cn.sharesdk.demo.tpl.R; import cn.sharesdk.framework.FakeActivity; import cn.sharesdk.framework.Platform; import cn.sharesdk.framework.ShareSDK; import cn.sharesdk.framework.utils.UIHandler; public class SignupPage extends FakeActivity implements OnClickListener, Callback { private enum ChangeUserType {USER_NAME, USER_NOTE}; private static final int SHOW_PROGRESS_DIALOG = 1; private static final int LOAD_USER_ICON = 2; private static final int MSG_SHOW_TOAST = 3; private static final int INTENT_ACTION_PICTURE = 0; private static final int INTENT_ACTION_CAREMA = 1; private static final int INTENT_ACTION_CROP = 2; private static final String PICTURE_NAME = \"userIcon.jpg\"; private OnLoginListener signupListener; private ImageView ivUserIcon; private TextView tvUserName, tvUserGender, tvUserNote, tvEnsure; private Platform platform; private String picturePath; private UserInfo userInfo = new UserInfo(); public void setOnLoginListener(OnLoginListener l) { this.signupListener = l; } @Override public void onCreate() { activity.setContentView(R.layout.tpl_page_signup); activity.findViewById(R.id.ll_back).setOnClickListener(this); tvUserName = (TextView) activity.findViewById(R.id.tv_user_name); tvUserGender = (TextView) activity.findViewById(R.id.tv_user_gender); tvUserNote = (TextView) activity.findViewById(R.id.tv_user_note); tvEnsure = (TextView) activity.findViewById(R.id.tv_ensure); ivUserIcon = (ImageView) activity.findViewById(R.id.iv_user_icon); ivUserIcon.setOnClickListener(this); tvEnsure.setOnClickListener(this); activity.findViewById(R.id.rl_icon).setOnClickListener(this); activity.findViewById(R.id.rl_name).setOnClickListener(this); activity.findViewById(R.id.rl_gender).setOnClickListener(this); activity.findViewById(R.id.rl_note).setOnClickListener(this); initData(); } public void setPlatform(String platName) { platform = ShareSDK.getPlatform(platName); } private void initData(){ String gender = \"\"; if(platform != null){ gender = platform.getDb().getUserGender(); if(gender.equals(\"m\")){ userInfo.setUserGender(UserInfo.Gender.BOY); gender = getContext().getString(R.string.tpl_boy); }else{ userInfo.setUserGender(UserInfo.Gender.GIRL); gender = getContext().getString(R.string.tpl_girl); } userInfo.setUserIcon(platform.getDb().getUserIcon()); userInfo.setUserName(platform.getDb().getUserName()); userInfo.setUserNote(platform.getDb().getUserId()); } tvUserName.setText(userInfo.getUserName()); tvUserGender.setText(gender); tvUserNote.setText(\"USER ID : \" + userInfo.getUserNote()); if(!TextUtils.isEmpty(userInfo.getUserIcon())){ loadIcon(); } if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)){ String thumPicture = Environment.getExternalStorageDirectory().getAbsolutePath()+\"/\"+activity.getPackageName()+\"/download\"; File pictureParent =new File(thumPicture); File pictureFile =new File(pictureParent, PICTURE_NAME); if(!pictureParent.exists()){ pictureParent.mkdirs(); } try{ if (!pictureFile.exists()) { pictureFile.createNewFile(); } }catch (Exception e) { e.printStackTrace(); } picturePath = pictureFile.getAbsolutePath(); Log.e(\"picturePath ==>>\", picturePath); }else{ Log.e(\"change user icon ==>>\", \"there is not sdcard!\"); } } @Override public void onClick(View v) { switch (v.getId()) { case R.id.ll_back: this.finish(); break; case R.id.tv_ensure: UIHandler.sendEmptyMessage(MSG_SHOW_TOAST, SignupPage.this); break; case R.id.rl_icon: getPicture(); break; case R.id.rl_name: showChangeInfo(ChangeUserType.USER_NAME); break; case R.id.rl_gender: showGerderDialog(); break; case R.id.rl_note: showChangeInfo(ChangeUserType.USER_NOTE); break; case R.id.iv_user_icon: PicViewer pv = new PicViewer(); pv.setImagePath(userInfo.getUserIcon()); pv.show(activity, null); break; default: break; } } @Override public boolean handleMessage(Message msg) { switch (msg.what) { case SHOW_PROGRESS_DIALOG: break; case LOAD_USER_ICON: ivUserIcon.setImageURI(Uri.parse(picturePath)); break; case MSG_SHOW_TOAST: if (signupListener != null) { if (signupListener.onSignUp(userInfo) ) { Toast.makeText(activity, R.string.signup_success, Toast.LENGTH_SHORT).show(); finish(); } else { Toast.makeText(activity, R.string.signup_failed, Toast.LENGTH_SHORT).show(); } } break; default: break; } return false; } public void loadIcon() { final String imageUrl = platform.getDb().getUserIcon(); new Thread(new Runnable() { @Override public void run() { try { URL picUrl = new URL(imageUrl); Bitmap userIcon = BitmapFactory.decodeStream(picUrl.openStream()); FileOutputStream b = null; try { b = new FileOutputStream(picturePath); userIcon.compress(Bitmap.CompressFormat.JPEG, 100, b); } catch (FileNotFoundException e) { e.printStackTrace(); } finally { try { b.flush(); b.close(); } catch (IOException e) { e.printStackTrace(); } } userInfo.setUserIcon(picturePath); Message msg = new Message(); msg.what = LOAD_USER_ICON; UIHandler.sendMessage(msg, SignupPage.this); } catch (Exception e) { e.printStackTrace(); } } }).start(); } @Override public void onActivityResult(int requestCode, int resultCode, Intent data) { if(requestCode == INTENT_ACTION_PICTURE && resultCode == Activity.RESULT_OK && null != data){ Cursor c = activity.getContentResolver().query(data.getData(), null, null, null, null); c.moveToNext(); String path = c.getString(c.getColumnIndex(MediaStore.MediaColumns.DATA)); c.close(); soutl(\"\") if(new File(path).exists()){ soutl(\"\") userInfo.setUserIcon(path); ivUserIcon.setImageBitmap(compressImageFromFile(path)); } }else if(requestCode == INTENT_ACTION_CAREMA && resultCode == Activity.RESULT_OK){ userInfo.setUserIcon(picturePath); ivUserIcon.setImageDrawable(Drawable.createFromPath(picturePath)); }else if(requestCode == INTENT_ACTION_CROP && resultCode == Activity.RESULT_OK && null != data){ ivUserIcon.setImageDrawable(Drawable.createFromPath(picturePath)); } } private void showChangeIconDialog(){ final Dialog dialog = new Dialog(getContext(), R.style.WhiteDialog); dialog.setContentView(R.layout.tpl_icon_select_dialog); dialog.findViewById(R.id.dialog_camera).setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { dialog.dismiss(); openCamera(); } }); dialog.findViewById(R.id.dialog_picture).setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { dialog.dismiss(); getPicture(); } }); dialog.show(); } private void getPicture(){ Intent intent = new Intent(Intent.ACTION_PICK); intent.setType(\"image private void openCamera(){ Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(new File(picturePath))); intent.putExtra(MediaStore.EXTRA_VIDEO_QUALITY, 1); startActivityForResult(intent, INTENT_ACTION_CAREMA); } private void openCrop(Uri uri){ Intent intent = new Intent(\"com.android.camera.action.CROP\"); intent.setDataAndType(uri, \"image private void showGerderDialog(){ final Dialog dialog = new Dialog(getContext(), R.style.WhiteDialog); dialog.setContentView(R.layout.tpl_gender_select_dialog); final ImageView ivBoy = (ImageView) dialog.findViewById(R.id.dialog_iv_boy); final ImageView ivGirl = (ImageView) dialog.findViewById(R.id.dialog_iv_girl); if(userInfo.getUserGender() == UserInfo.Gender.BOY){ ivGirl.setVisibility(View.GONE); ivBoy.setVisibility(View.VISIBLE); }else{ ivBoy.setVisibility(View.GONE); ivGirl.setVisibility(View.VISIBLE); } dialog.findViewById(R.id.rl_boy).setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { ivGirl.setVisibility(View.GONE); ivBoy.setVisibility(View.VISIBLE); tvUserGender.setText(R.string.tpl_boy); userInfo.setUserGender(UserInfo.Gender.BOY); dialog.dismiss(); } }); dialog.findViewById(R.id.rl_girl).setOnClickListener(new OnClickListener(){ @Override public void onClick(View v) { ivGirl.setVisibility(View.VISIBLE); ivBoy.setVisibility(View.GONE); tvUserGender.setText(R.string.tpl_girl); userInfo.setUserGender(UserInfo.Gender.GIRL); dialog.dismiss(); } }); dialog.show(); } private void showChangeInfo(final ChangeUserType type){ String title; String content; String hint; if(type == ChangeUserType.USER_NAME){ content = tvUserName.getText().toString(); title = getContext().getString(R.string.tpl_change_user_name_title); hint = getContext().getString(R.string.tpl_input_user_name_hint); }else{ content = tvUserNote.getText().toString(); title = getContext().getString(R.string.tpl_change_user_note_title); hint = getContext().getString(R.string.tpl_input_user_note_hint); } View dlgView = View.inflate(activity, R.layout.tpl_change_userinfo_dialog, null); LayoutParams layoutParams = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT); final Dialog dialog = new Dialog(getContext(), R.style.WhiteDialog); dialog.setContentView(dlgView, layoutParams); final TextView tvTitle = (TextView) dialog.findViewById(R.id.dialog_tv_title); final EditText etInfo = (EditText) dialog.findViewById(R.id.dialog_ev_info); final TextView tvHint = (TextView) dialog.findViewById(R.id.dialog_tv_hint); tvTitle.setText(title); etInfo.setText(content); tvHint.setText(hint); dialog.findViewById(R.id.dialog_btn_save).setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { String content = etInfo.getText().toString(); if(type == ChangeUserType.USER_NAME){ tvUserName.setText(content); userInfo.setUserName(content); }else{ tvUserNote.setText(content); userInfo.setUserNote(content); } dialog.dismiss(); } }); dialog.show(); } private Bitmap compressImageFromFile(String srcPath) { BitmapFactory.Options newOpts = new BitmapFactory.Options(); newOpts.inJustDecodeBounds = true; Bitmap bitmap = BitmapFactory.decodeFile(srcPath, newOpts); newOpts.inJustDecodeBounds = false; int w = newOpts.outWidth; int h = newOpts.outHeight; float hh = 800f; float ww = 480f; int be = 1; if (w > h && w > ww) { be = (int) (newOpts.outWidth / ww); } else if (w < h && h > hh) { be = (int) (newOpts.outHeight / hh); } if (be <= 0) be = 1; newOpts.inSampleSize = be; newOpts.inPreferredConfig = Config.ARGB_8888; newOpts.inPurgeable = true; newOpts.inInputShareable = true; bitmap = BitmapFactory.decodeFile(srcPath, newOpts); return bitmap; } }", "dependencies": [{"file_path": "ThirdPartyLoginDemo-master/ThirdPartyLoginDemo-master/gen/cn/sharesdk/demo/tpl/R.java", "file_content": "package cn.sharesdk.demo.tpl; public final class R { public static final class attr { } public static final class color { public static final int dialog_white_bg=0x7f040004; public static final int login_with_other_plat_text_color=0x7f040003; public static final int logo_text_color=0x7f040001; public static final int page_back=0x7f040000; public static final int white=0x7f040002; } public static final class drawable { public static final int checked=0x7f020000; public static final int dialog_et_bg=0x7f020001; public static final int et_bg=0x7f020002; public static final int ic_launcher=0x7f020003; public static final int logo_facebook=0x7f020004; public static final int logo_qq=0x7f020005; public static final int logo_qzone=0x7f020006; public static final int logo_sinaweibo=0x7f020007; public static final int logo_tencentweibo=0x7f020008; public static final int logo_twitter=0x7f020009; public static final int msg_login=0x7f02000a; public static final int other_login=0x7f02000b; public static final int qq_login=0x7f02000c; public static final int ssdk_auth_title_back=0x7f02000d; public static final int ssdk_back_arr=0x7f02000e; public static final int ssdk_logo=0x7f02000f; public static final int ssdk_title_div=0x7f020010; public static final int tpl_logo=0x7f020011; public static final int tpl_title_back_arrow=0x7f020012; public static final int user_icon=0x7f020013; public static final int wechat_login=0x7f020014; public static final int weibo_login=0x7f020015; } public static final class id { public static final int btn_get_verify_code=0x7f080013; public static final int btn_send_verify_code=0x7f080015; public static final int dialog_btn_save=0x7f080001; public static final int dialog_camera=0x7f08000a; public static final int dialog_ev_info=0x7f080002; public static final int dialog_iv_boy=0x7f080006; public static final int dialog_iv_girl=0x7f080009; public static final int dialog_picture=0x7f08000b; public static final int dialog_tv_boy=0x7f080005; public static final int dialog_tv_girl=0x7f080008; public static final int dialog_tv_hint=0x7f080003; public static final int dialog_tv_title=0x7f080000; public static final int et_phone=0x7f080012; public static final int et_verify_code=0x7f080014; public static final int iv_user_icon=0x7f08001a; public static final int ll_back=0x7f080021; public static final int ll_title_bar=0x7f080018; public static final int rl_boy=0x7f080004; public static final int rl_gender=0x7f08001d; public static final int rl_girl=0x7f080007; public static final int rl_icon=0x7f080019; public static final int rl_name=0x7f08001b; public static final int rl_note=0x7f08001f; public static final int textView1=0x7f08000c; public static final int tvFacebook=0x7f080016; public static final int tvMsgRegister=0x7f08000d; public static final int tvOther=0x7f080011; public static final int tvQq=0x7f080010; public static final int tvTwitter=0x7f080017; public static final int tvWeibo=0x7f08000f; public static final int tvWeixin=0x7f08000e; public static final int tv_ensure=0x7f080023; public static final int tv_title=0x7f080022; public static final int tv_user_gender=0x7f08001e; public static final int tv_user_name=0x7f08001c; public static final int tv_user_note=0x7f080020; } public static final class integer { public static final int app_version_code=0x7f060000; } public static final class layout { public static final int tpl_change_userinfo_dialog=0x7f030000; public static final int tpl_gender_select_dialog=0x7f030001; public static final int tpl_icon_select_dialog=0x7f030002; public static final int tpl_login_page=0x7f030003; public static final int tpl_msg_login_dialog=0x7f030004; public static final int tpl_other_plat_dialog=0x7f030005; public static final int tpl_page_signup=0x7f030006; public static final int tpl_progress_dialog=0x7f030007; public static final int tpl_title_layout=0x7f030008; } public static final class string { public static final int after_auth=0x7f05003f; public static final int app_name=0x7f050030; public static final int app_version=0x7f050031; public static final int auth_cancel=0x7f05003b; public static final int auth_complete=0x7f05003d; public static final int auth_error=0x7f05003c; public static final int douban=0x7f050019; public static final int dropbox=0x7f050023; public static final int email=0x7f050014; public static final int evernote=0x7f05001b; public static final int facebook=0x7f050010; public static final int flickr=0x7f050021; public static final int foursquare=0x7f05001e; public static final int google_plus_client_inavailable=0x7f050004; public static final int googleplus=0x7f05001d; public static final int if_register_needed=0x7f05003e; public static final int instagram=0x7f050025; public static final int instagram_client_inavailable=0x7f050007; public static final int kaixin=0x7f050013; public static final int line=0x7f050029; public static final int line_client_inavailable=0x7f050009; public static final int linkedin=0x7f05001c; public static final int login_with_msg=0x7f050034; public static final int login_with_other_plat=0x7f050038; public static final int login_with_qzone=0x7f050037; public static final int login_with_sina_weibo=0x7f050036; public static final int login_with_weixin=0x7f050035; public static final int logining=0x7f05003a; public static final int mingdao=0x7f050028; public static final int mingdao_share_content=0x7f05002c; public static final int neteasemicroblog=0x7f050018; public static final int pinterest=0x7f050020; public static final int pinterest_client_inavailable=0x7f050006; public static final int proj_name=0x7f050032; public static final int qq=0x7f05001f; public static final int qq_client_inavailable=0x7f050005; public static final int qzone=0x7f05000c; public static final int renren=0x7f050012; public static final int share_sdk=0x7f050033; public static final int share_to_mingdao=0x7f05002d; public static final int share_to_qq=0x7f05002b; public static final int share_to_qzone=0x7f05002a; public static final int share_to_qzone_default=0x7f05002e; public static final int shortmessage=0x7f050015; public static final int signup_failed=0x7f050059; public static final int signup_success=0x7f050058; public static final int sinaweibo=0x7f05000a; public static final int sohumicroblog=0x7f050016; public static final int sohusuishenkan=0x7f050017; public static final int tencentweibo=0x7f05000b; public static final int tpl_boy=0x7f05004c; public static final int tpl_camera=0x7f05004d; public static final int tpl_cancel=0x7f050041; public static final int tpl_change_user_name_title=0x7f05004f; public static final int tpl_change_user_note_title=0x7f050050; public static final int tpl_get_verify_code=0x7f050056; public static final int tpl_girl=0x7f05004b; public static final int tpl_input_user_name_hint=0x7f050051; public static final int tpl_input_user_note_hint=0x7f050052; public static final int tpl_key_user_gender=0x7f050044; public static final int tpl_key_user_icon=0x7f050042; public static final int tpl_key_user_name=0x7f050043; public static final int tpl_key_user_note=0x7f050045; public static final int tpl_msg_login_hint=0x7f050054; public static final int tpl_no_sdcard=0x7f050053; public static final int tpl_ok=0x7f050040; public static final int tpl_picture=0x7f05004e; public static final int tpl_send_verify_code=0x7f050057; public static final int tpl_sign_up=0x7f05004a; public static final int tpl_sign_user_info=0x7f050049; public static final int tpl_value_user_gender=0x7f050047; public static final int tpl_value_user_name=0x7f050046; public static final int tpl_value_user_note=0x7f050048; public static final int tpl_verify_code_hint=0x7f050055; public static final int tumblr=0x7f050022; public static final int twitter=0x7f050011; public static final int use_login_button=0x7f05002f; public static final int userid_found=0x7f050039; public static final int vkontakte=0x7f050024; public static final int website=0x7f050001; public static final int wechat=0x7f05000d; public static final int wechat_client_inavailable=0x7f050003; public static final int wechatfavorite=0x7f05000f; public static final int wechatmoments=0x7f05000e; public static final int weibo_oauth_regiseter=0x7f050000; public static final int weibo_upload_content=0x7f050002; public static final int yixin=0x7f050026; public static final int yixin_client_inavailable=0x7f050008; public static final int yixinmoments=0x7f050027; public static final int youdao=0x7f05001a; } public static final class style { public static final int AppTheme=0x7f070000; public static final int CommonDialog=0x7f070001; public static final int WhiteDialog=0x7f070002; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "ThirdPartyLoginDemo-master/ThirdPartyLoginDemo-master/src/cn/sharesdk/tpl/SignupPage.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "SignupPage handles UI interactions, image processing, user data management, and platform communication. This consolidation of multiple responsibilities violates SRP."}, {"principle": "Open/Closed", "justification": "Adding new user information fields or modifying dialog types would require direct modification of SignupPage's existing code rather than extension, violating OCP."}, {"principle": "Dependency Inversion", "justification": "SignupPage directly depends on concrete Platform/ShareSDK implementations instead of abstractions. High-level signup logic is tightly coupled to low-level platform details."}]}]}
{"project_id": 130, "chunk_id": 1, "prompt": {"main_file_path": "ThirdPartyLoginDemo-master/ThirdPartyLoginDemo-master/src/cn/sharesdk/tpl/SignupPage.java", "main_file_content": "package cn.sharesdk.tpl; import java.io.File; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.net.URL; import android.app.Activity; import android.app.Dialog; import android.content.Intent; import android.database.Cursor; import android.graphics.Bitmap; import android.graphics.Bitmap.Config; import android.graphics.BitmapFactory; import android.graphics.drawable.Drawable; import android.net.Uri; import android.os.Environment; import android.os.Handler.Callback; import android.os.Message; import android.provider.MediaStore; import android.text.TextUtils; import android.util.Log; import android.view.View; import android.view.View.OnClickListener; import android.widget.EditText; import android.widget.ImageView; import android.widget.LinearLayout.LayoutParams; import android.widget.TextView; import android.widget.Toast; import cn.sharesdk.demo.tpl.R; import cn.sharesdk.framework.FakeActivity; import cn.sharesdk.framework.Platform; import cn.sharesdk.framework.ShareSDK; import cn.sharesdk.framework.utils.UIHandler; public class SignupPage extends FakeActivity implements OnClickListener, Callback { private enum ChangeUserType {USER_NAME, USER_NOTE}; private static final int SHOW_PROGRESS_DIALOG = 1; private static final int LOAD_USER_ICON = 2; private static final int MSG_SHOW_TOAST = 3; private static final int INTENT_ACTION_PICTURE = 0; private static final int INTENT_ACTION_CAREMA = 1; private static final int INTENT_ACTION_CROP = 2; private static final String PICTURE_NAME = \"userIcon.jpg\"; private OnLoginListener signupListener; private ImageView ivUserIcon; private TextView tvUserName, tvUserGender, tvUserNote, tvEnsure; private Platform platform; private String picturePath; private UserInfo userInfo = new UserInfo(); public void setOnLoginListener(OnLoginListener l) { this.signupListener = l; } @Override public void onCreate() { activity.setContentView(R.layout.tpl_page_signup); activity.findViewById(R.id.ll_back).setOnClickListener(this); tvUserName = (TextView) activity.findViewById(R.id.tv_user_name); tvUserGender = (TextView) activity.findViewById(R.id.tv_user_gender); tvUserNote = (TextView) activity.findViewById(R.id.tv_user_note); tvEnsure = (TextView) activity.findViewById(R.id.tv_ensure); ivUserIcon = (ImageView) activity.findViewById(R.id.iv_user_icon); ivUserIcon.setOnClickListener(this); tvEnsure.setOnClickListener(this); activity.findViewById(R.id.rl_icon).setOnClickListener(this); activity.findViewById(R.id.rl_name).setOnClickListener(this); activity.findViewById(R.id.rl_gender).setOnClickListener(this); activity.findViewById(R.id.rl_note).setOnClickListener(this); initData(); } public void setPlatform(String platName) { platform = ShareSDK.getPlatform(platName); } private void initData(){ String gender = \"\"; if(platform != null){ gender = platform.getDb().getUserGender(); if(gender.equals(\"m\")){ userInfo.setUserGender(UserInfo.Gender.BOY); gender = getContext().getString(R.string.tpl_boy); }else{ userInfo.setUserGender(UserInfo.Gender.GIRL); gender = getContext().getString(R.string.tpl_girl); } userInfo.setUserIcon(platform.getDb().getUserIcon()); userInfo.setUserName(platform.getDb().getUserName()); userInfo.setUserNote(platform.getDb().getUserId()); } tvUserName.setText(userInfo.getUserName()); tvUserGender.setText(gender); tvUserNote.setText(\"USER ID : \" + userInfo.getUserNote()); if(!TextUtils.isEmpty(userInfo.getUserIcon())){ loadIcon(); } if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)){ String thumPicture = Environment.getExternalStorageDirectory().getAbsolutePath()+\"/\"+activity.getPackageName()+\"/download\"; File pictureParent =new File(thumPicture); File pictureFile =new File(pictureParent, PICTURE_NAME); if(!pictureParent.exists()){ pictureParent.mkdirs(); } try{ if (!pictureFile.exists()) { pictureFile.createNewFile(); } }catch (Exception e) { e.printStackTrace(); } picturePath = pictureFile.getAbsolutePath(); Log.e(\"picturePath ==>>\", picturePath); }else{ Log.e(\"change user icon ==>>\", \"there is not sdcard!\"); } } @Override public void onClick(View v) { switch (v.getId()) { case R.id.ll_back: this.finish(); break; case R.id.tv_ensure: UIHandler.sendEmptyMessage(MSG_SHOW_TOAST, SignupPage.this); break; case R.id.rl_icon: getPicture(); break; case R.id.rl_name: showChangeInfo(ChangeUserType.USER_NAME); break; case R.id.rl_gender: showGerderDialog(); break; case R.id.rl_note: showChangeInfo(ChangeUserType.USER_NOTE); break; case R.id.iv_user_icon: PicViewer pv = new PicViewer(); pv.setImagePath(userInfo.getUserIcon()); pv.show(activity, null); break; default: break; } } @Override public boolean handleMessage(Message msg) { switch (msg.what) { case SHOW_PROGRESS_DIALOG: break; case LOAD_USER_ICON: ivUserIcon.setImageURI(Uri.parse(picturePath)); break; case MSG_SHOW_TOAST: if (signupListener != null) { if (signupListener.onSignUp(userInfo) ) { Toast.makeText(activity, R.string.signup_success, Toast.LENGTH_SHORT).show(); finish(); } else { Toast.makeText(activity, R.string.signup_failed, Toast.LENGTH_SHORT).show(); } } break; default: break; } return false; } public void loadIcon() { final String imageUrl = platform.getDb().getUserIcon(); new Thread(new Runnable() { @Override public void run() { try { URL picUrl = new URL(imageUrl); Bitmap userIcon = BitmapFactory.decodeStream(picUrl.openStream()); FileOutputStream b = null; try { b = new FileOutputStream(picturePath); userIcon.compress(Bitmap.CompressFormat.JPEG, 100, b); } catch (FileNotFoundException e) { e.printStackTrace(); } finally { try { b.flush(); b.close(); } catch (IOException e) { e.printStackTrace(); } } userInfo.setUserIcon(picturePath); Message msg = new Message(); msg.what = LOAD_USER_ICON; UIHandler.sendMessage(msg, SignupPage.this); } catch (Exception e) { e.printStackTrace(); } } }).start(); } @Override public void onActivityResult(int requestCode, int resultCode, Intent data) { if(requestCode == INTENT_ACTION_PICTURE && resultCode == Activity.RESULT_OK && null != data){ Cursor c = activity.getContentResolver().query(data.getData(), null, null, null, null); c.moveToNext(); String path = c.getString(c.getColumnIndex(MediaStore.MediaColumns.DATA)); c.close(); soutl(\"\") if(new File(path).exists()){ soutl(\"\") userInfo.setUserIcon(path); ivUserIcon.setImageBitmap(compressImageFromFile(path)); } }else if(requestCode == INTENT_ACTION_CAREMA && resultCode == Activity.RESULT_OK){ userInfo.setUserIcon(picturePath); ivUserIcon.setImageDrawable(Drawable.createFromPath(picturePath)); }else if(requestCode == INTENT_ACTION_CROP && resultCode == Activity.RESULT_OK && null != data){ ivUserIcon.setImageDrawable(Drawable.createFromPath(picturePath)); } } private void showChangeIconDialog(){ final Dialog dialog = new Dialog(getContext(), R.style.WhiteDialog); dialog.setContentView(R.layout.tpl_icon_select_dialog); dialog.findViewById(R.id.dialog_camera).setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { dialog.dismiss(); openCamera(); } }); dialog.findViewById(R.id.dialog_picture).setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { dialog.dismiss(); getPicture(); } }); dialog.show(); } private void getPicture(){ Intent intent = new Intent(Intent.ACTION_PICK); intent.setType(\"image private void openCamera(){ Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(new File(picturePath))); intent.putExtra(MediaStore.EXTRA_VIDEO_QUALITY, 1); startActivityForResult(intent, INTENT_ACTION_CAREMA); } private void openCrop(Uri uri){ Intent intent = new Intent(\"com.android.camera.action.CROP\"); intent.setDataAndType(uri, \"image private void showGerderDialog(){ final Dialog dialog = new Dialog(getContext(), R.style.WhiteDialog); dialog.setContentView(R.layout.tpl_gender_select_dialog); final ImageView ivBoy = (ImageView) dialog.findViewById(R.id.dialog_iv_boy); final ImageView ivGirl = (ImageView) dialog.findViewById(R.id.dialog_iv_girl); if(userInfo.getUserGender() == UserInfo.Gender.BOY){ ivGirl.setVisibility(View.GONE); ivBoy.setVisibility(View.VISIBLE); }else{ ivBoy.setVisibility(View.GONE); ivGirl.setVisibility(View.VISIBLE); } dialog.findViewById(R.id.rl_boy).setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { ivGirl.setVisibility(View.GONE); ivBoy.setVisibility(View.VISIBLE); tvUserGender.setText(R.string.tpl_boy); userInfo.setUserGender(UserInfo.Gender.BOY); dialog.dismiss(); } }); dialog.findViewById(R.id.rl_girl).setOnClickListener(new OnClickListener(){ @Override public void onClick(View v) { ivGirl.setVisibility(View.VISIBLE); ivBoy.setVisibility(View.GONE); tvUserGender.setText(R.string.tpl_girl); userInfo.setUserGender(UserInfo.Gender.GIRL); dialog.dismiss(); } }); dialog.show(); } private void showChangeInfo(final ChangeUserType type){ String title; String content; String hint; if(type == ChangeUserType.USER_NAME){ content = tvUserName.getText().toString(); title = getContext().getString(R.string.tpl_change_user_name_title); hint = getContext().getString(R.string.tpl_input_user_name_hint); }else{ content = tvUserNote.getText().toString(); title = getContext().getString(R.string.tpl_change_user_note_title); hint = getContext().getString(R.string.tpl_input_user_note_hint); } View dlgView = View.inflate(activity, R.layout.tpl_change_userinfo_dialog, null); LayoutParams layoutParams = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT); final Dialog dialog = new Dialog(getContext(), R.style.WhiteDialog); dialog.setContentView(dlgView, layoutParams); final TextView tvTitle = (TextView) dialog.findViewById(R.id.dialog_tv_title); final EditText etInfo = (EditText) dialog.findViewById(R.id.dialog_ev_info); final TextView tvHint = (TextView) dialog.findViewById(R.id.dialog_tv_hint); tvTitle.setText(title); etInfo.setText(content); tvHint.setText(hint); dialog.findViewById(R.id.dialog_btn_save).setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { String content = etInfo.getText().toString(); if(type == ChangeUserType.USER_NAME){ tvUserName.setText(content); userInfo.setUserName(content); }else{ tvUserNote.setText(content); userInfo.setUserNote(content); } dialog.dismiss(); } }); dialog.show(); } private Bitmap compressImageFromFile(String srcPath) { BitmapFactory.Options newOpts = new BitmapFactory.Options(); newOpts.inJustDecodeBounds = true; Bitmap bitmap = BitmapFactory.decodeFile(srcPath, newOpts); newOpts.inJustDecodeBounds = false; int w = newOpts.outWidth; int h = newOpts.outHeight; float hh = 800f; float ww = 480f; int be = 1; if (w > h && w > ww) { be = (int) (newOpts.outWidth / ww); } else if (w < h && h > hh) { be = (int) (newOpts.outHeight / hh); } if (be <= 0) be = 1; newOpts.inSampleSize = be; newOpts.inPreferredConfig = Config.ARGB_8888; newOpts.inPurgeable = true; newOpts.inInputShareable = true; bitmap = BitmapFactory.decodeFile(srcPath, newOpts); return bitmap; } }", "dependencies": [{"file_path": "ThirdPartyLoginDemo-master/ThirdPartyLoginDemo-master/src/cn/sharesdk/tpl/UserInfo.java", "file_content": "package cn.sharesdk.tpl; public class UserInfo { private String userIcon; private String userName; private Gender userGender; private String userNote; public String getUserIcon() { return userIcon; } public void setUserIcon(String userIcon) { this.userIcon = userIcon; } public String getUserName() { return userName; } public void setUserName(String userName) { this.userName = userName; } public Gender getUserGender() { return userGender; } public void setUserGender(Gender userGender) { this.userGender = userGender; } public String getUserNote() { return userNote; } public void setUserNote(String userNote) { this.userNote = userNote; } public static enum Gender {BOY, GIRL} }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "ThirdPartyLoginDemo-master/ThirdPartyLoginDemo-master/src/cn/sharesdk/tpl/SignupPage.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "SignupPage handles UI interactions, image loading, camera/gallery intents, data persistence, and network operations. This indicates multiple responsibilities beyond managing user signup flows."}, {"principle": "Open-Closed", "justification": "Adding new user information fields or modifying dialog behaviors would require direct modifications to SignupPage rather than extension through inheritance/abstractions."}, {"principle": "Dependency Inversion", "justification": "Direct dependency on concrete Platform and ShareSDK classes instead of abstractions. High-level signup logic is tightly coupled to low-level platform implementation details."}]}]}
{"project_id": 130, "chunk_id": 0, "prompt": {"main_file_path": "ThirdPartyLoginDemo-master/ThirdPartyLoginDemo-master/src/cn/sharesdk/demo/tpl/LoginActivity.java", "main_file_content": "package cn.sharesdk.demo.tpl; import java.util.HashMap; import cn.sharesdk.tpl.OnLoginListener; import cn.sharesdk.tpl.ThirdPartyLogin; import cn.sharesdk.tpl.UserInfo; import android.app.Activity; import android.app.AlertDialog.Builder; import android.content.DialogInterface; import android.content.DialogInterface.OnClickListener; import android.os.Bundle; public class LoginActivity extends Activity { private static String APPKEY = \"27fe7909f8e8\"; private static String APPSECRET = \"3c5264e7e05b8860a9b98b34506cfa6e\"; protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Builder builder = new Builder(LoginActivity.this); builder.setTitle(R.string.if_register_needed); builder.setMessage(R.string.after_auth); builder.setPositiveButton(R.string.tpl_ok, new OnClickListener() { public void onClick(DialogInterface dialog, int which) { showDemo(); finish(); } }); builder.create().show(); } private void showDemo() { ThirdPartyLogin tpl = new ThirdPartyLogin(); tpl.setSMSSDKAppkey(APPKEY, APPSECRET); tpl.setOnLoginListener(new OnLoginListener() { public boolean onSignin(String platform, HashMap<String, Object> res) { return true; } public boolean onSignUp(UserInfo info) { return true; } }); tpl.show(this); } }", "dependencies": [{"file_path": "ThirdPartyLoginDemo-master/ThirdPartyLoginDemo-master/src/cn/sharesdk/tpl/OnLoginListener.java", "file_content": "package cn.sharesdk.tpl; import java.util.HashMap; public interface OnLoginListener { public boolean onSignin(String platform, HashMap<String, Object> res); public boolean onSignUp(UserInfo info) ; }"}, {"file_path": "ThirdPartyLoginDemo-master/ThirdPartyLoginDemo-master/src/cn/sharesdk/tpl/ThirdPartyLogin.java", "file_content": "package cn.sharesdk.tpl; import java.util.HashMap; import android.app.Dialog; import android.content.Context; import android.os.Handler; import android.os.Handler.Callback; import android.os.Message; import android.text.TextUtils; import android.view.View; import android.view.Window; import android.view.View.OnClickListener; import android.widget.Button; import android.widget.EditText; import android.widget.Toast; import cn.sharesdk.demo.tpl.R; import cn.sharesdk.facebook.Facebook; import cn.sharesdk.framework.FakeActivity; import cn.sharesdk.framework.Platform; import cn.sharesdk.framework.PlatformActionListener; import cn.sharesdk.framework.ShareSDK; import cn.sharesdk.sina.weibo.SinaWeibo; import cn.sharesdk.tencent.qzone.QZone; import cn.sharesdk.twitter.Twitter; import cn.sharesdk.wechat.friends.Wechat; import cn.smssdk.EventHandler; import cn.smssdk.SMSSDK; public class ThirdPartyLogin extends FakeActivity implements OnClickListener, Callback, PlatformActionListener { private static final int MSG_SMSSDK_CALLBACK = 1; private static final int MSG_AUTH_CANCEL = 2; private static final int MSG_AUTH_ERROR= 3; private static final int MSG_AUTH_COMPLETE = 4; private String smssdkAppkey; private String smssdkAppSecret; private OnLoginListener signupListener; private Handler handler; private Dialog msgLoginDlg; public void setSMSSDKAppkey(String appkey, String appSecret) { smssdkAppkey = appkey; smssdkAppSecret = appSecret; } public void setOnLoginListener(OnLoginListener l) { this.signupListener = l; } public void onCreate() { handler = new Handler(this); activity.setContentView(R.layout.tpl_login_page); (activity.findViewById(R.id.tvMsgRegister)).setOnClickListener(this); (activity.findViewById(R.id.tvWeixin)).setOnClickListener(this); (activity.findViewById(R.id.tvWeibo)).setOnClickListener(this); (activity.findViewById(R.id.tvQq)).setOnClickListener(this); (activity.findViewById(R.id.tvOther)).setOnClickListener(this); } public void onDestroy() { SMSSDK.unregisterAllEventHandler(); } public void onClick(View v) { switch(v.getId()) { case R.id.tvMsgRegister: { popupMsgLogin(); } break; case R.id.tvWeixin: { Platform wechat = ShareSDK.getPlatform(Wechat.NAME); authorize(wechat); } break; case R.id.tvWeibo: { Platform sina = ShareSDK.getPlatform(SinaWeibo.NAME); authorize(sina); } break; case R.id.tvQq: { Platform qzone = ShareSDK.getPlatform(QZone.NAME); authorize(qzone); } break; case R.id.tvOther: { authorize(null); } break; case R.id.tvFacebook: { Dialog dlg = (Dialog) v.getTag(); dlg.dismiss(); Platform facebook = ShareSDK.getPlatform(Facebook.NAME); authorize(facebook); } break; case R.id.tvTwitter: { Dialog dlg = (Dialog) v.getTag(); dlg.dismiss(); Platform twitter = ShareSDK.getPlatform(Twitter.NAME); authorize(twitter); } break; } } private void popupMsgLogin() { msgLoginDlg = new Dialog(activity, R.style.WhiteDialog); View dlgView = View.inflate(activity, R.layout.tpl_msg_login_dialog, null); final EditText etPhone = (EditText) dlgView.findViewById(R.id.et_phone); final EditText etVerifyCode = (EditText) dlgView.findViewById(R.id.et_verify_code); Button btnGetVerifyCode = (Button) dlgView.findViewById(R.id.btn_get_verify_code); Button btnSendVerifyCode = (Button) dlgView.findViewById(R.id.btn_send_verify_code); btnGetVerifyCode.setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { String phone = etPhone.getText().toString(); if(TextUtils.isEmpty(phone)){ Toast.makeText(activity, \"\u8bf7\u8f93\u5165\u624b\u673a\u53f7\u7801\", Toast.LENGTH_SHORT).show(); }else{ SMSSDK.getVerificationCode(\"86\", phone); } } }); btnSendVerifyCode.setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { String phone = etPhone.getText().toString(); String verifyCode = etVerifyCode.getText().toString(); if(TextUtils.isEmpty(verifyCode)){ Toast.makeText(activity, \"\u8bf7\u8f93\u5165\u9a8c\u8bc1\u7801\", Toast.LENGTH_SHORT).show(); }else{ SMSSDK.submitVerificationCode(\"86\", phone, verifyCode); } } }); msgLoginDlg.requestWindowFeature(Window.FEATURE_NO_TITLE); msgLoginDlg.setContentView(dlgView); msgLoginDlg.show(); } private void authorize(Platform plat) { if (plat == null) { popupOthers(); return; } plat.setPlatformActionListener(this); plat.SSOSetting(true); plat.showUser(null); } private void popupOthers() { Dialog dlg = new Dialog(activity, R.style.WhiteDialog); View dlgView = View.inflate(activity, R.layout.tpl_other_plat_dialog, null); View tvFacebook = dlgView.findViewById(R.id.tvFacebook); tvFacebook.setTag(dlg); tvFacebook.setOnClickListener(this); View tvTwitter = dlgView.findViewById(R.id.tvTwitter); tvTwitter.setTag(dlg); tvTwitter.setOnClickListener(this); dlg.requestWindowFeature(Window.FEATURE_NO_TITLE); dlg.setContentView(dlgView); dlg.show(); } public void onComplete(Platform platform, int action, HashMap<String, Object> res) { if (action == Platform.ACTION_USER_INFOR) { Message msg = new Message(); msg.what = MSG_AUTH_COMPLETE; msg.obj = new Object[] {platform.getName(), res}; handler.sendMessage(msg); } } public void onError(Platform platform, int action, Throwable t) { if (action == Platform.ACTION_USER_INFOR) { handler.sendEmptyMessage(MSG_AUTH_ERROR); } t.printStackTrace(); } public void onCancel(Platform platform, int action) { if (action == Platform.ACTION_USER_INFOR) { handler.sendEmptyMessage(MSG_AUTH_CANCEL); } } @SuppressWarnings(\"unchecked\") public boolean handleMessage(Message msg) { switch(msg.what) { case MSG_AUTH_CANCEL: { Toast.makeText(activity, R.string.auth_cancel, Toast.LENGTH_SHORT).show(); } break; case MSG_AUTH_ERROR: { Toast.makeText(activity, R.string.auth_error, Toast.LENGTH_SHORT).show(); } break; case MSG_AUTH_COMPLETE: { Toast.makeText(activity, R.string.auth_complete, Toast.LENGTH_SHORT).show(); Object[] objs = (Object[]) msg.obj; String platform = (String) objs[0]; HashMap<String, Object> res = (HashMap<String, Object>) objs[1]; if (signupListener != null && signupListener.onSignin(platform, res)) { SignupPage signupPage = new SignupPage(); signupPage.setOnLoginListener(signupListener); signupPage.setPlatform(platform); signupPage.show(activity, null); } } break; case MSG_SMSSDK_CALLBACK: { if (msg.arg2 == SMSSDK.RESULT_ERROR) { Toast.makeText(activity, \"\u64cd\u4f5c\u5931\u8d25\", Toast.LENGTH_SHORT).show(); } else { switch (msg.arg1) { case SMSSDK.EVENT_SUBMIT_VERIFICATION_CODE: { if(msgLoginDlg != null && msgLoginDlg.isShowing()){ msgLoginDlg.dismiss(); } Toast.makeText(activity, \"\u63d0\u4ea4\u9a8c\u8bc1\u7801\u6210\u529f\", Toast.LENGTH_SHORT).show(); Message m = new Message(); m.what = MSG_AUTH_COMPLETE; m.obj = new Object[] {\"SMSSDK\", (HashMap<String, Object>) msg.obj}; handler.sendMessage(m); } break; case SMSSDK.EVENT_GET_VERIFICATION_CODE:{ Toast.makeText(activity, \"\u9a8c\u8bc1\u7801\u5df2\u7ecf\u53d1\u9001\", Toast.LENGTH_SHORT).show(); } break; } } } break; } return false; } public void show(Context context) { initSDK(context); super.show(context, null); } private void initSDK(Context context) { ShareSDK.initSDK(context); SMSSDK.initSDK(context, smssdkAppkey, smssdkAppSecret); EventHandler eh = new EventHandler(){ public void afterEvent(int event, int result, Object data) { Message msg = new Message(); msg.arg1 = event; msg.arg2 = result; msg.obj = data; handler.sendMessage(msg); } }; SMSSDK.registerEventHandler(eh); } }"}, {"file_path": "ThirdPartyLoginDemo-master/ThirdPartyLoginDemo-master/src/cn/sharesdk/tpl/UserInfo.java", "file_content": "package cn.sharesdk.tpl; public class UserInfo { private String userIcon; private String userName; private Gender userGender; private String userNote; public String getUserIcon() { return userIcon; } public void setUserIcon(String userIcon) { this.userIcon = userIcon; } public String getUserName() { return userName; } public void setUserName(String userName) { this.userName = userName; } public Gender getUserGender() { return userGender; } public void setUserGender(Gender userGender) { this.userGender = userGender; } public String getUserNote() { return userNote; } public void setUserNote(String userNote) { this.userNote = userNote; } public static enum Gender {BOY, GIRL} }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "ThirdPartyLoginDemo-master/ThirdPartyLoginDemo-master/src/cn/sharesdk/tpl/ThirdPartyLogin.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "ThirdPartyLogin handles SMS login, social platform authorization, UI dialog management, and SDK initialization. These multiple responsibilities violate SRP."}, {"principle": "Open-Closed", "justification": "Adding a new login platform requires modifying onClick() with new case statements instead of extending via abstractions, violating OCP."}, {"principle": "Dependency Inversion", "justification": "Directly depends on concrete SMSSDK/ShareSDK implementations instead of abstractions. High-level login logic depends on low-level SDK details."}]}, {"file_path": "ThirdPartyLoginDemo-master/ThirdPartyLoginDemo-master/src/cn/sharesdk/tpl/OnLoginListener.java", "violatedPrinciples": [{"principle": "Interface Segregation", "justification": "OnLoginListener forces implementers to handle both onSignin and onSignUp methods even if only one is needed, violating ISP."}]}, {"file_path": "ThirdPartyLoginDemo-master/ThirdPartyLoginDemo-master/src/cn/sharesdk/demo/tpl/LoginActivity.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "LoginActivity directly instantiates concrete ThirdPartyLogin class instead of depending on an abstraction, violating DIP."}]}]}
{"project_id": 130, "chunk_id": 0, "prompt": {"main_file_path": "ThirdPartyLoginDemo-master/ThirdPartyLoginDemo-master/src/cn/sharesdk/demo/tpl/wxapi/WXEntryActivity.java", "main_file_content": "package cn.sharesdk.demo.tpl.wxapi; import android.content.Intent; import android.widget.Toast; import cn.sharesdk.wechat.utils.WXAppExtendObject; import cn.sharesdk.wechat.utils.WXMediaMessage; import cn.sharesdk.wechat.utils.WechatHandlerActivity; public class WXEntryActivity extends WechatHandlerActivity { public void onGetMessageFromWXReq(WXMediaMessage msg) { Intent iLaunchMyself = getPackageManager().getLaunchIntentForPackage(getPackageName()); startActivity(iLaunchMyself); } public void onShowMessageFromWXReq(WXMediaMessage msg) { if (msg != null && msg.mediaObject != null && (msg.mediaObject instanceof WXAppExtendObject)) { WXAppExtendObject obj = (WXAppExtendObject) msg.mediaObject; Toast.makeText(this, obj.extInfo, Toast.LENGTH_SHORT).show(); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "ThirdPartyLoginDemo-master/ThirdPartyLoginDemo-master/src/cn/sharesdk/demo/tpl/wxapi/WXEntryActivity.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "WXEntryActivity directly extends concrete WechatHandlerActivity from a low-level module. High-level business logic should depend on abstractions rather than concrete third-party implementations."}]}]}
{"project_id": 130, "chunk_id": 0, "prompt": {"main_file_path": "ThirdPartyLoginDemo-master/ThirdPartyLoginDemo-master/gen/cn/sharesdk/demo/tpl/R.java", "main_file_content": "package cn.sharesdk.demo.tpl; public final class R { public static final class attr { } public static final class color { public static final int dialog_white_bg=0x7f040004; public static final int login_with_other_plat_text_color=0x7f040003; public static final int logo_text_color=0x7f040001; public static final int page_back=0x7f040000; public static final int white=0x7f040002; } public static final class drawable { public static final int checked=0x7f020000; public static final int dialog_et_bg=0x7f020001; public static final int et_bg=0x7f020002; public static final int ic_launcher=0x7f020003; public static final int logo_facebook=0x7f020004; public static final int logo_qq=0x7f020005; public static final int logo_qzone=0x7f020006; public static final int logo_sinaweibo=0x7f020007; public static final int logo_tencentweibo=0x7f020008; public static final int logo_twitter=0x7f020009; public static final int msg_login=0x7f02000a; public static final int other_login=0x7f02000b; public static final int qq_login=0x7f02000c; public static final int ssdk_auth_title_back=0x7f02000d; public static final int ssdk_back_arr=0x7f02000e; public static final int ssdk_logo=0x7f02000f; public static final int ssdk_title_div=0x7f020010; public static final int tpl_logo=0x7f020011; public static final int tpl_title_back_arrow=0x7f020012; public static final int user_icon=0x7f020013; public static final int wechat_login=0x7f020014; public static final int weibo_login=0x7f020015; } public static final class id { public static final int btn_get_verify_code=0x7f080013; public static final int btn_send_verify_code=0x7f080015; public static final int dialog_btn_save=0x7f080001; public static final int dialog_camera=0x7f08000a; public static final int dialog_ev_info=0x7f080002; public static final int dialog_iv_boy=0x7f080006; public static final int dialog_iv_girl=0x7f080009; public static final int dialog_picture=0x7f08000b; public static final int dialog_tv_boy=0x7f080005; public static final int dialog_tv_girl=0x7f080008; public static final int dialog_tv_hint=0x7f080003; public static final int dialog_tv_title=0x7f080000; public static final int et_phone=0x7f080012; public static final int et_verify_code=0x7f080014; public static final int iv_user_icon=0x7f08001a; public static final int ll_back=0x7f080021; public static final int ll_title_bar=0x7f080018; public static final int rl_boy=0x7f080004; public static final int rl_gender=0x7f08001d; public static final int rl_girl=0x7f080007; public static final int rl_icon=0x7f080019; public static final int rl_name=0x7f08001b; public static final int rl_note=0x7f08001f; public static final int textView1=0x7f08000c; public static final int tvFacebook=0x7f080016; public static final int tvMsgRegister=0x7f08000d; public static final int tvOther=0x7f080011; public static final int tvQq=0x7f080010; public static final int tvTwitter=0x7f080017; public static final int tvWeibo=0x7f08000f; public static final int tvWeixin=0x7f08000e; public static final int tv_ensure=0x7f080023; public static final int tv_title=0x7f080022; public static final int tv_user_gender=0x7f08001e; public static final int tv_user_name=0x7f08001c; public static final int tv_user_note=0x7f080020; } public static final class integer { public static final int app_version_code=0x7f060000; } public static final class layout { public static final int tpl_change_userinfo_dialog=0x7f030000; public static final int tpl_gender_select_dialog=0x7f030001; public static final int tpl_icon_select_dialog=0x7f030002; public static final int tpl_login_page=0x7f030003; public static final int tpl_msg_login_dialog=0x7f030004; public static final int tpl_other_plat_dialog=0x7f030005; public static final int tpl_page_signup=0x7f030006; public static final int tpl_progress_dialog=0x7f030007; public static final int tpl_title_layout=0x7f030008; } public static final class string { public static final int after_auth=0x7f05003f; public static final int app_name=0x7f050030; public static final int app_version=0x7f050031; public static final int auth_cancel=0x7f05003b; public static final int auth_complete=0x7f05003d; public static final int auth_error=0x7f05003c; public static final int douban=0x7f050019; public static final int dropbox=0x7f050023; public static final int email=0x7f050014; public static final int evernote=0x7f05001b; public static final int facebook=0x7f050010; public static final int flickr=0x7f050021; public static final int foursquare=0x7f05001e; public static final int google_plus_client_inavailable=0x7f050004; public static final int googleplus=0x7f05001d; public static final int if_register_needed=0x7f05003e; public static final int instagram=0x7f050025; public static final int instagram_client_inavailable=0x7f050007; public static final int kaixin=0x7f050013; public static final int line=0x7f050029; public static final int line_client_inavailable=0x7f050009; public static final int linkedin=0x7f05001c; public static final int login_with_msg=0x7f050034; public static final int login_with_other_plat=0x7f050038; public static final int login_with_qzone=0x7f050037; public static final int login_with_sina_weibo=0x7f050036; public static final int login_with_weixin=0x7f050035; public static final int logining=0x7f05003a; public static final int mingdao=0x7f050028; public static final int mingdao_share_content=0x7f05002c; public static final int neteasemicroblog=0x7f050018; public static final int pinterest=0x7f050020; public static final int pinterest_client_inavailable=0x7f050006; public static final int proj_name=0x7f050032; public static final int qq=0x7f05001f; public static final int qq_client_inavailable=0x7f050005; public static final int qzone=0x7f05000c; public static final int renren=0x7f050012; public static final int share_sdk=0x7f050033; public static final int share_to_mingdao=0x7f05002d; public static final int share_to_qq=0x7f05002b; public static final int share_to_qzone=0x7f05002a; public static final int share_to_qzone_default=0x7f05002e; public static final int shortmessage=0x7f050015; public static final int signup_failed=0x7f050059; public static final int signup_success=0x7f050058; public static final int sinaweibo=0x7f05000a; public static final int sohumicroblog=0x7f050016; public static final int sohusuishenkan=0x7f050017; public static final int tencentweibo=0x7f05000b; public static final int tpl_boy=0x7f05004c; public static final int tpl_camera=0x7f05004d; public static final int tpl_cancel=0x7f050041; public static final int tpl_change_user_name_title=0x7f05004f; public static final int tpl_change_user_note_title=0x7f050050; public static final int tpl_get_verify_code=0x7f050056; public static final int tpl_girl=0x7f05004b; public static final int tpl_input_user_name_hint=0x7f050051; public static final int tpl_input_user_note_hint=0x7f050052; public static final int tpl_key_user_gender=0x7f050044; public static final int tpl_key_user_icon=0x7f050042; public static final int tpl_key_user_name=0x7f050043; public static final int tpl_key_user_note=0x7f050045; public static final int tpl_msg_login_hint=0x7f050054; public static final int tpl_no_sdcard=0x7f050053; public static final int tpl_ok=0x7f050040; public static final int tpl_picture=0x7f05004e; public static final int tpl_send_verify_code=0x7f050057; public static final int tpl_sign_up=0x7f05004a; public static final int tpl_sign_user_info=0x7f050049; public static final int tpl_value_user_gender=0x7f050047; public static final int tpl_value_user_name=0x7f050046; public static final int tpl_value_user_note=0x7f050048; public static final int tpl_verify_code_hint=0x7f050055; public static final int tumblr=0x7f050022; public static final int twitter=0x7f050011; public static final int use_login_button=0x7f05002f; public static final int userid_found=0x7f050039; public static final int vkontakte=0x7f050024; public static final int website=0x7f050001; public static final int wechat=0x7f05000d; public static final int wechat_client_inavailable=0x7f050003; public static final int wechatfavorite=0x7f05000f; public static final int wechatmoments=0x7f05000e; public static final int weibo_oauth_regiseter=0x7f050000; public static final int weibo_upload_content=0x7f050002; public static final int yixin=0x7f050026; public static final int yixin_client_inavailable=0x7f050008; public static final int yixinmoments=0x7f050027; public static final int youdao=0x7f05001a; } public static final class style { public static final int AppTheme=0x7f070000; public static final int CommonDialog=0x7f070001; public static final int WhiteDialog=0x7f070002; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "ThirdPartyLoginDemo-master/ThirdPartyLoginDemo-master/gen/cn/sharesdk/demo/tpl/R.java", "violatedPrinciples": []}]}
{"project_id": 130, "chunk_id": 0, "prompt": {"main_file_path": "ThirdPartyLoginDemo-master/ThirdPartyLoginDemo-master/gen/cn/sharesdk/demo/tpl/BuildConfig.java", "main_file_content": "package cn.sharesdk.demo.tpl; public final class BuildConfig { public final static boolean DEBUG = true; }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "ThirdPartyLoginDemo-master/ThirdPartyLoginDemo-master/gen/cn/sharesdk/demo/tpl/BuildConfig.java", "violatedPrinciples": []}]}
{"project_id": 131, "chunk_id": 0, "prompt": {"main_file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/Main.java", "main_file_content": "package fr.wallet; import fr.wallet.service.DistributionService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.CommandLineRunner; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class Main implements CommandLineRunner { @Autowired private DistributionService distributionService; public static void main(String[] args) { SpringApplication.run(Main.class, args); } @Override public void run(String... args) throws Exception { distributionService.giveGiftCards(1,1,50, \"2020-09-16\"); distributionService.giveGiftCards(2,1,100, \"2020-08-01\"); distributionService.giveGiftCards(3,2,1000, \"2020-05-01\"); distributionService.giveGiftCards(3,2,200, \"2020-07-04\"); } }", "dependencies": [{"file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/service/DistributionService.java", "file_content": "package fr.wallet.service; import java.io.IOException; public interface DistributionService { void giveGiftCards(int companyId, int userId, int amount, String startDate) throws IOException; }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/Main.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Main class handles both application bootstrapping and executing business logic (calling giveGiftCards), introducing multiple reasons to change if bootstrapping or business logic evolves."}]}]}
{"project_id": 131, "chunk_id": 0, "prompt": {"main_file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/repository/DistributionJPARepository.java", "main_file_content": "package fr.wallet.repository; import fr.wallet.domain.Distribution; import org.springframework.data.jpa.repository.JpaRepository; public interface DistributionJPARepository extends JpaRepository<Distribution, Integer> { }", "dependencies": [{"file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/domain/Distribution.java", "file_content": "package fr.wallet.domain; import com.fasterxml.jackson.annotation.JsonIgnore; import com.fasterxml.jackson.annotation.JsonProperty; import com.fasterxml.jackson.databind.annotation.JsonDeserialize; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import fr.wallet.service.CustomDateDeserializer; import fr.wallet.service.CustomDateSerializer; import javax.persistence.*; import java.time.LocalDate; @Entity public class Distribution { @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Integer id; @JsonIgnore @ManyToOne private Wrapper wrapper; private int amount; @JsonSerialize(using= CustomDateSerializer.class) @JsonDeserialize(using= CustomDateDeserializer.class) @JsonProperty(\"start_date\") private LocalDate startDate; @JsonSerialize(using=CustomDateSerializer.class) @JsonDeserialize(using=CustomDateDeserializer.class) @JsonProperty(\"end_date\") private LocalDate endDate; @JsonProperty(\"company_id\") private int companyId; @JsonProperty(\"user_id\") private int userId; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public Wrapper getWrapper() { return wrapper; } public void setWrapper(Wrapper wrapper) { this.wrapper = wrapper; } public int getAmount() { return amount; } public void setAmount(int amount) { this.amount = amount; } public LocalDate getStartDate() { return startDate; } public void setStartDate(LocalDate startDate) { this.startDate = startDate; } public LocalDate getEndDate() { return endDate; } public void setEndDate(LocalDate endDate) { this.endDate = endDate; } public int getCompanyId() { return companyId; } public void setCompanyId(int companyId) { this.companyId = companyId; } public int getUserId() { return userId; } public void setUserId(int userId) { this.userId = userId; } @Override public String toString() { return \"Distribution{\" + \"id=\" + id + \", wrapper=\" + wrapper + \", amount=\" + amount + \", startDate=\" + startDate + \", endDate=\" + endDate + \", companyId=\" + companyId + \", userId=\" + userId + '}'; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/domain/Distribution.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Distribution handles both JPA entity mapping and JSON serialization/deserialization logic, introducing multiple reasons to change if persistence or presentation requirements evolve."}]}, {"file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/repository/DistributionJPARepository.java", "violatedPrinciples": [{"principle": "Interface Segregation", "justification": "DistributionJPARepository extends JpaRepository, exposing all its methods. Clients depending on this interface are forced to depend on unused methods, violating ISP."}]}]}
{"project_id": 131, "chunk_id": 0, "prompt": {"main_file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/repository/WrapperJPARepository.java", "main_file_content": "package fr.wallet.repository; import fr.wallet.domain.Wrapper; import org.springframework.data.jpa.repository.JpaRepository; public interface WrapperJPARepository extends JpaRepository<Wrapper, Integer> { }", "dependencies": [{"file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/domain/Wrapper.java", "file_content": "package fr.wallet.domain; import com.fasterxml.jackson.annotation.JsonIgnore; import javax.persistence.*; import java.util.List; @Entity public class Wrapper { @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @JsonIgnore private Integer id; @OneToMany(mappedBy=\"wrapper\", cascade=CascadeType.REMOVE) private List<Company> companies; @OneToMany(mappedBy=\"wrapper\", cascade=CascadeType.REMOVE) private List<User> users; @OneToMany(mappedBy=\"wrapper\", cascade=CascadeType.REMOVE) private List<Distribution> distributions; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public List<Company> getCompanies() { return companies; } public void setCompanies(List<Company> companies) { this.companies = companies; } public List<User> getUsers() { return users; } public void setUsers(List<User> users) { this.users = users; } public List<Distribution> getDistributions() { return distributions; } public void setDistributions(List<Distribution> distributions) { this.distributions = distributions; } @Override public String toString() { return \"Wrapper{\" + \"id=\" + id + \", companies=\" + companies + \", users=\" + users + \", distributions=\" + distributions + '}'; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 131, "chunk_id": 0, "prompt": {"main_file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/repository/WrapperFileRepository.java", "main_file_content": "package fr.wallet.repository; import fr.wallet.domain.Wrapper; import java.io.IOException; public interface WrapperFileRepository { Wrapper findOneFromJson() throws IOException; void saveWrapperAsJson(Wrapper wrapper) throws IOException; }", "dependencies": [{"file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/domain/Wrapper.java", "file_content": "package fr.wallet.domain; import com.fasterxml.jackson.annotation.JsonIgnore; import javax.persistence.*; import java.util.List; @Entity public class Wrapper { @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @JsonIgnore private Integer id; @OneToMany(mappedBy=\"wrapper\", cascade=CascadeType.REMOVE) private List<Company> companies; @OneToMany(mappedBy=\"wrapper\", cascade=CascadeType.REMOVE) private List<User> users; @OneToMany(mappedBy=\"wrapper\", cascade=CascadeType.REMOVE) private List<Distribution> distributions; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public List<Company> getCompanies() { return companies; } public void setCompanies(List<Company> companies) { this.companies = companies; } public List<User> getUsers() { return users; } public void setUsers(List<User> users) { this.users = users; } public List<Distribution> getDistributions() { return distributions; } public void setDistributions(List<Distribution> distributions) { this.distributions = distributions; } @Override public String toString() { return \"Wrapper{\" + \"id=\" + id + \", companies=\" + companies + \", users=\" + users + \", distributions=\" + distributions + '}'; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/repository/WrapperFileRepository.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "WrapperFileRepository interface depends directly on concrete Wrapper class. High-level modules should depend on abstractions (e.g., an interface for Wrapper) rather than concrete implementations."}]}]}
{"project_id": 131, "chunk_id": 0, "prompt": {"main_file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/repository/WrapperFileRepositoryImpl.java", "main_file_content": "package fr.wallet.repository; import com.fasterxml.jackson.databind.ObjectMapper; import fr.wallet.domain.Wrapper; import org.springframework.stereotype.Repository; import java.io.File; import java.io.IOException; import java.nio.file.Path; import java.nio.file.Paths; @Repository public class WrapperFileRepositoryImpl implements WrapperFileRepository { private final String filePath = \"level1/data/output.json\"; private final ObjectMapper objectMapper = new ObjectMapper(); public WrapperFileRepositoryImpl() { } @Override public Wrapper findOneFromJson() throws IOException { Path pathObject = Paths.get(filePath); File file = pathObject.toFile(); String initFilePath = \"level1/data/input.json\"; if (file.exists()) return this.objectMapper.readValue(file, Wrapper.class); else return this.objectMapper.readValue(new File(initFilePath), Wrapper.class); } @Override public void saveWrapperAsJson(Wrapper wrapper) throws IOException { this.objectMapper.writerWithDefaultPrettyPrinter().writeValue(new File(this.filePath), wrapper); } }", "dependencies": [{"file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/domain/Wrapper.java", "file_content": "package fr.wallet.domain; import com.fasterxml.jackson.annotation.JsonIgnore; import javax.persistence.*; import java.util.List; @Entity public class Wrapper { @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @JsonIgnore private Integer id; @OneToMany(mappedBy=\"wrapper\", cascade=CascadeType.REMOVE) private List<Company> companies; @OneToMany(mappedBy=\"wrapper\", cascade=CascadeType.REMOVE) private List<User> users; @OneToMany(mappedBy=\"wrapper\", cascade=CascadeType.REMOVE) private List<Distribution> distributions; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public List<Company> getCompanies() { return companies; } public void setCompanies(List<Company> companies) { this.companies = companies; } public List<User> getUsers() { return users; } public void setUsers(List<User> users) { this.users = users; } public List<Distribution> getDistributions() { return distributions; } public void setDistributions(List<Distribution> distributions) { this.distributions = distributions; } @Override public String toString() { return \"Wrapper{\" + \"id=\" + id + \", companies=\" + companies + \", users=\" + users + \", distributions=\" + distributions + '}'; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/repository/WrapperFileRepositoryImpl.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The class manages file paths, checks file existence, and handles JSON serialization/deserialization. Combining file I/O operations and data transformation violates having only one reason to change."}, {"principle": "Open-Closed", "justification": "The class is not extendable for new serialization formats or storage mechanisms without modifying existing code. Hardcoded file paths and ObjectMapper usage prevent closed modification."}, {"principle": "Dependency Inversion", "justification": "Directly depends on concrete ObjectMapper and file system operations without abstractions. High-level repository logic should depend on interfaces, not low-level serialization/details."}]}]}
{"project_id": 131, "chunk_id": 0, "prompt": {"main_file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/repository/CompanyJPARepository.java", "main_file_content": "package fr.wallet.repository; import fr.wallet.domain.Company; import org.springframework.data.jpa.repository.JpaRepository; public interface CompanyJPARepository extends JpaRepository<Company, Integer> { }", "dependencies": [{"file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/domain/Company.java", "file_content": "package fr.wallet.domain; import com.fasterxml.jackson.annotation.JsonIgnore; import javax.persistence.*; @Entity public class Company { @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Integer id; @JsonIgnore @ManyToOne private Wrapper wrapper; private String name; private int balance; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public Wrapper getWrapper() { return wrapper; } public void setWrapper(Wrapper wrapper) { this.wrapper = wrapper; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getBalance() { return balance; } public void setBalance(int balance) { this.balance = balance; } @Override public String toString() { return \"Company{\" + \"id=\" + id + \", wrapper=\" + wrapper + \", name='\" + name + '\\'' + \", balance=\" + balance + '}'; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/repository/CompanyJPARepository.java", "violatedPrinciples": [{"principle": "Interface Segregation", "justification": "CompanyJPARepository extends JpaRepository, which may force clients to depend on unused methods, violating ISP."}]}, {"file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/domain/Company.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "Company directly references concrete Wrapper class instead of an abstraction, violating DIP."}]}]}
{"project_id": 131, "chunk_id": 0, "prompt": {"main_file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/repository/UserJPARepository.java", "main_file_content": "package fr.wallet.repository; import fr.wallet.domain.User; import org.springframework.data.jpa.repository.JpaRepository; public interface UserJPARepository extends JpaRepository<User, Integer> { }", "dependencies": [{"file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/domain/User.java", "file_content": "package fr.wallet.domain; import com.fasterxml.jackson.annotation.JsonIgnore; import javax.persistence.*; @Entity public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @JsonIgnore @ManyToOne private Wrapper wrapper; private int balance; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public Wrapper getWrapper() { return wrapper; } public void setWrapper(Wrapper wrapper) { this.wrapper = wrapper; } public int getBalance() { return balance; } public void setBalance(int balance) { this.balance = balance; } @Override public String toString() { return \"User{\" + \"id=\" + id + \", wrapper=\" + wrapper + \", balance=\" + balance + '}'; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/domain/User.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "User directly depends on the concrete Wrapper class. High-level modules should depend on abstractions, not concrete implementations."}]}, {"file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/repository/UserJPARepository.java", "violatedPrinciples": [{"principle": "Interface Segregation", "justification": "UserJPARepository extends JpaRepository, which includes many methods. Clients depending on this interface may not use all methods, violating ISP."}]}]}
{"project_id": 131, "chunk_id": 0, "prompt": {"main_file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/controller/WrapperController.java", "main_file_content": "package fr.wallet.controller; import fr.wallet.domain.Wrapper; import fr.wallet.repository.WrapperJPARepository; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.CrossOrigin; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; import java.util.List; @CrossOrigin(\"*\") @RestController public class WrapperController { @Autowired private WrapperJPARepository wrapperJPARepository; @GetMapping(path = \"/wrappers\") public List<Wrapper> findAll() { return wrapperJPARepository.findAll(); } }", "dependencies": [{"file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/domain/Wrapper.java", "file_content": "package fr.wallet.domain; import com.fasterxml.jackson.annotation.JsonIgnore; import javax.persistence.*; import java.util.List; @Entity public class Wrapper { @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @JsonIgnore private Integer id; @OneToMany(mappedBy=\"wrapper\", cascade=CascadeType.REMOVE) private List<Company> companies; @OneToMany(mappedBy=\"wrapper\", cascade=CascadeType.REMOVE) private List<User> users; @OneToMany(mappedBy=\"wrapper\", cascade=CascadeType.REMOVE) private List<Distribution> distributions; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public List<Company> getCompanies() { return companies; } public void setCompanies(List<Company> companies) { this.companies = companies; } public List<User> getUsers() { return users; } public void setUsers(List<User> users) { this.users = users; } public List<Distribution> getDistributions() { return distributions; } public void setDistributions(List<Distribution> distributions) { this.distributions = distributions; } @Override public String toString() { return \"Wrapper{\" + \"id=\" + id + \", companies=\" + companies + \", users=\" + users + \", distributions=\" + distributions + '}'; } }"}, {"file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/repository/WrapperJPARepository.java", "file_content": "package fr.wallet.repository; import fr.wallet.domain.Wrapper; import org.springframework.data.jpa.repository.JpaRepository; public interface WrapperJPARepository extends JpaRepository<Wrapper, Integer> { }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/controller/WrapperController.java", "violatedPrinciples": [{"principle": "Interface Segregation", "justification": "WrapperController depends on WrapperJPARepository (JpaRepository), which exposes multiple methods. The controller only uses findAll(), but is forced to depend on the entire interface."}, {"principle": "Dependency Inversion", "justification": "WrapperController directly depends on WrapperJPARepository, a low-level module. High-level modules should depend on abstractions, not concrete repository interfaces."}]}]}
{"project_id": 131, "chunk_id": 0, "prompt": {"main_file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/service/DistributionService.java", "main_file_content": "package fr.wallet.service; import java.io.IOException; public interface DistributionService { void giveGiftCards(int companyId, int userId, int amount, String startDate) throws IOException; }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/service/DistributionService.java", "violatedPrinciples": []}]}
{"project_id": 131, "chunk_id": 0, "prompt": {"main_file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/service/CustomDateSerializer.java", "main_file_content": "package fr.wallet.service; import com.fasterxml.jackson.core.JsonGenerator; import com.fasterxml.jackson.databind.SerializerProvider; import com.fasterxml.jackson.databind.ser.std.StdSerializer; import java.io.IOException; import java.time.LocalDate; public class CustomDateSerializer extends StdSerializer<LocalDate> { public CustomDateSerializer() { this(null); } private CustomDateSerializer(Class<LocalDate> t) { super(t); } @Override public void serialize(LocalDate value, JsonGenerator gen, SerializerProvider arg2) throws IOException { gen.writeString(JsonUtils.FORMATTER.format(value)); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/service/CustomDateSerializer.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "CustomDateSerializer directly depends on JsonUtils.FORMATTER, a concrete utility class, instead of an abstraction for date formatting. High-level modules should depend on abstractions, not concrete implementations."}]}]}
{"project_id": 131, "chunk_id": 0, "prompt": {"main_file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/service/DistributionServiceImpl.java", "main_file_content": "package fr.wallet.service; import fr.wallet.domain.Company; import fr.wallet.domain.Distribution; import fr.wallet.domain.User; import fr.wallet.domain.Wrapper; import fr.wallet.repository.*; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.io.IOException; import java.time.LocalDate; import java.util.ArrayList; import java.util.List; @Service public class DistributionServiceImpl implements DistributionService { @Autowired private WrapperFileRepository wrapperFileRepository; @Autowired private WrapperJPARepository wrapperJPARepository; @Autowired private DistributionJPARepository distributionJPARepository; @Autowired private UserJPARepository userJPARepository; @Autowired private CompanyJPARepository companyJPARepository; public void giveGiftCards(int userId, int companyId, int amount, String startDate) throws IOException { Wrapper wrapper = wrapperFileRepository.findOneFromJson(); Company company = wrapper.getCompanies().stream() .filter(c -> c.getId() == companyId) .findFirst().get(); User user = wrapper.getUsers().stream() .filter(u -> u.getId() == userId) .findFirst().get(); if (company.getBalance() >= amount) { company.setBalance(company.getBalance() - amount); user.setBalance(user.getBalance() + amount); LocalDate localStartDate = LocalDate.parse(startDate, JsonUtils.FORMATTER); Distribution dist = new Distribution(); dist.setUserId(userId); dist.setCompanyId(companyId); dist.setAmount(amount); dist.setStartDate(localStartDate); dist.setEndDate(localStartDate.plusYears(1).minusDays(1)); List<Distribution> distributions = new ArrayList<>(wrapper.getDistributions()); int nextId = distributions.size() + 1; dist.setId(nextId); distributions.add(dist); wrapper.setDistributions(distributions); soutl(\"\") wrapperFileRepository.saveWrapperAsJson(wrapper); wrapper = wrapperJPARepository.save(wrapper); Wrapper finalWrapper = wrapper; wrapper.getUsers().forEach(u -> { u.setWrapper(finalWrapper); userJPARepository.save(u); }); wrapper.getCompanies().forEach(c -> { c.setWrapper(finalWrapper); companyJPARepository.save(c); }); wrapper.getDistributions().forEach(d -> { d.setWrapper(finalWrapper); distributionJPARepository.save(d); }); } } }", "dependencies": [{"file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/domain/Company.java", "file_content": "package fr.wallet.domain; import com.fasterxml.jackson.annotation.JsonIgnore; import javax.persistence.*; @Entity public class Company { @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Integer id; @JsonIgnore @ManyToOne private Wrapper wrapper; private String name; private int balance; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public Wrapper getWrapper() { return wrapper; } public void setWrapper(Wrapper wrapper) { this.wrapper = wrapper; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getBalance() { return balance; } public void setBalance(int balance) { this.balance = balance; } @Override public String toString() { return \"Company{\" + \"id=\" + id + \", wrapper=\" + wrapper + \", name='\" + name + '\\'' + \", balance=\" + balance + '}'; } }"}, {"file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/domain/Distribution.java", "file_content": "package fr.wallet.domain; import com.fasterxml.jackson.annotation.JsonIgnore; import com.fasterxml.jackson.annotation.JsonProperty; import com.fasterxml.jackson.databind.annotation.JsonDeserialize; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import fr.wallet.service.CustomDateDeserializer; import fr.wallet.service.CustomDateSerializer; import javax.persistence.*; import java.time.LocalDate; @Entity public class Distribution { @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Integer id; @JsonIgnore @ManyToOne private Wrapper wrapper; private int amount; @JsonSerialize(using= CustomDateSerializer.class) @JsonDeserialize(using= CustomDateDeserializer.class) @JsonProperty(\"start_date\") private LocalDate startDate; @JsonSerialize(using=CustomDateSerializer.class) @JsonDeserialize(using=CustomDateDeserializer.class) @JsonProperty(\"end_date\") private LocalDate endDate; @JsonProperty(\"company_id\") private int companyId; @JsonProperty(\"user_id\") private int userId; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public Wrapper getWrapper() { return wrapper; } public void setWrapper(Wrapper wrapper) { this.wrapper = wrapper; } public int getAmount() { return amount; } public void setAmount(int amount) { this.amount = amount; } public LocalDate getStartDate() { return startDate; } public void setStartDate(LocalDate startDate) { this.startDate = startDate; } public LocalDate getEndDate() { return endDate; } public void setEndDate(LocalDate endDate) { this.endDate = endDate; } public int getCompanyId() { return companyId; } public void setCompanyId(int companyId) { this.companyId = companyId; } public int getUserId() { return userId; } public void setUserId(int userId) { this.userId = userId; } @Override public String toString() { return \"Distribution{\" + \"id=\" + id + \", wrapper=\" + wrapper + \", amount=\" + amount + \", startDate=\" + startDate + \", endDate=\" + endDate + \", companyId=\" + companyId + \", userId=\" + userId + '}'; } }"}, {"file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/domain/User.java", "file_content": "package fr.wallet.domain; import com.fasterxml.jackson.annotation.JsonIgnore; import javax.persistence.*; @Entity public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @JsonIgnore @ManyToOne private Wrapper wrapper; private int balance; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public Wrapper getWrapper() { return wrapper; } public void setWrapper(Wrapper wrapper) { this.wrapper = wrapper; } public int getBalance() { return balance; } public void setBalance(int balance) { this.balance = balance; } @Override public String toString() { return \"User{\" + \"id=\" + id + \", wrapper=\" + wrapper + \", balance=\" + balance + '}'; } }"}, {"file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/domain/Wrapper.java", "file_content": "package fr.wallet.domain; import com.fasterxml.jackson.annotation.JsonIgnore; import javax.persistence.*; import java.util.List; @Entity public class Wrapper { @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @JsonIgnore private Integer id; @OneToMany(mappedBy=\"wrapper\", cascade=CascadeType.REMOVE) private List<Company> companies; @OneToMany(mappedBy=\"wrapper\", cascade=CascadeType.REMOVE) private List<User> users; @OneToMany(mappedBy=\"wrapper\", cascade=CascadeType.REMOVE) private List<Distribution> distributions; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public List<Company> getCompanies() { return companies; } public void setCompanies(List<Company> companies) { this.companies = companies; } public List<User> getUsers() { return users; } public void setUsers(List<User> users) { this.users = users; } public List<Distribution> getDistributions() { return distributions; } public void setDistributions(List<Distribution> distributions) { this.distributions = distributions; } @Override public String toString() { return \"Wrapper{\" + \"id=\" + id + \", companies=\" + companies + \", users=\" + users + \", distributions=\" + distributions + '}'; } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/service/DistributionServiceImpl.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The class handles multiple responsibilities: business logic for gift card distribution, direct data retrieval from repositories, JSON serialization/deserialization, and database persistence. Changes in any of these areas would require modifying the class."}, {"principle": "Dependency Inversion", "justification": "High-level service directly depends on concrete repository implementations (e.g., WrapperFileRepository, WrapperJPARepository) instead of abstractions. Low-level modules are referenced directly without interface-based decoupling."}]}]}
{"project_id": 131, "chunk_id": 0, "prompt": {"main_file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/service/JsonUtils.java", "main_file_content": "package fr.wallet.service; import java.time.format.DateTimeFormatter; public class JsonUtils { public final static DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\"); }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 131, "chunk_id": 0, "prompt": {"main_file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/service/CustomDateDeserializer.java", "main_file_content": "package fr.wallet.service; import com.fasterxml.jackson.core.JsonParser; import com.fasterxml.jackson.databind.DeserializationContext; import com.fasterxml.jackson.databind.deser.std.StdDeserializer; import java.io.IOException; import java.time.LocalDate; public class CustomDateDeserializer extends StdDeserializer<LocalDate> { public CustomDateDeserializer() { this(null); } private CustomDateDeserializer(Class<?> vc) { super(vc); } @Override public LocalDate deserialize(JsonParser jsonparser, DeserializationContext context) throws IOException { String date = jsonparser.getText(); return LocalDate.parse(date, JsonUtils.FORMATTER); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/service/CustomDateDeserializer.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "CustomDateDeserializer directly references JsonUtils.FORMATTER, a concrete implementation detail. High-level deserialization logic depends on a low-level utility class instead of an abstraction interface."}]}]}
{"project_id": 131, "chunk_id": 0, "prompt": {"main_file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/domain/Wrapper.java", "main_file_content": "package fr.wallet.domain; import com.fasterxml.jackson.annotation.JsonIgnore; import javax.persistence.*; import java.util.List; @Entity public class Wrapper { @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @JsonIgnore private Integer id; @OneToMany(mappedBy=\"wrapper\", cascade=CascadeType.REMOVE) private List<Company> companies; @OneToMany(mappedBy=\"wrapper\", cascade=CascadeType.REMOVE) private List<User> users; @OneToMany(mappedBy=\"wrapper\", cascade=CascadeType.REMOVE) private List<Distribution> distributions; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public List<Company> getCompanies() { return companies; } public void setCompanies(List<Company> companies) { this.companies = companies; } public List<User> getUsers() { return users; } public void setUsers(List<User> users) { this.users = users; } public List<Distribution> getDistributions() { return distributions; } public void setDistributions(List<Distribution> distributions) { this.distributions = distributions; } @Override public String toString() { return \"Wrapper{\" + \"id=\" + id + \", companies=\" + companies + \", users=\" + users + \", distributions=\" + distributions + '}'; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/domain/Wrapper.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Wrapper class manages three separate collections (companies, users, distributions), introducing multiple reasons for change, thus violating SRP."}, {"principle": "Dependency Inversion", "justification": "Wrapper directly depends on concrete classes (Company, User, Distribution) instead of abstractions, violating DIP as high-level modules should not depend on low-level implementations."}]}]}
{"project_id": 131, "chunk_id": 0, "prompt": {"main_file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/domain/User.java", "main_file_content": "package fr.wallet.domain; import com.fasterxml.jackson.annotation.JsonIgnore; import javax.persistence.*; @Entity public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @JsonIgnore @ManyToOne private Wrapper wrapper; private int balance; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public Wrapper getWrapper() { return wrapper; } public void setWrapper(Wrapper wrapper) { this.wrapper = wrapper; } public int getBalance() { return balance; } public void setBalance(int balance) { this.balance = balance; } @Override public String toString() { return \"User{\" + \"id=\" + id + \", wrapper=\" + wrapper + \", balance=\" + balance + '}'; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 131, "chunk_id": 0, "prompt": {"main_file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/domain/Company.java", "main_file_content": "package fr.wallet.domain; import com.fasterxml.jackson.annotation.JsonIgnore; import javax.persistence.*; @Entity public class Company { @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Integer id; @JsonIgnore @ManyToOne private Wrapper wrapper; private String name; private int balance; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public Wrapper getWrapper() { return wrapper; } public void setWrapper(Wrapper wrapper) { this.wrapper = wrapper; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getBalance() { return balance; } public void setBalance(int balance) { this.balance = balance; } @Override public String toString() { return \"Company{\" + \"id=\" + id + \", wrapper=\" + wrapper + \", name='\" + name + '\\'' + \", balance=\" + balance + '}'; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/domain/Company.java", "violatedPrinciples": [{"principle": "Dependency Inversion", "justification": "Company directly depends on concrete Wrapper class instead of an abstraction. High-level modules should depend on abstractions, not concrete implementations."}]}]}
{"project_id": 131, "chunk_id": 0, "prompt": {"main_file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/domain/Distribution.java", "main_file_content": "package fr.wallet.domain; import com.fasterxml.jackson.annotation.JsonIgnore; import com.fasterxml.jackson.annotation.JsonProperty; import com.fasterxml.jackson.databind.annotation.JsonDeserialize; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import fr.wallet.service.CustomDateDeserializer; import fr.wallet.service.CustomDateSerializer; import javax.persistence.*; import java.time.LocalDate; @Entity public class Distribution { @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Integer id; @JsonIgnore @ManyToOne private Wrapper wrapper; private int amount; @JsonSerialize(using= CustomDateSerializer.class) @JsonDeserialize(using= CustomDateDeserializer.class) @JsonProperty(\"start_date\") private LocalDate startDate; @JsonSerialize(using=CustomDateSerializer.class) @JsonDeserialize(using=CustomDateDeserializer.class) @JsonProperty(\"end_date\") private LocalDate endDate; @JsonProperty(\"company_id\") private int companyId; @JsonProperty(\"user_id\") private int userId; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public Wrapper getWrapper() { return wrapper; } public void setWrapper(Wrapper wrapper) { this.wrapper = wrapper; } public int getAmount() { return amount; } public void setAmount(int amount) { this.amount = amount; } public LocalDate getStartDate() { return startDate; } public void setStartDate(LocalDate startDate) { this.startDate = startDate; } public LocalDate getEndDate() { return endDate; } public void setEndDate(LocalDate endDate) { this.endDate = endDate; } public int getCompanyId() { return companyId; } public void setCompanyId(int companyId) { this.companyId = companyId; } public int getUserId() { return userId; } public void setUserId(int userId) { this.userId = userId; } @Override public String toString() { return \"Distribution{\" + \"id=\" + id + \", wrapper=\" + wrapper + \", amount=\" + amount + \", startDate=\" + startDate + \", endDate=\" + endDate + \", companyId=\" + companyId + \", userId=\" + userId + '}'; } }", "dependencies": [{"file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/service/CustomDateDeserializer.java", "file_content": "package fr.wallet.service; import com.fasterxml.jackson.core.JsonParser; import com.fasterxml.jackson.databind.DeserializationContext; import com.fasterxml.jackson.databind.deser.std.StdDeserializer; import java.io.IOException; import java.time.LocalDate; public class CustomDateDeserializer extends StdDeserializer<LocalDate> { public CustomDateDeserializer() { this(null); } private CustomDateDeserializer(Class<?> vc) { super(vc); } @Override public LocalDate deserialize(JsonParser jsonparser, DeserializationContext context) throws IOException { String date = jsonparser.getText(); return LocalDate.parse(date, JsonUtils.FORMATTER); } }"}, {"file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/service/CustomDateSerializer.java", "file_content": "package fr.wallet.service; import com.fasterxml.jackson.core.JsonGenerator; import com.fasterxml.jackson.databind.SerializerProvider; import com.fasterxml.jackson.databind.ser.std.StdSerializer; import java.io.IOException; import java.time.LocalDate; public class CustomDateSerializer extends StdSerializer<LocalDate> { public CustomDateSerializer() { this(null); } private CustomDateSerializer(Class<LocalDate> t) { super(t); } @Override public void serialize(LocalDate value, JsonGenerator gen, SerializerProvider arg2) throws IOException { gen.writeString(JsonUtils.FORMATTER.format(value)); } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "virtual-wallet-master/virtual-wallet-master/src/main/java/fr/wallet/domain/Distribution.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Distribution class handles both data persistence (JPA annotations) and JSON serialization/deserialization (Jackson annotations), introducing multiple reasons to change."}, {"principle": "Dependency Inversion", "justification": "High-level module Distribution directly depends on concrete Wrapper class and low-level CustomDateSerializer/Deserializer implementations instead of abstractions."}]}]}
{"project_id": 132, "chunk_id": 0, "prompt": {"main_file_path": "compactEngine-main/compressorImages/Compressor.java", "main_file_content": "package compressorImages; import java.awt.image.BufferedImage; import java.io.File; import java.io.FileWriter; import java.util.HashMap; import java.util.Map; import javax.imageio.ImageIO; public class Compressor { public void compressImage(String inputImagePath, String outputFilePath) { long startTime = System.currentTimeMillis(); try { BufferedImage image = ImageIO.read(new File(inputImagePath)); Map<Integer, Integer> redFrequency = new HashMap<>(); Map<Integer, Integer> greenFrequency = new HashMap<>(); Map<Integer, Integer> blueFrequency = new HashMap<>(); int width = image.getWidth(); int height = image.getHeight(); for (int y = 0; y < height; y++) { for (int x = 0; x < width; x++) { int rgb = image.getRGB(x, y); int red = (rgb >> 16) & 0xff; int green = (rgb >> 8) & 0xff; int blue = rgb & 0xff; redFrequency.put(red, redFrequency.getOrDefault(red, 0) + 1); greenFrequency.put(green, greenFrequency.getOrDefault(green, 0) + 1); blueFrequency.put(blue, blueFrequency.getOrDefault(blue, 0) + 1); } } HuffmanTree redTree = new HuffmanTree(redFrequency); HuffmanTree greenTree = new HuffmanTree(greenFrequency); HuffmanTree blueTree = new HuffmanTree(blueFrequency); FileWriter writer = new FileWriter(outputFilePath); writer.write(width + \" \" + height + \"\\n\"); writer.write(\"RED\\n\" + redFrequency + \"\\n\"); writer.write(\"GREEN\\n\" + greenFrequency + \"\\n\"); writer.write(\"BLUE\\n\" + blueFrequency + \"\\n\"); for (int y = 0; y < height; y++) { for (int x = 0; x < width; x++) { int rgb = image.getRGB(x, y); int red = (rgb >> 16) & 0xff; int green = (rgb >> 8) & 0xff; int blue = rgb & 0xff; writer.write(redTree.getCodes().get(red)); writer.write(greenTree.getCodes().get(green)); writer.write(blueTree.getCodes().get(blue)); } } writer.close(); soutl(\"\") System.out.printf(\"\"\" Informa\u00e7\u00f5es da compress\u00e3o: - Largura: %d pixels - Altura: %d pixels - Tamanho do arquivo comprimido: %d bytes \\n \"\"\", width, height, new File(outputFilePath).length()); long endTime = System.currentTimeMillis(); soutl(\"\") } catch (Exception e) { e.printStackTrace(); soutl(\"\") } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "compactEngine-main/compressorImages/Compressor.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Compressor class handles image processing, Huffman tree generation, file I/O operations, and logging. These multiple responsibilities violate SRP, as changes to any one aspect would require modifying the class."}, {"principle": "Open-Closed", "justification": "The class cannot be extended to support new compression algorithms or output formats without modifying its existing code. It directly implements specific logic without abstraction, violating OCP."}, {"principle": "Dependency Inversion", "justification": "The Compressor class directly instantiates low-level components like HuffmanTree and FileWriter. High-level modules should depend on abstractions rather than concrete implementations, but no interfaces are used here."}]}]}
{"project_id": 132, "chunk_id": 0, "prompt": {"main_file_path": "compactEngine-main/compressorImages/EntropyCalculator.java", "main_file_content": "package compressorImages; import java.awt.image.BufferedImage; import javax.imageio.ImageIO; import java.io.File; import java.util.HashMap; import java.util.Map; public class EntropyCalculator { public static void calculate(String imagePath) { try { BufferedImage image = ImageIO.read(new File(imagePath)); soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") } catch (Exception e) { e.printStackTrace(); } } private static double calculateEntropy(BufferedImage image, String channel) { Map<Integer, Integer> frequencyMap = new HashMap<>(); int width = image.getWidth(); int height = image.getHeight(); int totalPixels = width * height; for (int y = 0; y < height; y++) { for (int x = 0; x < width; x++) { int rgb = image.getRGB(x, y); int value; if (channel.equals(\"R\")) { value = (rgb >> 16) & 0xFF; } else if (channel.equals(\"G\")) { value = (rgb >> 8) & 0xFF; } else { value = rgb & 0xFF; } frequencyMap.put(value, frequencyMap.getOrDefault(value, 0) + 1); } } double entropy = 0.0; for (int frequency : frequencyMap.values()) { double probability = (double) frequency / totalPixels; entropy -= probability * (Math.log(probability) / Math.log(2)); } return entropy; } private static double calculateTotalEntropy(BufferedImage image) { Map<String, Integer> frequencyMap = new HashMap<>(); int width = image.getWidth(); int height = image.getHeight(); int totalPixels = width * height; for (int y = 0; y < height; y++) { for (int x = 0; x < width; x++) { int rgb = image.getRGB(x, y); int red = (rgb >> 16) & 0xFF; int green = (rgb >> 8) & 0xFF; int blue = rgb & 0xFF; String key = red + \",\" + green + \",\" + blue; frequencyMap.put(key, frequencyMap.getOrDefault(key, 0) + 1); } } double entropy = 0.0; for (int frequency : frequencyMap.values()) { double probability = (double) frequency / totalPixels; entropy -= probability * (Math.log(probability) / Math.log(2)); } return entropy; } public static double getTotalEntropy(String imagePath) { try { BufferedImage image = ImageIO.read(new File(imagePath)); return calculateTotalEntropy(image); } catch (Exception e) { e.printStackTrace(); return -1; } } public static double getEntropyImageAverage(String imagePath) { try { BufferedImage image = ImageIO.read(new File(imagePath)); double redEntropy = calculateEntropy(image, \"R\"); double greenEntropy = calculateEntropy(image, \"G\"); double blueEntropy = calculateEntropy(image, \"B\"); return (redEntropy + greenEntropy + blueEntropy) / 3; } catch (Exception e) { e.printStackTrace(); return -1; } } public static double getEntropyChannel(String imagePath, String channel) { try { BufferedImage image = ImageIO.read(new File(imagePath)); return calculateEntropy(image, channel); } catch (Exception e) { e.printStackTrace(); return -1; } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "compactEngine-main/compressorImages/EntropyCalculator.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "EntropyCalculator handles image loading, channel-specific entropy calculations, and total entropy calculations. These are multiple responsibilities that could change independently."}, {"principle": "Open-Closed", "justification": "Adding new entropy calculation methods (e.g., for new color spaces) requires modifying the existing class rather than extending it through abstractions."}, {"principle": "Dependency Inversion", "justification": "High-level entropy calculations directly depend on concrete image processing implementations (BufferedImage, ImageIO) instead of abstractions."}]}]}
{"project_id": 132, "chunk_id": 0, "prompt": {"main_file_path": "compactEngine-main/compressorImages/MainTeste.java", "main_file_content": "package compressorImages; import java.io.File; import java.io.FileFilter; import java.util.Random; import java.util.Scanner; public class MainTeste { static Scanner input = new Scanner(System.in); public static void main(String[] args) { do { switch (Menu()) { case 1 -> { input.nextLine(); soutl(\"\") String inputImagePath = input.nextLine(); int random = new Random().nextInt(1000); String compressedFilePath = \"./images/compressedImages/imagemComprimida\"+ random +\".txt\"; soutl(\"\") Compressor compressor = new Compressor(); compressor.compressImage(inputImagePath, compressedFilePath); soutl(\"\") } case 2 -> { input.nextLine(); soutl(\"\") String compressedFilePath = input.nextLine(); int random = new Random().nextInt(1000); String outputImagePath = \"./images/decompressedImages/ImagemDescomprimida\"+ random +\".png\"; soutl(\"\") Decompressor decompressor = new Decompressor(); decompressor.decompressImage(compressedFilePath, outputImagePath); soutl(\"\") } case 3 -> { input.nextLine(); soutl(\"\") String inputImagePath = input.nextLine(); soutl(\"\") } case 4 -> { input.nextLine(); soutl(\"\") String inputImagePath = input.nextLine(); soutl(\"\") } case 5 -> { input.nextLine(); soutl(\"\") String inputImagePath = input.nextLine(); soutl(\"\") EntropyCalculator.calculate(inputImagePath); } case 6 -> { input.nextLine(); soutl(\"\") String inputImagePath = input.nextLine(); int random = new Random().nextInt(1000); String compressedFilePath = \"./images/compressedImages/imagemComprimida\"+ random +\".txt\"; String outputImagePath = \"./images/decompressedImages/ImagemDescomprimida\"+ random +\".png\"; soutl(\"\") Compressor compressor = new Compressor(); compressor.compressImage(inputImagePath, compressedFilePath); soutl(\"\") soutl(\"\") Decompressor decompressor = new Decompressor(); decompressor.decompressImage(compressedFilePath, outputImagePath); soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") EntropyCalculator.calculate(inputImagePath); } case 7 -> { input.nextLine(); File f = new File(\"images/testImages\"); File[] files = f.listFiles(new FileFilter() { @Override public boolean accept(File pathname) { return pathname.isFile(); } }); for (int i = 1; i <= files.length; i++) { String inputImagePath = \"images/testImages/image\"+i+\".png\"; int random = new Random().nextInt(1000); String compressedFilePath = \"./images/compressedImages/imagemComprimida\"+ random +\".txt\"; String outputImagePath = \"./images/decompressedImages/ImagemDescomprimida\"+ random +\".png\"; soutl(\"\") Compressor compressor = new Compressor(); compressor.compressImage(inputImagePath, compressedFilePath); soutl(\"\") soutl(\"\") Decompressor decompressor = new Decompressor(); decompressor.decompressImage(compressedFilePath, outputImagePath); soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") EntropyCalculator.calculate(inputImagePath); } } case 9 -> { soutl(\"\") System.exit(0); } default -> { soutl(\"\") } }} while (true); } public static int Menu() { soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") soutl(\"\") int opcao = input.nextInt(); return opcao; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "compactEngine-main/compressorImages/MainTeste.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "MainTeste handles multiple responsibilities: user input, menu display, compression, decompression, entropy calculation, and batch processing. This gives it multiple reasons to change."}, {"principle": "Open-Closed", "justification": "Adding new functionality (e.g., a new compression algorithm) requires modifying the switch-case in main(), rather than extending via abstractions."}, {"principle": "Dependency Inversion", "justification": "MainTeste directly instantiates concrete Compressor, Decompressor, and EntropyCalculator classes. High-level modules should depend on abstractions, not concrete implementations."}]}]}
{"project_id": 132, "chunk_id": 0, "prompt": {"main_file_path": "compactEngine-main/compressorImages/HuffmanTree.java", "main_file_content": "package compressorImages; import java.util.HashMap; import java.util.Map; import java.util.PriorityQueue; public class HuffmanTree { protected HuffmanNode root; private Map<Integer, String> codes = new HashMap<>(); public HuffmanTree(Map<Integer, Integer> frequencies) { PriorityQueue<HuffmanNode> queue = new PriorityQueue<>(); for (Map.Entry<Integer, Integer> entry : frequencies.entrySet()) { queue.add(new HuffmanNode(entry.getKey(), entry.getValue())); } while (queue.size() > 1) { HuffmanNode left = queue.poll(); HuffmanNode right = queue.poll(); HuffmanNode parent = new HuffmanNode(-1, left.frequency + right.frequency); parent.left = left; parent.right = right; queue.add(parent); } root = queue.poll(); generateCodes(root, \"\"); } private void generateCodes(HuffmanNode node, String code) { if (node == null) return; if (node.value != -1) { codes.put(node.value, code); } generateCodes(node.left, code + \"0\"); generateCodes(node.right, code + \"1\"); } public Map<Integer, String> getCodes() { return codes; } public HuffmanNode getRoot() { return root; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "compactEngine-main/compressorImages/HuffmanTree.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "HuffmanTree handles both tree construction and code generation, which are two distinct responsibilities. This creates multiple reasons for the class to change."}, {"principle": "Open-Closed", "justification": "The tree construction logic is hardcoded in the constructor. Extending the tree-building algorithm would require modifying existing code instead of overriding or extending via abstractions."}, {"principle": "Dependency Inversion", "justification": "HuffmanTree directly depends on the concrete HuffmanNode class. High-level modules should depend on abstractions rather than concrete implementations."}]}]}
{"project_id": 132, "chunk_id": 0, "prompt": {"main_file_path": "compactEngine-main/compressorImages/Decompressor.java", "main_file_content": "package compressorImages; import java.io.BufferedReader; import java.io.File; import java.io.FileReader; import java.io.IOException; import java.util.HashMap; import java.util.Map; import javax.imageio.ImageIO; import java.awt.image.BufferedImage; public class Decompressor { public void decompressImage(String inputFilePath, String outputImagePath) { long startTime = System.currentTimeMillis(); try (BufferedReader reader = new BufferedReader(new FileReader(inputFilePath))) { String[] dimensions = reader.readLine().split(\" \"); int width = Integer.parseInt(dimensions[0]); int height = Integer.parseInt(dimensions[1]); reader.readLine(); Map<Integer, Integer> redFrequency = parseFrequencies(reader.readLine()); reader.readLine(); Map<Integer, Integer> greenFrequency = parseFrequencies(reader.readLine()); reader.readLine(); Map<Integer, Integer> blueFrequency = parseFrequencies(reader.readLine()); HuffmanTree redTree = new HuffmanTree(redFrequency); HuffmanTree greenTree = new HuffmanTree(greenFrequency); HuffmanTree blueTree = new HuffmanTree(blueFrequency); BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); for (int y = 0; y < height; y++) { for (int x = 0; x < width; x++) { int red = decodeColor(reader, redTree); int green = decodeColor(reader, greenTree); int blue = decodeColor(reader, blueTree); int rgb = (red << 16) | (green << 8) | blue; image.setRGB(x, y, rgb); } } ImageIO.write(image, \"png\", new File(outputImagePath)); soutl(\"\") System.out.printf(\"\"\" Informa\u00e7\u00f5es da descompress\u00e3o: - Largura: %d pixels - Altura: %d pixels - Caminho da imagem descomprimida:\\n '%s' \\n \"\"\", width, height, outputImagePath); long endTime = System.currentTimeMillis(); soutl(\"\") } catch (Exception e) { e.printStackTrace(); soutl(\"\") } } private Map<Integer, Integer> parseFrequencies(String frequencyData) { Map<Integer, Integer> frequencies = new HashMap<>(); frequencyData = frequencyData.replaceAll(\"[{} ]\", \"\"); String[] pairs = frequencyData.split(\",\"); for (String pair : pairs) { String[] keyValue = pair.split(\"=\"); int value = Integer.parseInt(keyValue[0]); int frequency = Integer.parseInt(keyValue[1]); frequencies.put(value, frequency); } return frequencies; } private int decodeColor(BufferedReader reader, HuffmanTree tree) throws IOException { HuffmanNode currentNode = tree.getRoot(); int bit; while (currentNode.left != null && currentNode.right != null) { bit = reader.read(); if (bit == '0') { currentNode = currentNode.left; } else if (bit == '1') { currentNode = currentNode.right; } else { throw new IOException(\"Formato inv\u00e1lido no arquivo compactado.\"); } } return currentNode.value; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "compactEngine-main/compressorImages/Decompressor.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Decompressor class handles multiple responsibilities including file I/O, frequency parsing, Huffman tree construction, image decoding, and output logging. This bundling of multiple tasks into one class violates SRP."}, {"principle": "Open-Closed", "justification": "The decompressImage method directly implements Huffman decoding logic. Supporting new decompression algorithms would require modifying this method instead of extending existing behavior, violating OCP."}, {"principle": "Dependency Inversion", "justification": "The Decompressor class directly instantiates HuffmanTree (a low-level module) without depending on an abstraction. High-level decompression logic depends on concrete implementations, violating DIP."}]}]}
{"project_id": 132, "chunk_id": 0, "prompt": {"main_file_path": "compactEngine-main/compressorImages/HuffmanNode.java", "main_file_content": "package compressorImages; public class HuffmanNode implements Comparable<HuffmanNode> { int value; int frequency; HuffmanNode left; HuffmanNode right; public HuffmanNode(int value, int frequency) { this.value = value; this.frequency = frequency; } @Override public int compareTo(HuffmanNode node) { return this.frequency - node.frequency; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 134, "chunk_id": 0, "prompt": {"main_file_path": "ATM-System-main/ATM-System-main/ATMS.java", "main_file_content": "import java.util.*; import java.io.*; class Menus { public void displayWelcomeScreen() { ATMS.clearConsol(); sout(\"\") sout(\"\") Scanner scan = new Scanner(System.in); int choice = scan.nextInt(); switch (choice) { case 1: try { ATMS.login.login(); } catch (IOException e) { e.printStackTrace(); } break; case 2: try { ATMS.registration.registration(); } catch (IOException e) { e.printStackTrace(); } break; case 3: try { ATMS.changePin.changePin(); } catch (IOException e) { e.printStackTrace(); } break; case 4: sout(\"\") try { sout(\"\") System.in.read(); } catch (IOException e) { e.printStackTrace(); } System.exit(0); break; default: sout(\"\") try { sout(\"\") System.in.read(); } catch (IOException e) { e.printStackTrace(); } ATMS.menu.displayWelcomeScreen(); } scan.close(); } public void displayMainMenu() { ATMS.clearConsol(); sout(\"\") sout(\"\") Scanner scan = new Scanner(System.in); int choice = scan.nextInt(); switch (choice) { case 1: try { ATMS.transaction.viewBalance(); } catch (IOException e) { e.printStackTrace(); } break; case 2: try { ATMS.transaction.withdrawal(); } catch (IOException e) { e.printStackTrace(); } break; case 3: try { ATMS.transaction.deposit(); } catch (IOException e) { e.printStackTrace(); } break; case 4: sout(\"\") try { sout(\"\") System.in.read(); } catch (IOException e) { e.printStackTrace(); } ATMS.menu.displayWelcomeScreen(); break; default: sout(\"\") try { sout(\"\") System.in.read(); } catch (IOException e) { e.printStackTrace(); } ATMS.menu.displayMainMenu(); } scan.close(); } } class Registration { Scanner scan = new Scanner(System.in); String Acc_no; String nam; String dob; String phn; String pin; String bal; public void registration() throws IOException { ATMS.clearConsol(); sout(\"\") sout(\"\") String Acc_no = scan.nextLine(); try { ATMS.database.getRecords(Acc_no); } catch (Exception e) { } if (Acc_no.equals(ATMS.accountNumber)) { sout(\"\") sout(\"\") System.in.read(); ATMS.menu.displayWelcomeScreen(); } else { createAccount(Acc_no); } } public void createAccount(String Acc_no) throws IOException { String acc_no = Acc_no; sout(\"\") String nam = scan.nextLine(); sout(\"\") String dob = scan.nextLine(); sout(\"\") String phn = scan.nextLine(); sout(\"\") String pin = scan.nextLine(); sout(\"\") String bal = scan.nextLine(); sout(\"\") String pas = scan.nextLine(); File log = new File(\"ATM.txt\"); try { if (!log.exists()) { log.createNewFile(); } FileWriter fileWriter = new FileWriter(log, true); BufferedWriter bufferedWriter = new BufferedWriter(fileWriter); bufferedWriter .write(acc_no + \" : \" + nam + \" , \" + dob + \" , \" + phn + \" , \" + pin + \" , \" + bal + \" , \" + pas); bufferedWriter.write(\"\\n\"); bufferedWriter.close(); sout(\"\") sout(\"\") System.in.read(); } catch (IOException e) { soutl(\"\") e.printStackTrace(); } ATMS.menu.displayWelcomeScreen(); } } class Login { public void login() throws IOException { ATMS.clearConsol(); Scanner scan = new Scanner(System.in); if (new File(\"ATM.txt\").isFile()) { sout(\"\") String acc_no = scan.nextLine(); ATMS.database.getRecords(acc_no); if (acc_no.equals(ATMS.accountNumber)) { sout(\"\") String pin = scan.nextLine(); if (pin.equals(ATMS.pin)) { ATMS.menu.displayMainMenu(); } else { sout(\"\") sout(\"\") System.in.read(); scan.nextLine(); login(); } } else { sout(\"\") sout(\"\") System.in.read(); ATMS.menu.displayWelcomeScreen(); } } else { sout(\"\") sout(\"\") System.in.read(); ATMS.menu.displayWelcomeScreen(); } scan.close(); } } class Transaction { public void viewBalance() throws IOException { ATMS.clearConsol(); String name = ATMS.name; int bal = Integer.parseInt(ATMS.balance); sout(\"\") sout(\"\") System.in.read(); ATMS.menu.displayMainMenu(); } public void withdrawal() throws IOException { ATMS.clearConsol(); Scanner scan = new Scanner(System.in); int balance = Integer.parseInt(ATMS.balance); int userChoice = 0; while (userChoice == 0) { ATMS.clearConsol(); sout(\"\") sout(\"\") sout(\"\") int choice = scan.nextInt(); switch (choice) { case 1: if (500 <= balance) { balance = balance - 500; ATMS.balance = String.valueOf(balance); sout(\"\") sout(\"\") System.in.read(); ATMS.database.updateRecord(); } else { soutl(\"\") sout(\"\") System.in.read(); } break; case 2: if (1000 <= balance) { balance = balance - 1000; ATMS.balance = String.valueOf(balance); sout(\"\") sout(\"\") System.in.read(); ATMS.database.updateRecord(); } else { sout(\"\") sout(\"\") System.in.read(); } break; case 3: if (2000 <= balance) { balance = balance - 2000; ATMS.balance = String.valueOf(balance); sout(\"\") sout(\"\") System.in.read(); ATMS.database.updateRecord(); } else { sout(\"\") sout(\"\") System.in.read(); } break; case 4: if (2500 <= balance) { balance = balance - 2500; ATMS.balance = String.valueOf(balance); sout(\"\") sout(\"\") System.in.read(); ATMS.database.updateRecord(); } else { sout(\"\") sout(\"\") System.in.read(); } break; case 5: if (5000 <= balance) { balance = balance - 5000; ATMS.balance = String.valueOf(balance); sout(\"\") sout(\"\") System.in.read(); ATMS.database.updateRecord(); } else { sout(\"\") sout(\"\") System.in.read(); } break; case 6: sout(\"\") int withdraw_amount = scan.nextInt(); if(withdraw_amount > 0 && withdraw_amount <= balance) { balance = balance - withdraw_amount; ATMS.balance = String.valueOf(balance); sout(\"\") sout(\"\") System.in.read(); ATMS.database.updateRecord(); } else if(withdraw_amount < 0) { sout(\"\") sout(\"\") System.in.read(); } else { sout(\"\") sout(\"\") System.in.read(); } break; case 0: sout(\"\") sout(\"\") System.in.read(); ATMS.menu.displayMainMenu(); break; default: soutl(\"\") sout(\"\") System.in.read(); break; } } scan.close(); } public void deposit() throws IOException { ATMS.clearConsol(); int balance = Integer.parseInt(ATMS.balance); Scanner scan = new Scanner(System.in); sout(\"\") int amount = scan.nextInt(); if (amount > 0 || amount < 50000) { balance = balance + amount; ATMS.balance = String.valueOf(balance); sout(\"\") sout(\"\") System.in.read(); ATMS.database.updateRecord(); ATMS.menu.displayMainMenu(); } scan.close(); } } class ChangePin { public void changePin() throws IOException { ATMS.clearConsol(); Scanner scan = new Scanner(System.in); sout(\"\") String acc_no = scan.nextLine(); ATMS.database.getRecords(acc_no); if (acc_no.equals(ATMS.accountNumber)) { sout(\"\") String pas = scan.nextLine(); if (pas.equals(ATMS.password)) { sout(\"\") String PIN = scan.nextLine(); ATMS.pin = PIN; sout(\"\") sout(\"\") System.in.read(); ATMS.database.updateRecord(); } else { sout(\"\") sout(\"\") System.in.read(); } } else { sout(\"\") sout(\"\") System.in.read(); } scan.close(); } } class Database { public void getRecords(String acc_no) throws IOException { File file = new File(\"ATM.txt\"); FileReader fr = new FileReader(file); BufferedReader br = new BufferedReader(fr); String line; if (file.exists()) { while ((line = br.readLine()) != null) { String[] parts = line.split(\":\"); String Accounts = parts[0].trim(); if (acc_no.equals(Accounts)) { String values = parts[1].trim(); String[] arrSplit = values.split(\",\"); ATMS.accountNumber = acc_no; ATMS.name = arrSplit[0].trim(); ATMS.dob = arrSplit[1].trim(); ATMS.phoneNumber = arrSplit[2].trim(); ATMS.pin = arrSplit[3].trim(); ATMS.balance = arrSplit[4].trim(); ATMS.password = arrSplit[5].trim(); break; } } } br.close(); } public void updateRecord() throws IOException { File tempFile = new File(\"tempfile\"); FileWriter fw = new FileWriter(tempFile); File originalFile = new File(\"ATM.txt\"); FileReader fr = new FileReader(originalFile); BufferedReader br = new BufferedReader(fr); String line; try { if (originalFile.exists()) { while ((line = br.readLine()) != null) { String[] parts = line.split(\":\"); String Account = parts[0].trim(); if (Account.equals(ATMS.accountNumber)) { continue; } fw.write(line); fw.write(\"\\n\"); fw.flush(); } fw.close(); br.close(); originalFile.delete(); tempFile.renameTo(originalFile); } } catch (IOException e) { soutl(\"\") e.printStackTrace(); } File log = new File(\"ATM.txt\"); try { if (!log.exists()) { log.createNewFile(); } FileWriter fileWriter = new FileWriter(log, true); BufferedWriter bufferedWriter = new BufferedWriter(fileWriter); bufferedWriter.write(ATMS.accountNumber + \" : \" + ATMS.name + \" , \" + ATMS.dob + \" , \" + ATMS.phoneNumber + \" , \" + ATMS.pin + \" , \" + ATMS.balance + \" , \" + ATMS.password); bufferedWriter.write(\"\\n\"); bufferedWriter.close(); ATMS.menu.displayMainMenu(); } catch (IOException e) { soutl(\"\") e.printStackTrace(); } } } public class ATMS { static String accountNumber = null; static String name = null; static String dob = null; static String phoneNumber = null; static String pin = null; static String balance = null; static String password = null; static Menus menu = new Menus(); static Registration registration = new Registration(); static Database database = new Database(); static Login login = new Login(); static Transaction transaction = new Transaction(); static ChangePin changePin = new ChangePin(); public final static void clearConsol() { sout(\"\") System.out.flush(); } public static void main(String[] args) throws IOException { Menus menu = new Menus(); menu.displayWelcomeScreen(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "ATM-System-main/ATM-System-main/ATMS.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Menus class handles both UI rendering and user input processing, and the Registration class manages user input, validation, and file operations, violating SRP by having multiple responsibilities."}, {"principle": "Open-Closed", "justification": "The Menus class uses switch-case blocks to handle menu options, requiring direct modification to add new functionality, which violates OCP by not being extendable without changing existing code."}, {"principle": "Dependency Inversion", "justification": "High-level classes like ATMS and Menus directly depend on concrete low-level modules (e.g., Database, Registration) instead of abstractions, violating DIP by creating tight coupling."}]}]}
{"project_id": 135, "chunk_id": 0, "prompt": {"main_file_path": "Java-JDBC-main/Java-JDBC-main/MyFirstJDBCProject/src/main/java/org/example/DBHelp.java", "main_file_content": "package org.example; import java.sql.*; import java.sql.SQLException; public class DBHelp { private final static String SQL_INSERT = \"INSERT INTO film_text(film_id, title, description) VALUES(?,?,?)\"; private final Connection connect; public DBHelp() throws SQLException { connect = ConnectorDB.getConnection(); } public PreparedStatement getPreparedStatement() { PreparedStatement ps = null; try { ps = connect.prepareStatement(SQL_INSERT); } catch (SQLException e) { e.printStackTrace(); } return ps; } public void insertFilm(PreparedStatement ps, FilmText cr) { try { ps.setInt(1, cr.getId()); ps.setString(2, cr.getTitle()); ps.setString(3, cr.getDescription()); ps.executeUpdate(); } catch (SQLException e) { e.printStackTrace(); } } public void closeStatement(PreparedStatement ps) { if (ps != null) { try { ps.close(); } catch (SQLException e) { e.printStackTrace(); } } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Java-JDBC-main/Java-JDBC-main/MyFirstJDBCProject/src/main/java/org/example/DBHelp.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "DBHelp manages database connections, prepares statements, executes updates, and handles resource closure, indicating multiple responsibilities."}, {"principle": "Open-Closed", "justification": "Adding new database operations requires modifying DBHelp's existing code instead of extending it via abstractions."}, {"principle": "Dependency Inversion", "justification": "DBHelp directly depends on the concrete ConnectorDB class instead of an abstraction for database connections."}]}]}
{"project_id": 135, "chunk_id": 0, "prompt": {"main_file_path": "Java-JDBC-main/Java-JDBC-main/MyFirstJDBCProject/src/main/java/org/example/DBInsertRunner.java", "main_file_content": "package org.example; import java.sql.*; import java.util.ArrayList; public class DBInsertRunner { public static void main(String[] args) throws SQLException { DBHelp helper = new DBHelp(); PreparedStatement statement = helper.getPreparedStatement(); ArrayList<FilmText> list = new ArrayList<>() { { add(new FilmText(1003, \"FILM 3\", \"Description of the Film 3\")); add(new FilmText(1004, \"FILM 4\", \"Description of the Film 4\")); add(new FilmText(1005, \"FILM 5\", \"Description of the Film 5\")); add(new FilmText(1006, \"FILM 6\", \"Description of the Film 6\")); add(new FilmText(1007, \"FILM 7\", \"Description of the Film 7\")); } }; addingByPrepareStatement(helper, statement, list); } private static void addingByPrepareStatement(DBHelp helper, PreparedStatement statement, ArrayList<FilmText> list) { try { for (FilmText film : list) { helper.insertFilm(statement, film); } Main.seeResult(list); } finally { assert helper != null; helper.closeStatement(statement); } } }", "dependencies": [{"file_path": "Java-JDBC-main/Java-JDBC-main/MyFirstJDBCProject/src/main/java/org/example/DBHelp.java", "file_content": "package org.example; import java.sql.*; import java.sql.SQLException; public class DBHelp { private final static String SQL_INSERT = \"INSERT INTO film_text(film_id, title, description) VALUES(?,?,?)\"; private final Connection connect; public DBHelp() throws SQLException { connect = ConnectorDB.getConnection(); } public PreparedStatement getPreparedStatement() { PreparedStatement ps = null; try { ps = connect.prepareStatement(SQL_INSERT); } catch (SQLException e) { e.printStackTrace(); } return ps; } public void insertFilm(PreparedStatement ps, FilmText cr) { try { ps.setInt(1, cr.getId()); ps.setString(2, cr.getTitle()); ps.setString(3, cr.getDescription()); ps.executeUpdate(); } catch (SQLException e) { e.printStackTrace(); } } public void closeStatement(PreparedStatement ps) { if (ps != null) { try { ps.close(); } catch (SQLException e) { e.printStackTrace(); } } } }"}]}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Java-JDBC-main/Java-JDBC-main/MyFirstJDBCProject/src/main/java/org/example/DBHelp.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "DBHelp handles database connection, statement preparation, data insertion, and resource closure. These multiple responsibilities violate SRP as changes in connection handling or insertion logic would require modifying the same class."}, {"principle": "Dependency Inversion", "justification": "DBHelp directly depends on ConnectorDB.getConnection(), a concrete implementation. High-level modules like DBInsertRunner also depend directly on DBHelp instead of abstractions, violating DIP."}]}]}
{"project_id": 135, "chunk_id": 0, "prompt": {"main_file_path": "Java-JDBC-main/Java-JDBC-main/MyFirstJDBCProject/src/main/java/org/example/Main.java", "main_file_content": "package org.example; import java.sql.*; import java.util.ArrayList; import java.util.Properties; public class Main { public static void main(String[] args) throws SQLException { Connection cnn = ConnectorDB.getConnection(); settingDB(); Statement st = cnn.createStatement(); ArrayList<FilmText> lst = new ArrayList<>(); st.executeUpdate(\"INSERT film_text VALUES (1001, 'FILM 1', 'Description of the Film 1'),\" + \"(1002, 'FILM 2', 'Description of the Film 2')\"); ResultSet rs = st.executeQuery(\"SELECT * FROM film_text\"); putInArrayList(rs,lst); seeResult(lst); st.close(); cnn.close(); } static void seeResult(ArrayList<FilmText> lst) { if (lst.size() > 0) { for (FilmText film : lst) { soutl(\"\") } } else { soutl(\"\") } } private static void putInArrayList(ResultSet _rs,ArrayList<FilmText> lst) throws SQLException { while (_rs.next()) { FilmText currentFilm = new FilmText(); currentFilm.setId(_rs.getInt(\"film_id\")); currentFilm.setTitle(_rs.getString(\"title\")); currentFilm.setDescription(_rs.getString(\"description\")); lst.add(currentFilm); } } private static void settingDB() { Properties prop = new Properties(); prop.put(\"user\", \"root\"); prop.put(\"password\", \"FNaf12112002\"); prop.put(\"autoReconnect\", \"true\"); prop.put(\"characterEncoding\", \"UTF-8\"); prop.put(\"useUnicode\", \"true\"); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Java-JDBC-main/Java-JDBC-main/MyFirstJDBCProject/src/main/java/org/example/Main.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Main class handles database connection setup, SQL execution, data processing, and output. These multiple responsibilities violate SRP as the class has more than one reason to change."}, {"principle": "Open-Closed", "justification": "The Main class is not designed for extension. Adding new database operations or altering data processing would require modifying existing code rather than extending it."}, {"principle": "Dependency Inversion", "justification": "The Main class directly depends on concrete database implementation classes (e.g., Connection, Statement) instead of abstractions. High-level modules should depend on interfaces, not low-level details."}]}]}
{"project_id": 135, "chunk_id": 0, "prompt": {"main_file_path": "Java-JDBC-main/Java-JDBC-main/MyFirstJDBCProject/src/main/java/org/example/ConnectorDB.java", "main_file_content": "package org.example; import java.sql.Connection; import java.sql.DriverManager; import java.sql.SQLException; import java.util.ResourceBundle; public class ConnectorDB { protected static Connection getConnection() throws SQLException { ResourceBundle resource = ResourceBundle.getBundle(\"db\"); String url = resource.getString(\"db.url\"); String user = resource.getString(\"db.user\"); String pass = resource.getString(\"db.password\"); return DriverManager.getConnection(url, user, pass); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Java-JDBC-main/Java-JDBC-main/MyFirstJDBCProject/src/main/java/org/example/ConnectorDB.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The ConnectorDB class handles both configuration loading (reading from resource bundle) and database connection creation, which are two distinct responsibilities. Changes to configuration handling or connection logic would both require modifying this class."}]}]}
{"project_id": 135, "chunk_id": 0, "prompt": {"main_file_path": "Java-JDBC-main/Java-JDBC-main/MyFirstJDBCProject/src/main/java/org/example/FilmText.java", "main_file_content": "package org.example; public class FilmText { private int id; private String title; private String description; public FilmText() {} public FilmText(int id, String title, String description) { this.id = id; this.title = title; this.description = description; } public void setId(int id) { this.id = id; } public void setTitle(String title) { this.title = title; } public void setDescription(String description) { this.description = description; } public int getId() { return id; } public String getTitle() { return title; } public String getDescription() { return description; } @Override public String toString(){ return String.format(\"%d\\t%s\\t%s\", id, title, description); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Java-JDBC-main/Java-JDBC-main/MyFirstJDBCProject/src/main/java/org/example/FilmText.java", "violatedPrinciples": []}]}
{"project_id": 136, "chunk_id": 0, "prompt": {"main_file_path": "road-trip-master/road-trip-master/application/src/main/java/org/curiouscreature/android/roadtrip/TrackingScrollView.java", "main_file_content": "package org.curiouscreature.android.roadtrip; import android.content.Context; import android.util.AttributeSet; import android.widget.ScrollView; public class TrackingScrollView extends ScrollView { public interface OnScrollChangedListener { void onScrollChanged(TrackingScrollView source, int l, int t, int oldl, int oldt); } private OnScrollChangedListener mOnScrollChangedListener; public TrackingScrollView(Context context, AttributeSet attrs) { this(context, attrs, 0); } public TrackingScrollView(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); } public void setOnScrollChangedListener(OnScrollChangedListener listener) { mOnScrollChangedListener = listener; } @Override protected void onScrollChanged(int l, int t, int oldl, int oldt) { super.onScrollChanged(l, t, oldl, oldt); if (mOnScrollChangedListener != null) { mOnScrollChangedListener.onScrollChanged(this, l, t, oldl, oldt); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "road-trip-master/road-trip-master/application/src/main/java/org/curiouscreature/android/roadtrip/TrackingScrollView.java", "violatedPrinciples": []}]}
{"project_id": 136, "chunk_id": 0, "prompt": {"main_file_path": "road-trip-master/road-trip-master/application/src/main/java/org/curiouscreature/android/roadtrip/MainActivity.java", "main_file_content": "package org.curiouscreature.android.roadtrip; import android.app.Activity; import android.content.res.Resources; import android.graphics.*; import android.graphics.drawable.ColorDrawable; import android.graphics.drawable.Drawable; import android.os.Bundle; import android.view.*; import android.widget.ImageView; import android.widget.LinearLayout; import android.widget.Space; import android.widget.Toast; import java.util.ArrayList; import java.util.List; @SuppressWarnings(\"ConstantConditions\") public class MainActivity extends Activity { private static final boolean ANIMATE_BACKGROUND = false; private static class State { int background; int map; int photos[]; final List<Bitmap> bitmaps = new ArrayList<Bitmap>(); State(int background, int map, int[] photos) { this.background = background; this.map = map; this.photos = photos; } } private final State[] mStates = { new State(R.color.az, R.raw.map_az, new int[] { R.drawable.photo_01_antelope, R.drawable.photo_09_horseshoe, R.drawable.photo_10_sky }), new State(R.color.ut, R.raw.map_ut, new int[] { R.drawable.photo_08_arches, R.drawable.photo_03_bryce, R.drawable.photo_04_powell, }), new State(R.color.ca, R.raw.map_ca, new int[] { R.drawable.photo_07_san_francisco, R.drawable.photo_02_tahoe, R.drawable.photo_05_sierra, R.drawable.photo_06_rockaway }), }; private IntroView mIntroView; private Drawable mActionBarDrawable; private Drawable mWindowBackground; private int mAccentColor; private int mAccentColor2; private final Rect mTempRect = new Rect(); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mActionBarDrawable = getResources().getDrawable(R.drawable.ab_solid); mActionBarDrawable.setAlpha(0); getActionBar().setBackgroundDrawable(mActionBarDrawable); mAccentColor = getResources().getColor(R.color.accent); mAccentColor2 = getResources().getColor(R.color.accent2); mIntroView = (IntroView) findViewById(R.id.intro); mIntroView.setSvgResource(R.raw.map_usa); mIntroView.setOnReadyListener(new IntroView.OnReadyListener() { @Override public void onReady() { loadPhotos(); } }); ((TrackingScrollView) findViewById(R.id.scroller)).setOnScrollChangedListener( new TrackingScrollView.OnScrollChangedListener() { @Override public void onScrollChanged(TrackingScrollView source, int l, int t, int ol, int ot) { handleScroll(source, t); } }); } private void handleScroll(ViewGroup source, int top) { final float actionBarHeight = getActionBar().getHeight(); final float firstItemHeight = findViewById(R.id.scroller).getHeight() - actionBarHeight; final float alpha = Math.min(firstItemHeight, Math.max(0, top)) / firstItemHeight; mIntroView.setTranslationY(-firstItemHeight / 3.0f * alpha); mActionBarDrawable.setAlpha((int) (255 * alpha)); View decorView = getWindow().getDecorView(); removeOverdraw(decorView, alpha); if (ANIMATE_BACKGROUND) { changeBackgroundColor(decorView, alpha); } ViewGroup container = (ViewGroup) source.findViewById(R.id.container); final int count = container.getChildCount(); for (int i = 0; i < count; i++) { View item = container.getChildAt(i); View v = item.findViewById(R.id.state); if (v != null && v.getGlobalVisibleRect(mTempRect)) { ((StateView) v).reveal(source, item.getBottom()); } } } @SuppressWarnings(\"PointlessBitwiseExpression\") private void changeBackgroundColor(View decorView, float alpha) { float srcR = ((mAccentColor >> 16) & 0xff) / 255.0f; float srcG = ((mAccentColor >> 8) & 0xff) / 255.0f; float srcB = ((mAccentColor >> 0) & 0xff) / 255.0f; float dstR = ((mAccentColor2 >> 16) & 0xff) / 255.0f; float dstG = ((mAccentColor2 >> 8) & 0xff) / 255.0f; float dstB = ((mAccentColor2 >> 0) & 0xff) / 255.0f; int r = (int) ((srcR + ((dstR - srcR) * alpha)) * 255.0f); int g = (int) ((srcG + ((dstG - srcG) * alpha)) * 255.0f); int b = (int) ((srcB + ((dstB - srcB) * alpha)) * 255.0f); ColorDrawable background = (ColorDrawable) decorView.getBackground(); if (background != null) { background.setColor(0xff000000 | r << 16 | g << 8 | b); } } private void removeOverdraw(View decorView, float alpha) { if (alpha >= 1.0f) { mIntroView.setTranslationY(-mIntroView.getHeight() * 2.0f); } if (alpha >= 1.0f && decorView.getBackground() != null) { mWindowBackground = decorView.getBackground(); decorView.setBackground(null); } else if (alpha < 1.0f && decorView.getBackground() == null) { decorView.setBackground(mWindowBackground); mWindowBackground = null; } } private void loadPhotos() { final Resources resources = getResources(); new Thread(new Runnable() { @Override public void run() { for (State s : mStates) { for (int resId : s.photos) { s.bitmaps.add(BitmapFactory.decodeResource(resources, resId)); } } mIntroView.post(new Runnable() { @Override public void run() { finishLoadingPhotos(); } }); } }, \"Photos Loader\").start(); } private void finishLoadingPhotos() { mIntroView.stopWaitAnimation(); LinearLayout container = (LinearLayout) findViewById(R.id.container); LayoutInflater inflater = getLayoutInflater(); Space spacer = new Space(this); spacer.setLayoutParams(new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, findViewById(R.id.scroller).getHeight())); container.addView(spacer); for (State s : mStates) { addState(inflater, container, s); } } private void addState(LayoutInflater inflater, LinearLayout container, final State state) { final int margin = getResources().getDimensionPixelSize(R.dimen.activity_peek_margin); final View view = inflater.inflate(R.layout.item_state, container, false); final StateView stateView = (StateView) view.findViewById(R.id.state); stateView.setSvgResource(state.map); view.setBackgroundResource(state.background); LinearLayout subContainer = (LinearLayout) view.findViewById(R.id.sub_container); Space spacer = new Space(this); spacer.setLayoutParams(new LinearLayout.LayoutParams( container.getWidth() - margin, LinearLayout.LayoutParams.MATCH_PARENT)); subContainer.addView(spacer); ImageView first = null; for (Bitmap b : state.bitmaps) { ImageView image = (ImageView) inflater.inflate(R.layout.item_photo, subContainer, false); if (first == null) first = image; image.setImageBitmap(b); subContainer.addView(image); } ColorMatrix cm = new ColorMatrix(); cm.setSaturation(0.0f); first.setTag(cm); first.setColorFilter(new ColorMatrixColorFilter(cm)); final ImageView bw = first; TrackingHorizontalScrollView s = (TrackingHorizontalScrollView) view.findViewById(R.id.scroller); s.setOnScrollChangedListener(new TrackingHorizontalScrollView.OnScrollChangedListener() { @Override public void onScrollChanged(TrackingHorizontalScrollView source, int l, int t, int oldl, int oldt) { final float width = source.getWidth() - margin; final float alpha = Math.min(width, Math.max(0, l)) / width; stateView.setTranslationX(-width / 3.0f * alpha); stateView.setParallax(1.0f - alpha); removeStateOverdraw(view, state, alpha); if (alpha < 1.0f) { ColorMatrix cm = (ColorMatrix) bw.getTag(); cm.setSaturation(alpha); bw.setColorFilter(new ColorMatrixColorFilter(cm)); } else { bw.setColorFilter(null); } } }); container.addView(view); } private void removeStateOverdraw(View stateView, State state, float alpha) { if (alpha >= 1.0f && stateView.getBackground() != null) { stateView.setBackground(null); stateView.findViewById(R.id.state).setVisibility(View.INVISIBLE); } else if (alpha < 1.0f && stateView.getBackground() == null) { stateView.setBackgroundResource(state.background); stateView.findViewById(R.id.state).setVisibility(View.VISIBLE); } } @Override public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.main, menu); return true; } @Override public boolean onOptionsItemSelected(MenuItem item) { int id = item.getItemId(); if (id == R.id.action_about) { Toast.makeText(this, R.string.text_about, Toast.LENGTH_LONG).show(); return true; } return super.onOptionsItemSelected(item); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "road-trip-master/road-trip-master/application/src/main/java/org/curiouscreature/android/roadtrip/MainActivity.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "MainActivity handles UI setup, scroll handling, photo loading, background color transitions, and view inflation. Multiple responsibilities violate SRP."}, {"principle": "Open-Closed", "justification": "State management is hardcoded in mStates array. Adding new states requires modifying MainActivity instead of extending through abstractions."}, {"principle": "Dependency Inversion", "justification": "Directly depends on concrete TrackingScrollView/TrackingHorizontalScrollView implementations instead of abstractions. High-level scroll logic couples with low-level details."}]}]}
{"project_id": 136, "chunk_id": 0, "prompt": {"main_file_path": "road-trip-master/road-trip-master/application/src/main/java/org/curiouscreature/android/roadtrip/TrackingHorizontalScrollView.java", "main_file_content": "package org.curiouscreature.android.roadtrip; import android.content.Context; import android.util.AttributeSet; import android.widget.HorizontalScrollView; public class TrackingHorizontalScrollView extends HorizontalScrollView { public interface OnScrollChangedListener { void onScrollChanged(TrackingHorizontalScrollView source, int l, int t, int oldl, int oldt); } private OnScrollChangedListener mOnScrollChangedListener; public TrackingHorizontalScrollView(Context context, AttributeSet attrs) { this(context, attrs, 0); } public TrackingHorizontalScrollView(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); } public void setOnScrollChangedListener(OnScrollChangedListener listener) { mOnScrollChangedListener = listener; } @Override protected void onScrollChanged(int l, int t, int oldl, int oldt) { super.onScrollChanged(l, t, oldl, oldt); if (mOnScrollChangedListener != null) { mOnScrollChangedListener.onScrollChanged(this, l, t, oldl, oldt); } } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": []}
{"project_id": 136, "chunk_id": 0, "prompt": {"main_file_path": "road-trip-master/road-trip-master/application/src/main/java/org/curiouscreature/android/roadtrip/StateView.java", "main_file_content": "package org.curiouscreature.android.roadtrip; import android.animation.ObjectAnimator; import android.content.Context; import android.content.res.TypedArray; import android.graphics.Canvas; import android.graphics.Paint; import android.util.AttributeSet; import android.util.Log; import android.view.View; import java.util.ArrayList; import java.util.List; @SuppressWarnings(\"ForLoopReplaceableByForEach\") public class StateView extends View { private static final String LOG_TAG = \"StateView\"; private final Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); private final SvgHelper mSvg = new SvgHelper(mPaint); private int mSvgResource; private final Object mSvgLock = new Object(); private List<SvgHelper.SvgPath> mPaths = new ArrayList<SvgHelper.SvgPath>(0); private Thread mLoader; private float mPhase; private float mFadeFactor; private int mDuration; private float mParallax = 1.0f; private float mOffsetY; private ObjectAnimator mSvgAnimator; public StateView(Context context, AttributeSet attrs) { this(context, attrs, 0); } public StateView(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); mPaint.setStyle(Paint.Style.STROKE); TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.IntroView, defStyle, 0); try { if (a != null) { mPaint.setStrokeWidth(a.getFloat(R.styleable.StateView_strokeWidth, 1.0f)); mPaint.setColor(a.getColor(R.styleable.StateView_strokeColor, 0xff000000)); mPhase = a.getFloat(R.styleable.StateView_phase, 1.0f); mDuration = a.getInt(R.styleable.StateView_duration, 4000); mFadeFactor = a.getFloat(R.styleable.StateView_fadeFactor, 10.0f); } } finally { if (a != null) a.recycle(); } } private void updatePathsPhaseLocked() { final int count = mPaths.size(); for (int i = 0; i < count; i++) { SvgHelper.SvgPath svgPath = mPaths.get(i); svgPath.renderPath.reset(); svgPath.measure.getSegment(0.0f, svgPath.length * mPhase, svgPath.renderPath, true); svgPath.renderPath.rLineTo(0.0f, 0.0f); } } public float getParallax() { return mParallax; } public void setParallax(float parallax) { mParallax = parallax; invalidate(); } public float getPhase() { return mPhase; } public void setPhase(float phase) { mPhase = phase; synchronized (mSvgLock) { updatePathsPhaseLocked(); } invalidate(); } public int getSvgResource() { return mSvgResource; } public void setSvgResource(int svgResource) { mSvgResource = svgResource; } @Override protected void onSizeChanged(final int w, final int h, int oldw, int oldh) { super.onSizeChanged(w, h, oldw, oldh); if (mLoader != null) { try { mLoader.join(); } catch (InterruptedException e) { Log.e(LOG_TAG, \"Unexpected error\", e); } } mLoader = new Thread(new Runnable() { @Override public void run() { mSvg.load(getContext(), mSvgResource); synchronized (mSvgLock) { mPaths = mSvg.getPathsForViewport( w - getPaddingLeft() - getPaddingRight(), h - getPaddingTop() - getPaddingBottom()); updatePathsPhaseLocked(); } } }, \"SVG Loader\"); mLoader.start(); } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); synchronized (mSvgLock) { canvas.save(); canvas.translate(getPaddingLeft(), getPaddingTop() + mOffsetY); final int count = mPaths.size(); for (int i = 0; i < count; i++) { SvgHelper.SvgPath svgPath = mPaths.get(i); int alpha = (int) (Math.min(mPhase * mFadeFactor, 1.0f) * 255.0f); svgPath.paint.setAlpha((int) (alpha * mParallax)); canvas.drawPath(svgPath.renderPath, svgPath.paint); } canvas.restore(); } } public void reveal(View scroller, int parentBottom) { if (mSvgAnimator == null) { mSvgAnimator = ObjectAnimator.ofFloat(this, \"phase\", 0.0f, 1.0f); mSvgAnimator.setDuration(mDuration); mSvgAnimator.start(); } float previousOffset = mOffsetY; mOffsetY = Math.min(0, scroller.getHeight() - (parentBottom - scroller.getScrollY())); if (previousOffset != mOffsetY) invalidate(); } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "road-trip-master/road-trip-master/application/src/main/java/org/curiouscreature/android/roadtrip/StateView.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "StateView handles SVG loading, path rendering, animation management, parallax calculation, and view attribute parsing. These multiple responsibilities violate SRP."}, {"principle": "Open-Closed", "justification": "StateView cannot be extended to modify SVG loading or rendering behavior without modifying existing code. No extension points for variation points like path processing."}, {"principle": "Dependency Inversion", "justification": "StateView directly instantiates concrete SvgHelper. High-level view component should depend on abstraction for SVG processing rather than concrete implementation."}]}]}
{"project_id": 136, "chunk_id": 0, "prompt": {"main_file_path": "road-trip-master/road-trip-master/application/src/main/java/org/curiouscreature/android/roadtrip/IntroView.java", "main_file_content": "package org.curiouscreature.android.roadtrip; import android.animation.Animator; import android.animation.AnimatorListenerAdapter; import android.animation.ObjectAnimator; import android.content.Context; import android.content.res.TypedArray; import android.graphics.*; import android.util.AttributeSet; import android.util.Log; import android.view.View; import android.view.animation.LinearInterpolator; import java.util.ArrayList; import java.util.List; @SuppressWarnings({\"ForLoopReplaceableByForEach\", \"UnusedDeclaration\"}) public class IntroView extends View { private static final String LOG_TAG = \"IntroView\"; private final Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); private final SvgHelper mSvg = new SvgHelper(mPaint); private int mSvgResource; private final Object mSvgLock = new Object(); private List<SvgHelper.SvgPath> mPaths = new ArrayList<SvgHelper.SvgPath>(0); private Thread mLoader; private SvgHelper.SvgPath mWaitPath; private SvgHelper.SvgPath mDragPath; private Paint mArrowPaint; private int mArrowLength; private int mArrowHeight; private float mPhase; private float mWait; private float mDrag; private int mDuration; private float mFadeFactor; private int mRadius; private ObjectAnimator mSvgAnimator; private ObjectAnimator mWaitAnimator; private OnReadyListener mListener; public static interface OnReadyListener { void onReady(); } public IntroView(Context context, AttributeSet attrs) { this(context, attrs, 0); } public IntroView(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.IntroView, defStyle, 0); try { if (a != null) { mPaint.setStrokeWidth(a.getFloat(R.styleable.IntroView_strokeWidth, 1.0f)); mPaint.setColor(a.getColor(R.styleable.IntroView_strokeColor, 0xff000000)); mPhase = a.getFloat(R.styleable.IntroView_phase, 1.0f); mDuration = a.getInt(R.styleable.IntroView_duration, 4000); mFadeFactor = a.getFloat(R.styleable.IntroView_fadeFactor, 10.0f); mRadius = a.getDimensionPixelSize(R.styleable.IntroView_waitRadius, 50); mArrowLength = a.getDimensionPixelSize(R.styleable.IntroView_arrowLength, 32); mArrowHeight = a.getDimensionPixelSize(R.styleable.IntroView_arrowHeight, 18); } } finally { if (a != null) a.recycle(); } init(); } private void init() { mPaint.setStyle(Paint.Style.STROKE); createWaitPath(); setLayerType(LAYER_TYPE_SOFTWARE, null); mSvgAnimator = ObjectAnimator.ofFloat(this, \"phase\", 0.0f, 1.0f).setDuration(mDuration); mWaitAnimator = ObjectAnimator.ofFloat(this, \"wait\", 1.0f, 0.0f).setDuration(mDuration); mWaitAnimator.setRepeatMode(ObjectAnimator.RESTART); mWaitAnimator.setRepeatCount(ObjectAnimator.INFINITE); mWaitAnimator.setInterpolator(new LinearInterpolator()); mWaitAnimator.start(); } private void createWaitPath() { Paint paint = new Paint(mPaint); paint.setStrokeWidth(paint.getStrokeWidth() * 4.0f); Path p = new Path(); p.moveTo(0.0f, 0.0f); p.lineTo(mRadius * 6.0f, 0.0f); mWaitPath = new SvgHelper.SvgPath(p, paint); mArrowPaint = new Paint(mWaitPath.paint); paint = new Paint(mWaitPath.paint); mDragPath = new SvgHelper.SvgPath(makeDragPath(mRadius), paint); } public void setSvgResource(int resource) { if (mSvgResource == 0) { mSvgResource = resource; } } public void stopWaitAnimation() { ObjectAnimator alpha = ObjectAnimator.ofInt(mWaitPath.paint, \"alpha\", 0); alpha.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { mWaitAnimator.cancel(); ObjectAnimator.ofFloat(IntroView.this, \"drag\", 1.0f, 0.0f).setDuration(mDuration / 3).start(); } }); alpha.start(); } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); synchronized (mSvgLock) { canvas.save(); canvas.translate(getPaddingLeft(), getPaddingTop() - getPaddingBottom()); final int count = mPaths.size(); for (int i = 0; i < count; i++) { SvgHelper.SvgPath svgPath = mPaths.get(i); int alpha = (int) (Math.min(mPhase * mFadeFactor, 1.0f) * 255.0f); svgPath.paint.setAlpha(alpha); canvas.drawPath(svgPath.renderPath, svgPath.paint); } canvas.restore(); } canvas.save(); canvas.translate(0.0f, getHeight() - getPaddingBottom() - mRadius * 3.0f); if (mWaitPath.paint.getAlpha() > 0) { canvas.translate(getWidth() / 2.0f - mRadius * 3.0f, mRadius); canvas.drawPath(mWaitPath.path, mWaitPath.paint); } else { canvas.translate((getWidth() - mDragPath.bounds.width()) / 2.0f, 0.0f); canvas.drawPath(mDragPath.path, mDragPath.paint); canvas.drawPath(mDragPath.path, mArrowPaint); } canvas.restore(); } @Override protected void onSizeChanged(final int w, final int h, int oldw, int oldh) { super.onSizeChanged(w, h, oldw, oldh); if (mLoader != null) { try { mLoader.join(); } catch (InterruptedException e) { Log.e(LOG_TAG, \"Unexpected error\", e); } } mLoader = new Thread(new Runnable() { @Override public void run() { mSvg.load(getContext(), mSvgResource); synchronized (mSvgLock) { mPaths = mSvg.getPathsForViewport( w - getPaddingLeft() - getPaddingRight(), h - getPaddingTop() - getPaddingBottom()); updatePathsPhaseLocked(); } post(new Runnable() { @Override public void run() { invokeReadyListener(); if (mSvgAnimator.isRunning()) mSvgAnimator.cancel(); mSvgAnimator.start(); } }); } }, \"SVG Loader\"); mLoader.start(); } private void invokeReadyListener() { if (mListener != null) mListener.onReady(); } public void setOnReadyListener(OnReadyListener listener) { mListener = listener; } private void updatePathsPhaseLocked() { final int count = mPaths.size(); for (int i = 0; i < count; i++) { SvgHelper.SvgPath svgPath = mPaths.get(i); svgPath.renderPath.reset(); svgPath.measure.getSegment(0.0f, svgPath.length * mPhase, svgPath.renderPath, true); svgPath.renderPath.rLineTo(0.0f, 0.0f); } } public float getPhase() { return mPhase; } public void setPhase(float phase) { mPhase = phase; synchronized (mSvgLock) { updatePathsPhaseLocked(); } invalidate(); } public float getWait() { return mWait; } public void setWait(float wait) { mWait = wait; mWaitPath.paint.setPathEffect(createConcaveArrowPathEffect(mWaitPath.length, mWait, 32.0f)); invalidate(); } public float getDrag() { return mDrag; } public void setDrag(float drag) { mDrag = drag; mDragPath.paint.setPathEffect(createPathEffect(mDragPath.length, mDrag, mArrowLength)); mArrowPaint.setPathEffect(createArrowPathEffect(mDragPath.length, mDrag, mArrowLength)); int alpha = (int) (Math.min((1.0f - mDrag) * mFadeFactor, 1.0f) * 255.0f); mDragPath.paint.setAlpha(alpha); mArrowPaint.setAlpha(alpha); invalidate(); } private static PathEffect createPathEffect(float pathLength, float phase, float offset) { return new DashPathEffect(new float[] { pathLength, pathLength }, Math.max(phase * pathLength, offset)); } private PathEffect createArrowPathEffect(float pathLength, float phase, float offset) { return new PathDashPathEffect(makeArrow(mArrowLength, mArrowHeight), pathLength, Math.max(phase * pathLength, offset), PathDashPathEffect.Style.ROTATE); } private PathEffect createConcaveArrowPathEffect(float pathLength, float phase, float offset) { return new PathDashPathEffect(makeConcaveArrow(mArrowLength, mArrowHeight), mArrowLength * 1.2f, Math.max(phase * pathLength, offset), PathDashPathEffect.Style.ROTATE); } private static Path makeDragPath(int radius) { Path p = new Path(); RectF oval = new RectF(0.0f, 0.0f, radius * 2.0f, radius * 2.0f); float cx = oval.centerX(); float cy = oval.centerY(); float rx = oval.width() / 2.0f; float ry = oval.height() / 2.0f; final float TAN_PI_OVER_8 = 0.414213562f; final float ROOT_2_OVER_2 = 0.707106781f; float sx = rx * TAN_PI_OVER_8; float sy = ry * TAN_PI_OVER_8; float mx = rx * ROOT_2_OVER_2; float my = ry * ROOT_2_OVER_2; float L = oval.left; float T = oval.top; float R = oval.right; float B = oval.bottom; p.moveTo(R, cy); p.quadTo( R, cy + sy, cx + mx, cy + my); p.quadTo(cx + sx, B, cx, B); p.quadTo(cx - sx, B, cx - mx, cy + my); p.quadTo(L, cy + sy, L, cy); p.quadTo( L, cy - sy, cx - mx, cy - my); p.quadTo(cx - sx, T, cx, T); p.lineTo(cx, T - oval.height() * 1.3f); return p; } private static Path makeArrow(float length, float height) { Path p = new Path(); p.moveTo(-2.0f, -height / 2.0f); p.lineTo(length, 0.0f); p.lineTo(-2.0f, height / 2.0f); p.close(); return p; } private static Path makeConcaveArrow(float length, float height) { Path p = new Path(); p.moveTo(-2.0f, -height / 2.0f); p.lineTo(length - height / 4.0f, -height / 2.0f); p.lineTo(length, 0.0f); p.lineTo(length - height / 4.0f, height / 2.0f); p.lineTo(-2.0f, height / 2.0f); p.lineTo(-2.0f + height / 4.0f, 0.0f); p.close(); return p; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "road-trip-master/road-trip-master/application/src/main/java/org/curiouscreature/android/roadtrip/IntroView.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "IntroView handles SVG loading, animation management, path creation, and rendering. These multiple responsibilities increase reasons for change."}, {"principle": "Open-Closed", "justification": "IntroView cannot be extended to modify SVG rendering or animation behavior without altering its existing code, violating extensibility."}, {"principle": "Dependency Inversion", "justification": "IntroView directly instantiates SvgHelper (concrete class) without depending on an abstraction, coupling high-level logic to low-level details."}]}]}
{"project_id": 136, "chunk_id": 0, "prompt": {"main_file_path": "road-trip-master/road-trip-master/application/src/main/java/org/curiouscreature/android/roadtrip/SvgHelper.java", "main_file_content": "package org.curiouscreature.android.roadtrip; import android.content.Context; import android.graphics.*; import android.util.Log; import com.caverock.androidsvg.PreserveAspectRatio; import com.caverock.androidsvg.SVG; import com.caverock.androidsvg.SVGParseException; import java.util.ArrayList; import java.util.List; public class SvgHelper { private static final String LOG_TAG = \"SVG\"; private final List<SvgPath> mPaths = new ArrayList<SvgPath>(); private final Paint mSourcePaint; private SVG mSvg; public SvgHelper(Paint sourcePaint) { mSourcePaint = sourcePaint; } public void load(Context context, int svgResource) { if (mSvg != null) return; try { mSvg = SVG.getFromResource(context, svgResource); mSvg.setDocumentPreserveAspectRatio(PreserveAspectRatio.UNSCALED); } catch (SVGParseException e) { Log.e(LOG_TAG, \"Could not load specified SVG resource\", e); } } public static class SvgPath { private static final Region sRegion = new Region(); private static final Region sMaxClip = new Region( Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE); final Path path; final Path renderPath = new Path(); final Paint paint; final float length; final Rect bounds; final PathMeasure measure; SvgPath(Path path, Paint paint) { this.path = path; this.paint = paint; measure = new PathMeasure(path, false); this.length = measure.getLength(); sRegion.setPath(path, sMaxClip); bounds = sRegion.getBounds(); } } public List<SvgPath> getPathsForViewport(final int width, final int height) { mPaths.clear(); Canvas canvas = new Canvas() { private final Matrix mMatrix = new Matrix(); @Override public int getWidth() { return width; } @Override public int getHeight() { return height; } @Override public void drawPath(Path path, Paint paint) { Path dst = new Path(); getMatrix(mMatrix); path.transform(mMatrix, dst); mPaths.add(new SvgPath(dst, new Paint(mSourcePaint))); } }; RectF viewBox = mSvg.getDocumentViewBox(); float scale = Math.min(width / viewBox.width(), height / viewBox.height()); canvas.translate( (width - viewBox.width() * scale) / 2.0f, (height - viewBox.height() * scale) / 2.0f); canvas.scale(scale, scale); mSvg.renderToCanvas(canvas); return mPaths; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "road-trip-master/road-trip-master/application/src/main/java/org/curiouscreature/android/roadtrip/SvgHelper.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "SvgHelper handles SVG loading, parsing, viewport scaling, path transformation, and rendering logic. Combining resource management, rendering setup, and path processing exceeds a single responsibility."}, {"principle": "Open-Closed", "justification": "SvgHelper directly implements rendering logic in getPathsForViewport. To modify rendering behavior (e.g., scaling strategies), the class must be modified instead of extended."}, {"principle": "Dependency Inversion", "justification": "SvgHelper directly depends on the concrete SVG class from AndroidSVG. High-level SVG processing logic should depend on abstractions, not a third-party implementation."}]}]}
{"project_id": 137, "chunk_id": 0, "prompt": {"main_file_path": "Music-Player-App-master/src/Song.java", "main_file_content": "package com.SongPlaylistApp; public class Song { private String title; private double duration; public Song(String title, double duration) { this.title = title; this.duration = duration; } public Song(){ } public String getTitle() { return title; } public double getDuration() { return duration; } @Override public String toString() { return \"Song{\" + \"title='\" + title + '\\'' + \", duration=\" + duration + '}'; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Music-Player-App-master/src/Song.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Song class manages both data representation (title, duration) and string formatting (toString). These are two distinct responsibilities: data storage and presentation logic."}]}]}
{"project_id": 137, "chunk_id": 0, "prompt": {"main_file_path": "Music-Player-App-master/src/Album.java", "main_file_content": "package com.SongPlaylistApp; import java.util.ArrayList; import java.util.LinkedList; public class Album { private String name; private String artist; private ArrayList<Song> songs; public Album(String name, String artist) { this.name = name; this.artist = artist; this.songs = new ArrayList<Song>(); } public Album(){ } public Song findSong(String title){ for(Song checkedSong : songs){ if(checkedSong.getTitle().equals(title)) return checkedSong; } return null; } public boolean addSong(String title, double duration){ if(findSong(title) == null){ songs.add(new Song(title,duration)); return true; } else { return false; } } public boolean addToPlayList(int trackNumber, LinkedList<Song> PlayList){ int index = trackNumber - 1; if(index > 0 && index <= this.songs.size()){ PlayList.add(this.songs.get(index)); return true; } return false; } public boolean addToPlayList(String title, LinkedList<Song> PlayList){ for(Song checkedSong : this.songs){ if (checkedSong.getTitle().equals(title)){ PlayList.add(checkedSong); return true; } } return false; } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Music-Player-App-master/src/Album.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "Album manages song storage and playlist interactions, which are two distinct responsibilities. Changes to playlist logic or song storage would both require modifying the class."}, {"principle": "Open-Closed", "justification": "Album cannot support new playlist types (e.g., non-LinkedList) without modifying its methods. It lacks abstractions to extend behavior without altering existing code."}]}]}
{"project_id": 137, "chunk_id": 0, "prompt": {"main_file_path": "Music-Player-App-master/src/Main.java", "main_file_content": "package com.SongPlaylistApp; import java.util.*; public class Main { private static ArrayList<Album> albums = new ArrayList<>(); public static void main(String[] args) { Album album = new Album(\"Album1\",\"AC/DC\"); album.addSong(\"Apna Bana Le\",4.5); album.addSong(\"Tum Hi Ho\",3.5); album.addSong(\"Tu Hi Yaar Mera\",5.0); albums.add(album); album = new Album(\"Album2\",\"Arijit Singh\"); album.addSong(\"Egiye De\",4.5); album.addSong(\"Suno Na Sangemarmar\",3.5); album.addSong(\"Ei Bhalo Ei Kharap\",4.5); albums.add(album); LinkedList<Song> playList_1 = new LinkedList<>(); albums.get(0).addToPlayList(\"Apna Bana Le\",playList_1); albums.get(0).addToPlayList(\"Tum Hi Ho\",playList_1); albums.get(0).addToPlayList(\"Tu Hi Yaar Mera\",playList_1); albums.get(1).addToPlayList(\"Egiye De\",playList_1); albums.get(1).addToPlayList(\"Suno Na Sangemarmar\",playList_1); albums.get(1).addToPlayList(\"Ei Bhalo Ei Kharap\",playList_1); play(playList_1); } private static void play(LinkedList<Song> playList){ Scanner sc = new Scanner(System.in); boolean quit = false; boolean forward = true; ListIterator<Song> listIterator = playList.listIterator(); if(playList.size() == 0){ soutl(\"\") }else { soutl(\"\") printMenu(); } while(!quit){ int action = sc.nextInt(); sc.nextLine(); switch (action){ case 0: soutl(\"\") quit = true; break; case 1: if(!forward){ if(listIterator.hasNext()){ listIterator.next(); } forward = true; } if(listIterator.hasNext()){ soutl(\"\") }else { soutl(\"\") forward = false; } break; case 2: if(forward){ if (listIterator.hasPrevious()){ listIterator.previous(); } forward = false; } if(listIterator.hasPrevious()){ soutl(\"\") }else { soutl(\"\") forward = false; } break; case 3: if(forward){ if(listIterator.hasPrevious()){ soutl(\"\") forward = false; }else { soutl(\"\") } }else { if(listIterator.hasNext()){ soutl(\"\") forward = true; }else { soutl(\"\") } } break; case 4: printList(playList); break; case 5: printMenu(); break; case 6: if (playList.size() >0){ listIterator.remove(); if(listIterator.hasNext()){ soutl(\"\") } else { if(listIterator.hasPrevious()) soutl(\"\") } } } } } private static void printMenu(){ soutl(\"\") soutl(\"\") } private static void printList(LinkedList<Song> playList){ Iterator<Song> iterator = playList.iterator(); soutl(\"\") while (iterator.hasNext()){ soutl(\"\") } soutl(\"\") } }", "dependencies": []}, "task": "SOLID Violations Detection", "output_schema": "{\"$defs\": {\"ViolatedPrinciple\": {\"properties\": {\"principle\": {\"description\": \"The violated SOLID principle.\", \"enum\": [\"Single Responsibility\", \"Open-Closed\", \"Liskov\", \"Interface Segregation\", \"Dependency Inversion\"], \"title\": \"Principle\", \"type\": \"string\"}, \"justification\": {\"description\": \"Explanation of why the principle was violated in 2 sentences only.\", \"maxLength\": 300, \"title\": \"Justification\", \"type\": \"string\"}}, \"required\": [\"principle\", \"justification\"], \"title\": \"ViolatedPrinciple\", \"type\": \"object\"}, \"Violation\": {\"properties\": {\"file_path\": {\"description\": \"Path of the file containing the violation.\", \"title\": \"File Path\", \"type\": \"string\"}, \"violatedPrinciples\": {\"description\": \"List of violated principles with justifications.\", \"items\": {\"$ref\": \"#/$defs/ViolatedPrinciple\"}, \"title\": \"Violatedprinciples\", \"type\": \"array\"}}, \"required\": [\"file_path\", \"violatedPrinciples\"], \"title\": \"Violation\", \"type\": \"object\"}}, \"properties\": {\"violations\": {\"description\": \"Detected SOLID violations.\", \"items\": {\"$ref\": \"#/$defs/Violation\"}, \"title\": \"Violations\", \"type\": \"array\"}}, \"required\": [\"violations\"], \"title\": \"SolidDetectionOutput\", \"type\": \"object\"}", "violations": [{"file_path": "Music-Player-App-master/src/Main.java", "violatedPrinciples": [{"principle": "Single Responsibility", "justification": "The Main class handles multiple responsibilities including initializing data, managing playlist interactions, and handling user input. This violates SRP as it has more than one reason to change."}, {"principle": "Open-Closed", "justification": "The play method's switch-case structure is not closed for modification. Adding new playback actions requires altering the existing method instead of extending behavior through abstractions."}, {"principle": "Dependency Inversion", "justification": "The Main class directly depends on concrete classes Album and Song instead of abstractions. High-level modules should depend on interfaces, not low-level implementations."}]}]}
