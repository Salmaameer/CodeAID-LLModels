# -- coding: utf-8 --
"""LabelingDetectionData.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CPyJeZy3rhGl4Vzt5Wx8oeEy3lHXB90m

# Labeling Data Using Deepseek

## Overview
This notebook aims to finetune the model to detect and refactor SOLID principles.

## Import Needed Libraries
"""

import json
from pydantic import BaseModel, Field
from typing import List, Literal
import json_repair
from google import genai
from google.genai import types
import os


Principle = Literal[
    "Single Responsibility", "Open-Closed", "Liskov",
    "Interface Segregation", "Dependency Inversion"
]


class ViolatedPrinciple(BaseModel):
    principle: Principle = Field(..., description="The violated SOLID principle.")
    justification: str = Field(..., max_length=300,
                               description="Explanation of why the principle was violated in 2 sentences only.")


class Violation(BaseModel):
    file_path: str = Field(..., description="Path of the file containing the violation.")
    violatedPrinciples: List[ViolatedPrinciple] = Field(...,
                                                        description="List of violated principles with justifications.")


class SolidDetectionOutput(BaseModel):
    violations: List[Violation] = Field(..., description="Detected SOLID violations.")


Smell = Literal[
    "Feature Envy", "Inappropriate Intimacy",
    "Message Chains", "Middle Man"
]


class CouplingSmell(BaseModel):
    smell: Smell = Field(..., description="Type of coupling smell detected.")
    justification: str = Field(..., max_length=300,
                               description="Justification for the detected coupling smell in 2 sentences only.")


class CouplingViolation(BaseModel):
    filesPaths: List[str] = Field(..., description="Files involved in the coupling smell.")
    smells: List[CouplingSmell] = Field(..., description="Details about the detected coupling smells.")


class CouplingDetectionOutput(BaseModel):
    couplingSmells: List[CouplingViolation] = Field(..., description="Detected coupling code smells.")


"""## Send Prompt to model"""


def parse_json(text):
    try:
        return json_repair.loads(text)
    except:
        return None

os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = "my-service-account.json"

# Initialize Gemini client globally for reuse
genai_client = genai.Client(
    vertexai=True,
    project="abiding-circle-461421-a8",
    location="global"
)

MODEL_NAME = "gemini-2.5-flash-preview-05-20"

def send_prompt(messages):
    """
    Sends prompt to Gemini model and returns parsed JSON response
    """
    # Convert OpenAI-style messages to Gemini format
    contents = []
    for msg in messages:
        parts = [types.Part(text=msg["content"])]
        contents.append(types.Content(role=msg["role"], parts=parts))

    config = types.GenerateContentConfig(
        temperature=1,
        top_p=1,
        seed=0,
        max_output_tokens=8192,
        safety_settings=[],
    )

    try:
        chunks = genai_client.models.generate_content_stream(
            model=MODEL_NAME,
            contents=contents,
            config=config,
        )
        full_response = ""
        for chunk in chunks:
            if chunk.text:
                full_response += chunk.text

        parsed = parse_json(full_response)
        if parsed:
            return parsed
        else:
            print("Failed to parse Gemini response")
            return None

    except Exception as e:
        print("Gemini API Error:", str(e))
        return None



"""## Prompt Generator"""

def detect_solid_violations(input_path, output_path, unparsed_path):
    with open(input_path, "r") as f_in, open(output_path, "a") as f_out, open(unparsed_path, "a") as unparsed_f_out:
        for line_num, line in enumerate(f_in, 1):
            data = json.loads(line)

            solid_violations_detection_messages = [
                {
                    "role": "user",
                    "content": "\n".join([
                        "You are a senior software engineer.",
                        "You will be given one file with its file dependencies.",
                        "Your task is to detect violations of SOLID principles: Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, and Dependency Inversion.",
                        "",
                        "Principle definitions (apply these strictly):",
                        "SRP: A class has exactly one reason to change—only one responsibility.",
                        "OCP: A class may be extended without modifying its existing code.",
                        "LSP: Subtypes must behave interchangeably with their base types.",
                        "ISP: Clients should only depend on the methods they actually use.",
                        "DIP: High‑level (policy/business) modules must depend on abstractions (interfaces/abstract classes), not on concrete (implementation) classes. Low‑level modules must implement those abstractions; they should NOT be directly referenced by high‑level modules.",
                        "Don't include the usage of built in classes (e.g. java.util.Scanner, java.lang.String, List, Map), they don't break DIP",
                        "",
                        "Apply a step-by-step reasoning process to identify any violations.",
                        "Start by explaining what each principle means in the current context, and how the code complies or fails to comply with it.",
                        "",
                        "After providing your first assessment, re-evaluate your findings and refine your judgment if necessary.",
                        "",
                        "Finally, reflect on your answer: did you miss anything? Could your answer be improved? If so, revise accordingly.",
                        "",
                        "Always respond in a structured JSON format. Do not include any explanation outside the JSON.",
                        "You have to extract SOLID Violations from Code according the Pydantic details.",
                        "Be objective and thorough, even if no violations are found.",
                        "Do not generate any introduction or conclusion."
                        "## Code:",
                        json.dumps(data["content"], ensure_ascii=False),
                        "",

                        "## Pydantic Details:",
                        json.dumps(
                            SolidDetectionOutput.model_json_schema(), ensure_ascii=False
                        ),
                        "",
                        "## SOLID Violations:",
                        "json"
                    ])
                }
            ]

            response = send_prompt(solid_violations_detection_messages)

            if not response:
                unparsed_f_out.write(line)
                continue
            violations = response.get("violations", [])
            result = {
                "project_id": data["project_id"],
                "chunk_id": data["chunk_id"],
                "prompt": data["content"],
                "task": "SOLID Violations Detection",
                "output_schema": json.dumps(SolidDetectionOutput.model_json_schema(), ensure_ascii=False),
                "violations": violations
            }
            f_out.write(json.dumps(result) + "\n")
            print(response)

def detect_coupling(input_path, output_path, unparsed_path):
    with open(input_path, "r") as f_in, open(output_path, "a") as f_out, open(unparsed_path, "a") as unparsed_f_out:
        for line in f_in:
            data = json.loads(line)
            coupling_smells_detection_messages = [
                {
                    "role": "user",
                    "content": "\n".join([
                        "You are a software engineer.",
                        "You will be given one file with its file dependencies.",
                        "Your task is to identify and explain any of the following coupling smells:",
                        "",
                        "- Feature Envy: A method that seems more interested in another class than the one it is in, accessing its data and methods frequently.",
                        "- Inappropriate Intimacy: Two classes that share too much information or access each other's internal details excessively.",
                        "- Incomplete Library Class: A library class is missing functionality that should be there, forcing users to add methods or subclasses that break encapsulation.",
                        "- Message Chains: A client asks one object for another object, then that object for another, and so on, forming a long chain of calls.",
                        "- Middle Man: A class that delegates almost everything to another class and does very little itself.",
                        "",
                        "Use a step-by-step reasoning process (Chain of Thought) to evaluate if any of these smells exist in the code.",
                        "For each suspected smell, explain what triggered it, and which class/method is involved.",
                        "",
                        "After your first pass, review your analysis and refine it if necessary.",
                        "Then, critically evaluate your final result.",
                        "- Did you miss any smell?",
                        "- Did you misclassify anything?",
                        "- Could your reasoning be more precise?",
                        "",
                        "Always respond in a structured JSON format. Do not include any explanation outside the JSON.",
                        "You have to extract Coupling code smells from Code according the Pydantic details.",
                        "Be objective and thorough, even if no violations are found.",
                        "Do not generate any introduction or conclusion.",
                        "## Code:",
                        json.dumps(data["content"], ensure_ascii=False),
                        "",
                        "## Pydantic Details:",
                        json.dumps(CouplingDetectionOutput.model_json_schema(), ensure_ascii=False),
                        "",
                        "## Coupling code smells:",
                        "json"
                    ])
                }
            ]

            response = send_prompt(coupling_smells_detection_messages)

            if not response:
                unparsed_f_out.write(line)
                continue
            smells = response.get("couplingSmells", [])

            result = {
                "project_id": data["project_id"],
                "chunk_id": data["chunk_id"],
                "prompt": data["content"],
                "task": "Coupling Smells Detection",
                "output_schema": json.dumps(CouplingDetectionOutput.model_json_schema(),
                                            ensure_ascii=False),
                "couplingSmells": smells
            }
            f_out.write(json.dumps(result) + "\n")
            print(response)


detect_solid_violations("medium.jsonl", "testResult.jsonl", "rerun.jsonl")
# detect_coupling("medium.jsonl", "mediumLabelledCoupling.jsonl", "rerun.jsonl")